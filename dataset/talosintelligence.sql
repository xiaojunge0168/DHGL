INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (1, 'Yi Technology Home Camera 27US QR Code trans_info Code Execution Vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the QR code scanning functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted QR Code can cause a buffer overflow, resulting in code execution. An attacker can make the camera scan a QR code to trigger this vulnerability. Alternatively, a user could be convinced to display a QR code from the internet to their camera, which could exploit this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Yi Home Camera is an IoT home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device: the ability to view the camera from anywhere, offline and subscription-based cloud storage, and ease of setup. During the network configuration stage of the setup, the Yi camera prompts the user to show it a QR code that is generated by the app running on the user’s phone. The user types in the SSID and password of the network that they wish for the camera to connect to, and then the app communicates to  , asking for a  , which is used for identification of the device on the server side. After the response has been received, the phone will generate a QR code that contains the following data:  . Where by the   field is the   found in the https response,   is the base64 encoded SSID of the network, and   is the the base64 encoded password that has been encoded against a static string. After this QR code has been generated, the user shows this to the camera, which will then scan it using the underlying ZBAR QR Code scanning library (https://github.com/Zbar/Zbar)[https://github.com/Zbar/Zbar]. After the string has been read in by the camera, it is parsed by the following code: For some reason, it uses a modified JSON parsing function [2] to grab the values of each of these keys, looking inside the string scanned by the QR code stored in R7 [1]. The results of each of these scans are stored on addresses on the stack (*_dst), which looks like: Looking inside the   function we can see a few key operations: First, it finds the location of the needle in the haystack via  , and then further down, skips over the first 11 single quotes, double quotes and colons that it finds. After this, the main vulnerability can be found: It adds the length of the needle [1]  to the return value of the   call [4] and the amount of quotes, single quotes and colons that it found (max of 11), such that it can find the value of the parameter passed as the needle. For instance, if a needle is  , then R0 would point to the space immediately proceeding the equals sign. Then it writes result string into the   address stored in R8 [4] using   (which is not length limited), and the format string seen at [2] (which copies  over all  non-  characters). Remembering that the output variable is an address located on the stack of the calling function, and that the stack looks like the following: It becomes apparent that the only thing stopping a buffer overflow is the max read length that the Zbar QR code object can handle, which from heuristic testing seems to be 263 (0x107) characters, which is more than enough for a buffer overflow in either the SSID dst to overwrite the return address on the stack. Below are the proof of concepts that generate QR codes that demonstrate the two vulnerabilities. The   call can overwrite a buffer of size 0x104, which is more than enough to overflow the return address from the   field at $bp-0xE8: The   call can overwrite a buffer of size 0x104, which is more than enough to overflow the return address from the   field at $bp-0xA8: Naturally, this payload does not get triggered until the function actually returns, which actually only occurs once a valid code has been scanned. Thus, if a malicious code is scanned before the owner scans their own QR code for their network credentials, the payload will be triggered immediately when a network connection is gained, so it should be cautioned that users should not scan QR codes found on the internet. OhThread 1 \"rmm\" received signal SIGSEGV, Segmentation fault.\n0x41414140 in ?? ()\n(gdb) info reg\nr0             0x0      0\nr1             0x0      0\nr2             0x106d75cc       275609036\nr3             0x106d75cc       275609036\nr4             0x41414141       1094795585\nr5             0x41414141       1094795585\nr6             0x41414141       1094795585\nr7             0x41414141       1094795585\nr8             0x41414141       1094795585\nr9             0x41414141       1094795585\nr10            0x41414141       1094795585\nr11            0x41414141       1094795585\nr12            0xb6eee210       3069108752\nsp             0xbea11ae8       0xbea11ae8\nlr             0xb6ea13a0       3068793760\npc             0x41414140       0x41414140\ncpsr           0x68000030       1744830512\n(gdb) bt Backtrace stopped: previous frame identical to this frame (corrupt stack?) 2018-05-01 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0571');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (2, 'Yi Technology Home Camera 27US Firmware Update Code Execution Vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the firmware update functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted file can cause a logic flaw and command injection, resulting in code execution. An attacker can insert an SD card to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 7.6 - CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-78 - Improper Neutralization of Special Elements used in an OS Command Yi Home Camera is an IoT home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device: the ability to view video from anywhere, offline and subscription-based cloud storage, and ease of setup. When updating the firmware of the Yi Home Camera, there are two options: OTA or via a microSD card inserted physically into the device. Directions for this process can be found at  , and the firmware files themselves are available at  . For the 27US version, the tar archive contains two files,   and  , but it only actually updates with the  , which will be the main subject of this writeup. Please note this issue is referring to a local update only. While the   file is a simple Uboot image and subsequent JFFS2 filesystem, the  \nfirmware file is a lot more opaque: During the power-on stage, the following code in   runs: Which  at [1] checks to see if the   file exits on the SD card root directory. If it exists, then it looks at the   string inside the firmware image, and compares it to the current firmware version at [2]. The kernel modules loaded at [3] and [4] will become relevant soon, but to continue, the actual firmware unpacking occurs in [5], when the   script is run, which will be broken down now: At first, the script will extract the portions of the firmware as listed above,  , , and the rest as  . The interesting things happen next, though: At [1], the   is decrypted by a binary, presumably doing RSA decryption with a   file that was copied into the directory earlier. The result of this decryption is placed in  , which gets prepended to   and thrown into  . The first 33 bytes [3] of  home3 are the md5sum of the firmware, and then the next 33 bytes [4] are the password used to  decrypt a .7z archive, which comes from home4. Finally, the first 22 bytes [5] of home4 contain a version string used for version comparison. After this, some nonsensical version comparisons fail, due to reasons explained in TALOS-2018-0566, and then the following command is run:  . In turn, the   binary runs the following command: The   parameter provided to 7za is just the value from the   field earlier, and as shown, home4 is hardcoded as the .7z archive being decrypted. After the decryption has happened, the   script is run to actually copy over the new firmware. Unfortunately,  there are a few oversights in this process. For starters, the return value of the   binary is never checked, such that if it fails for any reason, the process still continues. One case of this is if an “encrypted” firmware file is presented that is less than the expected size of 1344, which causes rsa dec to fail, and for the   file to be empty. An even more interesting case though, is that rsa dec will actually just not decrypt anything if it’s given a buffer with a length of less than 0x100, it will simply write the input into the output   file: Thus, since the output file   is user-controlled, referring back to the extpkg.sh: Since dec key is prepended, and home2 is user-controlled, it follows that home3 is fully user-controlled. The first 33 bytes can be used to pass any md5sum checks, and the next 33 bytes get used in the system call to 7za, resulting in command injection. Since the   line takes our value for $key as argv[1], we cannot have any spaces inside of the resulting characters passed to  . Since /bin/sh points to busybox, typical bash command injection tricks such as ${/bin/nc,…,-e,/bin/sh} won\'t work. However, if one just sets   to “;sh” then the resulting string passed to system is  , allowing one to run anything they want to put inside of home4. Discovered by Lilith <(^_^)> of Cisco Talos.\nhttp://talosintelligence.com/vulnerability-reports/ 2018-05-01 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0565');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (3, 'Yi Technology Home Camera 27US CRCDec denial-of-service vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the UDP network functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted set of UDP packets can allocate unlimited memory, resulting in denial of service. An attacker can send a set of packets to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-400: Uncontrolled Resource Consumption Yi Home Camera is an internet-of-things home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device such as the ability to view the video from anywhere, offline and subscription-based cloud storage, and ease of setup. When the Yi Camera communicates with the ‘Yi Home’ phone app, in order to provide video feeds and status updates, the network daemon in charge is the   binary. This daemon provides network discovery, authorization, and also settings manipulation functionality, all over UDP. The custom protocol handling this is rather simple to start, and a basic overview is given below: If the camera and the phone running the ‘Yi Home’ app are on the same subnet, a handshake occurs with the custom TNP protocol before any other operations can happen. The phone sends a   (\\x30) packet to UDP port 31208, to which the phone will respond with an   (\\x31) packet from a new source port. It should be noted that this   can be sent to a broadcast address or a single IP address, and also that the   response contains the Device ID (DID) of the camera, which is needed to pass certain checks. A sample DID consists of a prefix, serial and suffix, for example:  . After the initial packet exchange, the thread controlling this socket enters the   function, which contains a jumptable for dealing with a subset of the possible   opcodes. Of interest for this bug is the   opcode,  which seems to validate a response from remote servers by utilizing a complex CRC algorithm. Throughout testing, this message has not been seen naturally on the wire, so the theory is that this is  artifact code that has not been removed. The relevant disassembly follows below: At [1], the size of the input buffer data is taken and added to 0x4 before using that as the size of the input malloc buffer, which is stored into R2 eventually [2]. At 3, a call to   is made, with the following approximation of parameters: Once inside of  , a quick stub is called to load the  , which doesn’t actually load anything, and then we step into the main body. To summarize the main functionality, it allocates a new buffer of size   - 0x4, does a bunch of CRC operations on our input buffer, and throws that into the buffer that was just allocated. Interestingly, approximately only the first 0xD0 bytes are actually CRC’d, the rest are just copied over from the UDP buffer to the malloc’d buffer. After this, the code walks backward from the end of the CRC’d bytes and replaces all “\\x43”/”C” bytes with null bytes, until it hits the end of the buffer-4. If the function finds a byte that is not a “C”, the function returns an error, after freeing the inner buffer. If the function only finds “CCCC” however, the CRC’d data will be memcpy’d from the buffer malloc’d inside the CRCDec function to the buffer that was malloc’d and then passed in as the   parameter. After this, the program will free the inner malloc buffer. When the   function returns, if the CRC checksum “CCCC” was not found and CRCDec returned an error,   will just free the buffer allocated before  , and return to processing new packets: Unfortunately, if there was no error, the login status is updated, and nothing else really occurs. The buffer malloc’d before   is never freed, allowing an arbitrary amount of memory to be allocated by the `p2p_tnp process, causing quite a few unintended consequences. Depending on the amount of these packets sent, and also the size of the data allocated, different outcomes can be achieved by an unauthenticated attacker with network connectivity. For testing purposes, the following buffer was used: `”A”*0x4A0+”CCCC”. If one sends approximately 0xC00 packets, the device’s LED will eventually start blinking and the camera’s owners will no longer be able to reach the device from their Yi Home phone apps, even though it maintains network connectivity. The camera must then be physically rebooted in order to regain functionality. It is theorized that only the   service is crashing at this point, rendering the UDP network comms disabled. If one sends approximately 0x1000 packets, then the device LED also starts blinking, but this time, the  ,  ,   and   services all crash, causing a complete network disconnect. After a certain amount of time, the   binary will realize that   has crashed, and will promptly reboot the device. Thus, depending on the goals of the attacker, a camera reboot can also be propagated with this vulnerability. 2018-06-13 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0602');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (4, 'Yi Technology Home Camera 27US nonce reuse authentication bypass vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the firmware update functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted set of UDP packets can cause a logic flaw, resulting in an authentication bypass. An attacker can sniff network traffic and send a set of packets to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 9.0 – CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-323: Reusing a Nonce, Key Pair in Encryption Yi Home Camera is an internet of things home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device: the ability to view video from anywhere, offline and subscription-based cloud storage, and ease of setup. When the Yi Camera communicates with the ‘Yi Home’ phone app, in order to provide video feeds and status updates, the network daemon in charge is the   binary. This daemon provides network discovery, authorization, and also settings manipulation functionality, all over UDP. The custom protocol handling this is rather simple to start, and a basic overview is given below: If the camera and the phone running the ‘Yi Home’ app are on the same subnet, a handshake occurs with the custom TNP protocol before any other operations can happen. The phone sends a MSG_LAN_SEARCH (\\x30) packet to UDP port 31208, to which the phone will respond with a MSG_LAN_NOTIFY (\\x31) packet from a new source port. It should be noted that this MSG_LAN_SEARCH can be sent to a broadcast address or a single IP address, and also that the MSG_LAN_SEARCH response contains the Device ID (DID) of the camera, which is needed to pass certain checks. A sample DID consists of a prefix, serial, and suffix. For example: TNPUSAC-112233-NMEDP. After the initial packet exchange, the camera will respond with a MSG RDY (\\x42) packet and the thread controlling this socket enters the PPPP_thread_recv_Proto_device function. This function contains a large jump table for dealing with a subset of the possible TNP opcodes. Of most interest for this writeup is a set of basic opcodes (MSG_P2P_NOTIFY_ACK, MSG_ALIVE) that can be sent to enter another jump table of opcodes inside of the tnp::PPPP_thread_recv_DRW function. For more context, each time a user connects to the Yi Camera and initiates a live camera feed, or editing of settings, the code path enters the tnp::PPPP_thread_recv_DRW, and a large amount of data is cleared out for this new user. A max of 10 of these sessions can occur simultaneously, any more connections will be dropped until a slot frees. Any connection that is talking with the recv_DRW thread and taking up one of these session slots will be henceforth referred to as a TNP_Session. Inside of this new jumptable, a set of fewer opcodes is available, however the complexity of some of them is far greater. In examining the MSG_RCV_DRW opcode (\\xD0), a lot more validation must be passed in order to reach actually useful code. A summary of the MSG_RCV_DRW packet is given below: If the MSG_RCV_DRW message passes the required checks mentioned in the comments up until [1], then the program will append all data below [1] into a linked list structure that is used for ordering of the UDP messages (essentially reimplementing TCP). The structure of the singly linked list (SLL) is shown here: It’s worth mentioning that each TNP_Session allocates four different linked lists, each one serving a different queuing purpose. The best approximation/naming conventions are listed here, along with a set offset that is used to find them from the TNP_Session’s base address: Regardless, for the “\\xD0” opcode, the linked list node is put into the LL_Control queue. Assuming  that there is not already a node with the given LL_Index (which results in a packet drop/free), the SLL_node is inserted into the list at the index provided in the packet. A malloc then occurs, of size  , and that new address is copied into the   field of the allocated SLL_Node. Everything from offset 0x13 down is copied into this new heap chunk, and then sits around until the entire SLL has all of its indexes filled, or a set timeout has occurred. If one sends a MSG_RCV_DRW packet with an LL_Index field of 0x4, MSG DRW packets of index 0x0-0x3 must also be received, or else the packet will be discarded. If there is a gap in the LL_Indexes given, the camera will read the linked list data packets until the gap occurs, and nothing more. After the MSG_RCV_DRW packets have all been received, or the timeout (approximately 10 seconds) occurs, another thread inside of the   function reads the LL_Control queue, walking the linked list inside of the   function. Inside of  , the next parts of the packets are examined: First, the PPPP_Read function is called, which will copy the first eight bytes from offset 0xA of our MSG DRW packet ([1] and [2]) into a stack buffer of  . If [2] is larger than 0x3FE, or if [2] is larger than the actual amount of bytes in the rest of the message, it is considered invalid and discarded. If this size check passes, then a second call to   happens, this time reading   [2] bytes from the LL_Nodes’ data blocks. Assuming nothing funky occurs, the program returns to   and checks the   field’s first byte, which must be less than or equal to one. Assuming that all the above checks have been passed, the program takes everything from [3] down and passes it as the data to the   function, which can toggle settings and initiate live camera feeds, among other important features. Appropriately, it is where the first actual authentication check also occurs. Before any more processing occurs, the Yi Camera will examine the first 0x20 bytes of the  field [4] for a nonce and an encrypted and encoded hash generated from the nonce: Quick note: The key used to generate the HmacSha1 is reset to a random value on every reboot. In order to prevent a nonce-replay attack (as these MSG_RCV_DRW messages are sent cleartext over UDP and also potentially over the internet), the TNP_Session stores a list of the last 0x64 good nonces that were used. This list is checked whenever a new request is received, and the Yi Camera will drop any requests that reuse any nonce in this list. Unfortunately, there are a couple of issues with this nonce scheme, mainly because the good Session struct, which is on a per-connection basis. Thus, if an attacker sniffs a valid nonce and initiates a new TNP_Session while the previous session is still active (thus taking up a new TNP\\Session slot), the list of previously used nonces is empty, allowing for a successful nonce-replay attack. Even more concerning though is that upon the ending of a TNP_Session, the tnp Session itself. At the end of the   function that the tnp Session struct (size 0xD38) to null, clearing out the previously used nonce list, allowing for replays to occur in the same TNP Session connected. 2018-06-13 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0601');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (5, 'Yi Technology Home Camera 27US p2p_tnp cleartext data transmission vulnerability', 'None', '2018-10-31', 'An exploitable information disclosure vulnerability exists in the phone-to-camera communications of Yi Home Camera 27US 1.8.7.0D. An attacker can sniff network traffic to exploit this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 9.0 – CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-319: Cleartext Transmission of Sensitive Information Yi Home Camera is an internet-of-things home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device, such as the ability to view video from anywhere, offline and subscription-based cloud storage, and ease of setup. When the Yi Camera communicates with the ‘Yi Home’ phone app, in order to provide video feeds and status updates, the network daemon in charge is the   binary. This daemon provides network discovery, authorization, and also settings manipulation functionality, all over UDP. To quickly sum up this issue, a huge portion of the functionality of this device is unencrypted. This simple fact leads to a multitude of issues and vulnerabilities. Any communications between any two devices mentioned in this advisory are potentially vulnerable to a MITM attack, whether it be replaying or modification of traffic, or a similar attack. (The only real exception to this is playing video data, which will be covered later on.) Two different scenarios will be presented, as they both entail different risks: when the Yi Home Camera and its controlling phone are on different subnets and when they are not. Also, a quick side note, anything that happens through the   binary is encrypted over HTTPS to the   domain (this changes based on region). Without rehashing the entire p2p_tnp protocol, it is sufficient to note that many settings can be changed from the owner\'s phone, with 173 different opcodes being listed inside of the Yi Home application APK. As of the current version of the Yi Home Camera, only 45 of these opcodes lead to valid cases within the p2p_tnp binary, all of which would be vulnerable to an attacker with MITM access on the phone/app\'s subnet. Even in a situation where MITM\'ing is not possible (e.g. Dynamic Arp Inspection, static arps, or being on a different subnet) utilizing unencrypted traffic for p2p_tnp leads to more potential vulnerabilities, since an attacker can hop onto another user\'s session by brute forcing port numbers. Moving on from this scenario, let us examine the more concerning of what occurs when the phone and camera are on different subnets. Three IP addresses are semi-hardcoded into the camera\'s persistent /tmp/mmap.info settings, which are used for remote cloud communications. As of version 1.8.7.0D the IP\'s are as such: The camera will send the same UDP packet to all three addresses, first starting with the MSG_DEV_LGN_KEY (\\x14) message, which contains the device ID of the camera, and a timestamped nonce and HMAC SHA1 signed version of the nonce. Impersonating a camera cannot happen without knowing the DID and secret key on the device, so even with UDP, this portion is somewhat secure, as the nonces cannot be replayed either (although since there\'s no signing of the data itself, the message could be edited via MITM). A sample message looks as such: After logging in, keepalives are sent back and forth, but eventually, upon request by a Yi Home app that\'s not on the same subnet, the remote Yi authentication servers will inform the camera of a new IP address that will act as the bridge between the phone and app. As of the current version, the IP is usually \"173.153.82.163\" for the camera, and “173.73.4.202” for the phone. The above situation requires some work from the phone, though. The same MSG_DEV_LGN_KEY message is sent to any of the same servers, however, no SHA1 HMAC nonce is required, so the only thing needed is the DID of the camera. A sample DID consists of a prefix, serial, and suffix. For example, TNPUSAC-112233-NMEDP.\nAfter this is sent, the remote servers inform the phone of the remote bridge “173.73.4.202” mentioned above, as well as the UDP port that the communications occur over. Once this is done, all UDP traffic sent to this port is piped over to the camera. Of huge concern at this point is that, while we cannot brute-force the DIDs for any given device (even though only the suffix and serial number are unique), since UDP is in play, it would be sufficient to constantly probe the remote bridges “173.153.82.163” and “173.73.4.202” for open UDP ports, such that an attacker could talk with whatever was on the other side, potentially leading to other vulnerabilities being exposed in the p2p_tnp daemon. Also of obvious concern is that all UDP traffic flows over the broader internet, unencrypted. This includes nonces used for authentication (which are vulnerable to replay attacks), MP4 audio stream data from the camera which is completely unencrypted, and anything else sensitive that may have been missed. It is worth noting that the MP4 video data (not audio) is encrypted with an AES key regenerated on every reboot of the camera, and then shared with the Yi servers. Eventually, the phone is able to view the data. 2018-06-13 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0616');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (6, 'Yi Technology Home Camera 27US TimeSync Code Execution Vulnerability', 'None', '2018-10-31', 'An exploitable firmware downgrade vulnerability exists in the time syncing functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted packet can cause a buffer overflow, resulting in code execution. An attacker can intercept and alter network traffic to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 9.6 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Yi Home Camera is an IoT home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device: the ability to view video from anywhere, offline and subscription-based cloud storage, and ease of setup. After initial pairing to a network has occurred and the camera has network connectivity, it immediately reaches out to   to perform a time synchronization. The request disassembly is shown below: A command is built inside of the address pointed to by R6 at [0], which is located on the stack, and then this is eventually passed as R0 to a call to  , and the first 0x800 [1] bytes of the results are stored in the address pointed to by R4 [2], which is a size 0x800 buffer on the stack. This results in the following request and response being sent: It should be explicitly noted that this occurs over HTTP and not HTTPS. Thus, if there’s any sort of MITM attack going on, the attacker has complete control over the response (with the exception of the 0x800 size limit). Keeping that in mind, let\'s move on to what is done with the response: A new function   is called that takes in three parameters. Somewhat similar to strstr, it searches for the needle “code” [2] inside of the haystack [3] which is the POST data read from the server, and then stores the output inside of R0, which is an address further up on the stack. This setup,  under normal circumstances would be somewhat safe, considering the length restriction (0x800) of the server’s response. But it is most unfortunate that the   function is not the most securely implemented: As one might expect, it first searches for the needle within the haystack. If the needle is not found, it returns 0. If a strstr match is found, the resulting address is stored in R6, and then the length of the needle is found and added to the address in R6, which results in a pointer to the parameter’s value, which is stored in R1. Continuing on, it weirdly loops 12 times, incrementing R1 until it finds a character that’s not a quote (0x27), double quote (0x22) or colon char (0x3a). After this, the new pointer is stored in LR and we resume with disassembly: The program reads in all the characters that are not do not match the set of chars at   from the value of the JSON parameter at [1], and then outputs it to R4 at [2], which is the original R0/output address passed in. Not surprisingly, there’s a couple issues here. First, there’s no length checks anywhere in the function, the only restriction is that our haystack is 0x800 bytes long max, due to the previous  . The second issue is that the output buffer that gets written to is most definitely not 0x800 bytes long. A quick glance at the stack setup: The output of our   call is going to go to [1]. It should also be noted that the   parameter is treated the same way, and read with   into the stack address at [2]. Since the overflow occurs higher up on the stack, and the variable at [4] is so large, we cannot actually overflow into the stored return address, but thankfully, we can overflow into the   variable. Which, if atoi(code) does not return 0x4e20, ends up getting passed back into  : Thus resulting in whatever string we overflow with getting evaluated as a command, and code execution: 2018-05-01 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0567');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (7, 'Yi Technology Home Camera 27US QR Code Base64 Code Execution Vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the QR code scanning functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted QR Code can cause a buffer overflow, resulting in code execution. An attacker can make the camera scan a QR code to trigger this vulnerability. Alternatively, a user could be convinced to display a QR code from the internet to their camera, which could exploit this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 9.1 – CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Yi Home Camera is an IoT home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IOT device: viewing from anywhere, offline and subscription-based cloud storage, and ease of setup. During the network configuration stage of the setup, the Yi camera prompts the user to show it a QR code that is generated by the app running on the user’s phone. The user types in the SSID and password of the network that they wish to connect the camera to, and then the app communicates to  , asking for a  , which is used for identification of the device on the server side. After the response has been received, the phone will generate a QR code that contains the following data:  . Where by the   field is the bindkey found in the https response,   is the base64 encoded SSID of the network, and   is the the base64 encoded password that has been encoded against a static string. It should definitely be asserted here that the password and SSID do not get sent over the network, only the bindkey gets asked for and returned, but it should also be noted that this vulnerability can still be triggered by the end server at this stage if it sends a bind key that contains the   string. After this QR code has been generated, the user shows this to the camera, which will then scan it using the underlying ZBAR QR Code scanning library (https://github.com/Zbar/Zbar)[https://github.com/Zbar/Zbar]. After the string has been read in by the camera, it is parsed by the following code: For some reason, it uses modified JSON parsing function [2] to grab the values of each of these keys, looking inside the string scanned by the QR code stored in R7 [1]. The results of each of these scans are stored on addresses on the stack (*_dst), which looks like such: Immediately after reading these values into the stack, the   and   values are base64 decoded with a custom implementation of the conversion: Importantly, the output of both these calls to   also go on the stack, with the destination for the password decoding being R5 [1], which is the   variable on the stack, which is conveniently located immediately above the return address. The underlying bug is within the b64_decode function, which doesn’t really have any size constraints on the output. This function will never exit unless it has detected an equals sign or a null inside of the processed data, and only at certain offsets within the buffer. So, it follows that if a someone passes a string without any equals signs (or nulls), it’ll just keep going, which is not the most secure implementation, and can easily result in a buffer overflow, since the stack destinations are all 0x40 in length, but the input string read in is not bounded except by the QR reader implementation itself, which for some reason seems to only be able to read QRCodes which store ~263 (0x107) bytes of data. Regardless, when decoding the   field from   to  , an interesting thing occurs when passing in a length 0x40 base64 encoded password, if only due to the layout of the stack: Since the source and the destination are next to each other, as long as both the source destination do not contain   or  , the program keeps decoding further and further down the stack, and will start reusing the   field as the source of its decoding, allowing us to write further down than intended, as long as the decoded base64 is also valid base64 encoded data. Since base64 decoding results in a reduction by 25% from input length to output length, the first iteration of decoding puts us at  , since the input length is going to be 0x40. Then, as long as our data is base64 encoded twice, we go another 0x24 bytes further in the destination, resulting in  a write to  . Finally, as long as that last 0x24 bytes has also been base64 encoded, we can write further down the stack, reaching the return address with a controlled write by triply base64 encoding the final payload. This payload does not get triggered until the function actually returns, which actually only occurs once a valid code has been scanned. Thus, if a malicious code is scanned before the owner scans their own QR code for their network credentials, the payload will be triggered immediately when a network connection is gained, so it should be cautioned that users should not scan QR codes found wandering throughout the internet. Alternatively, as discussed earlier, the server could send back the   and   strings, triggering the vulnerability as well. 2018-05-01 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0572');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (8, 'Yi Technology Home Camera 27US notice_to denial-of-service vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the firmware update functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted set of UDP packets can cause a settings change, resulting in denial of service. An attacker can send a set of packets to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-328: Reversible One-Way Hash Yi Home Camera is an internet-of-things home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device, such as the ability to view video from anywhere, offline and subscription-based cloud storage, and ease of setup. When the Yi camera communicates with the Yi Home phone app, in order to provide video feeds and status updates, the network daemon in charge is the   binary. This daemon provides network discovery, authorization, and settings manipulation functionality, all over UDP. The custom protocol handling this is rather simple to start, and a basic overview is given below: If the camera and the phone running the ‘Yi Home’ app are on the same subnet, a handshake occurs with the custom TNP protocol before any other operations can happen. The phone sends a MSG_LAN_SEARCH (\\x30) packet to UDP port 31208, to which the phone will respond with a MSG NOTIFY (\\x31) packet from a new source port. It should be noted that this MSG_LAN_SEARCH can be sent to a broadcast address or a single IP address, and also that the MSG_LAN_SEARCH response contains the device ID (DID) of the camera, which is needed to pass certain checks. A sample DID consists of a prefix, serial, and suffix, for example: TNPUSAC-112233-NMEDP. After the initial packet exchange, the thread controlling this socket enters the PPPP_thread_\\recv_Proto_device function, which contains a jumptable for dealing with a subset of the possible TNP opcodes. Of interest for this bug is the MSG_NOTICE_TO (\\x3C) opcode, which  will copy up to 0x400 bytes of the message into a stack buffer, and start to parse the contents, first looking for a valid DID string. If the DID provided does not match the DID of the camera, the validation routine will error out, but since the camera’s DID is provided in the MSG_LAN_NOTIFY response, this is a non-issue. After DID validation, the big buffer is then passed as an argument to the   function pointer, which is only written once, appropriately to the   function. Interestingly, the only things the   function does is look at   and strcmp it against “TurnOff” and “TurnOn”. If either of these strings is found, it calls  , which switches the camera feed to that state, allowing one to render the camera feed unavailable to the owner of the camera. While the camera itself is still on, and can be switched back on from the owner’s Yi Home application, it is trivial for an attacker to send these MSG_NOTICE_TO packets in a loop, causing the camera’s feed to stay permanently off, rendering it completely useless. It should be noted that there are other available code flows to call   that also require some sort of authentication, so it is theorized that the MSG_NOTICE_TO opcode is an artifact piece of code that should probably be removed. 2018-06-13 - Vendor disclosure \n2018-09-03 - Vendor patched \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0595');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (9, 'Yi Technology Home Camera 27US Firmware Downgrade Vulnerability', 'None', '2018-10-31', 'An exploitable firmware downgrade vulnerability exists in the firmware update functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted file can cause a logic flaw, resulting in a firmware downgrade. An attacker can insert an SD card to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 5.7 - CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:L CWE-20: Improper Input Validation Yi Home Camera is an IoT home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IOT device: viewing from anywhere, offline and subscription based cloud storage, and ease of setup. When updating the firmware of the Yi Home Camera, there are two options: OTA or via a microSD card inserted physically into the device. Directions for this process can be found at  , and the firmware files themselves are available at  . For the 27US version, the tar archive contains two files,   and  , but it only actually updates with the  , which will be the main subject of this writeup. Please note, this issue is referring to a local update only. While the   file is a simple Uboot image and subsequent JFFS2 filesystem, the  \nfirmware file is a lot more opaque: During the power-on stage, the following code in   runs:  Which  at [1] checks to see if the   file exits on the SD card root directory. If it exists, then it looks at the   string inside the firmware image, and compares it to the current firmware version at [2]. The kernel modules loaded at [3] and [4] will become relevant soon, but to continue, the actual firmware unpacking occurs in [5], when the   script is run, which will be broken down now: At first, the script will extract the portions of the firmware as listed above,  , , and the rest as  . The interesting things are what happen next though: At [1], the   is decrypted by a binary, presumably doing RSA decryption with a   file that was copied into the directory earlier. The result of this decryption is placed in  , which gets prepended to   and thrown into  . The first 33 bytes [3] of  home3 are the md5sum of the firmware, and then the next 33 bytes [4] are the password used to  decrypt a .7z archive, which comes from home4. Finally, the first 22 bytes [5] of home4 contain a version string used for version comparison. The assorted files are then read into variables and checked as listed below: Curiously, at [1] and [2], the “-ne” and “-ge” operators are used, which are designated for integer comparisons, not for string comparisons, and as such, since  ,  , and   will contain something similar to “1.8.7.0D_201708091510”,  these comparisons will all error out, and the version checks will never occur, causing the firmware upgrade to proceed with a older version of the firmware. It should be reiterated that the parent script   does contain a version check is correctly formed: However, it should also be noted that there is only a check for  , and not anything that could prevent a downgrade. 2018-05-01 - Vendor Disclosure \nYYYY-MM-DD - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0566');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (10, 'Yi Technology Home Camera 27US cloudAPI SSID Code Execution Vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the cloud OTA setup functionality of Yi Home Camera 27US 1.8.7.0D. A specially crafted SSID can cause a command injection, resulting in code execution. An attacker can cause a camera to connect to this SSID to trigger this vulnerability. Alternatively, an attacker can convince a user to connect their camera to this SSID. Yi Technology Home Camera 27US 1.8.7.0D 8.8 - CVSS:3.0/AV:A/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Yi Home Camera is an IoT home camera sold globally. The 27US version is one of the newer models sold in the US, and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device: the ability to view the video from anywhere, offline and subscription-based cloud storage, and ease of setup. During the network configuration stage of the setup, the Yi camera prompts the user to show it a QR code that is generated by the app running on the user’s phone. The user types in the SSID and password of the network that they wish for the camera to connect to, and then the app communicates to  , generating a QR code containing the SSID and an encrypted password of the access point. Once the camera is connected to the internet, it then proceeds to sync up with the application, and also notifies the Yi servers that it is online, with the following cloudAPI command: That ends up generating a request that looks like the following: More interesting, though, is how the above command is put together in the first place. Examining the   binary that utilizes this   shows us the following string containing “on_line”: This command string gets sent directly to   and eventually evaluated with a  : At [1], we see the command being built on the stack, with R0 pointing to  . At [2], the cause of the previous log message above is shown, and at [3], the resulting call to   is given, with R0 once again pointing to  . And for brevity,   does just go straight into popen: Thus, if someone connects their own camera, or convinces someone else to connect their camera to an SSID with any sort of command injection strings, it will simply be evaluated as a command.\nIf we have an SSID named  , the resulting on_line packet sent to https://api.us.xiaoyi.net is as such: The command injection is not included, as it has been evaluated and ran as a command: It should be noted that SSID’s are limited in length (32 bytes), and that the camera does not have wget or curl or netcat natively on the box, so options are limited for the actual payload. Enterprising individuals might take advantage of the cloudAPI binary’s network functionality to gain a foothold, however. 2018-05-01 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0580');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (11, 'Yi Technology Home Camera 27US Firmware 7z CRC Collision Vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the firmware update functionality of the Yi Home Camera 27US 1.8.7.0D. A specially crafted 7-Zip file can cause a CRC collision, resulting in a firmware update and code execution. An attacker can insert an SDcard to trigger this vulnerability. Yi Technology Home Camera 27US 1.8.7.0D 7.6 - CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-328: Reversible One-Way Hash Yi Home Camera is an internet of things home camera sold globally. The 27US version is one of the newer models sold in the U.S., and is the most basic model out of the Yi Technology camera lineup.\nIt still, however, includes all the functionality that one would expect from an IoT device: the ability to view video from anywhere, offline and subscription-based cloud storage, and ease of setup. When updating the firmware of the Yi Home Camera, there are two options: over-the-air, or via a microSD card inserted into the device. Directions for this process can be found at  , and the firmware files themselves are available at  . For the 27US version, the tar archive contains two files,   and  , but it only actually updates with the  , which will be the main subject of this writeup. Please note, this issue is referring to a local update only. While the   file is a simple Uboot image and subsequent JFFS2 filesystem, the   firmware file is a lot more opaque: During the power-on stage, the following code in   runs: Which at [1] checks to see if the   file exits on the sdcard root directory. If it exists, then it looks at the   string inside the firmware image, and compares it to the current firmware version at [2]. The kernel modules loaded at [3] and [4] will become relevant soon, but to continue, the actual firmware unpacking occurs in [5], when the   script is run, which will be broken down now: At first, the script will extract the portions of the firmware as listed above,  , , and the rest as  . The interesting things happen next, though: At [1], the   is decrypted by a binary, presumably doing RSA decryption with a   file that was copied into the directory earlier. The result of this decryption is placed in  , which gets prepended to   and thrown into  . The first 33 bytes [3] of  home3 are the md5sum of the firmware, and then the next 33 bytes [4] are the password used to decrypt a .7z archive, which comes from  . Finally, the first 22 bytes [5] of   contain a version string used for version comparison. After this, some nonsensical version comparisons fail, due to reasons explained in TALOS-2018-0566, and then the following command is run:  . In turn, the   binary runs the following command: The   parameter provided to 7za is just the value from the   field earlier, and as shown,   is hardcoded as the .7z archive being decrypted. After the decryption has happened, the   script is run to actually copy over the new firmware. A major oversight in this process is that only a portion of the .7z firmware file is protected by the public/private key encryption. After the first 1366 bytes of home_y18m the contents are that of the final firmware file, with the exception of approximately the first 1024 bytes missing (as they are within the encrypted portion). Normally, this would be a stopper for most file formats, but we can further examine the .7z protocol for more options. Before continuing, it should be noted that the password used for the 7-Zip encryption is  , which was found by editing the firmware unpacking script. After this important detail is known, we can proceed with modifying the portion of the 7-Zip file that is not encrypted also by a private RSA key, and generate a valid home_y18m firmware file with our own files packaged that will pass all the sanity checks. To develop our own modified 7-Zip file, let us examine the headers of the   7-Zip file: ë  TailSize       : 0x39 The first metadata contained in the file is, as one would expect, right at the beginning, which means it\'s in the private key encrypted portion of the 7-Zip, so we cannot actually edit this portion of the 7-Zip without corrupting the data during the decryption process.  Thankfully, we can note most important fields:  ,  ,  and  , which actually describe another metadata header (the Tail Header) further down in the 7-Zip, inside of the unencrypted portion. Examining the Tail header at the address provided  gives us the following output: Looking for the most important fields out of there for the purposes of exploitation, we can see   at [1], which points to the first input stream of the 7-Zip file at offset 0x244f20+0x20. This essentially points us to the first encoded input stream that we will be decoding with AES and then LZMA later on. Stepping back, we can also see that the resulting output stream has a CRC attached to it also, which, after decoding, will throw an error if the CRC does not match. From heuristic testing, the first input stream describes the folders for the files, and also has a pointer to the encoded file data. In order to examine that, we\'d have to decode and decrypt the first input stream so that we had the data required to decode the second input stream. But since that\'s a lot of work, the easier route is to just mess with the unencrypted/unencoded portions of the file for now, e.g. the Tail Header. Remembering that we can\'t touch the  , , and   fields inside of the first header, in order to edit anything important, we have to make the CRC match 0xc452055e, which entails exploring exactly how 7-Zip does CRCs: We can summarize what it does: There is a table of 0x400 UInt32 variables, all set to somewhat random numbers, with no repeats (except for indexes 0x0,0x100,0x200, and 0x300 all are equal to 0x0). Then, it looks at every four bytes of the input buffer and splits those chunks into separate bytes. It takes four UInt32ís from the table that correspond to the bytes and their position, such that if the input buffer is 0x10203040, it would take the UInt32ís from table[0x010],table[0x120],table[0x230], and table[0x340] and XOR them all together. Then it would take this number, XOR it against the next four bytes of the input buffer, and repeat. To make the process easier to understand, we can attach a lot of printfs to the 7-Zip code as such: The end result generates the desired CRC that we saw in the 7z headers from before, so we\'re on the right track. The question now is how to bypass this check and generate our desired headers while also colliding the CRC. In order to get 7-Zip to unpack our own files instead of the official file/encrypted firmware, we can just move the   header from 0x244f20 to wherever we want. Obviously, this will change the generated CRC, but since the CRC mainly uses XOR, and we know the final CRC that we want to generate (0xc452055e), we can just XOR whatever we generate in the second to last iteration with a number to make turn it into 0xf25ff021. This will cause the table indexing operation to generate the values required to end up with 0xc452055e. We must now figure out what parts of the TailHeader can be edited without throwing errors. Killing two birds with one stone, we can actually make the following modifications at the end of the 7-Zip file: The   field determines if the CRCs for all the unpacked folders are defined, and if it\'s not set, it doesn\'t end up checking the folder CRCs afterwards. Then, we throw another null to exit out of the TailHeader parsing, and another null for alignment. We\'re still under the   limit with five bytes left, so we can append whatever bytes we need in order to make the CRC collision work, regardless of whatever changes made to the rest of the TailHeader: As seen at [1], we have changed the dataOffset field to actually point past the TailHeader (which throws a warning, but will still decompress), and at [2] we can see that the CRC matches the untouched CRC from the original home4 file, thus allowing us to append or alter whatever data we want (that\'s not encrypted by the RSA private key), and still have it decompress successfully, allowing for a user-controlled firmware update. It should be noted that there would still be some work to be done in generating the corresponding encrypted folder and file data, but to help speed things along, the AES IV for each Input Stream can be found within the decoded/decrypted input stream headers, along with the IV size, number of Sha256 iterations to generate the key, and the lack of a salt. Also worth noting is that the password string provided ( ) gets expanded to 64 bytes beforehand by turning it into a unicode string (appending ì\\x00î to each char). 2018-05-01 - Vendor disclosure \n2018-09-03 - Vendor submitted build to Talos for testing \n2018-09-05 - Talos confirmed issue patched \n2018-10-22 - Vendor released new firmware \n2018-10-31 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0584');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (12, 'Simple DirectMedia Layer SDL2_Image do_layer_surface code execution vulnerability', 'None', '2018-10-31', 'An exploitable code execution vulnerability exists in the XCF image rendering functionality of SDL2_image-2.0.3. A specially crafted XCF image can cause a heap overflow, resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.3 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow LibSDL is a multi-platform library for easy access to low-level hardware and graphics, providing support for a large amount of video games, software and emulators. The last known count of software using LibSDL (from 2012) was at more than 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When parsing and storing an XCF file (the native file type for Gimp), the LibSDL2 library will first create an SDL_Surface object based on the dimensions of the destination object: The   and   fields are taken directly from the file, as are the first eight bytes, big endian, after the XCF signature. Based of these values, the size of the buffer that stores the resulting picture data after parsing   is allocated to a size corresponding to the data of the final image. The resulting allocation is then calculated with the following code: Each XCF image consists of a set of layers that get displayed on top of each other. Each of these layers consists of an XCF_hierarchy, which defines a set of XCF_levels inside of the file, which each in turn define a set of tiles that actually define the raw pixel data that is written to the surface->pixels buffer from above. For each tile, in each XCF_level, inside each layer (three nested loops), we end up writing to the destination buffer at a given offset corresponding to the location of the tile. To clarify: At [1], we see that we’re going to keep writing to the destination   as long as we have more level->tile_file_offsets, which is an array completely under an attacker’s control. When deciding the destination of the formatted image data, the pointer is calculated at [2], as an offset from the   buffer, which is affected by both   and  . At [3], we can see that   will keep increasing as long as it is less than the   and if there are more  , which are also under attacker control. Thus, the image can describe an arbitrary amount of tiles within the XCF_layer, which, since there’s no checking or correspondence of the layer’s size to the destination surface’s size, allow an attacker to overwrite an arbitrary amount of data on the heap, potentially leading to code execution. 2018-09-11 - Initial Vendor Contact \n2018-09-26 - Vendor Patched \n2018-mm-dd - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0645');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (13, 'MKVToolNix MKVINFO read_one_element code execution vulnerability', 'None', '2018-10-26', 'A use-after-free vulnerability exists in the way MKVToolNix MKVINFO v25.0.0 handles the MKV (matroska) file format. A specially crafted MKV file can cause arbitrary code execution in the context of the current user. MKVToolNix mkvinfo v25.0.0 (\'Prog Noir\') 64-bit 7.3 - AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free This vulnerability can be triggered by providing the user a specifically crafted MKV file to test with the MKVINFO tool. While reading a new element, the parser attempts to validate the current element by checking if it has a particular valid value. If there is no such value [1], then the parser deletes the element since the read was invalid [2]. Even though the element is deleted, the value is passed back to the calling function via the   variable [4]. However there is no validation, even if this element is valid and was not freed before. If the function \"found_in\" returns false [5], mkvinfo will try to delete the l2 EbmlElement. The   function, will return false because the element was never added to the ElementList. It is possible to forge a file such that the function l1->Read (line 154; EbmlMaster::Read) will free the element so another delete operation (line 156) will create a classic use-after-free vulnerability. This situation is confirmed by valgrind: And finally in GDB: 2018-10-25 - Vendor Disclosure \n2018-10-25 - Vendor Patched \n2018-10-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0694');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (14, 'Sophos HitmanPro.Alert hmpalert 0x222000 kernel memory disclosure vulnerability', 'None', '2018-10-25', 'An exploitable memory disclosure vulnerability exists in the 0x222000 IOCTL handler functionality of Sophos HitmanPro.Alert 3.7.6.744. A specially crafted IRP request can cause the driver to return uninitialized memory, resulting in kernel memory disclosure. An attacker can send an IRP request to trigger this vulnerability. Sophos HitmanPro.Alert - hmpalert.sys 3.7.6.744 - Windows 7 x86 4.0 - CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N CWE-200: Information Exposure This vulnerability can be triggered by sending IOCTL requests to the hmpalert device. Here, we show that the default access control on the device allows for any user on the system to send IOCTL requests: Privileged memory disclosure vulnerabilities exist in the IOCTL handler for the 0x222000 control code. The vulnerable function looks like this: We see that without a previous check of   size, it\'s passed as an argument to the   function at line 9. Analyzing   we see: that at addresses: Next, as we can see at line 10, 16 bytes are declared as a buffer size returned to usermode. Tracking what range of bytes is set inside the   function, we know that the buffer at offset range [2;7] is not initialized. Combining that fact with the buffered method used to transfer input data from the IRP request means the buffer retuned to user mode will contain five bytes of leaked kernel memory. Output: 2018-07-23 - Vendor Disclosure \n2018-09-17 - Vendor Patched \n2018-10-25 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0635');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (15, 'Sophos HitmanPro.Alert hmpalert 0x2222CC privilege escalation vulnerability', 'None', '2018-10-25', 'An exploitable arbitrary write vulnerability exists in the 0x2222CC IOCTL handler functionality of Sophos HitmanPro.Alert 3.7.6.744.\nA specially crafted IRP request can cause the driver to write data under controlled by an attacker address, resulting in memory corruption. An attacker can send IRP request to trigger this vulnerability. Sophos HitmanPro.Alert - hmpalert.sys 3.7.6.744 - Windows 7 x86 9.3 - CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-123: Write-what-where Condition This vulnerability can be triggered by sending IOCTL requests to the hmpalert device. Here we show the default access control on the device allows any user on the system to send IOCTL requests: An arbitrary write vulnerability exists in the IOCTL handler for control code 0x2222CC. The vulnerable code looks like this: Three parameters coming from user mode are passed to the   function as an arguments. Let us take a closer look at   function. As we can see at line 12 some sort of checks are made related with  . Indeed,   is checked in context of whether it belongs to the one of \"protected\"/\"monitored\" lsass.exe address space regions. Attacker can try to leak lsass process memory regions addresses using different vulnerability or just brute force them. Next, the read data is copied to   at line 23. Further at line 33, data from   is copied into the address pointed to by the   argument which is fully controlled by the attacker. There are no size checks to ensure that the destination address has enough space for the copy operation. This vulnerability leads to memory corruption and can be used by an attacker to gain arbitrary code execution and privilege escalation. 2018-07-23 - Vendor Disclosure \n2018-09-17 - Vendor Patched \n2018-10-25 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0636');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (16, 'Live Networks LIVE555 streaming media RTSPServer lookForHeader code execution vulnerability', 'None', '2018-10-18', 'An exploitable code execution vulnerability exists in the HTTP packet-parsing functionality of the LIVE555 RTSP server library. A specially crafted packet can cause a stack-based buffer overflow, resulting in code execution. An attacker can send a packet to trigger this vulnerability. Live Networks LIVE555 Media Server Version 0.92 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow The LIVE555 Media Libraries are a lightweight set of multimedia streaming libraries for RTSP/RTCP/RTSP/SIP, with code support for both servers and clients. They are utilized by popular media players such as VLC and MPlayer, as well as a multitude of embedded devices (mainly cameras).  This vulnerability is in the server component which interacts with these media players but does not impact the media players. One of the functionalities enabled by LIVE555 for their standard RTSP server is the ability to tunnel RTSP over HTTP, which is served by a different port bound by the server, typically TCP 80, 8000, or 8080, depending on what ports are available on the host machine. This port can support normal RTSP, but in certain cases, the HTTP client can negotiate the RTSP-over-HTTP tunnel. The code that handles this feature is: As shown above at [3], the “Accept” and “x-sessioncookie” HTTP headers are what decide if it is an RTSP-over-HTTP tunnel or not. Thus, the parameters are read from the input bytes into the sessionCookie [1] and acceptStr [2] buffers on the stack (both of size 200), and then parsed further down. The code path leads into the   function: The only really important things to note are that the char arrays from the parent function are once again passed into a new function directly at [1] ( ) and [2] ( ). This leads into the lookForHeader function: The outermost loop iterates over our input bytes until the   is found. In the case of this program, it continuously looks for “Accept:” and “x-sessioncookie:” with   at [1]. As the comment notes, another loop skips over any whitespace found, and then starts to look for the expected newline chars ‘\\r\\n’ at [2]. After this, the program correctly limits the size of the copy to  , which is correctly set to 0xc8 (200) on both calls into this function. After the copy, the break at [3] is hit, which only actually breaks out of the loop at [4], causing the code to jump back to the initial   loop that was mentioned above. Thus, if there’s another “Accept:” or “x-sessioncookie” string within the buffer, the copy again takes place, and if we examine the actual method of copying at [5], we can see that our initial pointer (that’s pointing to an address in the stack frame of the   function) continues to increment, and while the length of any given copy is limited to the size of the buffer, when there’s no limit on the amount of copies that can occur on an ever increasing destination address, a stack-based buffer overflow can be easily triggered. 2018-10-10 - Vendor Disclosure \n2018-10-17 - Vendor Patched \n2018-10-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0684');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (17, 'Linksys ESeries multiple OS command injection vulnerabilities', 'None', '2018-10-16', 'Multiple exploitable operating system command injections exist in the Linksys ESeries line\nof routers. Specially crafted entries to network configuration information\ncan cause execution of arbitrary system commands, resulting in full control of\nthe device. An attacker can send an authenticated HTTP request to trigger this\nvulnerability. Linksys E1200 Firmware Version 2.0.09\nLinksys E2500 Firmware Version 3.0.04 \n 7.2 - CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Multiple devices in the Linksys ESeries line of routers are susceptible to OS\ncommand injection vulnerabilities due to improper filtering of data passed\nto and retrieved from NVRAM. Many of the configuration details passed to ESeries routers during\nconfiguration must be retained across a device\'s power cycle. Since the device\nhas only one writable directory (/tmp) and that directory is cleared on\nreboot, the device uses NVRAM to store configuration details. When the apply.cgi page is requested with parameters indicating a change to\npersistent configuration settings, those parameters are processed by the\n\'get_cgi\' function call during which they get placed directly into NVRAM\nvia a \'set_nvram\' call. The following example is the apply.cgi disassembly of the path\nthat is taken to write any passed configuration data to NVRAM.\nExecution starts at address 0x00425C20 where the variables are first\nloaded, and then enters a loop until all passed variables are processed. After certain configuration changes are made, including both of the changes\nassociated with these vulnerabilities, a reboot of device services is required.\nThe httpd binary handles this by sending a SIGHUP signal to PID 1, a binary\nnamed \'preinit\'. When \'preinit\' receives this signal it enters a code path\nwhere it restarts all necessary system services. This example can be seen in\nthe apply.cgi disassembly below: When the \'preinit\' binary enters this code path, it exposes functionality\nwhere raw data from nvram_get calls is passed into system commands.\nExamples for each of the three command injection vulnerabilities can\nbe seen below. CVE-2018-3953 - machine_name - start_lltd Data entered into the \'Router Name\' input field through the web portal is\nsubmitted to apply.cgi as the value to the \'machine_name\' POST parameter.\nThe machine_name data goes through the nvram_set process described above.\nWhen the \'preinit\' binary receives the SIGHUP signal it enters a code path\nthat continues until it reaches offset 0x0042B5C4 in the \'start_lltd\'\nfunction. Within the \'start_lltd\' function, a \'nvram_get\' call is used to\nobtain the value of the user-controlled \'machine_name\' NVRAM entry.\nThis value is then entered directly into a command intended to write the\nhost name to a file and subsequently executed. CVE-2018-3954 - machine_name - set_host_domain_name Data entered into the \'Router Name\' input field through the web portal is\nsubmitted to apply.cgi as the value to the \'machine_name\' POST parameter.\nThe machine_name data goes through the nvram_set process described above.\nWhen the \'preinit\' binary receives the SIGHUP signal it enters a code path\nthat calls a function named \'set_host_domain_name\' from its libshared.so\nshared object. The \'set_host_domain_name\' function in libshared.so continues to offset\n0x0001FA40 where nvram_get is called against the \'machine_name\' parameter.\nThe result of that operation is subsequently combined with a string via\na sprintf call and passed directly into system. CVE-2018-3955 - wan_domain - set_host_domain_name Data entered into the \'Domain Name\' input field through the web portal is\nsubmitted to apply.cgi as the value to the \'wan_domain\' POST parameter.\nThe wan_domain data goes through the nvram_set process described above.\nWhen the \'preinit\' binary receives the SIGHUP signal it enters a code path\nthat calls a function named \'set_host_domain_name\' from its libshared.so\nshared object. The \'set_host_domain_name\' function in libshared.so continues until offset\n0x0001FBCC where nvram_get is called against the \'wan_domain\' parameter.\nThe result of that operation is subsequently combined with a string via\na snprintf call and passed directly into system. N/A Usage: Vulnerable parameters:\n - wan name Example: NOTE: This proof of concept will work for both the E1200 and the E2500. 2018-07-09 - Vendor Disclosure \n2018-08-14 - Vendor released patch for e1200 \n2018-10-04 - Vendor released patch for e2500 \n2018-10-10 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0625');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (18, 'Microsoft WindowsCodecs.dll SniffAndConvertToWideString information leak vulnerability', 'None', '2018-10-10', 'An exploitable memory leak vulnerability exists in the   function of WindowsCodecs.dll 10.0.17134.1. A specially crafted JPEG file can cause the library to return uninitialized memory, resulting in an information leak. An a victim would have to interact with a malformed JPEG file to trigger this vulnerability. WindowsCodecs.dll 10.0.17134.1 (WinBuild.160101.0800) 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N CWE-125: Out-of-bounds Read This vulnerability is present in the WindowsCodecs DLL library, which is an implementation of the Windows Imaging Component (WIC) that provides an extensive framework for working with images and image metadata. An attacker is able to leak heap memory due to improper string null termination after calling   on a JPEG file with a malformed metadata field. Here is a simple application that uses the WIC APIs that try to parse metadata from a malformed JPEG file: As we can see, there is an out-of-bounds read during the   structure copy operation. Let\'s take a look at the   function: The out-of-bounds read operation appears at  . Based on the   field value, which is 31 ( ), we know that this   contains a   string. The loop where the OOB read occurs is executed to find the WideChar string null terminator, so it looks like   contains an improperly terminated   string. We land in the   method where the metadata field value is read directly from the file and is later converted to the string above after tracking the string. In our case, the tag that causes the issue is located at   and looks like this: where data related with that tag is at  : 020Fh: 41 53 43 49 49 00 00 00 D3 AA AA AA AA AA AA AA  ASCII...Óªªªªªªª\n021Fh: AA AA                                            ªª According to the  , the   tag can contain designated internal text encoding. That is why the data format is set to undefined and needs to be checked explicitly. Also, the last sentence describing this tag says: Standard suggests that a NULL termination byte is not necessary and indeed our tag\'s data does not have it. Next, after the tag\'s data is read and assigned to the PROPVARIANT   argument, we can see the following code inside the   method: The   function is called when our   is set to   and tag type is   which in our case is true.\nNote that   will be explicitly set to   in this case. When encoding of our   is specified as   or  , a conversion is made from that format to WideString inside the   function and the resulting string is assigned to the   argument.\nTo understand where problem appears we need to dive into the   function and the function   that it calls. Its pseudo code looks as follows: As its name states, this function is responsible for detecting the proper CodePage for   characters and the number of characters after conversion. At   there is an atempt to obtain the amount of characters after conversion but the   API has the   flag set which means that if the  MultiByteToWideChar` API will fail. A reminder of our string :  does not exist as a UTF-8 character but   does and these two bytes will be count as a 1 character. Moving further we have the   bytes chain which does not exist in UTF-8 in any possible sequence, so the   API fails. The   variable is changed via a call to     from UTF-8 to (on testing machine)  . Later a call   API is made but this time without   flag set. This is the definition according the MSDN: This implies that the illegal byte sequence will be replaced with 0xFFFD and count as a 1 character.\nIn our case the number of characters detected is: So a call to   at   will set the   variable to 9. At   the authors took into a count NULL \"byte\" and add 1 to   variable. With this information, the   is finally converted inside   which looks as follow: Notice that in our case   changed from UTF-8 to ANSI Latin1 because of the illegal characters in  . This is important because wqhen using that particular code page characters like 0xD3AA won\'t be treated as a one but two separates chars and generaly all bytes will be converted in the following way: This ends up writing 1 extra character overwriting the terminating NULL byte. As a result, no termination character is set at the end of the newly created WideString. Finally, we land inside the   method, which calls the   function where the    API will be called, this time on a   variant object which contains a non-NULL-terminated WideString that causes an out-of-bounds read during the copy operation. An attacker can use this vulnerability to leak important heap memory and use it to bypass mitigations when exploiting another vulnerability. 2018-08-06 - Vendor Disclosure \n2018-10-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0644');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (19, 'Intel Unified Shader Compiler for Intel Graphics Accelerator Remote Denial Of Service', 'None', '2018-10-9', 'An exploitable denial of service vulnerability exists in the Intel\'s Unified Shader Compiler for Intel(R) Graphics Accelerator (10.18.14.4889). A specially crafted pixel shader can cause denial-of-service issues. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability can be triggered from VMware guest, and VMware host will be affected (leading to vmware-vmx.exe process freeze / unresponsiveness / host CPU resource consumption). Intel igdusc64.dll 10.18.14.4889  (x64) on Windows 8.1 x64\nVMware Workstation 14 (14.0.0 build-6661328) with Windows 8.1 x64 as guestVM 6.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H CWE-835: Loop with Unreachable Exit Condition (\'Infinite Loop\') This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) to the Intel igdusc64.dll driver. Such attack can be triggered from local machine (usermode), from VMware guest usermode (to trigger the bug on VMware host) or theoretically through WEBGL (remote website) — assuming the browser will not use ANGLE and somehow supply the malformed shader to the vulnerable Intel driver. In a typical situation, even if the shader consists of infinite loop, it\'s execution should be terminated by the driver watchdog. This is correct for shaders that don\'t use nested loops. So, for example, a simple pixel shader like the one below will not cause any problems in the Intel igdusc64.dll driver despite the fact that the for loop should theoretically run forever. However, this is not the case when a shader is used that consists of nested loops (one of which being infinite): The second loop condition will never be met, therefore this loop will run forever, causing the igdusc64.dll driver to execute the following code indefinitely: This leads to excessive CPU resource consumption on the host, and basically renders the process unresponsive (so in case of a virtual machine, the entire VM will be unresponsive). 2018-04-19 - Vendor Disclosure \n2018-10-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0579');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (20, 'VMware Workstation 14 Shader Functionality Assert Denial Of Service', 'None', '2018-10-9', 'An exploitable denial-of-service vulnerability exists in  VMware Workstation 14. A specially crafted pixel shader can cause denial-of-service issues. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability can be triggered from VMware guest, and VMware host will be affected (leading vmware-vmx.exe process to crash on host). VMware Workstation 14 (14.1.1 build-7528167) with Windows 10 x64 as guestVM 6.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H CWE-617: Reachable Assertion This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) inside VMware guest OS. Such an attack can be triggered from the VMware guest usermode to cause a memory denial-of-service attack on vmware-vmx.exe process on the host, or theoretically through WEBGL (remote website) — assuming the browser will not use ANGLE, and will somehow supply the malformed shader. A sample shader that triggers the bug is provided below: By forcing the initial value of the loop counter variable (\"j\") to be in range from 0x80000000 to 0xfff00000, it is possible to cause the vmware-vmx.exe process to terminate due to an assert condition. VMware compiles the shader and passes it to the graphics card driver on host. The shader gets executed and causes a  reset of the device. We can assume so by two errors reported in the VMware log. The DXGI_ERROR_DEVICE_REMOVED error states that \"video card has been physically removed from the system, or a driver upgrade for the video card has occurred. The application should destroy and recreate the device.\" The DXGI_ERROR_DEVICE_HUNG error states that \"the application\'s device failed due to badly formed commands sent by the application. This is a design-time issue that should be investigated and fixed.\" This situation most likely causes panic in the vmware-vmx.exe process and leads to its termination. From the vmware-vmx.exe: From the vmware-vmx-debug.exe: 2018-05-07 - Vendor Disclosure \n2018-10-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0589');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (21, 'Intel Unified Shader Compiler for Intel Graphics Accelerator Pointer Corruption', 'None', '2018-10-9', 'An exploitable pointer corruption vulnerability exists in the Intel\'s Unified Shader Compiler for Intel(R) Graphics Accelerator (10.18.14.4889). A specially crafted pixel shader can cause a pointer corruption resulting in at least denial of service or, if exploited successfully, code execution. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability can be triggered from a VMware guest and the VMware host will be affected (potentially leading VMware ti crash or a guest-to-host escape). Intel igdusc64.dll 10.18.14.4889  (x64) on Windows 8.1 x64\nVMware Workstation 14 (14.0.0 build-6661328) with Windows 8.1 x64 as guestVM 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-822: Untrusted Pointer Dereference This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) to the Intel igdusc64.dll driver. Such an attack can be triggered from a local machine (usermode), from VMware guest usermode (to cause memory corruption on VMware host) or theoretically through WEBGL (remote website) -- assuming the browser will not use ANGLE and will somehow supply the malformed shader to the vulnerable Intel driver. A specifically crafted shader file causes igdusc64.dll driver to execute memory location taken from a pointer that is corrupted/invalid: More disassembly: An attacker can influence the index value (0x45AF5E) used for calculating the final pointer however this is not the culprit of the problem. The actual pointer corruption happens in some odd way, earlier in sub_142B0. This function writes a new pointer to a [mem - 4] region where later [mem] region is being used by the function that uses this region as a \"source\" for a call instruction destination. Meaning the final pointer will in fact be computed from two different pointers. In this example the memory address with call destination was 0x0000008029505a78, but sub_142B0\nwrote a pointer to 0x0000008029505a74 - so 4 bytes before that. The rest of v-table does not appear to be corrupted, all other entries are valid: and all the entries appear to point to correct function locations: The heap memory itself doesn\'t appear to be corrupted as well. Whether such \"limited\" control for the attacker is enough to turn this bug into full code execution is unclear, but cannot be excluded entirely. 2018-02-27 - Vendor Disclosure \n2018-10-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0533');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (22, 'Intel Unified Shader Compiler for Intel Graphics Accelerator Remote Denial Of Service', 'None', '2018-10-9', 'An exploitable denial-of-service vulnerability exists in the Intel\'s Unified Shader Compiler for Intel(R) Graphics Accelerator (10.18.14.4889). A specially crafted pixel shader can cause denial-of-service issues. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability can be triggered from VMware guest, and VMware host will be affected (leading to vmware-vmx.exe process crash on host). Intel igdusc64.dll 10.18.14.4889  (x64) on Windows 8.1 x64\nVMware Workstation 14 (14.0.0 build-6661328) with Windows 8.1 x64 as guestVM 7.7 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H CWE-131: Incorrect Calculation of Buffer Size This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) to the Intel igdusc64.dll driver. Such an attack can be triggered from local machine (usermode), from VMware guest usermode (to trigger the bug on VMware host) or theoretically through WEBGL (remote website) — assuming the browser will not use ANGLE and somehow supply the malformed shader to the vulnerable Intel driver. By supplying a specially generated shader file, an attacker can force the igdusc64.dll to execute the \"memcpy_s\" function with arguments that trigger an exception, which later forces termination of the program in order to prevent memory corruption. The initial problem starts when there is no proper validation of the return value provided by \"sub 34BC30\" in a while loop condition (maximum value of iterations). By supplying a malformed shader, an attacker can force this value to be 0xFFFFFFFF (-1), and therefore force the while loop in \"sub 0x1E9A0\" is called, fragments of which are provided below: Please note that at [1], the LEA instruction is used to calculate the final size for the   call. This is done by multiplying RBX register by 4 and truncating the result to a 32-bit value (the result is later stored in ECX / R14D). As you can see, the instruction at 0x1EA20 calculates the source size (count) parameter for the   function. The initial 32-bit value is taken from [rsi+0x20] memory and is multiplied later by shifting left at [2] (shl 2 / fast multiply by 4) but the result of this operation is a 64-bit value, not 32-bit, and it is stored in the R9 register. By supplying the malformed pixel shader, an attacker can force the Intel igdusc64.dll driver to allocate memory with size 0 (calculated size parameter passed to   will be 0 due to 32-bit number limitations) but the   size (count) parameter passed to the   function will be much bigger (0x0000000080000000). If the normal   function would have been used that could cause a memory corruption, but since the   function is used in, the incorrect parameter will be detected and the exception will be thrown which will result in the application being terminated. 2018-04-19 - Vendor Disclosure \n2018-10-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0568');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (23, 'Google PDFium JBIG2 image ComposeToOpt2WithRect information disclosure vulnerability', 'None', '2018-10-3', 'An exploitable out-of-bounds read on the heap vulnerability exists in the JBIG2 parsing code of Google Chrome version 67.0.3396.99. A specially crafted PDF document can trigger an out-of-bounds read, which can possibly lead to an information leak that could be used as part of an exploit. An attacker needs to trick the user into visiting a malicious site to trigger the vulnerability. Google Chrome version 67.0.3396.99 5.9 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:L/A:N CWE-125: Out-of-bounds read PDFium is an open-source PDF renderer developed by Google and used extensively in the Chrome browser, as well as other online services and standalone applications. This bug was triaged on in the latest version of git, as well as the latest Chromium address sanitizer build that\'s available. A heap buffer overflow is present in the code responsible for decoding a JBIG2 image stream. A PDF object describing the JBIG2 image details with specific details is required: In the above object, specified width and height are of importance. The minimal contents of the stream required to trigger this vulnerability are: Contents of the first region above isn\'t important, but it\'s presence is required. When parsing an immediate generic region (type 38, or 0x26 specifically) the execution eventually ends up at   in  . The following code is interesting in particular: In the above code, variables   and   come directly from the   and   fields in the immediate generic region. Values of   and   represent the size of the destination decoded bitmap as specified by the   and   keys in object   of the PDF. Due to the way arithmetic decoding works for the specified  , the values of   will be increasing with each call. The buffer pointed to by   is allocated in a call to   and depends indirectly on the values of   and  , thus it is under the attacker\'s control. The out-of-bounds memory read bug lies in the fact that it is possible to both skip the check at [1] and increment the   pointer at [2] to beyond the allocated buffer, thus allowing access to adjacent memory. The variable   also increases by one in each call to  , so if the check at [1] passes,   can point out of bounds. For an out-of-bounds condition to happen, the calculated offset at [2] must be greater than   times  , while still passing the check at [1]. With the values supplied in the attached proof of concept, this is indeed the case, and leads to a crash at line 747 where out-of-bounds memory is accessed: Since the out-of-bounds buffer pointer is increased with each call to  , memory is leaked one byte at a time up to controllable size. A patch along the lines of the following should be sufficient: It should be pointed out that the size of the destination buffer (the decoded bitmap) is based on height and width as specified in the PDF object   and is unaffected by this heap overflow. This is the reason this vulnerability is confined to an out-of-bounds read. Also, given that the size of the allocation of the overflowed buffer is under direct control, and that we can further manipulate values in the calculation at [2], a possibly targeted region of the memory, of controllable size, could be read into the destination buffer. With precise control of the memory layout and decoder manipulations it is possible that this could lead to further memory corruption. Address sanitizer output: 2018-07-25 - Vendor Disclosure \n2018-10-02 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0639');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (24, 'Adobe Acrobat Reader DC collab review server remote code execution vulnerability', 'None', '2018-10-2', 'Specific JavaScript code embedded in a PDF file can lead to a use-after-free condition when opening a PDF document in Adobe Acrobat Reader DC 2018.011.20040. With careful memory manipulation, this can lead to arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.011.20040 6.8 - CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a large user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. The one method call required to trigger this vulnerability is privileged and can only be called from trusted functions or from a trusted location. Additionally, the use-after-free condition is only triggered upon closing the application. Adobe Acrobat Reader DC supports embedded JavaScript code in the PDF to allow for interactive PDF forms. This gives the potential attacker the ability to precisely control memory layout and poses an additional attack surface. While executing the following piece of code, a stale reference misuse can lead to a dereference of a previously freed object which can cause further memory corruption: When closing the application, a number of objects are freed and due to cache/reference mishandling, an object is referenced again after it has been freed already. If we let Adobe Reader execute all JavaScript code, then break, we can set the breakpoint at AcroRd32!AcroWinMainSandbox+0x1e7f5`. After trying to close the application, our breakpoint will be hit a total of nine times. We are interested in the last two. The second to last time our breakpoint is hit, we see: We break just as   is being dereferenced, and it\'s   being accessed. The code that follows is: From the previous   output, we can see that the object is currently in a busy allocation of size 0x70. The callstack at the previous breakpoint is as follows: If we let the process resume, it will eventually free this object: This lets us examine both where the object was freed and how it was retrieved. Continuing the execution brings us back once again to our initial breakpoint: We can see that the same object is being dereferenced. Since the object has been freed, this triggers a use-after-free condition and results in an immediate crash. In essence, the same object reference is being used to free the object twice. With heap debugging flags fully disabled, this leads to a crash when the process tries to execute code on a random address with which the freed memory was overwritten. With careful memory layout manipulation, that address could point to attacker-controlled code and ultimately result in arbitrary code execution. Crash with heap debugging disabled: 2018-07-05 - Vendor Disclosure \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0623');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (25, 'Foxit PDF Reader JavaScript getNthFieldName remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use-after-free Foxit PDF Reader is one of the most popular PDF document readers, and has a large user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with a crafted object as argument, which can trigger a use-after-free condition, like in the following code: In the above code, we create an object   and overload its   method to be  . Then, when   is invoked,   of the first argument is called, effectivelly closing the document and freeing a number of objects. When   continues execution, it reuses a stale reference of a freed object causing a crash. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand in  . Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straight forward conditions for arbitrary code execution. 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0608');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (26, 'Foxit PDF Reader JavaScript Field object signatureInfo remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.2.0.9297. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.2.0.9297. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Accessing a variable which keeps a reference to a stale object can lead to a use-after-free condition. This particular vulnerability lies in saving a reference to   object by invoking   method of a form field. When the document is closed, objects are freed and accessing a stale reference results in a use-after-free condition, like in the following code: Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. We can abuse typed arrays to try and fill the memory of the freed object. A simple spray of   typed array of size 0x30 sufices in this case: Instructions immediately following the point of crash are: We control the contents of   in the first instruction since we control the contents of the reused memory. This leads to the following crash if it\'s non-zero: By further manipulating memory layout and contents of reclaimed memory, the above division can succeed and then lead to more direct instruction pointer control ultimately leading to arbitrary code execution. 2018-09-10 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0663');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (27, 'Foxit PDF Reader Javascript removeDataObject Remote Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a large user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with a crafted object as argument, which can trigger a use-after-free condition, like in the following code: In the above code, we create an object   and overload its   method to be  . Then, when   is invoked,   of the first argument is called, effectively closing the document and freeing a number of objects. When   continues execution, it reuses a stale reference of a freed object, causing a crash. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated  freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand in  . Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straightforward conditions for arbitrary code execution. 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0607');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (28, 'Foxit PDF Reader JavaScript JSON.Stringify this remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use-after-free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with the   object as argument, which can trigger a use-after-free condition like in the following code: In the above code, we make a reference to the   object as variable  . Then, the document is closed. Afterward, calling   with   as argument leads to a use-after-free vulnerability. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand. Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straightforward conditions for arbitrary code execution. Note that this vulnerability is almost the same as the use-after-free condition triggered in JSON.stringify triggered with   object described in TALOS-2018-0612, but in this case, a different object is actually reused and the crash occurs in a different place. 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 -  Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0611');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (29, 'Atlantis Word Processor document endnote reference code execution vulnerability', 'None', '2018-10-1', 'An exploitable arbitrary write vulnerability exists in the Word document parser of the Atlantis word processor. A specially crafted document can prevent Atlas from adding elements to an array that is indexed by a loop. When reading from this array, the application will use an out-of-bounds index which can result in arbitrary data being read as a pointer. Later, when the application attempts to write to said pointer, an arbitrary write will occur. This can allow an attacker to further corrupt memory, which leads to code execution under the context of the application. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.0.2.3\nAtlantis Word Processor 3.0.2.5 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-129: Improper Validation of Array Index Atlantis\' Word Processor is a traditional word processor that has a number of features, including portability. It is ideally suited for both writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors, such as Microsoft Office Word 2007. Atlantis also has the capability to encrypt document files and to fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When Atlantis tries to parse a Microsoft Word Binary Document, the application will first fingerprint it to determine the correct file format. Once discovering that the file is a compound document file, it will locate the \"WordDocument\" stream, check the stream\'s signature, and then read the   out of its header. After storing a couple of fields out of the  , the application will then use a field from the   to determine which stream contains table information which can be \"1Table\" or \"0Table.\" Once identifying the correct table stream, the application will then read an offset to the CLX array and its size out of the   and use this to locate the CLX array. When parsing this array, the application will check if the elements in the array are pointing to compressed pieces/text. If an individual piece is compressed, the application will re-calculate the character position and write it back into the array. If the CLX array size (as stored in the  ) is smaller than a multiple of the size of each individual element, this new character position will be written outside the bounds of the array, leading to a heap-based buffer overflow. When first loading a document, the application will call the following function. This function takes a   and the file format type as an index and is responsible for fingerprinting the file and then parsing it. First, at [1], the application will call the function  , which will read a filename from the function\'s frame and then write a file handle into the   variable at  . After the handle is allocated, the application will read the file into a buffer and then call the function at   to verify that the file matches the type that was specified. Once this has been verified to be a Word document (.doc), the application will then call the function at [2] in order to parse the file. To parse a .doc file, the application will execute the following function. This will first perform a number of things to figure out how to handle the .doc file. First, the application will check the beginning of the \"WordDocument\" stream for a 16-bit signature 0xa5ec. Once that is determined, Atlantis can then read from the Fib in the \"WordDocument\" stream\'s header to locate which stream contains table data [3]. If this bit is set [1], then the table can be located in the \"1Table\" stream. If it is cleared [0], then the table will be located in the \"0Table\" stream. The correct stream is then opened by the call at [4] or [5]. Finally, the last stream that this function will open is the \"Data\" stream. This stream is opened at [6]. After opening up the required streams, Atlantis will begin to parse required data out of them. At [6], the application will begin to parse various records such as the   table (Document Properties),   table (Bookmarks), etc. After parsing this, the application will take the sum of the various   fields that are listed. These fields are needed by parsers of the Word Document to determine the location of the different sections of a document. Eventually the application will execute the instruction at [7] and continue parsing more of the file format. Once inside function  , the application will then enter the loop at [8]. This loop will iterate over the different sections of the document in order to process all of the fields that are defined within a particular section. This is done by parsing the different PLC structures that are defined within the Word Document\'s   header. On the fifth iteration of this loop, the application will process the   field in the  . This field is responsible for determining the document fields that are located within the \"Endnote\" section. Once the position and size of the   are determined, at [9] the application will read it into a   object and then eventually enter a loop that processes the CLX records. At this point, the application will then process the CLX records in order to identify which \"pieces\" of the document the fields are in. This is done by reading the CLX location from the  , and then iterating through each entry in the piece descriptor table  . After locating the location of each piece and then calculating its size, the function call at [10] is made with the range of the piece and its size. Once inside the function at  , the application will start by calculating the position of the section by using its argument to determine which   fields to sum. At [11], the application will grab the index from the function\'s argument and at [12] a loop will be entered that will read each   and add it to a variable that represents the beginning of the specified section. Each   from the field described prior will be an offset from this position inside the \"WordDocument\" stream. After determining the base of the endnote section, the application will then execute the following code. This code will use the CLX descriptor combined with the base of the section in order to read a field from the \"WordDocument\" stream at [13]. After reading this field information into a large array, the function call at [14] will be executed. Inside function  , the function will perform a few calculations (depending on whether the piece descriptor specified the text is compressed or not) in order to locate the correct character position into the current section, the \"Endnote\" section, for the current field. After doing this, the following code will be executed. At the beginning of this code, the application will calculate a pointer to a   object in a different frame at [15]. This   object actually contains the contents of the   field,  , that was read from the document\'s   earlier. After dereferencing this pointer, the application will then call a function at [16]. Depending on the index that is passed to this, this function may return the size of a   object belonging to   also read out of the  . This size will be later used to calculate the number of iterations for a loop. Immediately following the reading of the size from the   object at [18], the size will then be used to calculate the number of   elements inside the   field. Once this has been determined, the loop at [19] will be entered. This loop will increase an index for each iteration of the loop and will iterate for the number of   elements that was calculated from the size of the   object for the   field. This index that is incremented will later be used to fetch a pointer from a   which will then be written to. Inside the prior described loop, the application will then enter a case statement that will process different lists depending on the case. After executing the case statement, the application will then execute the following code before continuing the loop. As a safety at [20], the application will incorrectly check that the index is not larger than the number of elements described by the  . However, as will be shown later this index should be checked against the number of the   elements. At [21], the current invalid index will then be passed to the function 0x5955a4. Inside the function  , the following code will eventually get executed. At [22], the application will fetch a   that collected the   objects referenced by the   field. Due to the application not checking the invalid index against the number of elements in this  , the function call at [23] which fetches an element from a   will return a pointer outside the bounds of the list. This function will actually return an invalid pointer which then gets stored at [24]. Later at [25], this pointer will get read and then used to write a   to at [26]. This results in the invalid pointer being written to which results in an arbitrary write which can lead to code execution under the context of the application. Set a breakpoint when the index   is larger than the length of the  Output the fields belonging to the  . The length of the   is 0x15. Output the index that is used. The index is 0x21. Dump out members of the  Dump out the item pointed to by the index Continue execution... Dump out the contents of pointer that was dereferenced. To use the proof of concept, simply open up the document in the target application. The application should crash at the instruction specified while trying to write a pointer to a  . 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0650');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (30, 'Foxit PDF Reader JavaScript this.info multiple remote code execution vulnerabilities', 'None', '2018-10-1', 'A total of six separate use-after-free vulnerabilities exist in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to run. Direct access to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. It should be noted that   method requires higher privileges so either the document needs to come from a trusted location or the user must click a dialogue box that allows it to run. This particular vulnerability lies in accessing saved references to certain properties of   object, which can trigger a use-after-free condition. Specific examples are below. A use-after-free condition can occur when accessing the   property of the   object. The following code demonstrates this: This results in the following crash: A use-after-free condition can occur when accessing the   property of the   object. The following code demonstrates this: This results in the following crash: A use-after-free condition can occur when accessing the   property of the   object. The following code demonstrates this: This results in the following crash: A use-after-free condition can occur when accessing the   property of the   object. The following code demonstrates this: This results in the following crash: A use-after-free condition can occur when accessing the   property of the   object. The following code demonstrates this: This results in the following crash: A use-after-free condition can occur when accessing the   property of the   object. The following code demonstrates this: This results in the following crash: In all of the above crashes, access violation happens when memory pointed to by   is dereferenced, which is already freed. If this memory location is placed under attacker control, a double dereference could lead to control over contents of   which is used in a   instruction, thus leading to arbitrary code execution. It should be pointed out that even though all of the above crashes happen at the same place, the execution paths are different, as evidenced by the call stack, thus separate CVEs have been allocated for each. 2018-07-16 - Vendor Disclosure \n2018-09-18 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0628');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (31, 'Foxit PDF Reader JavaScript field object signatureGetSeedValue remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.2.0.9297. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.2.0.9297. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which frees numerous used objects, but the JavaScript can continue to execute. A use-after-free condition can occur when accessing a variable that keeps a reference to a stale object. This particular vulnerability lies in saving a reference to   object by invoking   method of a form field. Objects are freed when the document is closed, and a use-after-free condition occurs when accessing the stale reference: Opening this proof-of-concept PDF document in Foxit Reader with pageheap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to a   instruction with controllable operand in  . This leads to a relatively straightforward condition for arbitrary code execution since the contents of the memory pointed to by   can be easily controlled. 2018-09-10 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0665');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (32, 'Foxit PDF Reader JavaScript field object isDefaultChecked remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.2.0.9297. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.2.0.9297. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees numerous used objects, but the JavaScript can continue to execute. A use-after-free condition can be created by invoking a method that keeps a stale reference to a now-freed object. This could be abused to execute arbitrary code. This particular vulnerability lies in invoking   method of a field object with a crafted object as argument, which can trigger a use-after-free condition: Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. Also, we can see that the instruction immediately following the point of crash makes an indirect call to a controlled address. We can abuse typed arrays to try and fill the memory of the freed object. A simple spray of   typed array suffices in this case: Loading the proof of concept in the Foxit Reader with pageheap disabled this time results in the following crash: This can easily lead to arbitrary code execution, as we have direct control over the instruction pointer. 2018-09-10 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0664');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (33, 'Atlantis Word Processor empty TTableRow TList code execution vulnerability', 'None', '2018-10-1', 'An exploitable uninitialized pointer vulnerability exists in the Word document parser of the the Atlantis Word Processor. A specially crafted document can cause an array fetch to return an uninitialized pointer and then performs some arithmetic before writing a value to the result. Usage of this uninitialized pointer can allow an attacker to corrupt heap memory resulting in code execution under the context of the application. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.0.2.3\nAtlantis Word Processor 3.0.2.5 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-391: Unchecked Error Condition The Atlantis Word Processor is a traditional word processor that comes with a variety of features. It is ideally suited for both writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors, such as Microsoft Office Word 2007. Atlantis also has the ability to encrypt document files and fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When Atlantis tries to parse a Microsoft Word Binary Document, the application will first fingerprint it to determine the correct file format. Once discovering that the file is a compound document file, it will locate the \"WordDocument\" stream, check the stream\'s signature, and then read the   out of its header. After storing a couple of fields out of the  , the application will then use a field from the   to determine which stream contains table information which can be \"1Table\" or \"0Table\". Once identifying the correct table stream, the application will then read an offset to the CLX array and its size out of the   and use this to locate the CLX array. When parsing this array, the application will check if the elements in the array are pointing to compressed pieces/text. If an individual piece is compressed, the application will re-calculate the character position and write it back into the array. If the CLX array size (as stored in the  ) is smaller than a multiple of the size of each individual element, this new character position will be written outside the bounds of the array leading to a heap-based buffer overflow. When first loading a document the application will call the following function. This function takes a   and the file format type as an index and is responsible for fingerprinting the file and then parsing it. Firstly at [1], the application will call the function   which will read a filename from the function\'s frame and then write a file handle into the   variable at  . After the handle is allocated, the application will read the file into a buffer and then call the function at   to verify that the file matches the type that was specified. Once this has been verified to be a Word Document (.doc), the application will then call the function at [2] in order to parse the file. After successfully parsing the file, resulting in a   object, the application will continue by first popping the first   out of the   [3] and then iterating through all of the   objects associated with the   at [4]. After processing the sections, the application will then continue on to [5] where it will loop over a number of   object before executing. Later, the following code will be reached. At [6] the function is called with the   object that resulted from parsing the document as an argument. After descending into said function, the function call at [7] will be reached. Inside this function at [8], the application will fetch a   off of the parsed   obnect and then grab a   using   as the index. This   will be used to terminate the loop that follows. This loop will call the function at [9] for each iteration whilst passing the number of pages and the   to it. Inside the function  , the application will do a number of things to use the different lists belonging to the   objects to link the different   and   objects together. After executing all this at [10], the application will eventually execute the code at [11] to populate some fields inside the   object. After this is all initialized, the current frame is then passed to the function call at [12]. This code construct is typically used when a developer uses a closure or an anonymous function to process variables. At the beginning of the following function at [13], the application will call into the function  . This function will do some processing using the   object and then return a   for the current position. Finally at [14] at [15], the application will check to see if some byte fields are set. If they are not, then execution will continue. At [16], the application will finally call the function that wraps our vulnerability. This function will also get its caller\'s frame passed to it. At [17] of the following function, the application will grab the current  . This   will be used to loop through the current   belonging to the  . At [18], a loop will be entered which will search for a   that fits within specific boundaries. After this is found at [19], the application will store the found   to  . Later at [20], a   variable will be initialized which will then be populated with the   at [21]. Eventually the application will populate some fields in a   and hand off the   and the   to the function call at [22] which contains the vulnerability. At the beginning of the function, the application will first store its arguments followed by instantiating a   object. After encountering the branches at [23] and [24], the application will use the   passed as one of its arguments in order to grab the   object that owns it at [25]. At [26], the application will use an index from the caller\'s frame to fetch a   element from the  . Finally at [27], the application will encounter a branch which should initialize a   using the contents of another. First, the application will append eight bytes to the beginning of the previously allocated   object followed by constructing a number of   objects. It is prudent to note that when Delphi destroys a   object, Delphi will append the deleted object to a global cache. This way, when it is necessary to construct a  , Delphi can simply fetch one of the previously deleted   objects and avoid any allocations required. When the application constructs its numerous   objects, one of these objects is critical to triggering the vulnerability described by this document. At [25], is the   that is constructed. This   contains the aggregation of all of the   elements that were found in the  . A little farther after at [26], the application will call into a function that\'s responsible for taking the   at +6c of the   and using it to extend the   stored at   with its   elements. This is done inside the function call at [27]. However, due to the   at +6c being empty, this results in the code at [27] not being executed which results in the   at   also being empty. These lists should contain a number of   objects. However, due to a missing or corrupted property, (sprm) they are left empty. Later at [28], the application will fetch the first element from the empty  . As soon as the application attempts to initialize it at [29], this will result in the application writing to the uninitialized pointer that was fetched. This should allow an attacker to corrupt heap memory belonging to the application which can result in code execution under the context of the application. Set breakpoint at construction of empty TList. Execute instruction that constructs empty TList Tlist has been constructed and is empty. Execute till function that should initialize TList. Dump out empty TList in TDoc Step over which should initialize TList Dump out TList that should\'ve been initialized, but is still empty. Execute till function that fetches first element from TList Depiste this fetching a NULL pointer when executed, the pointer is actually uninitialized and is dependent on the state of the previous   that was destroyed. Uninitialized pointer fetched from TTableRow list is now written to To use the proof of concept, simply open up the document in the target application. The application should crash at the instruction specified while trying to write to the uninitialized pointer. 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0651');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (34, 'Foxit PDF Reader Javascript JSON.Stringify this.info Remote Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking   method of the active document with   object as argument, which can trigger a use-after-free condition like in the following code: In the above code, we make a reference to the   object as variable  . Then, the document is closed. Afterwards, calling   with   as argument leads to a use after free. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: First chance exceptions are reported before any exception handling.\nThis exception may be expected and handled. Analyzing the heap state clearly shows that   points into an unallocated freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand. Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straight forward conditions for arbitrary code execution. 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0612');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (35, 'Foxit PDF Reader JavaScript this.bookmarkRoot.children remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees numerous used objects, but the JavaScript can continue to execute. A direct access to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. It should be noted that the   method requires higher privileges so either the document needs to come from a trusted location or the user must click a dialog that allows it to run. This particular vulnerability lies in accessing saved reference to   object, which can trigger a use-after-free condition like in the following code: In the above code, after closing the current document, a large amount of objects is freed. By modifying the   method of   object, we trigger a use after free with the following crash: An access violation happens when accessing memory pointed to by   which points to a free memory location. If this memory location is placed under attacker control, the double dereference could lead to control over contents of   which is used in an unconditional jump instruction, thus leading to arbitrary code execution. 2018-07-16 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018—10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0630');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (36, 'Foxit PDF Reader JavaScript this.event.target Remote Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which frees numerous used objects, but the JavaScript can continue to run. Direct access to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. It should be noted that   method requires higher privileges so either the document needs to come from a thrusted location or the user must click a dialog that allows it to run. This particular vulnerability lies in accessing saved reference to   object, which can trigger a use-after-free condition like in the following code: In the above code, after closing the current document, a large number of objects are freed. By modifying the   method of   object, we trigger a use after free with the following crash: Access violation happens when accessing memory pointed to by   which points to a free memory location. If this memory location is placed under attacker control, double dereference could lead to control over contents of   which is used in a   instruction, thus leading to arbitrary code execution. 2018-07-16 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0632');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (37, 'Foxit PDF Reader Javascript importDataObject Remote Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.2.0.9297. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.2.0.9297. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. A multipage PDF document can have Javascript actions attached to \"page open\" and \"page close\" events. Careful manipulation of an allocated object upon \"page open\" and \"close\" can lead to use-after-free conditions which can be abused to gain arbitrary code execution. When opening the document, code associated with the \"open\" event of the page in focus will execute. Specifically, calling   in a \"page open\" event allocates an extra object on the heap. Then, the code in the \"open\" action for the whole document kicks in. Calling   can then dereference a freed object leading to a use-after-free condition. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. We can abuse typed arrays to try and fill the memory of the freed object. An object size of 0xff8 sufices in this case: Loading the PoC in the Foxit Reader with PageHeap disabled this time results in the following crash: This has a potential of being used as an arbitrary read, but careful manipulation of typed array contents can lead to more direct instruction pointer control and ultimately arbitrary code execution. 2018-09-10 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0662');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (38, 'Foxit PDF Reader JavaScript getPageBox remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use-after-free Foxit PDF Reader is one of the most popular PDF document readers, and has a large user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with a crafted object as argument, which can trigger a use-after-free condition, like in the following code: In the above code, we create an object   and overload its   method to be  . Then, when   is invoked,   of the second\nargument is called, effectively closing the document and freeing a number of objects. When   continues execution, it reuses a stale reference\nof a freed object causing a crash. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand in  . Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straightforward conditions for arbitrary code execution. 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0610');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (39, 'Foxit PDF Reader Javascript Optional Content Group Remote Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.2.0.9297. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.2.0.9297. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Accessing a variable which keeps a reference to a stale object can lead to use-after-free condition. This particular vulnerability lies in invoking the way \"Optional Content Groups\" are manipulated. Saving an OCG and then accessing its properties after the document is closed can trigger a use-after-free condition like in the following code: Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. Also, we can see that the instruction immediately following the point of the crash makes an indirect call to a controlled address. We can abuse typed arrays to try and fill the memory of the freed object. A simple spray of   typed array of size 0x48 sufices in this case: Loading the PoC in the Foxit Reader with PageHeap disabled this time results in the following crash: As we have direct control over the instruction pointer this can easily lead to arbitrary code execution. 2018-09-10 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0661');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (40, 'Foxit PDF Reader JavaScript this.dataObjects remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees numerous objects, but the JavaScript can continue to execute. Direct access to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. It should be noted that the   method requires higher privileges, so either the document needs to come from a trusted location, or the user must click a dialogue box that allows it to run. This particular vulnerability lies in accessing saved reference to   object, which can trigger a use-after-free condition like in the following code: In the above code, after closing the current document, a large amount of objects are freed. By modifying the   method of   object, we trigger a use-after-free condition with the following crash: An access violation happens when accessing memory pointed to by   which points to a free memory location. If this memory location is placed under attacker control, double dereference could lead to control over contents of   which is used in a direct   instruction, thus leading to arbitrary code execution. 2018-07-16 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0631');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (41, 'Foxit PDF Reader JavaScript getPageNumWords remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with a crafted object as argument, which can trigger a use-after-free condition, like in the following code: In the above code, we create an object   and overload its   method to be  . Then, when   is invoked,   of the first argument is called, effectively closing the document and freeing a number of objects. When   continues execution, it reuses a stale reference of a freed object causing a crash. It should be noted that the   method requires higher privileges so either the document needs to come from a trusted location or the user must click a dialog that allows it to run. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. And if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to a   instruction with a controllable operand in  . Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straight forward conditions for arbitrary code execution. 2018-07-16 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0629');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (42, 'Foxit PDF Reader JavaScript page change remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader, version 9.2.0.9297. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.2.0.9297. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. A multi-page PDF document can have JavaScript actions attached to \"page open\" and \"page close\" events. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Changing a page at a precise moment after the document is closed can lead to a use-after-free condition. In the attached PDF, the \"document open\" action puts the first page in focus which executes its \"page open\" action. This \"page open\" action then sets the focus on the second page which, in turn, executes the \"close\" action of page one. That action closes the document, which frees numerous objects, after which the page focus is changed and the use after free is triggered. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points to a freed memory region. We can abuse typed arrays to try and fill the memory of the freed object. An object size of 0x20 suffices in this case: Loading the proof of concept in the Foxit Reader with pageheap disabled results in the following crash: We can observe that the instruction immediately following the point of the crash makes an indirect   with   being the target. Since the value of   is under control, this leads to direct instruction pointer control and ultimately arbitrary code execution. 2018-09-10 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0660');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (43, 'Atlantis Word Processor Windows Enhanced Metafile Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable heap-based buffer overflow vulnerability exists in the Windows enhanced metafile parser of Atlantis Word Processor, version 3.2.5.0. A specially crafted image embedded within a document can cause an undersized allocation, resulting in an overflow when the application tries to copy data into it. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.2.5.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Atlantis\' Word Processor is a traditional word processor that is aimed to be both portable, flexible, and full of a number of features. This word processor is ideally suited for writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors, such as Microsoft Office Word 2007 and even has several similarities. Atlantis also has the capability to encrypt document files and fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When processing a Microsoft Word XML Document, the application has the ability to embed various images within the document. There are a number of image types, and these are handled by a class named  . When constructing a   class, the following function will be executed. This function will first check the header of the file to see if it matches a known signature for the PNG, GIF, or JFIF image formats. If the signature is not detected, then the application will determine the actual image type by checking the file extension embedded within the document against a global list. This enumeration is then passed to the function call at [1]. Inside the function call at  , the application will assign the image type enumeration to a local variable at [2]. Later at [3], the application will pass the image type enumeration as an argument to a function call. This function is responsible for constructing an instance of the class specific to the detected image file format. At [4], the application will enter a case statement and will then branch to the case that instantiates the constructor for the image format type specified by the enumeration. When handling a Windows metafile, it will branch to the following case. This handler will first construct an instance of a   object at [5] and then store it to a variable. A method will be called at [6] immediately afterward with the path to the actual image file. This method is a wrapper that will instantiate a   object and then proceed to use the object to load the image file for usage by the   object. Inside this method, the following code will be executed to wrap the loading of the image. The method will first construct a   object at [7] and then pass it as an argument to a method specific to each file format parser. The object\'s method is called at [8] and is actually responsible for reading the image file contents. The method that gets called is named   depending on the image type. This results in the following code being executed. This code is used to load data for parsing a Windows Enhanced Metafile image and starts out by calling the function at [9]. This call is responsible for verifying that the signature at the beginning of the file begins with \"EMF\" and aborting if not. Once the signature is verified, the application will finally make the call at [10] which will actually parse the image file header and contains the vulnerability within. The following function actually contains our vulnerability and starts by allocating 0x64 bytes on the stack. This space is used by the function to read the beginning of the EMF header. At [11], the application will call a function that wraps   to accomplish this and load data from the file onto the stack. The header for an EMF file includes a field representing the size of the entire file. This field is used by the application at [12] to perform an allocation. Due to the size from the file\'s header being provided by a user. This allows one to control the size of the allocation. Immediately following this allocation, the application will make a call to   at [13] using a hard-coded length of 0x64. Due to the file data being explicitly trusted to control the size used for the allocation of the destination pointer. An aggressor can specify a size less than 0x64, which will result in the call at [13] overflowing the destination buffer, which can allow for heap corruption. If the call to   for the 0x64 byte header does not corrupt memory, the following call at [14] that reads the rest of the file may corrupt memory. These types of heap corruptions can allow for code execution under the context of the application. 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0666');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (44, 'Foxit PDF Reader JavaScript getPageNthWord remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a large user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document, which can trigger a use-after-free condition called with specially crafted arguments like in the following code: In the above code, we craft an object   with overloaded   method to call function  . Then we invoke the   method. While accessing the arguments,   will expect its second argument to be of type   and will call the object\'s   method. In this case, that will execute function   which closes the current document. Closing the document frees a number of objects, and then when the execution returns to the rest of   method, a stale pointer is reused leading to use-after-free. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated freed memory region. If we examine the next few instructions we can see the following: We can observe from the above listing that twice-dereferenced address from  , through   ends up in   which is then used an operand to   instruction. This makes this vulnerability easy to exploit, since we can control the contents of  . 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor Patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0613');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (45, 'Foxit PDF Reader JavaScript getPageRotation remote code execution vulnerability', 'None', '2018-10-1', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use-after-free Foxit PDF Reader is one of the most popular PDF document readers, and has a large user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with a crafted object as argument, which can trigger a use-after-free condition, like in the following code: In the above code, we create an object   and overload its   method to be  . Then, when   is invoked,   of the first\nargument is called, effectivelly closing the document and freeing a number of objects. When   continues execution, it reuses a stale reference of a freed object causing a crash. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated  freed memory region. And if we take a look at the code immediatelly following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand in  . Since the contents of memory pointed to by   can easily be controlled,this leads to relatively straight forward conditions for arbitrary code execution. 2018-06-05 - Vendor Disclosure \n2018-09-28 - Vendor patched \n2018-10-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0609');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (46, 'Atlantis Word Processor Word Document Complex Piece Descriptor Table Fc.Compressed Code Execution Vulnerability', 'None', '2018-10-1', 'An exploitable out-of-bounds write vulnerability exists in the Word Document parser of the Atlantis Word Processor. A specially crafted document can cause Atlantis to write a value outside the bounds of a heap allocation, resulting in a buffer overflow. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.0.2.3, 3.0.2.5 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Atlantis\' Word Processor is a traditional word processor that markets itself as being portable and feature-heavy. This word processor is ideally suited for writers and students and provides a number of useful features that can help simplify, and even improve, one\'s writing. Atlantis Word Processor is fully compatible with other word processors such as Microsoft Word 2007. Atlantis also has the capability to encrypt document files and to fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When Atlantis tries to parse a Microsoft Word binary document, the application will first fingerprint it to determine the correct file format. Once discovering that the file is a compound document file, it will locate the \"WordDocument\" stream, check the stream\'s signature, and then read the   out of its header. After storing a couple of fields out of the  , the application will then use a field from the   to determine which stream contains table information which can be \"1Table\" or \"0Table\". Once it has identified the correct table stream, the application will then read an offset to the Clx array and its size out of the   and use this to locate the Clx array. When parsing this array, the application will check if the elements in the array are pointing to compressed pieces/text. If an individual piece is compressed, the application will re-calculate the character position and write it back into the array. If the CLX array size (as stored in the  ) is smaller than a multiple of the size of each individual element, this new character position will be written outside the bounds of the array, leading to a heap-based buffer overflow. When first loading a document, the application will call the following function. This function takes a   and the file format type as an index and is responsible for fingerprinting the file and then parsing it. First, at [1], the application will call the function 0x5ab474, which will read a filename from the function\'s frame and then write a file handle into the   variable at  . After the handle is allocated, the application will read the file into a buffer and then call the function at 0x5ad9aa to verify that the file matches the type that was specified. Once this has been verified to be a Word document (DOC), the application will then call the function at [2] in order to parse the file. To parse a DOC file, the application will execute the following function. This will first perform a number of things to figure out how to handle the file. First, the application will check the beginning of the \"WordDocument\" stream for a 16-bit signature 0xa5ec. Once that is determined, Atlantis can then read from the Fib in the \"WordDocument\" stream\'s header to locate which stream contains table data [3]. If this bit is set (1), then the table can be located in the \"1Table\" stream. If it is cleared (0), then the table will be located in the \"0Table\" stream. The correct stream is then opened by the call at [4] or [5]. Finally, the last stream that this function will open is the \"Data\" stream. This stream is opened at [6]. After opening up the required streams, Atlantis will begin to parse the required data out of them. At [6], the application will begin to parse various records such as the document properties table, PlcfBkl table (Bookmarks), etc. After parsing this, the application will take the sum of the various CCP fields that are listed. These fields are needed by parsers of the Word document to determine the location of the different sections of a document. Eventually, the application will execute the instruction at [7] and continue parsing more of the file format. Once inside the following function (0x597114), Atlantis will store some of the individual CCP fields that were summed up earlier. These fields will be used to collect the different sections belonging to the document. After they are collected, they are used to process a number of different fields within the  . Eventually, the application will get to the instruction at [8]. These instructions will use the   structure belonging to the   field in the   to locate the CLX array in the table stream. At [9], the   field containing the size of the \"Clx\" array will be used in an allocation. This allocation will be the heap buffer that will be overflown later. Immediately afterward at [10] the application will read the CLX array into the buffer. After reading the CLX array, Atlantis will begin to parse it. To parse this array, the application will read the first byte and check to see if it is a 0x01 or a 0x02. If it\'s a 0x01, it will process the array as an   array. If it\'s 0x02, it will process it as a   or a \"piece descriptor\" array. The vulnerability described in this advisory is related to how the application processes the piece descriptor array. Once determining that the CLX is pointing to a piece descriptor array, the application will pre-calculate some pointers into the data that need to be parsed. This will then be processed by a loop that will iterate for each element in the array. After determining how to parse the piece descriptor table, the application will execute the following loop. Each iteration of this loop will read each piece descriptor and determine whether the piece is described as compressed or not. This result will eventually be handed off to the function call at [11]. However, due to the way the application handles a compressed piece, the application may corrupt the memory that was allocated for the Clx array. At [12], the application will check to see if the   field is set. If this field is set, then execution will continue at [13]. At this point the application will extract the   offset from the piece descriptor, divide it by two, and then write it back into the array at [14]. Due to the application using the   field from the Fib to allocate this array and initialize it, the application may corrupt data during the last iteration after the array with the instruction at [14]. At [15], the pointer will then be freed. Due to the way the Delphi heap allocator works, this will result in an \"unlink\" that can be used to further corrupt memory. In the provided proof-of-concept, the   field is set to the following values. Due to the   field being set to a size of 0x31, which is not a multiple of the size of a piece descriptor (8), the application will read a uint32 partially outside the end of the Clx array when entering the loop described in the prior code, divide it by two, and then write it back into the array. Due to this uint32 being outside of the CLX array, this will corrupt any memory that is positioned after it. Execute until the CLX array gets allocated. The CLX array is allocated with 0x31 bytes. The buffer allocated for the CLX array was returned in %eax. Check each iteration of loop to identify the iteration that writes past the CLX array Last iteration of loop has written out of bounds of the CLX array. Continue execution till it gets freed. Step over the free which uses the corrupted memory. The provided proof of concept is encompassed within a Microsoft Word document that uses Microsoft\'s Compound File Binary format. Documentation for this can be found at   and its respective file format at   Binary File Format). A Microsoft Word compound document contains a number of streams. The ones that are utilized by this vulnerability are the \"WordDocument\" stream and the \"Table\" stream. The \"WordDocument\" stream contains the table of contents for the rest of the file using a structure referred to as the   or the \"File Information Block\". The table stream can have one of two names. These are \"0Table\" and \"1Table\". The specific stream name can be identified by a flag which is located in the   that is stored at the beginning of the \"WordDocument\" stream. In the \"WordDocument\" stream within the provided proof of concept, the   has the following structure. The application actually verifies that a file is valid by checking a couple of fields in the   structure despite this vulnerability only depending on a small number of fields. In this structure, the fields  ,  , and   contain the number of elements of the arrays that follow them. The   is composed of uint16 t, and the   is composed of uint64_t. The   structure has the following format. Atlantis verifies that the   field is set to 0xa5ec, and that the value for   is larger than 0x0065. The table stream is chosen by the   (0x0200) flag. If this value is true, then \"1Table\" is chosen, otherwise \"0Table\" is chosen. The other fields that Atlantis requires is that   (0x0004),   (0x0100), and   (0x8000) are cleared. The following fields are inside the   array. These fields are used by the piece descriptor table to determine when the   array terminates and the   array begins. Normally, the   field (index 3) can be used to determine the limits of the maximum value for  . However, if any of the   (index 4),   (index 5),   (index 6),   (index 7),   (index 8), or   (index 9) fields are set. Then the maximum value for   is based on the sum of these numbers. After Atlantis validates the fields in the header, the vulnerability consists of just the   field inside the   within the file information block. Each field inside   has the following format. This structure contains a field   which represents an offset into a stream, and   which represents the number of bytes. The   field is at index 33 of the   array. For an   structure, the   field represents the offset into the table stream. Atlantis uses the   field to control the size of the allocation which is then used in the loop that can corrupt memory. The application can corrupt memory after the array when it attempts to write a compressed offset back into the allocated CLX array because the field is not a multiple of the size of a piece description [8]. Using the   field from the  , the CLX array can be located inside the table stream. This array is prefixed with a byte,  , which determines what type of array will follow. Within the provided proof of concept, this value must be 0x02 in order for a piece descriptor table array to be contained. The piece descriptor table array is prefixed with a 32-bit length, which is used to describe the size of the   array. Inside the   array are two fields. The   field represents the character position. This array is composed of uint32_t and loops until one of the values is larger than the CCP fields that were explained earlier. Once the array has terminated, the rest of the structure (as sized by the   field of the   structure) is composed of   elements. Each   structure has the following format and is eight bytes long. The first 16 bits represent general flags, followed by a uint32_t for the   field, and then ended with a 16-bit value representing a  . This vulnerability revolves around the   field being compressed. A piece descriptor represents a compressed piece when the   flag (0x40000000) of the   field is set. When this field is set, the   (0x3fffffff) is divided by 2 and then written pasted the array corrupting any memory after the allocation. If the last element of the   array is compressed by setting this flag, this vulnerability is likely being triggered. 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0646');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (47, 'Atlantis Word Processor Office Open XML TTableRow double free code execution vulnerability', 'None', '2018-10-1', 'An exploitable double-free vulnerability exists in the Office Open XML parser of Atlantis Word Processor, version 3.2.5.0. A specially crafted document can cause a   instance to be referenced twice, resulting in a double-free vulnerability when both the references go out of scope. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.2.5.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-415: Double Free Atlantis\' Word Processor is a traditional word processor that is aimed to be both portable and flexible and contains a variety of features. This word processor is ideally suited for both writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors such as Microsoft Office Word 2007 and even has a similar interface. Atlantis also has the capability to encrypt document files and to fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When opening a document file, the application will construct an instance of the   object. This instance will eventually be passed as an argument to the function containing the following code. This code is a case statement and is responsible for switching to the correct document parser based on the document file type enumeration that is stored within the   instance. Eventually at [1], the application will call the function responsible for parsing Office Open XML documents. This function will initialize a number of variables that are used by the entire Office Open XML parser. This function is important in that it is considered by the author to be the upper-most function and all child functions called by this are executing within closures which allows numerous callees to modify the variables within this function. Some of these variables include the current styles that have been parsed, a variable containing the root   element, and even information about the table row (and table) that is currently being parsed. The current table row that this vulnerability revolves around is used specifically for keeping track of the current table row and is hence represented by a   object. This variable is located in this function\'s frame at  . After initializing some large arrays that are assumed by the author to contain different styles used by elements within the document, at [2] the application will search through the XML document for the \"w:body\" element. Once this is located, it will be passed as an argument to the function call at [3] in order to parse all of its child elements. As mentioned previously, the following function is used to iterate through all the children within the \"w:body\" tag. At the beginning of the function, this element is stored in the   register. A   element is also similar to a  . At [4], the application will read the number of child elements from the   element and use it in the loop that follows. For each child element, the application will call the recursive function at [5]. This next function is a recursive function that is entirely responsible for parsing the XML that composes an Office Open XML document. As a result, it has a large number of cases used to dispatch to the correct parser for each specific element. This function is responsible for containing the scope of the   that is abused by this vulnerability. At [6], the function will first convert the XML tag name into a token/enumeration. This will then be used in a case statement in order to handle processing of the element. At [7], the   element will have one of its properties checked which will be used to determine whether this element needs to be saved. Finally, before the function leaves, the   element will be freed at [8]. When the previously defined function handles particular cases, the application makes some assumptions about the order in which these tags are processed. Unfortunately this can allow for scoping issues which results in the vulnerability described by this document. When handling case 0x5d which represents the \"tr\" (table row) tag, the following code is executed. First at [10], a new   object is constructed. Immediately following this at [11], the properties from the previously parsed row is copied into the current one. At this point at [12], the application will then proceed to search for any new properties that need to be applied to the current row. This is done by searching for a child element with the tag \"tblPrEx\" or \"trPr\". Once an element is found, one of the calls to [13] will extract the attributes from the element and apply them to the   object. Later, when the application parses a table column identified by the \"tc\" tag in case 0x5b, the following code will be executed. Firstly, this case will grab an index out of the properties of the current table row and then use it to initialize a 0x90 byte object at [14]. After this, various styles will be extracted similar to the \"tr\" element (case 0x5d), described previously. However, the function call at [14] will then be called. This function call will recurse into the current function and iterate through the \"tc\" element\'s children. For future reference, this function call to 0x59cf1c is used to recurse into the various container elements by the document parser. When handling both the \"pPr\" tag (case 0x3c) and the \"rPr\" tag (case 0x49), the function at 0x59cf1c is called by [15]. When processing the malformed XML document included with this advisory in the proof-of-concept, one of the \"rPr\" elements is spread over two \"tr\" ( ) elements. Due to the way this malformed document is parsed by the application, this results in the \"rPr\" element being constructed twice but pointing to the same parent \"tr\" ( ) that the \"rPr\" tag is opened in. This results in the recursion parsing elements in the following approximate order. When parsing the \"rPr\" tag at [17], this object is constructed using the parent \"tr\" at [16]. Later when closing the tag, due to the \"rPr\" element being opened in the \"tr\" at [16], this results in the   being called on the same \"tr\" element ([16]) twice. This results in a double-free vulnerability which can cause heap corruption. Proper manipulation of this heap corruption can lead to code execution under the context of the application. Set some breakpoints to monitor scope of   that is double-freed. Constructing the first   object. Pointer to first   object. Constructing the second   object. Pointer to second   object. Freeing the second   object. Pointer to second   object. Freeing the second   object again. Freeing the second   object again. Heap is now corrupted Caller is pointing to  2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0668');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (48, 'Atlantis Word Processor Word document paragraph property (0xD608) sprmTDefTable uninitialized length code execution vulnerability', 'None', '2018-10-1', 'An exploitable uninitialized length vulnerability exists within the Word document-parser of the Atlantis Word Processor. A specially crafted document can cause Atlantis to skip initializing a value representing the number of columns of a table. Later, the application will use this as a length within a loop that will write to a pointer on the heap. Due to this value being controlled, a buffer overflow will occur, which can lead to code execution under the context of the application. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.0.2.3\nAtlantis Word Processor 3.0.2.5 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Atlantis\'= Word Processor is a traditional word processor that contains many features and aims to flexible for the user. This word processor is ideally suited for both writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors such as Microsoft Office Word 2007. Atlantis also has the capability to encrypt document files and to fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When Atlantis tries to parse a Microsoft Word Binary Document, the application will first fingerprint it to determine the correct file format. Once discovering that the file is a compound document file, it will locate the \"WordDocument\" stream, check the stream\'s signature, and then read the   out of its header. After storing a couple of fields out of the  , the application will then use a field from the   to determine which stream contains table information which can be \"1Table\" or \"0Table\". Once identifying the correct table stream, the application will then read an offset to the CLX array and its size out of the   and use this to locate the   array. When parsing this array, the application will check if the elements in the array are pointing to compressed pieces/text. If an individual piece is compressed, the application will re-calculate the character position and write it back into the array. If the CLX array size (as stored in the  ) is smaller than a multiple of the size of each individual element, this new character position will be written outside the bounds of the array, leading to a heap-based buffer overflow. When first loading a document, the application will call the following function. This function takes a   and the file format type as an index and is responsible for fingerprinting the file and then parsing it. Firstly at [1], the application will call the function 0x5ab474 which will read a filename from the function\'s frame and then write a file handle into the   variable at  . After the handle is allocated, the application will read the file into a buffer and then call the function at   to verify that the file matches the type that was specified. Once this has been verified to be a Word Document (doc), the application will then call the function at [2] in order to parse the file. To parse a .doc file, the application will execute the following function. This will first perform a number of things to figure out how to handle the .doc file. First, the application will check the beginning of the \"WordDocument\" stream for a 16-bit signature 0xa5ec. Once that is determined, Atlantis can then read from the Fib in the \"WordDocument\" stream\'s header to locate which stream contains table data [3]. If this bit is set [1], then the table can be located in the \"1Table\" stream. If it is cleared [0], then the table will be located in the \"0Table\" stream. The correct stream is then opened by the call at [4] or [5]. Finally, the last stream that this function will open is the \"Data\" stream. This stream is opened at [6]. After opening up the required streams, Atlantis will begin to parse required data out of them. At [6], the application will begin to parse various records such as the   table (Document Properties),   table (Bookmarks), etc. After parsing this, the application will take the sum of the various   fields that are listed. This fields are needed by parsers of the Word Document to determine the location of the different sections of a document. Eventually, the application will execute the instruction at [7] and continue parsing more of the file format. Inside the function  , the application will initialize a number of variables on the stack. At [7] and [8], the application will initialize arrays that are intended to contain various   properties associated with the word document with the value 0x80000000. These arrays are important in that they will be initialized later when the application attempts to parse the different pieces and to determine which properties to apply to which parts of each piece. Later at [9], the application enter a loop which will iterate through all of the different   field types defined within the document. Inside this loop, the application will then parse the   field that is defined within the  . This is done in order to identify the different sections that are defined by the document and to determine how to apply properties to each character or paragraph. After identifying the   field, the application will begin to read the contents of the   field. First at [10], the application will read the size ( ) of the   type followed by reading the character position ( ) at [11]. At [12], the application will allocate space for it and then read the contents of the CLX array from the \"WordDocument\" stream. After reading the CLX array from the stream, the application will then execute the following loop in order to handle the piece descriptor table. At [13], the application will check to see if the current piece is compressed in order to re-calculate the size of the specified piece. Eventually this information along with the beginning character position of the current piece is then passed to the function call at [14]. Inside the function  , the application will first calculate the   position using the values from the Fib. After determining the correct position based on the values from the  , the application will grab the   from the piece descriptor table and pass it to the function call at [15]. At the beginning of the function call, the application will pass through the   position to the function call at [16]. This function call is responsible for for parsing the different paragraph properties that are pointed to by the current piece descriptor within the bounds of the current   that was parsed earlier. As mentioned prior, there are a number of property arrays that are initialized to 0x80000000 inside of the function at  . The function call at   is responsible for actually initializing them with the correct values. First the function will store the pointer to the target property array which gets written to at [17] along with the   field from the piece descriptor table. After checking a number of things, the   field will be sought out and then parsed in order to get access to the   offset, which represents the sector that the paragraph properties are located at. This is then handed off to the call at [18]. At this point, the application will begin to parse the paragraph properties and store them in the property array. Eventually, when the application gets to [19], a case statement will determine which property was parsed and then store any of its operands into the   array. This vulnerability involves the   property not actually being parsed and thus leaving the index in the   array uninitialized as 0x80000000. If the   existed, the code at [20] would correctly the number of columns into the   array. Returning back to the function  , the application will continue to parse the different characters inside the current piece. Eventually the code at [21] will be executed. This code is responsible for processing any tables that were discovered within the piece. First the application will verify that the property is initialized followed by constructing a   object. After some pointer arithmetic, the application will read the uninitialized length from the property array at [22]. This is then immediately stored at offset 0xc4 of the   data at [23]. With the provided proof-of-concept, this value will be the incorrect length of 0x80000000. After storing the number of columns into offset +0xc4 of the   data, the application will execute the following code. This code will read the number of columns at [24] and then assign it to a variable at [25]. Again, due to the number of columns being uninitialized this results in a loop length of 0x80000000. After assigning the number of columns, the loop for the table\'s columns will be entered at [26]. This loop will take the current index, and multiply it by 18. This resulting value will then be used to grab a pointer out of the  . Due to the loop having a number of columns that is larger than the specified in the table, the iteration at [28] will result in an index being calculated that is out of bounds of the  . This results in the pointer at [27] being controllable by an attacker. There are a then number of ways that this pointer is used one of which it is written to which can cause controlled heap corruption. The provided proof of concept will crash while using the pointer within the loop at the following code. At [29], the application will read the out-of-bounds pointer and then add 0x4c to it. Immediately afterward, a function will be called with this pointer. Eventually, at [30], the application will write NULL to the arbitrary pointer resulting in heap corruption which can result in code execution under the context of the application. Set a breakpoint where   array is allocated at. Open up a document and execute to break at that location. Set a breakpoint where the loop counter for the   is assigned. Execute once, so we\'re at the first  , which is on the second-to-last page. Notice that the number of columns is three, which is correct. Execute again so we\'re on the second   on the last page. Notice that the length is uninitialized and is thus incorrect. Set a breakpoint where the calculated pointer is incremented and stored to local variable. Execute and notice that each iteration results in 0x90 being added to the pointer. Disable pointer that is used to monitor loop. Continue execution until crash. To use the proof of concept, simply open up the document in the target application. The application should crash at the instruction specified while trying to write to the pointer. 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0652');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (49, 'Atlantis Word Processor Office Open XML uninitialized TTableRow code execution vulnerability', 'None', '2018-10-1', 'An exploitable uninitialized pointer vulnerability exists in the Office Open XML parser of Atlantis Word Processor, version 3.2.5.0. A specially crafted document can cause an uninitialized pointer representing a   to be assigned to a variable on the stack. This variable is later dereferenced and then written to allow for controlled heap corruption, which can lead to code execution under the context of the application. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.2.5.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-457: Use of Uninitialized Variable Atlantis\' Word Processor is a traditional word processor that both portable and flexible, and contains a variety of features. This word processor is ideally suited for writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors such as Microsoft Office Word 2007 and even has a similar interface. Atlantis also has the capability to encrypt document files and fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When opening a document file, the application will construct an instance of the   object. Eventually, this instance will be passed as an argument to the function containing the following code. This code is a case statement and is responsible for switching to the correct document parser based on the document file type enumeration that is stored within the   instance. Eventually,k at [1], the application will call the function responsible for parsing Office Open XML documents. This function will initialize a number of variables that are used by the entire Office Open XML parser. This function is important because it is considered by the author to be the upper-most function and all child functions called by this are executing within closures which allows numerous callees to modify the variables within this function. Some of these variables include the current styles that have been parsed, a variable containing the root   element, and even information about the table row (and table) that is currently being parsed. The current table row that this vulnerability revolves around is used specifically for keeping track of the current table row and is hence represented by a   object. This variable is located in this function\'s frame at  . After initializing some large arrays that are assumed by the author to contain different styles used by elements within the document, at [2] the application will search through the XML document for the \"w:body\" element. Once this is located, it will be passed as an argument to the function call at [3] in order to parse all of its child elements. As mentioned previously, the following function is used to iterate through all the children within the \"w:body\" tag. At the beginning of the function, this element is stored in the   register. A   element is also similar to a  . At [4], the application will read the number of child elements from the   element and use it in the loop that follows. For each child element, the application will call the recursive function at [5]. This next function is a recursive function that is entirely responsible for parsing the XML that composes an Office Open XML document. As a result, it has a large number of cases used to dispatch to the correct parser for each specific element. This function is responsible for containing the scope of the   that is abused by this vulnerability. At [6], the function will first convert the XML tag name into a token/enumeration. This will then be used in a case statement in order to handle processing of the element. At [7], the   element will have one of its properties checked which will be used to determine whether this element needs to be saved. Finally before the function leaves, the current   element will be freed at [8]. When processing a row within a table, the \"tr\" tag is handled by the following code which is 0x5d. The code block at [9] is executed when this element is encountered. This results in the construction of a new   object. Immediately following this at [10], the resulting object is assigned into the current   that is defined within the upper-most frame. At this point, the application will copy any properties from the previously parsed   into the newly constructed one [11]. Alternatively, when parsing a \"tbl\" tag (case 0x5a) the following case will be executed. After extracting some properties/styles from the document similarly to the other table-related XML tags, the application will construct a   at [12] to contain them. Next the parser will read the current   that is stored in the variable belonging to the upper-most function at  , and then write it into a local variable at [13]. Afterwards, the application will construct a new   instance, and then store it at [14]. If this function is executed before the current   is initialized (explicitly done by the previously described code), this will result in the instruction at [13] initializing the local variable containing the current   with an uninitialized value. Later in the same handler for the \"tbl\" tag (case 0x5a), the application will execute the following code. The code will first shift the old source table row back to its original state. This is done by freeing the current one with   at [15]. Afterward at [16], the application will take the currently saved   out of the local variable belonging to the frame. Lastly, the application will take the local variable containing the current   and write it back into the upper-most function\'s original variable,  , at [17]. Due to the case for handling the \"tbl\" tag (case 0x5a) being able to be called before this local variable is initialized, this will result in an uninitialized pointer being written into the current   belonging to the upper-most frame. At this point, the application just needs to be convinced to use the current   stored in the upper-most frame. The provided proof-of-concept does this by embedding another \"tbl\" tag, followed by defining a \"tr\" tag for a table row. When parsing a \"tr\" element (case 0x5d), the following code will be executed. This code will parse various things within the current row element and initialize its properties with some of the attributes defined by the various elements within. Eventually the function call at [18] will be called with the current frame as its argument which will continue by parsing the children belonging to the row. With the provided proof-of-concept, the usage of the uninitialized   from the upper-most frame is triggered by a table column identified by the \"tc\" element (case 0x5b). Depending on the value of the uninitialized pointer, there are a number of places that can be used to corrupt memory. One such place is at [19] which will allow one to increment an arbitrary address leading to corruption. With further work, this can be made to lead to code execution within the context of the application. Set breakpoint at scope of current   in upper-most function Set breakpoint at hand-off of uninitialized   to local variable Set breakpoint at hand-off of local variable back into  We\'re at the beginning of the upper-most function where the   is allocated for (but not initialized) Value of   is pointing to value of uninitialized   and is saved in local variables Uninitialized   saved in local variables is restored to   in upper-most function Uninitialized pointer is used as base address to increment a property of  . 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0669');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (50, 'Atlantis Word Processor uninitialized TDocOleObject code execution vulnerability', 'None', '2018-10-1', 'An exploitable uninitialized variable vulnerability exists in the RTF-parsing functionality of Atlantis Word Processor. A specially crafted RTF file can leverage an uninitialized stack address, resulting in an out-of-bounds write, which in turn could lead to code execution. Atlantis Word Processor 3.2.6 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-457: Use of Uninitialized Variable Atlantis is a traditional word processor containing quite a few features. Atlantis supports a large variety of document formats, as well as quite a few different graphics formats to complement the text in a document. Many of the capabilities of Atlantis are designed to be more efficient for the user. One file format that is parsed by Atlantis is rich text format (RTF). RTF has a series of tokens that are parsed via a large switch statement as the parser comes across them. For example, the beginning of this parsing function looks like: Some switch cases are simply setting flags in the overarching document object, while others took parameters and call further functions for parsing. Each index in this switch statement is referenced to a global list of tokens available in Atlantis. RTF format allows for embedded OLE objects. These objects rely on a few tokens specific for OLE and are used to set a variety of options in the OLE. In particular, these tokens have the following switch cases: These cases rely on the   having a valid OLE pointer at offset   in order to set the correct value. This   passed to the RTF-parsing function comes from a stack variable: This stack variable is directly passed forward to the RTF-parsing function: The assumption at this point is, if any of the Ole token are parsed, a valid OLE document object pointer exists at offset  . The initialization function for the OLE document object is not necessarily called before parsing the OLE tokens. Because of this, the OLE document object pointer (offset  ) can be uninitialized. If this stack offset can be controlled by an attacker, then an attacker can write to an arbitrary address, causing an out-of-bounds write condition. 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0641');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (51, 'Atlantis Word Processor JPEG length underflow code execution vulnerability', 'None', '2018-10-1', 'An exploitable stack-based buffer overflow vulnerability exists in the JPEG parser of Atlantis Word Processor, version 3.2.5.0. A specially crafted image embedded within a document can cause a length to be miscalculated and underflow. This length is then treated as unsigned and then used in a copying operation. Due to the length underflow, the application will then write outside the bounds of a stack buffer, resulting in a buffer overflow. An attacker must convince a victim to open a document in order to trigger this vulnerability. Atlantis Word Processor 3.2.5.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Atlantis\' Word Processor is a traditional word processor that is aimed to be both portable, flexible and contains a number of features. This word processor is ideally suited for both writers and students and provides a number of useful features that can help simplify and even improve one\'s writing. Atlantis Word Processor is fully compatible with other word processors, such as Microsoft Office Word 2007 and even has a similar interface. Atlantis also has the capability to encrypt document files and to fully customize the interface. This application is written in Delphi and contains the majority of its capabilities within a single relocatable binary. When processing a Microsoft Word XML Document, the application has the ability to embed various images within the document. There are a number of image types and these are handled by a class named  . When constructing a   class, the following function will get executed. This function will first check the header of the file to see if it matches a known signature for the PNG, GIF, or JFIF image formats. If the signature is not detected, then the application will determine the actual image type by checking the file extension embedded within the document against a global list. When checking the header, the application will will first check for a PNG signature via a call to   [1]. The application will then check if the signature matches either a GIF or a PNG file. After checking for these signatures, the final check will look for the JFIF signature which is used to identify that the image is in JPEG format. Once identified as a JPEG, at [2] the application will assign an enumeration to a register and then pass it as an argument to [3]. The application will assign the image type enumeration to a local variable at [4] inside the function call at 0x5e6758. Later at [5], the application will pass the image type enumeration as an argument to a function call. This function is responsible for constructing an instance of the class specific to the detected image file format. At [6], the application will enter a case statement and will then branch to the case that instantiates the constructor for the image format type specified by the enumeration. The following case will be branched to when handling a JPEG. This handler will first construct an instance of a   object at [7] and then store it to a register. Immediately afterward, a method will be called at [8] with the path to the actual image file. This method is a wrapper which will instantiate a   object and then proceed to use the object to load the image file for usage by the   object. Inside this method, the following code will be executed to wrap the loading of the image. The method will first construct a   object at [9] and then pass it as an argument to a method specific to each file format parser. The object\'s method is called at [10] and is actually responsible for reading the image file contents. The function   is simply a wrapper around the lower-level JPEG parser. This function will call a couple of functions and then call the function responsible for initializing global JPEG parsing structures at [11]. Inside this function, a   object will be constructed followed by constructing a   object. Eventually, the function call at [12] will be made. This function allocates space for a global structure that contains function pointers which will be used during JPEG decoding. Once this is complete, the call at [13] will be made, which will immediately make another function call at [14] which will actually process the markers inside a JPEG image. The JPEG parser utilized by the application retains the current JPEG marker used for decoding in a global. This is first checked at [15] to determine whether the current state is the \"JPG\" marker (FF C8). If it\'s not, then the application will continue executing and then do some arithmetic at [16] to see if the marker is \"SOF9\" (FF C9). The function will read the global structure containing the different function pointers that was described previously and then dispatch into the first one similar to to the call at [17] when handling each of these markers. This first function pointer will look at the current JPEG state and then finally call into a function at [18] to process each specific marker. When processing specific markers, the following code will be executed. This code will perform a number of comparisons in order to narrow down on which function will be used to handle the different markers that can be encountered when parsing a JFIF stream, such as embedded within a JPEG image file format. At [19], application will use an index to dispatch into the handler for the currently parsed \"APPx\" marker. This will then result in the following code being executed by the application to handle the different \"APPx\" marker types. The first 16 bits after an \"APPx\" marker will contain the length of the marker. At [20], the application will read the first eight bits, and then assign it to the high byte of a variable that will be referred to as the  . At [21], the next byte will be read and it will be added to the current value of the   variable. This composes the 16-bit word, which will be used as the length of the structure following the marker. At this point, the application will perform a signed comparison to see if the count is less than the value of zero. If it is less than or equal to zero, then the block at [22] will be executed which will explicitly set the value of   to zero. Finally, the application will use the   variable as a terminator in a loop. At [23], the application will decrease the count by one and then immediately increment it by one when entering the loop. If the 16-bit word following any of the \"APPx\" markers is zero, this will result in the following loop continuously iterating until the next time the   variable is zero. At [24], the application does a simple byte-for-byte copy by reading a byte from the   register, and writing it back to the   register. The decrement for each iteration of the loop is done at [25]. Due to this loop being unbounded and writing into a local buffer, this can result in a stack-based buffer overflow which can lead to code execution under the context of the application. It is also prudent to note, that if this 16-bit length is larger than 0x20 then the stack-based buffer overflow will also occur due to the buffer having a maximum size of 0x20 bytes before overwriting the function\'s frame pointer. 2018-09-10 - Vendor Disclosure \n2018-09-11 - Vendor patched via beta version \n2018-09-26 - Vendor released \n2018-10-01 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0667');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (52, 'Epee Levin Packet Deserialization Code Execution Vulnerability', 'None', '2018-9-25', 'An exploitable code execution vulnerability exists in the Levin deserialization functionality of the epee library. A specially crafted network packet can cause a logic flaw, resulting in code execution. An attacker can send a packet to trigger this vulnerability. Monero \'Lithium Luna\' (v0.12.2.0-master-ffab6700) \n 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-704: Incorrect Type Conversion or Cast The Levin network protocol is an implementation of peer-to-peer (P2P) communications found in a large number of cryptocurrencies, including basically any cryptocurrency that is a descendant from the CryptoNote project. A few different implementations of Levin are in existence, but of note today is the epee library, an open-source Levin library. The epee library can be found in a large subset of projects that use Levin, most notably the cryptocurrency Monero. Before getting in-depth into the bug, a brief overview of the Levin protocol is required. An example of a normal P2P handshake between Monero nodes is below with some explanation. (Note: All numeric values are little-endian, unless otherwise stated). The above struct can be found in every Levin request, starting with a hardcoded QWORD signature [1], the QWORD size of the total packet, another byte that likely determines if it’s a request or response, a QWORD opcode [3], and then, finally, more hardcoded signature bytes. The above bytes are for the COMMAND_HANDSHAKE_T command, opcode 1001, and the exact definition can be found here:  . Assuming all the hardcoded signature checks pass, the rest of the data starts to get deserialized, with the code now looking for opcode specific structures and data. Referring back to the   opcode, the following structures must be found for a valid parse: Within  , the code will start to try to look for a Levin message with two sections, a node_data section and payload_data section. A dump of some bytes will explain what this entails more clearly: The first byte read [1] is the amount of sections within the serialized packet, read in via the read_varint() method, a quick explanation is that the smallest two bits of the first byte determine how many bytes to read in for the total read value (1,2, 4, or 8). Thus, if the first byte is \\x82, we’d read in another three bytes from the packet, append that to   and treat it as a little-endian value for the total length of the rest of the packet data. The next portion at [2] is easier, a byte determining the length of a section name, followed by the section name. The names must match 1-1 for the section names given in the   struct. At [3], the first section’s data is read in and deserialized. The first byte determines the type, and then based off of that type, the code flow changes. The list of available types is as follows: Since the type was \\x0C, it’s defined as an object, and the   function is called, which tries to read in a   from the packet, which is defined as follows: To help lay some more groundwork, here are some assorted structure definitions that will be referred to later: To recap on our basic example, we’re currently reading in the next set of bytes from our packet as a   object. In order to actually deserialize into the   struct, the definition is needed: Which on the wire looks like: Assuming that the types of all the bytes are accurate to the structure definition (a mismatch will throw an error) or that the provided types can be appropriately converted to the destination type (a note on this later), each of the individual fields is then also sanitized when it is read in, and then the values themselves must also pass checks for the variable that they fill. For example, the network ID field [1] must correspond to one of three hardcoded strings, depending on if the node is on the testnet, staging, or production Monero P2P network. Regarding the type conversions, there are codified conversions that can be performed if the type found in the network packet is a compatible type to that found in the serialization struct. For example, unsigned int to signed int, or vice versa. Most interestingly is that due to compatibility issues with other Monero clients, strings can be converted to uint64_t values, if they match certain regular expressions. The rest of the packet is similarly deserialized according to the COMMAND_HANDSHAKE type, resulting in the remainder of the packet deserializing into the\nCORE_SYNC_DATA struct found below: Which corresponds to the following network bytes: Now that the basic example has been covered, we can start to examine the actual bug, which occurs in the   class from  , which controls the deserialization of each individual data type. All the code from the first object read described above ( ) onward has been located within this class, so there’s only a few more new things to discuss, the first of which is the   function, which is where the code flow diverges based on deserialization object type. If the type has the SERIALIZE ARRY set at [1], instead of loading a singular data entry, we instead load an array of entries, the code for which is: In essence, the only real difference is   versus   being used, so what’s the difference between those functions? A quick listing of the function definition provides a clue: Since the code is inline template based C++ code, the readability (and reversibility) of the code is not too great, but we can quickly see that   has defined different functions for the string, section, and array_entry types, whereas   has not. Keeping that in mind, let\'s examine the   source: At [1], an   is created, depending on whatever type we give it, followed by a call to   at [2], which specifically refers to the   function. Looking through the source again, the different   definitions are given: The most important thing to note here is the lack of a specific definition for an   object, unlike that for the section and string object types. Apparently though, libboost has deemed that the   is a  , and as such, it uses the function at [1], which is rather simple: And then we arrive at the last function definition of [1]: The issue lies in the definition of what we are actually reading into. If we select an   object here, we end up doing a memcpy directly into that object. A refresher as to the object type: It will end up directly copying onto a boost::recursive_variant object, resulting in a crash in the following disassembly: At [1], $rax is controlled directly from the serialized packet sent, with $rdi pointing to a user-controlled buffer: 2018-08-02 - Vendor Disclosure \n2018-08-07 - Vendor acknowledged testing of patch \n2018-09-25 - Vendor released patch & publicly disclosed', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0637');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (53, 'ProtonVPN VPN client connect privilege escalation vulnerability', 'None', '2018-9-7', 'An exploitable code execution vulnerability exists in the connect functionality of ProtonVPN VPN client 1.5.1. A specially crafted configuration file can cause a privilege escalation, resulting in the ability to execute arbitrary commands with the system\'s privileges. ProtonVPN VPN Client 1.5.1 8.8 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-78: Improper neutralization of special elements used in an operating system command (\'OS Command\nInjection\') The ProtonVPN VPN client is divided in two parts: The GUI is used to generate an OpenVPN configuration file, and asks the service to execute the OpenVPN with the configuration file in argument. In April 2018, security firm VerSprite discovered and released CVE-2018-10169 (https://github.com/VerSprite/research/blob/master/advisories/VS-2018-017.md). To trigger this vulnerability, the attacker must add a parameter such as “plugin” or “script-security” in the OpenVPN configuration file. In this context, the plugin or the script will be executed by OpenVPN, which is executed by the service running as system. ProtonVPN published a patch to check for the presence on the “plugin” and “script-security” option in the configuration file: public class OpenVpnConfigSecurityValidator By looking at the source code of the   function of OpenVPN (https://github.com/OpenVPN/openvpn/blob/5961250e776194a411a8dfc1670c5c0c73107bf8/src/openvpn/options.c) we can see that the configuration file supports the quotation mark characters. Here is a proof of concept that bypasses the validation: Notepad.exe will be executed with the system privilege. Here is a POC that bypasses the validation: Notepad.exe will be executed with the system privilege. Discovered by Paul Rascagneres (@r00tbsd) of Cisco Talos.\nhttp://talosintelligence.com/vulnerability-reports/ 2018-07-05 - Vendor Disclosure \n2018-09-03 - Vendor Patched \n2018-09-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0679');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (54, 'NordVPN VPN client connect privilege escalation vulnerability', 'None', '2018-9-7', 'An exploitable code execution vulnerability exists in the connect functionality of NordVPN 6.14.28.0. A specially crafted configuration file can cause a privilege escalation, resulting in the execution of arbitrary commands with system privileges. NordVPN 6.14.28.0 8.8 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-78: Improper neutralization of special elements used in an operating system command (\'OS Command\nInjection\') The NordVPN VPN client is divided in two parts: The GUI is used to generate an OpenVPN configuration file, and asks the service to execute the OpenVPN with the configuration file in argument. In April 2018, security firm VerSprite discovered and released CVE-2018-10169 (https://github.com/VerSprite/research/blob/master/advisories/VS-2018-017.md). To trigger this vulnerability, the attacker must add a parameter such as “plugin” or “script-security” in the OpenVPN configuration file. In this context, the plugin or the script will be executed by OpenVPN, which is executed by the service running as system. NordVPN published a patch to check for the presence on the “plugin” and “script-security” option in the configuration file: public class OpenVpnConfigSecurityValidator By looking at the source code of the   function of OpenVPN (https://github.com/OpenVPN/openvpn/blob/5961250e776194a411a8dfc1670c5c0c73107bf8/src/openvpn/options.c) we can see that the configuration file supports the characters “ and ”. Here is a proof of concept that bypasses the validation: Notepad.exe will be executed with the system privilege. Here is a POC that bypasses the validation: Notepad.exe will be executed with the system privilege. 2018-07-05 - Vendor Disclosure \n2018-08-08 - Vendor advised patch is available  \n2018-09-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0622');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (55, 'ERPNext SQL Injection Vulnerabilities', 'None', '2018-9-5', 'Exploitable SQL injection vulnerabilities exists in the authenticated part of ERPNext v10.1.6. Specially crafted web requests can cause SQL injections resulting in data compromise. An attacker can use a browser to trigger these vulnerabilities, and no special tools are required. ERPNext v10.1.6 (master) CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N CWE-89: Improper Neutralization of Special Elements used in an SQL Command (\'SQL Injection\') The following parameters are vulnerable to SQL injection attacks: The searchfield parameter can be used to perform an SQL injection attack as shown below: The employee parameter can be used to perform an SQL injection attack as shown below: The sort_order parameter can be used to perform an SQL injection attack as shown below: The sort_by parameter can be used to perform an SQL injection attack as shown below: The start parameter can be used to perform an SQL injection attack as shown below: The order_by parameter can be used to perform an SQL injection attack as shown below: 2018-04-12 - Vendor Disclosure \n2018-09-05 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0560');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (56, 'Samsung SmartThings Hub video-core Camera Creation Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable buffer overflow vulnerability exists in the camera \"create\" feature of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly extracts the \"state\" field from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link on the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a POST request for the \"/cameras\" path, it\'s possible to add a new camera to the hub. Such request is handled by function  : Note that the binary embeds the   that is used to manage JSON objects. The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request, the parameters are:  ,  ,  ,  .\nAt [2] the function parses the JSON payload received in the request using  , which returns a  . It then calls   [3] passing the pointer to a local stack buffer and the   as parameters. The purpose of this function is to extract each parameter and store it in the buffer passed as argument.\nEach parameter is extracted using the following sequence: Additionally, before calling  , the parameters \"cameraId\", \"locationId\" and \"dni\" are verified using regular expressions, and the \"url\" parameter is simply truncated to a maximum length of 0x200.\nHowever, the \"state\" parameter is not sanitized in any way. In fact, we can see that the   value for the   call [7] is set from the   [6] output of the source string itself. At high level this would be: Since   is controlled by the user, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer, and potentially arbitrary code execution. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, but we decided not to test it to avoid damaging any live infrastructure. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. The following proof of concept shows how to crash the   process: 2018-04-16 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0575');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (57, 'Samsung SmartThings Hub video-core Database clips Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable stack-based buffer overflow vulnerability exists in the retrieval of database fields in  \'s HTTP server of Samsung SmartThings Hub. The   process insecurely extracts the fields from the \"clips\" table of its SQLite database, leading to a buffer overflow on the stack. An attacker can send a series of HTTP requests to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 7.5 - CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable function that can be exploited to achieve code execution on the   process, which is running as root. The hub allows to store clips information, which represent small recordings that can be triggered on specific events. These are stored in the \"clips\" table of  \'s SQLite database (found at \"/hub/data/videocore/db/VideoCore.db\"). Function   is used to retrieve all the columns from the \"clips\" table and save them in a structure, stored on the stack, passed as second argument. The function takes three arguments: the clip ID [1], the clip ID length [2], and a structure [3] where all the columns for the related clip ID should be stored.\nAt [4] a query is performed for fetching just one column: where \"clip-id\" is the first argument [1] and \"column\" is one of the columns of the table.\nIf   succeeds, the result is then copied in the structure [3] using   [5].\nThe input structure is populated by repeating the same logic for each column: Each element in the structure is supposed to have a maximum size of 512 bytes, but since there is no restriction on the length of the copy operation, the buffer can be overflowed, and this allows for overflowing the input structure and execute arbitrary code. Note that while we scored this vulnerability CVSS 7.5 on its own, it would constitute a CVSS 8.5 (CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H) when combined with TALOS-2018-0556. This is demonstrated in the proof of concepts below. Function   is called by multiple functions, in the following proof of concept we show just one of the ways for triggering the vulnerability, by crashing the   process.\nNote that it is assumed that a camera already exists in the hub. The first request will add a clip with id \"1234\", and after replying to the request the hub will continue to operate on the new camera and will call, among others,  .\nIf the second request is executed quickly enough (that is, before   is called), an attacker could manage to execute the second request while the first request is still being completed, in order to alter the content of the clip id \"1234\" by setting an overlong \"captureTime\", which will cause   to crash when handled by  . 2018-05-07 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0583');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (58, 'Samsung SmartThings Hub video-core Camera Update Code Execution Vulnerabilities', 'None', '2018-7-26', 'Multiple exploitable buffer overflow vulnerabilities exist in the camera \"update\" feature of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly extracts fields from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a PATCH request for the   path it\'s possible to replace the URL and the \"state\" value of an existing camera. Such request is handled by function  : Note that the binary embeds the   that is used to manage JSON objects. The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request, the parameters are   and  .\nThe JSON payload sent in the request is then parsed using   [2] and the \"camera-id\" specified in the request path is verified to exist in the database [3].\nThen, both   and   parameters are extracted using the following sequence: We can see that the   value for the   call is set from the   output of the source string itself. At high level this would be: Since   is controlled by the user, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer and execute arbitrary code. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, which we decided not to test to avoid damaging any live infrastructure. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. The following is a list of each vulnerability and its proof of concept.\nA key with value \"x\" means that its value is irrelevant, but the key still needs to be present.\nIt\'s also assumed that a camera is already present and its id is represented by the variable \"${sCameraId}\". The   call overflows the destination buffer, which has a size of 512 bytes.\nAn attacker can send an arbitrarily long \"url\" value in order to overwrite the saved-PC with 0x42424242: The   call overflows the destination buffer, which has a size of 512 bytes.\nAn attacker can send an arbitrarily long \"state\" value in order to overwrite the saved-PC with 0x42424242: 2018-04-16 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0574');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (59, 'Samsung SmartThings Hub video-core credentials Code Execution Vulnerability', 'None', '2018-7-26', 'Multiple exploitable buffer overflow vulnerabilities exist in the   handler of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly extracts fields from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a POST request for the \"/credentials\" path it\'s possible modify the credentials used by the hub to connect to remote servers. Such request is handled by function  : Note that the binary embeds the \"json-c\" library from https://github.com/json-c/json-c that is used to manage JSON objects. The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request, the parameters are:  ,  ,  ,  ,  ,  ,  . The library function   [2] is then used to parse the POST data, and a JSON object is returned.\nFinally,   [3] is used to retrieve each parameter from the main JSON object. This function, in turn, returns a new JSON object from which a string is extracted, using   [4].\nThe resulting string is copied in a buffer on the stack using   [5]: the destination buffer is calculated from  , which actually points on the stack. Moreover, the   value is set from the   output of the source string itself. At high level this would be: Since the   is controlled by the user, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer and execute arbitrary code. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, which we didn\'t test. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. The following is a list of each vulnerability and its proof of concept.\nEach proof of concept uses the placeholder \"OVERFLOW\" to highlight the vulnerable parameter, which can be replaced with   to make the device crash.\nA key with value \"x\" means that its value is irrelevant, but the key still needs to be present. The   at [5] overflows the destination buffer, which has a size of 128 bytes.\nAn attacker can send an arbitrarily long \"secretKey\" value in order to exploit this vulnerability: The   at [6] overflows the destination buffer, which has a size of 32 bytes.\nAn attacker can send an arbitrarily long \"accessKey\" value in order to exploit this vulnerability: The   at [7] overflows the destination buffer, which has a size of 2,000 bytes.\nAn attacker can send an arbitrarily long \"sessionToken\" value in order to exploit this vulnerability: The   at [8] overflows the destination buffer, which has a size of 64 bytes.\nAn attacker can send an arbitrarily long \"bucket\" value in order to exploit this vulnerability: The   at [9] overflows the destination buffer, which has a size of 160 bytes.\nAn attacker can send an arbitrarily long \"directory\" value in order to exploit this vulnerability: The   at [10] overflows the destination buffer, which has a size of 16 bytes.\nAn attacker can send an arbitrarily long \"region\" value in order to exploit this vulnerability: 2018-04-09 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0555');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (60, 'Samsung SmartThings Hub hubCore port 39500 sync denial-of-service vulnerability', 'None', '2018-7-26', 'An exploitable vulnerability exists in the remote servers of Samsung SmartThings Hub. The   process listens on port 39500 and relays any unauthenticated messages to SmartThings\' remote servers, which incorrectly handle camera IDs for the \"sync\" operation, leading to arbitrary deletion of cameras. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 6.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:H CWE-156: Improper Neutralization of Whitespace Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller that allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. While analyzing the   process, we identified the following traffic on port 39500, generated by   when requesting the \"/sync\" path [1]: The   process listens on port 39500, bound to \"0.0.0.0\", and simply forwards the HTTP request [2] to the remote Samsung SmartThings servers [3], which answer with [4]. The answer is finally forwarded back to the client [5].\nNote that being   bound to \"0.0.0.0\", request [1] could be omitted and request [2] could be initiated by anyone in the network, without any prior authentication. In essence, the \"sync\" request [1] is used to make sure that the remote servers and  \'s internal database are synchronized. All camera IDs known by   are included in the JSON string, and if   contains a   which doesn\'t exist in the remote servers, it will be deleted.\nContinuing on the example, if   is not found by the remote servers, the following traffic can be seen: Request [6] is sent by the remote Samsung SmartThings servers over the persistent TLS connection, and is thus received by the   process, which blindly forwards it to  \'s HTTP server on port 3000 [7]. Request [8] is simply the answer of   to the \"DELETE\" request. To summarize, the flow of events when a deletion is going to take place is: Where \"Sender\" can either be the hub itself (that is  , as shown in request [2]) or anyone in the network. As we can see, a portion of request [2] is included in request [6]: the  . In fact, it is first present in message M1, and is then propagated till   where it is sent inside M3. We noticed that the remote server does not strip whitespace characters appended to the   values sent in M1. This causes the remote servers to fail, recognizing an existing camera, which in turn, initiates the deletion procedure for the requested camera ID. The   will be inserted in M3 without modifications (that is, if it is still including any whitespace character), which will be discarded by  \'s HTTP server.\nThus, by appending one or more spaces at the end of a valid camera ID, anyone would be able to delete a camera from the hub without authentication. Moreover, note that if message M1 only contains camera IDs unknown to the remote servers, the denial of service would not be permanent and an attacker would need to send the \"sync\" message continuously. In fact, in this case remote servers, noticing that the the hub would have an empty camera list, will re-add all cameras known remotely by sending a \"POST /cameras\" request following request [8]. We found two different ways to avoid this: The following proof of concept shows how to delete an arbitrary camera, given its \"cameraId\". The request received by   is: Notice the additional space between the camera ID and the \"HTTP/1.1\" string, which will be discarded by the HTTP server. 2018-04-25 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0582');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (61, 'Samsung SmartThings Hub hubCore Google Breakpad backtrace.io information disclosure vulnerability', 'None', '2018-7-26', 'An exploitable information disclosure vulnerability exists in the crash handler of the   binary of the Samsung SmartThings Hub. When   crashes, Google Breakpad is used to record minidumps, which are sent over an insecure HTTPS connection to the backtrace.io service, leading to the exposure of sensitive data. An attacker can impersonate the remote backtrace.io server in order to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 6.8 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N CWE-295: Improper Certificate Validation Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller that allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. The   process utilizes Google Breakpad(https://chromium.googlesource.com/breakpad/breakpad/) for generating minidumps in the event of a crash. These minidumps are then sent over to the backtrace.io service(https://backtrace.io/). When the process starts, the function   is called to set up the crash handler: At [1], the function retrieves the URL used to submit the minidump to backtrace.io. This URL has a fixed value and is defined in /etc/default/hubcore: Finally, the function sets up the Google Breakpad exception handler. As we can see, the function   [2] will be called by Breakpad after the minidump has been generated. The function collects the minidump file, as well as a set of other information to be sent to backtrace.io using   [4].\nThe actual command executed is: As we can see, the insecure   switch is used [3], which allows cURL to perform insecure SSL connections.\nThus, an attacker with the ability to impersonate the remote \"smartthings.sp.backtrace.io\" server can intercept the minidump using a self-signed certificate in order to extract sensitive process data. Note that an hubCore crash can be triggered by using TALOS-2018-0593. 2018-05-14 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for fix \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0594');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (62, 'Samsung SmartThings Hub hubCore ZigBee firmware update CRC16 check denial-of-service vulnerability', 'None', '2018-7-26', 'An exploitable integer underflow vulnerability exists in the ZigBee firmware update routine of the   binary of the Samsung SmartThings Hub. The   process incorrectly handles malformed files existing in its \"data\" directory, leading to an infinite loop, which eventually causes the process to crash. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 5.3 - CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:C/C:N/I:N/A:H CWE-191: Integer Underflow (Wrap or Wraparound) Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller that allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. The   process handles most of the features provided by the hub.\nOne of those is the ability to talk to the ZigBee SoC on-board, and to update its firmware. Every 30 seconds, the   function is called to sequentially execute a series of tasks. One of these tasks is called  , which, among other functionalities, allows for updating the ZigBee firmware.\nTo achieve this, the function   is called in two instances, for checking the CRC16 of two different files employed in the firmware update process: \"/hub/data/hubcore/stZigbee\" and \"/hub/data/hubcore/stZigbeeNcp\". A series of custom functions are used for interacting with the filesystem and computing the CRC16. For the sake of brevity, we list below only the reverse-engineered prototypes of those functions. At [1],   contains the handle to the file passed as argument (either \"/hub/data/hubcore/stZigbee\" or \"/hub/data/hubcore/stZigbeeNcp\").\nThe file size is calculated [2] and the result stored in  . At [3], the file is checked to be not bigger than 4,999,999 bytes. At [4], the file size is retrieved again, but stored in  , and again, the result is checked to be not bigger than 4,999,999.\nAt [5], the CRC16 value is initialized, and the file length is decreased by two [6], assuming that a two-byte CRC16 value is present at the end of the file.\nThe execution then enters a loop, which reads the file contents [7] in chunks of 256 bytes for updating the current CRC16 value [8].\nAt [9],   keeps the number of bytes read, which is updated by adding the current chunk length ( ). Finally at [10],   (which contains the file size minus two) is compared against  , in order to exit the loop when all bytes are processed. The operation at [6] is unsafe, and can result in an integer underflow when the size of the file is either   or  .\nIf this happens,   will have a value respectively of   or  , which will cause the loop to try to read past the end of the file. This is not considered an error, and   will still return  , but the   value will be   since no bytes have been read. This, in turn, causes the increment at [9] to be ineffective, and the loop never terminates. Additionally,   runs a \"watchdog\" thread which, if not restarted, kills the process itself by calling  . Since the loop never terminates, the watchdog is never restarted and the process is killed.\nMoreover,   is responsible for restarting the system watchdog \"/dev/watchdog\", and since   is never restarted, the device is rebooted shortly after. Note that in order to exploit this vulnerability, an attacker needs to be able to create files inside the device. This can be achieved using TALOS-2018-0556, as demonstrated in the proof of concept below. The following proof of concept shows how to create an empty \"/hub/data/hubcore/stZigbee\" file using TALOS-2018-0556, which will cause the   process to crash, and in turn the device to reboot. 2018-05-14 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0593');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (63, 'Samsung SmartThings Hub video-core samsungWifiScan Code Execution Vulnerability', 'None', '2018-7-26', 'Multiple exploitable buffer overflow vulnerabilities exist in the samsungWifiScan handler of video-core\'s HTTP server of Samsung SmartThings Hub. The video-core process incorrectly extracts fields from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allow for a secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nFunction   is called when requesting the path \"/samsungWifiScan\" using the POST method: Note that the binary embeds the \"json-c\" library from https://github.com/json-c/json-c that is used to manage JSON objects.\nAs we can see,   [1] parses the POST data and returns a JSON object. Finally, a thread is created for executing the function   [2], passing the JSON object as parameter [3]. Right after initializing its local variables, the function calls   in order to extract the parameters from the POST request. The first four parameters passed to   are buffers on the local function stack, in order:  ,  ,  ,  . The last argument is the reference to the JSON object [4]. This function is supposed to extract each JSON parameter and fill the four buffers passed as argument.\nAt high level, this is how each parameter is extracted: Where: As we can see, the length of the value of each JSON field is not taken into account when copying to the buffer on the stack, which can be exploited to execute arbitrary code.\nWe identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, which we didn\'t test. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. The following is a list of each vulnerability and its proof of concept.\nEach proof of concept uses the placeholder \"OVERFLOW\" to highlight the vulnerable parameter, which can be replaced with   to make the device crash.\nA key with value \"x\" means that its value is irrelevant, but the key still needs to be present. The   at [5] overflows the destination buffer, which has a size of 40 bytes.\nAn attacker can send an arbitrarily long \"user\" value in order to exploit this vulnerability: The   at [6] overflows the destination buffer, which has a size of 40 bytes.\nAn attacker can send an arbitrarily long \"password\" value in order to exploit this vulnerability: The   at [7] overflows the destination buffer, which has a size of 40 bytes.\nAn attacker can send an arbitrarily long \"cameraIp\" value in order to exploit this vulnerability: The   at [8] overflows the destination buffer, which has a size of 40 bytes.\nAn attacker can send an arbitrarily long \"callbackUrl\" value in order to exploit this vulnerability: 2018-03-28 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0548');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (64, 'Samsung SmartThings Hub video-core clips Code Execution Vulnerability', 'None', '2018-7-26', 'Multiple exploitable buffer overflow vulnerabilities exist in the   handler of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly extracts fields from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a POST request for the   path, it\'s possible to set up new clip recording parameters in the hub. Such request is handled by function  : Note that the binary embeds the   that is used to manage JSON objects. The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request. The parameters are:  ,  ,  ,  ,  .\nAt [2], the   parameter is extracted from the POST request and at [3] the internal   database is queried to see if the specified \"correlationId\" already exists, in which case the function will terminate. Moreover, at [4] the database is queried again to ensure that the \"camera-id\" specified in the HTTP path already exists.\nIf the above conditions are satisfied,   [5] is called. The function begins by fetching the JSON payload from the HTTP request and by parsing it using   [6].\nThen, each of the five parameters are extracted using the following sequence: We can see that the   value for the   call is set from the   output of the source string itself. At high level, this would be: Since   is controlled by the user, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer and execute arbitrary code. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, but we decided not to test it to avoid damaging any live infrastructure. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. The following is a list of each vulnerability and its proof of concept.\nEach proof of concept uses the placeholder \"OVERFLOW\" to highlight the vulnerable parameter, which can be replaced with   to make the device crash.\nA key with value \"x\" means that its value is irrelevant, but the key still needs to be present.\nIt\'s also assumed that a camera is already present and its id is represented by the variable \"${sCameraId}\". The   call overflows the destination buffer, which has a size of 52 bytes.\nAn attacker can send an arbitrarily long \"captureTime\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 52 bytes.\nAn attacker can send an arbitrarily long \"startTime\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 52 bytes.\nAn attacker can send an arbitrarily long \"endTime\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 52 bytes.\nAn attacker can send an arbitrarily long \"correlationId\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 52 bytes.\nAn attacker can send an arbitrarily long \"callbackUrl\" value in order to exploit this vulnerability: 2018-04-12 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0570');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (65, 'Samsung SmartThings Hub video-core database shard code execution vulnerabilities', 'None', '2018-7-26', 'Multiple exploitable stack-based buffer overflow vulnerabilities exist in the retrieval of database fields in the   HTTP server of the Samsung SmartThings Hub. The   process insecurely extracts the fields from the \"shard\" table of its SQLite database, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 7.5 - CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller that allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable function that can be exploited to achieve code execution on the   process, which is running as root. For handling the livestreams, the hub stores a series of settings for connecting to cloud servers. These are stored in the \"shard\" table of  \'s SQLite database (found at \"/hub/data/videocore/db/VideoCore.db\"). Function   is used to retrieve the \"shard\" settings from the database and save them in a structure, stored on the stack, passed as first argument. It is reachable via the   and   threads, which call the vulnerable function every second. As we can see, the same sequence is used to extract each column of the \"shard\" table: Since there is no restriction on the length of the copy operation, the buffer can be overflowed, and this allows for overflowing the input structure and execute arbitrary code. Note that while we scored this vulnerability CVSS 7.5 on its own, it would constitute a CVSS 8.5 (CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H) when combined with TALOS-2018-0556. This is demonstrated in the proof of concepts below.\nFor each of the proof of concepts below, a key with value \"x\" means that its value is irrelevant, but the key still needs to be present. The   call overflows the destination buffer, which has a size of 128 bytes.\nAn attacker can send an arbitrarily long \"secretKey\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 32 bytes.\nAn attacker can send an arbitrarily long \"accessKey\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 2000 bytes.\nAn attacker can send an arbitrarily long \"sessionToken\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 64 bytes.\nAn attacker can send an arbitrarily long \"bucket\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 136 bytes.\nAn attacker can send an arbitrarily long \"directory\" value in order to exploit this vulnerability: The   call overflows the destination buffer, which has a size of 16 bytes.\nAn attacker can send an arbitrarily long \"region\" value in order to exploit this vulnerability: 2018-04-25 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0581');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (66, 'Samsung SmartThings Hub video-core Database shard.videoHostURL Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable stack-based buffer overflow vulnerability exists in the retrieval of a database field in  \'s HTTP server of Samsung SmartThings Hub. The   process insecurely extracts the shard.videoHostURL field from its SQLite database, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 7.5 - CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed on the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the ability to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable function that can be exploited to achieve code execution on the   process, which is running as root. The hub uses a \"videoHostURL\" field to handle the livestreams, saved inside the \"shard\" table of  \'s SQLite database (found at \"/hub/data/videocore/db/VideoCore.db\"). The \"videoHostURL\" is the base address, used to build the final link that an end user can use to look at the camera\'s stream. In the hub used for our tests, the \"videoHostURL\" is normally \"https://vh-na04-useast2.connect.smartthings.com:8300\". Function   is used to retrieve the \"videoHostURL\" from the database and save it in a buffer passed as first argument: If the \"videoHostURL\" is overridden by the value stored in the configuration file ([1] and [2]), the \"videoHostURL\" is copied to the buffer using   [3] with a maximum length of 0x100 bytes.\nVice-versa, the URL is fetched from the database by using the function   [4]. The query executed is: The result is finally copied in the buffer using   [5].\nSince there is no restriction on the length of the copy operation, the buffer can be overflowed, which allows for overflowing the stack buffer of the parent function and execute arbitrary code. This function is reachable in two different ways: Moreover, each of the three callers above pass a stack buffer when calling the vulnerable function, so all of the possible buffer overflows are stack-based. Note that while we scored this vulnerability CVSS 7.5 on its own, it would constitute a CVSS 8.5 (CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H) when combined with TALOS-2018-0556. This is demonstrated in the proof of concept below. The following proof of concept shows how to crash the   process: 2018-04-16 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0576');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (67, 'Samsung SmartThings Hub video-core REST Request Parser HTTP Pipelining Injection Vulnerabilities', 'None', '2018-7-26', 'Multiple exploitable vulnerabilities exist in the REST parser of  \'s HTTP server of the Samsung SmartThings Hub. The   process incorrectly handles pipelined HTTP requests, which allows successive requests to overwrite the previously parsed HTTP method, URL and body. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H CWE-444: Inconsistent Interpretation of HTTP Requests (\'HTTP Request Smuggling\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. The HTTP server implementation in   is based on  . The usage of   is explained in the project\'s \"readme\", and essentially allows for an HTTP server to be implemented using the following steps: The   library supports both chunked and pipelined requests. Because of this, the callbacks may be invoked multiple times during a single   call.\nThe callbacks defined by   are: The callbacks, as defined by  , correctly support chunked requests. However, they incorrectly handle pipelined requests, as they don\'t have the concept of multiple HTTP requests over a unique connection. The following is the implementation of the   callback, defined by  : The callback receives three arguments, in order: At [1], the current length of the parsed   string is extracted from the structure stored in  , and at [2], the function ensures that the final   has a maximum length of 512 characters.\nAt [3], the   portion received as second parameter is concatenated to the current  . Finally, at [4], the length is updated in the global structure. When pipelined HTTP requests are present, this callback will be called multiple times and the same   buffer will be updated, causing successive request to interfere with each other. The following proof of concept shows how to perform one unique HTTP request by concatenating the paths of two different requests: By looking at the hub\'s logs, we can see that the parsed request is \"GET /req1/req2\", rather than two different HTTP requests. Note that   imposes restrictions on the URI format, specifically when the URI just includes a path, this must start with either \"*\" or \"/\", otherwise an error is thrown and the parsing is interrupted. The following is the implementation of the   callback, defined by  : The implementation is similar to the   callback, except for the maximum size of the body component [2]. The following proof of concept shows how to perform one unique HTTP request, specifying the path in the first request, and the body in the second: As we can see, the \"url\" field of the camera has been changed to \"B\", by specifying the body part of the first HTTP request in the second HTTP request. The following is the implementation of the   callback, defined by  : This function is called every time   detects the end of an HTTP request. For example, if two HTTP requests are present in the buffer, this function will be called two times. At [5] the \"method\" field of a custom structure, defined by  , is updated.\nWhen pipelined HTTP requests are present, the last request will overwrite the \"method\" field last, so all previous methods will be discarded. The following proof of concept shows how to perform one unique HTTP request, using the second request for changing the method specified by the first one: By looking at the hub\'s logs, we can see that the parsed request is \"GET /cameras/00000000-0000-0000-0000-000000000001\", rather than \"PUT /cameras/00000000-0000-0000-0000-000000000001\". The following proof of concept shows how to use the three vulnerabilities above in order to trigger an additional vulnerability described in TALOS-2018-0573, which will overwrite the saved-PC with 0x41414141. Moreover, we verified that the same could be applied to the buffer overflow in TALOS-2018-0570 and the SQL injection in TALOS-2018-0556 (when used on the \"/clips\" path), however with the requirement of knowing at least an existing \"cameraId\". Finally, note that the three vulnerabilities in this report provide a different way of exploiting bugs in  , and could give mainly two advantages to an attacker: 2018-04-19 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0577');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (68, 'Samsung SmartThings Hub video-core AWSELB Cookie Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable buffer overflow vulnerability exists in the remote video-host communication of  \'s HTTP server of Samsung SmartThings Hub. The   process insecurely parses the AWSELB cookie while communicating with remote video-host servers, leading to a buffer overflow on the heap. An attacker able to impersonate the remote HTTP servers could trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a PUT request for the   path, it\'s possible to make the hub to start streaming the camera\'s video (specified by the \"camera-id\") towards the remote servers. The \"stream-type\" can have multiple values and represent the kind of stream requested, for example it could be set to \"hls1080p\".\nThe following is an example of such request: Note that the \"oauth-token\" is an OAuth 2.0 Bearer Token (canonical UUID), provided by auth-global.api.smartthings.com.\nSuch a request is handled by function  , which in turn calls   for setting up the communication with a remote video-host server and providing the remote streaming feature: At [1], the function starts to build an answer for the request that is being handled. The answer is composed by a JSON string, which will be filled by the answer from the request at [2].\nThe request [2] is a remote request toward a video-host server: the server\'s address is stored in  \'s database, and in the hub that we tested this address is \"https://vh-na04-useast2.connect.smartthings.com:8300\". The communication generated at [2] is the following: The HTTP body in the response contains a series of parameters that allow for pushing the camera stream remotely.\nMoreover, we can see that a cookie with name \"AWSELB\" is set.\nAt [3], function   parses the cookies, extracting the value of \"AWSELB\" if present. At [4] the function   is called for extracting the list of cookies, which will be stored in  .\nThen, by using   [5], the function loops over all the cookies\' values in the response, and if any one of them starts with the string \"AWSELB\" [6], its value is copied using   [7] into the heap buffer passed as parameter, which has a size of 512 bytes. Since the cookies are controlled by the remote server and there is no restriction on the length of the copy operation, anyone able to impersonate a video-host server could be able to overflow the heap buffer and execute arbitrary code. 2018-05-07 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0591');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (69, 'Samsung SmartThings Hub video-core samsungWifiScan Callback Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable stack-based buffer overflow vulnerability exists in the samsungWifiScan callback notification of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly handles the answer received from a smart camera, leading to a buffer overflow on the stack. An attacker can send a series of HTTP requests to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy requesting the path \"/samsungWifiScan\" it\'s possible to instruct the   process to discover a Samsung smart camera and notify the operation using a callback. As an example, consider this request: Once received,   will send the following HTTP request to \"camera-ip\": When the smart camera replies,   relays \"camera-http-response\" to the callback: The request at [1] is generated by  : We can see that   is used to send an HTTP request to the chosen \"camera-ip\". A buffer for storing the smart camera\'s answer is specified at [3]. After calling   [4], the response is passed as second argument to   [5]. This function is generating the POST request at [2], which is eventually dispatched at [6]. The POST data is created by calling   [7] and passing the unconstrained smart camera\'s response [8]. Since the destination buffer is on the stack [9], this can be exploited to execute arbitrary code. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, which we didn\'t test. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. Moreover, note that this vulnerability could also be exploited without prior authentication when an attacker has the possibility to wait for a camera discovery to happen, or when able to trigger a discovery through other means. The following proof of concept shows how to crash the   process: Once the netcat connection is closed,   should crash. 2018-03-28 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0549');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (70, 'Samsung SmartThings Hub video-core credentials videoHostUrl Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable buffer overflow vulnerability exists in the   handler of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly extracts the   field from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a POST request for the \"/credentials\" path it\'s possible modify the credentials used by the hub to connect to remote servers. Such request is handled by function  : Note that the binary embeds the \"json-c\" library from https://github.com/json-c/json-c, that is used to manage JSON objects. The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request, the parameters are:  ,  ,  ,  ,  ,  ,  . The library function   [2] is then used to parse the POST data, and a JSON object is returned.\nAt [3]   is used to retrieve the \"videoHostUrl\" parameter from the main JSON object. This function, in turn, returns a new JSON object from which a string is extracted, using   [4].\nFinally,   [5] is called to parse the value extracted from the \"videoHostUrl\" key. The parameters are, in order: the URI string, the URI string length, the destination buffer where the parsed URI is to be stored, the value 255 (that is the destination buffer size).\nNote that the destination buffer is stored on the stack. If the supplied   doesn\'t start with \"http\" [6], the string \"https://\" is inserted in front [7]. The function   [10] is then called for tokenizing the URI into the structure passed as first parameter [9].\nAt [11] the \"port\" field of the structure is retrieved, and if not null, the resulting URI from [7] is copied into   [12], which is the destination buffer passed as third argument to the function. Note that the   argument of the   [12] is set from the   output at [8]. At high level this would be: Since the   parameter is controlled by the user, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer and execute arbitrary code. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, which we didn\'t test. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. The following proof of concept shows how to crash the   process: 2018-04-09 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0554');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (71, 'Samsung SmartThings Hub video-core credentials Parsing SQL Injection Vulnerability', 'None', '2018-7-26', 'An exploitable JSON injection vulnerability exists in the   handler of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly parses the user-controlled JSON payload, leading to a JSON injection which in turn leads to a SQL injection in the   database. An attacker can send a series of HTTP requests to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component (\'Injection\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a POST request for the \"/credentials\" path it\'s possible to modify the credentials used by the hub to connect to remote servers.\nNew credentials are sent in the POST body using the JSON format: Where \"...\" would contain the appropriate value for each field.\nUsing the  , function   parses the JSON string into a  . All the fields are then extracted and a series of modifications are applied. Finally, the fields are saved in the internal   SQLite database at  . The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request, the parameters are:  ,  ,  ,  ,  ,  ,  . The library function   [2] is then used to parse the POST data, and a JSON object is returned.\nAt [3]   is used to retrieve the \"videoHostUrl\" parameter from the main JSON object: this function in turns returns a new JSON object from which a string is extracted, using   [4].\nThe same approach is used for extracting the rest of the parameters, with the exception that the \"videoHostUrl\" parameter is subject to a series of modifications and additional checks at [5]. Once all parameters are extracted, function   is called [6] to save the new fields in the database. A structure containing the extracted parameters is passed as first argument [7]. The function   [9] is used to build a new JSON string, using the parameters structure at [7] and the format string at [8].\nSpecifically, the format string is defined as: Finally, function   [10] parses the resulting JSON string and, by mapping each JSON key to a column name, updates the database accordingly. In this case the following query is generated and executed: As we can see, no sanitization is performed on the parameters throughout the whole JSON parsing and creation logic.\nMoreover, the \"json-c\" library has been compiled with  , which allows for defining strings with both single and double quotes.\nThe original JSON payload read from the POST request is expected to utilize double-quote characters for strings. If, instead, single-quotes are used, it is possible to inject arbitrary fields in the JSON string generated at [9]. In turn, this allows for specifying custom columns in the SQL query, which are not wrapped with quotes.\nSQL queries are executed using the   method, which allows execution of stacked queries. Thus, a JSON key containing a semicolon character allows for executing arbitrary SQL queries.\nFinally, arbitrary SQL queries could be exploited by an attacker to execute arbitrary code in the context of the   process. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, which we didn\'t test. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. Note that while we scored this vulnerability CVSS 8.8 on its own, it would constitute a CVSS 9.9 (CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H) when combined with TALOS-2018-0557. This is demonstrated in the proof of concept below. The following proof of concept shows how to crash the   process: This proof of concept exploits the JSON injection to execute an arbitrary SQL query.\nThe SQL query simply creates a new camera with id \"123\", and uses a 10,000 bytes long string of \"A\"s in place of the   column (2nd column). This string could be replaced with a ROP-like payload. The last   request makes   to delete the camera with id \"123\". Before deleting,   reads every field related to the camera, and since the application trusts the contents in the database, an overlong   is unexpected and causes a stack-based buffer overflow which overwrites the saved PC (TALOS-2018-0557). 2018-04-09 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0556');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (72, 'Samsung SmartThings Hub video-core RTSP Configuration Command Injection Vulnerability', 'None', '2018-7-26', 'An exploitable vulnerability exists in the smart cameras RTSP configuration of the Samsung SmartThings Hub. The device incorrectly handles spaces in the URL field, leading to an arbitrary operating system command injection. An attacker can send a series of HTTP requests to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-88: Argument Injection or Modification Samsung produces a series of devices aimed at controlling and monitoring a home such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use his or her smartphone to connect to his or her own house remotely and manage any other device through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allow for a secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The livestream configuration can be changed from the smartphone application. When a user changes the smart camera\'s password, the following request is sent to api.smartthings.com via HTTPS: Note that the request above actually sets all the smart camera\'s preferences in one shot. Notable parameters are: In order to apply the new configuration to the hub, SmartThings servers send a series of messages to the device, which are received by the   process.\nSpecifically, when the   value is changed,   will receive the following message: Note that the new parameter   was previously set on the initial camera setup phase. This message will be relayed without any modification to the HTTP server running inside the   process. The message notifies the   process for updating the URL needed to establish the RTSP connection. The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. Upon receiving the request above,   will save the new camera URL in its internal database.\nShortly after, the thread   of the   process will re-execute the   command using the new URL.\n  options are collected by function  : The function reads a series of parameters from the internal database, and builds a string (pointed by   [1]) by appending each parameter at the end ([2], [3], [4], [5]). Note that the actual URL value is added at [5].\nThe resulting string is simply a series of arguments for  . This is an example of such a string: Finally, function   is called [6], passing the reference to the arguments string as second parameter [7]: We can see that the arguments, passed as second parameter [8], are split on every space character [9] using the   function [12] in a loop [13].\nEvery token is saved into the   array [11], whose first element was set to   [10]. The resulting array is then passed as the   parameter of the   call [14]. Since the space character inside the   is never modified throughout the whole processing, and the arguments splitting is performed by simply looking for space characters, an attacker that controls the   can add new options to the invocation of the   binary. This can be exploited to execute arbitrary shell commands, resulting in a complete compromise of the device.\nWe identified three different vectors that allow for exploiting this vulnerability: The following proof of concept shows how to execute an arbitrary command inside the device, by using the api.smartthings.com vector. It\'s assumed that an attacker already owns a valid OAuth bearer token. A camera also needs to be set up on the hub. A fake camera could be added by an attacker, but for simplicity, we assume that we already have a configured camera available. Exploitation relies on the ability of   to pipe any raw data from a plain TCP connection into a file. This is possible thanks to the   file format and the   codec, since when used together, they omit any encoding or decoding of the raw stream.\nFor example, to write the string   into   in  , one could execute: Moreover,   supports multiple inputs and outputs on a unique invocation, which allows for injecting this kind of command anywhere in the arguments list. However, since the majority of the system partitions are mounted read-only, executing arbitrary commands becomes slightly more tricky, and we show how it can be done by overwriting two files: We can see that the   directory can be written to, and it also contains the script  , which is called when a core dump is generated.\nTo generate a core dump, it\'s enough to write any invalid string in  . This is a pipe read by the   process, which crashes as soon as an unexpected string is found in the pipe. So to execute an arbitrary command, it\'s enough to: Note that the   parameter is used to discard the rest of the URL where the password was injected. Otherwise,   would fail because an unknown option would be specified. 2018-03-23 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0539');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (73, 'Samsung SmartThings Hub video-core Camera URL Replace Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable buffer overflow vulnerability exists in the camera \"replace\" feature of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly extracts the URL field from a user-controlled JSON payload, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending a PUT request for the   path, it\'s possible to replace the URL of an existing camera. Such request is handled by function  : Note that the binary embeds the   that is used to manage JSON objects. The function initially calls   at [1] to verify that all the required parameters are specified in the JSON request. The parameters are:  ,  ,  ,  .\nAt [2] the function parses the JSON payload received in the request using  . It then extracts the \"cameraId\" [3] and the \"url\" field in stack buffers.\nRegarding the \"url\" field, we can see that the   value for the   call [5] is set from the   [4] output of the source string itself. At high level, this would be: Since   is controlled by the user, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer and execute arbitrary code. We identified two different vectors that allow for exploiting this vulnerability: A third vector might exist, but we decided not to test it to avoid damaging any live infrastructure. This would consist of sending a malicious request from the SmartThings mobile application to the remote SmartThings servers. In turn, depending on the remote APIs available, the servers could relay the malicious payload back to the device via the persistent TLS connection. To use this vector, an attacker would need to own a valid OAuth bearer token, or the relative username and password pair to obtain it. Note that right after the   call at [5], the database is updated to replace the supplied URL [6], using the following query: If the query fails (for example if the supplied \"cameraId\" doesn\'t exist), then an error is generated at [7], and the error message in written in a pointer stored in the stack at [8]  (if the query succeeds a similar execution happens).\nTo reach the end of the function and overwrite the stack arbitrarily, an attacker would need to provide a pointer to a writable address at  . Although ASLR is enabled, its entropy is low, and the process spawns 14 threads in total, some of them with large stacks. This makes exploitation reliable, as it\'s possible to easily predict a writable address. The following proof of concept shows how to crash the   process by overwriting the saved-PC with 0x41414141 and also write beyond it: Note that while the proof of concept uses a fixed stack address to simplify the demonstration (0x758a5555), in practice it would be possible to just overwrite the saved-PC with any pivoting gadget. 2018-04-16 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0573');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (74, 'Samsung SmartThings Hub hubCore Port 39500 HTTP Header Injection Vulnerability', 'None', '2018-7-26', 'An exploitable HTTP header injection vulnerability exists in the remote servers of Samsung SmartThings Hub. The   process listens on port 39500 and relays any unauthenticated message to SmartThings\' remote servers, which insecurely handle JSON messages, leading to partially controlled requests generated toward the internal   process. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 8.6 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers (\'HTTP Response Splitting\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. While analyzing the   process, we identified the following traffic on port 39500, generated by   when requesting the \"/sync\" path [1]: The   process listens on port 39500, bound to \"0.0.0.0\", and simply forwards the HTTP request [2] to the remote Samsung SmartThings servers [3], which answer with [4]. The answer is finally forwarded back to the client [5].\nNote that being   bound to \"0.0.0.0\", request [1] could be omitted and request [2] could be initiated by anyone in the network, without any prior authentication. In essence, the \"sync\" request [1] is used to make sure that the remote servers and  \'s internal database are synchronized. All camera IDs known by   are included in the JSON string, and if   contains a \"camera-id\" which doesn\'t exist in the remote servers, it will be deleted.\nContinuing on the example, if \"camera-id2\" is not found by the remote servers, the following traffic can be seen: Request [6] is sent by the remote Samsung SmartThings servers over the persistent TLS connection, and is thus received by the   process, which blindly forwards it to  \'s HTTP server on port 3000 [7]. Request [8] is simply the answer of   to the \"DELETE\" request. To summarize, the flow of events when a deletion is going to take place is: Where \"Sender\" can either be the hub itself (that is  , as shown in request [2]) or anyone in the network. As we can see, a portion of request [2] is included in request [6]: the  . In fact, it is first present in message M1, and is then propagated till   where it is sent inside M3. Moreover, we noticed that the remote server is subject to a header injection vulnerability when building the HTTP request M3 from the JSON M1.\nSpecifically, the JSON string M1 allows for any character to be included, so it is possible to send CRLF sequences (or their escaped counterpart, for example \"\\r\\n\" or \"\\u000d\\u000a\") in the \"camera-id2\" element. These characters are not stripped when creating the request M3, hence it gives the opportunity to arbitrarily modify the HTTP request sent to  , except for the \"DELETE /cameras/\" prefix, which will always be present. Nevertheless, by using CRLF sequences, this bug allows for injecting pipelined HTTP requests, which can be exploited using TALOS-2018-0577. Moreover, as described in TALOS-2018-0577, it is possible to further use TALOS-2018-0573 to achieve an arbitrary code execution from the network, without authentication. The following proof of concept shows how to send a pipelined HTTP request to the   process, which can be further exploited using TALOS-2018-0577. The request received by   is: 2018-04-19 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0578');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (75, 'Samsung SmartThings Hub video-core Database find-by-cameraId Code Execution Vulnerability', 'None', '2018-7-26', 'An exploitable stack-based buffer overflow vulnerability exists in the database \"find-by-cameraId\" functionality of  \'s HTTP server of Samsung SmartThings Hub. The   process incorrectly handles existing records inside its SQLite database, leading to a buffer overflow on the stack. An attacker can send an HTTP request to trigger this vulnerability. Samsung SmartThings Hub STH-ETH-250 - Firmware version 0.20.17 8.2 - CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Samsung produces a series of devices aimed at controlling and monitoring a home, such as wall switches, LED bulbs, thermostats and cameras.\nOne of those is the Samsung SmartThings Hub, a central controller which allows an end user to use their smartphone to connect to their house remotely and operate other devices through it.\nThe hub board utilizes several systems on chips. The firmware in question is executed by an i.MX 6 SoloLite processor (Cortex-A9), which has an ARMv7-A architecture. The firmware is Linux-based, and runs a series of daemons that interface with devices nearby via ethernet, ZigBee, Z-Wave and Bluetooth protocols. Additionally, the   process is responsible for communicating with the remote SmartThings servers via a persistent TLS connection. These servers act as a bridge that allows for secure communication between the smartphone application and the hub. End users can simply install the SmartThings mobile application on their smartphone to control the hub remotely. One of the features of the hub is that it connects to smart cameras, configures them and looks at their livestreams.\nFor testing, we set up the Samsung SmartCam SNH-V6414BN on the hub. Once done, the livestream can be displayed by the smartphone application by connecting either to the remote SmartThings servers, or directly to the camera, if they\'re both in the same subnetwork. Inside the hub, the livestream is handled by the   process, which uses   to connect via RTSP to the smart camera in its same local network, and at the same time, provides a streamable link for the smartphone application. The remote SmartThings servers have the possibility to communicate with the   process by sending messages in the persistent TLS connection, established by the   process. These messages can encapsulate an HTTP request, which   would relay directly to the HTTP server exposed by  . The HTTP server listens on port 3000, bound to the localhost address, so a local connection is needed to perform this request. We identified a vulnerable request that can be exploited to achieve code execution on the   process, which is running as root.\nBy sending an HTTP DELETE request for the   path it\'s possible to delete an existing smart camera which has the specified \"camera-id\". This request is handled by function  : Soon after initialization, the function   is called [2], passing as parameters the \"camera-id\" specified in the request, the \"camera-id\" string length, and a buffer allocated on the stack [1] where all the information about the camera is expected to be stored. The function searches for the camera with the given id in the database and saves each column in the buffer passed as third argument.\nAt [4] the first argument of the function (\"camera-id\") is copied on the stack and is used by the   function [6] as a filter on the database.\nWe can see that the function loops [5], and for each column of the table [7], pointed by the array at [3], a query is performed. Depending on [7],   will execute the following query: The pointer to the string resulting from the query will be saved in the fourth argument [8].\nFinally, if the query is successful, the result is saved using   [10] on the caller\'s buffer [2]. Moreover, the   parameter of the   is set from the   [9] output of the source string itself. At high level this would be: Since the   is directly fetched from the database, there is no restriction on the length of the copy operation, which allows for overflowing the stack buffer of the parent function and execute arbitrary code. To get this data into the database, the vulnerability described in TALOS-2018-0556 could be used. Note that while we scored this vulnerability CVSS 8.2 on its own, it would constitute a CVSS 9.9 (CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H) when combined with TALOS-2018-0556. This is demonstrated in the proof of concept below. The following proof of concept shows how to crash the   process: 2018-04-09 - Vendor Disclosure \n2018-05-23 - Discussion with vendor/review of timeline for disclosure \n2018-07-17 - Vendor patched \n2018-07-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0557');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (76, 'FocalScope XML External Entity Injection Vulnerability', 'None', '2018-7-20', 'An exploitable unauthenticated XML external injection vulnerability was identified in FocalScope v2416. A unauthenticated attacker could submit a specially crafted web request to FocalScope\'s server that could cause an XXE, and potentially result in data compromise. FocalScope v2416 9.4 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:H CWE-611: Improper Restriction of XML External Entity Reference (\'XXE\') FocalScope v2416 and prior is vulnerable to an unauthenticated XML External Entity injection attack. The following XML payload was used to trigger the XXE: Note: It was also observed that pretty much any page which takes XML input in POST request is vulnerable to this vulnerability, regardless of whether pages are protected by authentication or not. 2018-04-09 - Vendor Disclosure \n2018-04-12 - Sent plain text file to vendor \n2018-06-05 - 60 day follow up \n2018-06-27 - Final follow up \n2018-07-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0559');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (77, 'Sony IPELA E Series Camera 802dot1xclientcert remote code execution vulnerability', 'None', '2018-7-20', 'An exploitable stack-based buffer overflow vulnerability exists in the 802dot1xclientcert.cgi functionality of Sony IPELA E Series Camera. A specially crafted POST can cause a stack-based buffer overflow, resulting in remote code execution. An attacker can send a malicious POST request to trigger this vulnerability. Sony IPELA E series G5 firmware 1.87.00 9.1 - CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without checking size of input (\'Classic Buffer Overflow\') Sony IPELA Cameras are network-facing cameras used for monitoring and surveillance. One of the endpoints available on the IPELA cameras is 802dot1xclientcert.cgi. This endpoint is designed to handle everything related to certificate management for 802.1x. Before processing the incoming data, this endpoint trims data via the   header [0]. When the CONTENT_TYPE header has been found,   is searched for via  . The length of the data is then checked via   in preparation for copying the data locally. This data is directly copied to a local buffer via memcpy. Because this   length is not checked against a safe value, the memcpy overflows the buffer, resulting in a stack-based buffer overflow. This overflow also allows the attack to remotely execute commands on the device. 2018-06-04 - Vendor disclosure \n2018-07-19 - Vendor patched \n2018-07-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0605');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (78, 'Sony IPELA E Series Camera measurementBitrateExec command injection vulnerability', 'None', '2018-7-20', 'An exploitable command injection vulnerability exists in the measurementBitrateExec functionality of Sony IPELA E Series Network Camera. A specially crafted GET request can cause arbitrary commands to be executed. An attacker can send an HTTP request to trigger this vulnerability. Sony IPELA E series G5 firmware 1.87.00 9.1 - CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Sony IPELA Cameras are network facing cameras used for monitoring and surveillance. In order to measure network performance, the camera leverages  . While building the   command, a specific payload can be sent to the   in order to turn on performance measuring for UDP or TCP traffic: This string is parsed by   by finding the   substring and splitting at the comma: Subsequently, parsing the server address is done by using   to locate the next comma and extracting the string between the comma after  . The above parsing results in the following commands: While parsing the input measurement string, there isn\'t a check on the server address (-c). In this manner, any string can be placed as the server address and will be executed via  . Knowing this, an attacker can execute arbitrary commands in the position of the server address. 2018-06-04 - Vendor disclosure \n2018-07-19 - Vendor patched \n2018-07-20 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0604');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (79, 'ACD Systems Canvas Draw 4 setRasterData Heap Overflow Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable heap overflow exists in the TIFF parsing functionality of Canvas Draw version 4.0.0. A specially crafted TIFF image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a TIFF image to trigger this vulnerability and gain code execution. ACDSystems Canvas Draw 4.0.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-Based Buffer Overflow Canvas Draw 4 is a graphics editing tool used to create and edit images, as well as other graphic-related material. This product has a large user base, and is popular in its specific field. The vulnerable component is in the handling of TIFF images. TIFF is a raster-based image format used in graphics editing projects, thus making it a very common file format for such an application. The vulnerability arises in the parsing of a compressed and tiled TIFF image. TIFF has support for multiple versions of image compression, and an image application is expected to be able to handle them. The tag used to define levels of compression is tag number 259. The compression used in the vulnerable TIFF image is CCITT  Group 3. A brief description from the TIFF specification is shown below. The crash happens due to an invalid object being freed on the free list. This is often caused by a heap overflow, and subsequently corruption of the free list. Investigating further, we can confirm our suspicions. Employing Guard Malloc, the crash happens inside of memcpy and the stack trace is below. The overflow variable for the vulnerable function call is calculated via a series of shifts and multiplication, similar to that of decompressing data. The data it is decompressing, however, is user-controlled, and it is not verified before use. The calculation is shown below. Then the use of the variable: Using a debugger, we can verify this issue and see the actual size calculations and the overflow: Above is the vulnerable call to memcpy with the destination buffer in RDI, source in RSI and size in RBX. Inspecting their sizes, we see: There is a large overflow happening here copying over the bounds of the buffer supplied in RDI and writing to arbitrary memory. We can also see the crash is caused by the out-of-bounds write: The rep command is used to repeat a previous operation, moving RDX to RCX and writing out of bounds. This overwrites parts of the free list, causing a vulnerable condition to arise later in the program when this data is then attempted to be freed. An attacker could craft arbitrary data to overwrite with and gain code execution through this vulnerability. 2018-03-20 - Vendor Disclosure \n2018-04-18 - 30 day follow up \n2018-04-19 - Vendor escalated to Canvas development team \n2018-05-02 - 45 day follow up \n2018-06-25 - Vendor confirmed fix scheduled for next update \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0541');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (80, 'Foxit PDF Reader Javascript createTemplate nPage Remote Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s PDF Reader, version 9.1.0.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.0.5096. 8.0 - CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking the   method of the active document with a crafted object as argument, which can trigger a use-after-free condition, like in the following code: In the above code, we create an object   and overload its   method to be  . Then, when   is invoked,   of the second argument is called, effectively closing the document and freeing a number of objects. When   continues execution, it reuses a stale reference of a freed object, causing a crash. Opening this proof-of-concept PDF document in Foxit PDF Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated freed memory region. And, if we take a look at the code immediately following the point of crash, we can see   being used as a vtable pointer, ultimately leading to   instruction with controllable operand in  . Since the contents of memory pointed to by   can easily be controlled, this leads to relatively straightforward conditions for arbitrary code execution. 2018-06-05 - Vendor Disclosure \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0606');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (81, 'ACD Systems Canvas Draw 4 PlanarConfiguration Heap Overflow Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable heap overflow exists in the TIFF parsing functionality of Canvas Draw version 4.0.0. A specially crafted TIFF image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a TIFF image to trigger this vulnerability and gain the ability to execute code. ACDSystems Canvas Draw 4.0.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-Based Buffer Overflow Canvas Draw 4 is a graphics editing tool used to create and edit images, as well as other graphic-related material. This product has a large user base, and is popular in its specific field. The vulnerable component is in the handling of TIFF images. TIFF is a raster-based image format used in graphics editing projects, thus making it a very common file format for such an application. The vulnerability arises in the parsing of a tiled TIFF image with the PlanarConfiguration tag set. TIFF has two distinct ways for dealing with PlanarConfiguration, and by setting this tag to the default chunky version, i.e. stored contiguously with a tiled image, the application is thrown into a special parsing loop. Running the application with the vulnerable TIFF image and Guard Malloc, we get the crash below. As can be seen above, the application is processing the planar packed information. If we look to where the buffer in R10 comes from, we can see the size being used for allocation. The malloc log for R10 is below. And the area where this is calculated inside of  . The raster size of this image is returned, then passed into a malloc wrapper, returning a properly allocated buffer. The problem arises when using the buffer inside of  , the counter for the loop is miscalculated, and the overflow occurs. The relevant code is shown below. The above code calculates the loop counter for how many planars to unpack. At [0], eight is set as the value used for the size of the planar. Then, R15 is directly passed in and is too large a value. This causes the loop counter to be written as four, and causes the buffer to be overflowed. Below is the use of the counter variable and the vulnerable buffer to cause the overflow. At [1], the buffer is being accessed in the loop with the counter of proper size. Then, at [2], we see the problem with the counter show up, and the buffer is overwritten, causing a vulnerable condition to arise. An attacker could craft arbitrary data to overwrite with and gain code execution through this vulnerability. 2018-03-20 - Vendor Disclosure \n2018-04-18 - 30 day follow up \n2018-04-19 - Vendor escalated to Canvas development team \n2018-05-02 - 45 day follow up \n2018-06-25 - Vendor confirmed fix scheduled for next update \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0542');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (82, 'ACD Systems Canvas Draw 4 Invert Map Out-of-Bounds Write Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable out-of-bounds write exists in the PCX parsing functionality of Canvas Draw version 4.0.0. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. ACDSystems Canvas Draw 4.0.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Canvas Draw 4 is a graphics editing tool used to create and edit images, as well as other graphic-related material. This product has a large user base and is popular in its specific field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers and although has been replaced by more sophisticated formats, it is still in use and fully supported inside of Canvas Draw. The vulnerability arises in parsing the PCX image, specifically dealing with the column and row sizes of the image. Inside of the PCX header, values are set to determine the location of image data and the size of the image itself. By passing in incorrect values, the application will write out of bounds, attempting to access the image data. A look at the image header is shown below. The columns and rows are calculated by subtracting the bottom from the top, or subtracting the right from the left, respectively. As seen above, [0], the left value is far too large, causing a negative column value. This leads to an out-of-bounds write when the image map is accessed. The crash is shown below. At location [1], RCX is user-controlled determined by the column sizes shown above. This creates an exploitable condition and could be used to gain code execution. 2018-04-03 - Vendor Disclosure \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0553');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (83, 'Foxit PDF Reader Javascript MailForm Remote Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 9.1.5096. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user into opening the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.1.5096. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in invoking   method of the active document, which can trigger a use-after-free condition called with specially crafted arguments like we see in the following code: In the above code, we craft an array   with overloaded   method to call function  . Then we invoke   method. While accessing the arguments,   will expect second argument to be of type   and will call object\'s   method. In this case, that will execute function  , which closes the current document. Closing the document frees a number of objects, and then when the execution returns to the rest of   method, a stale pointer is reused, leading to use-after-free. Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into an unallocated freed memory region. If we examine the next few instructions we can see the following: We can observe from the above listing that twice-dereferenced address from  , through   ends up in   which is then used as argument to   instruction. This makes this vulnerability easy to exploit, since we can control the contents of  . And indeed, with a simple heap spray added after the call to  , we can get an object of our choosing at the desired address and ultimately get full EIP control: 2018-05-01 - Vendor Disclosure \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0588');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (84, 'ACD Systems Canvas Draw 4 Resolution_Set Out of Bounds Write Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable out-of-bounds write exists in the TIFF parsing functionality of Canvas Draw version 4.0.0. A specially crafted TIFF image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a TIFF image to trigger this vulnerability and gain the ability to execute code. ACDSystems Canvas Draw 4.0.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-Bounds Write Canvas Draw 4 is a graphics editing tool used to create and edit images, as well as other graphic-related material. This product has a large user base and is popular in its specific field. The vulnerable component is in the handling of TIFF images. TIFF is a raster-based image format used in graphics editing projects, thus making it a very common file format for such an application. The vulnerability arises in the parsing of a tiled TIFF image with a specially crafted resolution tag and data. The initial crash is shown below. Following the backtrace, we can see that the value of RDI has been incorrectly calculated. The location which it is set is below. The address in memory is loaded into RCX [0], and then passed into a get information function, [1]. Going a bit further, the vulnerability becomes apparent. The user-influenced address is loaded into the R14 register and the lower four bytes are then zeroed out in memory. When this value is then used later in   above, it causes an out-of-bounds write and an exploitable condition to arise. By crafting a special TIFF image an attacker could exploit this situation to gain code execution. 2018-03-20 - Vendor Disclosure \n2018-04-18 - 30 day follow up \n2018-04-19 - Vendor escalated to Canvas development team \n2018-05-02 - 45 day follow up \n2018-06-25 - Vendor confirmed fix scheduled for next update \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0544');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (85, 'ACD Systems Canvas Draw 4 IO Metadata Out-of-Bounds Write Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable out-of-bounds write exists in the PCX parsing functionality of Canvas Draw version 4.0.0. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. ACDSystems Canvas Draw 4.0.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Canvas Draw 4 is a graphics editing tool used to create and edit images, as well as other graphic-related material. This product has a large user base, and is popular in its specific field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers, and although it has been replaced by more sophisticated formats, it is still in use and is fully supported inside of Canvas Draw. The vulnerability arises in the parsing of the PCX image, specifically dealing with the compression of the image. The compression scheme is determined via the file header, and by choosing run length encoding as the compression, the program writes out of bounds using user-controlled data. The problem lies in the error-checking in the code. If there is an error present, the code path can be altered and allows user-controlled data to be accessed without validation. The initial crash is below. Looking further into the assembly, we can see where the RAX value has been set: At [1], there is a call to error check to see if the everything is OK and if this fails, returns a non-zero status: RAX is loaded with the value from R14 [2]. At the function prologue [0], RDI gets loaded into the R14 register. Checking the calling function, we can see the error: The R13 value at location [3], is user-controlled and not verified to contain the expected structure. Therefore, when calling into the meta data function [4] an exploitable condition arises. The user data is accessed as if it was a  , and a function pointer is attempted to be called. This allows an attacker to leverage control and potentially gain code execution. 2018-04-03 - Vendor Disclosure \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0552');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (86, 'ACD Systems Canvas Draw 4 Huff Table Out-of-bounds Write Code Execution Vulnerability', 'None', '2018-7-19', 'An exploitable out-of-bounds write exists in the TIFF parsing functionality of Canvas Draw version 4.0.0. A specially crafted TIFF image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a TIFF image to trigger this vulnerability and gain code execution. ACDSystems Canvas Draw 4.0.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-Bounds Write Canvas Draw 4 is a graphics editing tool used to create and edit images, as well as other graphic-related material. This product has a large user base and is popular in its specific field. The vulnerable component is in the handling of TIFF images. TIFF is a raster-based image format used in graphics editing projects, thus making it a very common file format for such an application. The vulnerability arises in the parsing of a tiled TIFF image with the Adobe Deflate compression scheme. This compression algorithm is not part of standard TIFF algorithms, but was added as an extension from Adobe, and uses a lossless Deflate compression scheme utilizing the zlib compressed data format. The Canvas Draw application supports this compression format and is able to handle files using it. The vulnerability arises in attempting to build a Huffman table. Huffman coding is one of the two things that make up the Deflate encoding scheme. When using the Deflate encoding scheme, the application takes user data directly from the TIFF image without validation. The initial crash is shown below. The value inside of RSI has come directly from the TIFF data field. Below is the relevant code leading up to the out of bounds write. The value inside of RCX at [0] is controlled via the compressed data inside the TIFF image. It then uses the value given and loads it into ESI, [1]. After doing some data shuffling, we finally get to the use again at [2], where a user-controlled value is written, too. This leads to an exploitable out-of-bounds write condition. By using specially crafted data, an attacker could gain the ability to execute code through this vulnerability. 2018-03-20 - Vendor Disclosure \n2018-04-18 - 30 day follow up \n2018-04-19 - Vendor escalated to Canvas development team \n2018-05-02 - 45 day follow up \n2018-06-25 - Vendor confirmed fix scheduled for next update \n2018-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0543');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (87, 'Computerinsel Photoline ANI Parsing Code Execution Vulnerability', 'None', '2018-7-11', 'A memory corruption vulnerability exists in the ANI-parsing functionality of Computerinsel Photoline 20.54. A specially crafted ANI image processed via the application can lead to a stack overflow, overwriting arbitrary data. An attacker can deliver an ANI image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.54 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Photoline is an image processing tool used to modify and edit images, as well as other graphics-editing tasks. This product has a large user base, and is popular in the graphic design field. The vulnerability arises in parsing the ANI image, specifically dealing with the size value in the header. Below is a small dump of the included proof of concept. At [0], the last four bytes are interpreted as a length value for the image data. By supplying an overly large value, in this case 0x600000FF, the program will read beyond the bounds of the supplied buffer. The code causing the crash is shown below. The code at [1] is doing a comparison on a header value, then subsequently calling in to memcpy. The length value passed in [2] is taken from the header shown above. This allows an attacker to supply an arbitrary length and overflow as much as desired. This creates an out-of-bounds write that could be exploited to gain code execution. 2018-05-01 - Vendor Disclosure \n2018-07-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0586');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (88, 'Computerinsel Photoline PCX Run Length Encoding Code Execution Vulnerability', 'None', '2018-7-11', 'A memory corruption vulnerability exists in the PCX-parsing functionality of Computerinsel Photoline 20.54. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.54 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image processing tool used to modify and edit images, as well as other graphics-editing tasks. This product has a large user base, and is popular in the graphic design field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers, and although it has been replaced by more sophisticated formats, it is still in use and fully supported inside of Canvas Draw. The vulnerability arises in parsing the PCX image, specifically dealing with the run length encoding of the image. The run length is the way that PCX handles new image chunks. This value determines the size of the upcoming image chunk. By crafting an image with successive large encoding values, the program can be caused to write a null byte out of bounds, leading to an exploitable condition. The code is shown below. The above code is a parsing loop designed to fill out the vulnerable object with the image data. The vulnerable object size is passed in and used as the max variable in the loop [2]. At location [0], it can be seen that the object is incremented based on the run length read in from the image. By crafting an image, an attacker can place a large run length toward the end of the image, causing the vulnerable object to be incremented beyond its bounds. Thus at location [1], the object is beyond its bounds and written to directly causing an out-of-bounds write and an exploitable condition to arise. 2018-05-01 - Vendor Disclosure \n2018-07-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0587');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (89, 'Computerinsel Photoline PSD Blending Channel Code Execution Vulnerability', 'None', '2018-7-11', 'A memory corruption vulnerability exists in the PSD-parsing functionality of Computerinsel Photoline 20.54. A specially crafted PSD image processed via the application can lead to a stack overflow, overwriting arbitrary data. An attacker can deliver a PSD image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.54 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Photoline is an image processing tool used to modify and edit images, as well as other graphic-related material. This product has a large user base, and is popular in its specific field. The vulnerability arises in parsing the PSD image, specifically dealing with the blending channels inside of the image. The PSD format supports the ability to have multiple layers and masks per image, and the vulnerability is in how the software deals with the length of these layers. By looking at the vulnerable images Blending Layer Length value, we see that it is 0x40000000. Shown below is the code using this value causing the overflow. The blending channel value is read directly from the image and used to copy this data into a stack-based buffer. This causes a direct overflow of the stack, and an overwrite of arbitrary data. There is a stack cookie present, but this could be circumvented by other means. This vulnerability could be exploited to gain code execution. 2018-05-01 - Vendor Disclosure \n2018-07-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0585');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (90, 'Antenna House Office Server Document Converter putlsttbl code execution vulnerability', 'None', '2018-7-10', 'An exploitable stack-based buffer overflow exists in the Microsoft Word document conversion functionality of the Antenna House Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312).\nA crafted Microsoft Word (DOC) document can lead to a stack-based buffer overflow, resulting in remote code execution. Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow This vulnerability is present in the Antenna House Office Server Document Converter, which is used as a document converter in many server enterprise solutions. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a DOC to PDF, JPEG and several other formats. A specially crafted Microsoft Word file can lead to stack based-buffer overflow and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious DOC using the OSDC library, we see the following state: As we can see, a stack-based buffer overflow appeared inside   method.\nLet us take a look at the most important parts of pseudo code of the   method where the stack overflow occurred: The code above is responsible for parsing the   record. At  , the size of the   record is read and next based on its value a while loop is executed.\nDuring each iteration, four bytes are copied to the   fixed size buffer (0x80 bytes). Two bytes are a constant value, and another two are bytes read directly from the file at  .\nKeeping that in mind, we can make a simple calculation that   is enough for   to a cause buffer overflow.\nKnowing these facts, we know that an attacker fully controls the amount of bytes used for the overflow and partially controls their content.\nIn these circumstances, an attacker, using a properly malformed Microsoft Word document, can overwrite function return address and turn that into remote code execution. 2018-06-01 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0599');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (91, 'Adobe Acrobat Reader DC Collab.drivers Remote Code Execution Vulnerability', 'None', '2018-7-10', 'A specific JavaScript code embedded in a PDF file can lead to an object type confusion when opening a PDF document in Adobe Acrobat Reader DC 2018.011.20038. With careful memory manipulation, this can lead to arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.011.20038 6.8 - CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H CWE-843: Access of Resource Using Incompatible Type (\'Type Confusion\') Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a large user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. The one method call required to trigger this vulnerability is privileged, and can only be called from trusted functions or from a trusted location. Adobe Acrobat Reader DC supports embedded JavaScript code in the PDF to allow for interactive PDF forms. This give the potential attacker the ability to precisely control memory layout, and poses an additional attack surface. While executing the following piece of JavaScript code, a specific condition leading to an object of wrong type being misinterpreted can cause memory corruption (it should be noted that all three of these lines require higher privileges, meaning they must be executed in a trusted PDF file): After calling  , which is an undocumented JavaScript function, a subsequent dereference of   with a call to a particular method will cause one extra object of wrong type to be accessed. After a call to  , in the debugger, we actually end up in the following code: At this call, EScript’s cachehash will be consulted, and an object returned as a result. Because things don’t change over many calls of the above code, we can get the resulting pointer in advance: And indeed, if we wait for the above call to return, we see the same result in the  : Looking up heap information of this pointer reveals the following: Note that it’s an object of size 0x108. In the sample proof of concept there are total of 12 benign calls on the above break point, all returning an object of size 0x108 as a result. But, 13th call (which is a result of calling  ) will be erroneous: In the above debugging output we can see, even before the call is made, that the returned object pointer will point to an object of size 8 in this case (note that this is with full page heap enabled and the details might vary with memory layout). And indeed, after returning from this call, we have a wrong object in  : This brings us to the consequence of this type confusion. Listing the immediately following code reveals the problem: If   isn’t null, a pointer value is read into   and is subsequently dereferenced in a   instruction. Because   now points to a wrong object type, this can possibly result in control flow hijacking and arbitrary code execution. Indeed, continuing the execution leads to a crash due to the instruction pointer pointing to an invalid location. Crash with full page heap enabled: 2018-04-16- Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0569');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (92, 'Antenna House Office Server Document Converter OLEread Code Execuction Vulnerability', 'None', '2018-7-10', 'An exploitable heap corruption exists in the PowerPoint document conversion functionality of the Antenna House Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312).\nA crafted PowerPoint (PPT) document can lead to heap corruption, resulting in remote code execution. Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write This vulnerability is present in the Antenna House Office Server Document Converter, which is used as a document converter in many server enterprise solutions. \nIt can convert common formats, such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a PowerPoint (PPT) to PDF, JPEG and several other formats. A specially crafted PowerPoint (PPT) file can lead to heap corruption and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious PowerPoint using the OSDC library, we see the following state: As we can see, a heap-based buffer overflow appeared during the memcpy operation. Looking at call stacks, we can see that the overflowed buffer has been allocated during operations related with the   record.\nFurther investigation revealed that   is indeed  the   record size. Next, let\'s debug the   method during parsing of the   record.\nPseudo code for the function looks as follows: The   argument is set to the   record size. In our case, this is  .   is the size of  , in this case   with value  .\nAs we can see at   if   is bigger than  , the   argument is set with result of the subtraction of   and   which equals the current record offset.\nNext, inside the while loop, data is read from a file into the   in the amount equal to the value of the   argument.\nA heap-based buffer overflow can occur in two scenarios:\n- When the   argument is bigger than previously allocated space for the  , but smaller than  \nand\n- When   is bigger than  , but the result of the subtraction of   and   (the current record offset) is bigger than previously allocated buffer.\nBoth critical scenarios lead to heap memory corruption and give an attacker a possibility to remotely execute arbitrary code. 2018-05-21 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0596');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (93, 'Antenna House Office Server Document Converter GetShapePropery 0x105 code execution vulnerability', 'None', '2018-7-10', 'An exploitable out-of-bounds write exists in the Microsoft Word document conversion functionality of the Antenna House Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312).\nA crafted Microsoft Word (DOC) document can lead to an out-of-bounds write, resulting in remote code execution. This vulnerability occurs in the   method. Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow This vulnerability is present in the Antenna House Office Server Document Converter, which is used as a document converter in many server enterprise solutions. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a DOC to PDF, JPEG and several other formats. A specially crafted Microsoft Word file can lead to a stack-based buffer overflow and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious Microsoft Word document using the OSDC library we see the following state: As we can see, a stack-based buffer overflow appeared inside   function, overwriting the return address.\nLet\'s take a look at the most important parts of a pseudo code representation of the   function: At the beginning of   at   the record type and record length are read from the file.\nNext, for record type     are executed. We see at   that, without any checks, an amount of data equal to the   value will be read from the file into   array.\nThis array has a fixed size equal to   bytes. Any value of   bigger than this one will cause a stack-based buffer overflow.\nIn those circumstances, attackers using a properly malformed Microsoft Word document can overwrite the function return address and turn that into remote code execution. 2018-06-01 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0603');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (94, 'Antenna House Office Server Document Converter vbgetfp code execution vulnerability', 'None', '2018-7-10', 'An exploitable out-of-bounds write exists in the Microsoft Word document conversion functionality of the Antenna House Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312).\nA crafted Microsoft Word (DOC) document can lead to an out-of-bounds write, resulting in remote code execution. This vulnerability occurs in the   method. Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write This vulnerability is present in the Antenna House Office Server Document Converter which is used as a document converter in many server enterprise solutions. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a Microsoft Word (DOC) to PDF, JPEG and several  other formats. A specially crafted Microsoft Word (DOC) file can lead to heap corruption and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious Microsoft Word (doc) using the OSDC library, we see the following state: As we can see, an out-of-bounds write appeared during some memory operations inside the   method. Looking at the call stack, we can see that the out-of-bounds write appears in the same function that the overflowed buffer is allocated in.\nLet\'s take a look at pseudo code for the   function: As we can see, the code above allocates two buffers: with constant size 512 bytes (0x200). Next, 512 bytes are ready directly from the file and copied into buffer at lines  27 and 31. The last byte (line 21) is used as a limit for the amount of iterations for a loop where the data from a   is copied to   buffer. During each iteration, 64 (0x40) bytes are copied. There is no check whether value of  >>4 is bigger than 0x200 / 0x40 = 8 .\nFor all values of   in the range of 144-255, an out-of-bounds write will occur, causing memory corruption. As a result, the attacker has the possibility to corrupt memory, potentially resulting in arbitrary remote code execution. 2018-05-21 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0597');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (95, 'Adobe Acrobat Reader DC Collab newWrStreamToCosObj Remote Code Execution Vulnerability', 'None', '2018-7-10', 'A specific JavaScript code embedded in a PDF file can lead to an object type confusion when opening a PDF document in Adobe Acrobat Reader DC 2018.011.20038. With careful memory manipulation, this can lead to arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.011.20038 6.8 - CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a large user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. The one method call required to trigger this vulnerability is privileged, and can only be called from trusted functions or from a trusted location. Adobe Acrobat Reader DC supports embedded JavaScript code in the PDF to allow for interactive PDF forms. This gives the potential attacker the ability to precisely control memory layout, and poses an additional attack surface. While executing the following piece of code, a cache misuse can lead to a dereference of a previously freed object which can cause further memory corruption: During a call to   an object allocated due to previous call to   is freed and reused due to the way Acrobat’s JavaScript engine handles caching. In a debugging session we can see the following: Breakpoint 1 is set on a call that frees the object in question. We can see that the pointer in   points to an allocated object of size   at address  . Breakpoint 2 is then enabled and set at the time of first invalid dereference of the object (the first use-after-free). When the second breakpoint is reached, we can see that the object pointed to by   is now free, and that it points to the same memory area as   at the previous breakpoint. If we examine the code immediately following the second breakpoint, we can see the following: Since we know that   points to freed memory, with careful memory layout control we could gain control over contents of   which is then used in a call which would lead to arbitrary code execution. The pointer to the object in   is retrieved by previously consulting     methods. 2018-05-08 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0590');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (96, 'Antenna House Office Server Document Converter vbputanld code execution vulnerability', 'None', '2018-7-10', 'An exploitable out-of-bounds write exists in the Microsoft Word document conversion functionality of the Antenna House Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312).\nA crafted Microsoft Word (DOC) document can lead to an out-of-bounds write, resulting in remote code execution. This vulnerability occurs in the   method. Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow This vulnerability is present in the Antenna House Office Server Document Converter, which is used as a document converter in many server enterprise solutions. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a DOC to PDF, JPEG and several other formats. A specially crafted Microsoft Word file can lead to a stack-based buffer overflow and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious Microsoft Word document using the OSDC library we see the following state: As we can see, a stack-based buffer overflow appeared inside the   function, overwriting the return address.\nLet\'s take a look at the most important parts of a pseudo code representation of the   function: At   we see a while loop controlled by the   variable. The value of the   variable is read directly from the file at  , so the while loop stays under full control of the attacker.\nEach time the while loop is executed, it reads eight bytes from the file into   ( ). After calculations, it turns out that the   array has allocated around 80 bytes on the stack.\nIt\'s easy to calculate that for   with a value bigger than 10, we will start reading another portion of data from the file outside of the   array bounds.\nThis means that attackers fully control the amount of the bytes used for the overflow and their content.\nIn those circumstances, attackers, using a properly malformed Microsoft Word document, can overwrite the function return address and turn that into remote code execution. 2018-06-01 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0600');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (97, 'Adobe Acrobat Reader DC JSON Stringify Remote Code Execution Vulnerability', 'None', '2018-7-10', 'A specific JavaScript code embedded in a PDF file can lead to a use-after-free condition when opening a PDF document in Adobe Acrobat Reader DC 2018.011.20038. With careful memory manipulation, this can lead to  arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.011.20038 6.8 - CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. The one method call required to trigger this vulnerability is privileged, and can only be called from trusted functions or from a trusted location. Adobe Acrobat Reader DC supports embedded JavaScript code in the PDF to allow for interactive PDF forms. This gives the potential attacker the ability to precisely control memory layout, and poses additional attack surfaces. While executing the following piece of code, a cache misuse can lead to a dereference of a previously freed object, which can cause further memory corruption: While executing   method on indirect reference to   object, an invalid pointer is retrieved, leading to a crash on the following address: Stepping back, we can see that pointer in   comes from the following function call: This is an indirect call to cachehash methods in   referencing   object, and a pointer to a freed object is returned: If we examine the code immediately following the point of the crash, we can see the following: Since the area of the freed memory is quickly used in an indirect   instruction, having control over the contents of this freed memory region can lead to arbitrary code execution. It should be noted that this issue is very similar in nature to TALOS-2018-0569. 2018-05-08 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0592');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (98, 'Antenna House Office Server Document Converter putShapeProperty Code Execution Vulnerability', 'None', '2018-7-10', 'An exploitable out-of-bounds write exists in the Microsoft Word document conversion functionality of the Antenna House Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312).\nA crafted Microsoft Word (DOC) document can lead to an out-of-bounds write, resulting in remote code execution. This vulnerability occurs in the   method. Office Server Document Converter version V6.1 Pro MR2 for Linux64 (6,1,2018,0312) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow This vulnerability is present in the Antenna House Office Server Document Converter, which is used as a document converter in many server enterprise solutions. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a DOC to PDF, JPEG and several other formats. A specially crafted Microsoft Word file can lead to a stack-based buffer overflow and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious Microsoft Word document using the OSDC library we see the following state: As we can see, a stack-based buffer overflow appeared during the   operation.\nLet\'s take a look at the most important parts of a pseudo code representation of the   function where the   operation takes place: As we can see,   is a fixed sized buffer of 0x200 bytes. Each time the while loop is executed, it adds 16 bytes to the buffer. The   variable which is the limits for the while loop in our case equals 0x3cb0.\nIt\'s obvious that in that situation, a stack-based buffer overflow will occur after a few iterations. Tracking the source of the   variable value and the   content we land in   method: As you can see, the   variable value is read directly from the file at  . Next, during each iteration, eight bytes are read from the file and put into the  .\nThis means that attackers fully control the amount of the bytes used for overflow and their content.\nIn those circumstances, attackers using a properly malformed Microsoft Word document can overwrite the function return address and turn that into remote code execution. 2018-05-21 - Vendor Disclosure \n2018-07-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0598');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (99, 'IBM AIX rmsock SetUID Binary Information Leak', 'None', '2018-7-3', 'An exploitable kernel memory leak vulnerability is exposed by the rmsock setUID functionality of IBM AIX 6.1 and IBM AIX 7.1. A specially crafted command line can cause a kernel memory leak, resulting in uninitialized kernel memory being exposed. An attacker can execute rmuser with an invalid socket address to trigger this vulnerability. IBM AIX 6.1, IBM AIX 7.1, IBM AIX 7.2, IBM VIOS 2.2 4.0 - CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N CWE-200 - Information Exposure It has been identified that the rmsock setUID binary can be manipulated by an unprivileged user into leaking uninitialized kernel memory. This can be achieved by manipulating the parameters that are passed to the rmsock setUID binary when calling it. By calling rmsock with a memory address, the AIX kernel will attempt to close a socket at the specified location. In order to close the socket, the rmsock setUID binary makes a call to getkerninfo() with the user-supplied value. As a result, the AIX kernel then attempts to manipulate the supplied location in an attempt to close the socket. Where the address does not point to a valid socket, the kernel may copy values at the user-supplied address back to userland. As a result, the rmsock setUID binary will return an error message consistent with disclosing 64 bits of kernel memory. A simple proof of concept of how an attacker may be able to trigger the condition can be seen below. 1) Identify the address that corresponds to a socket: 2) Observe the following: 3) Call the rmsock setUID binary on the identified address which corresponds to the socket*: 4) Call the rmsock setUID binary with an address that does not correspond to a socket: Further details on the intended use case for rmsock can be found here: https://www.ibm.com/developerworks/community/blogs/cgaix/entry/rmsock?lang=en 2018-03-23 - Vendor Disclosure \n2018-07-03 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0624');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (100, 'VMware Workstation 14 Shader Functionality Denial Of Service', 'None', '2018-6-28', 'An exploitable denial-of-service vulnerability exists in the VMware Workstation 14. A specially crafted pixel shader can cause a read access violation resulting in, at least, denial of service. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability can be triggered from VMware guest and VMware host, which will be affected (leading to vmware-vmx.exe process crash on host). VMware Workstation 14 (14.1.1.28517) on Windows 8.1 with Windows 10 x64 as guestVM 6.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H CWE-823: Use of Out-of-range Pointer Offset This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) inside a VMware guest operating system. Such attacks can be triggered from VMware guest usermode to cause a memory denial-of-service attack on vmware-vmx.exe process on host.\nA very simple pixel shader (fragment shader) consisting of only one instruction can trigger this vulnerability. Pixel shader data used to trigger the bug: As you can see, the only instruction in this case is mov (sm4 component-wise move). Please note unlike in typical, valid shader here dcl_input, dcl_output, dcl_temps declarations are missing. Output from the vmware-vmx-debug.exe process: As you can see, vmware-vmx-debug.exe process indicates that the   macro was triggered (PANIC: (ASSERT bora\\mks\\hostops\\DX11\\DX11ShaderTrans.c:85)) due to providing a malformed pixel shader. The entire virtual machine is terminated. The   macro is only available in DEBUG builds, therefore, this check will be ignored in the retail build (vmware-vmx.exe) leading to crash at: Here is the trace from pointer computation: In short, it is possible to create a shader in such a way that it will cause invalid pointer calculation. The pointer is later used for read memory operations. This causes access violation due to the pointer being invalid, which results in a denial of service, but could potentially be turned into an information disclosure vulnerability. 2018-03-20 - Vendor Disclosure \n2018-06-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0540');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (101, 'Insteon Hub PubNub \"cc\" Channel Message Handler Multiple Stack Overflow Code Execution Vulnerabilities', 'None', '2018-6-19', 'Multiple exploitable buffer overflow vulnerabilities exist in the PubNub message handler for the \"cc\" channel of Insteon Hub running firmware version 1012. Specially crafted commands sent through the PubNub service can cause a stack-based buffer overflow overwriting arbitrary data. An attacker should send an authenticated HTTP request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. To enable remote interaction via the Internet, Insteon Hub uses an online service called PubNub ( ).\nEnd-users install the \"Insteon for Hub\" application on their smartphone. Both the smartphone application and Insteon Hub include the PubNub SDK, which allows for a bi-directional communication using PubNub\'s REST API. The interaction with PubNub happens by means of publish/subscribe methods. Each device has a series of channels it can subscribe to, in order to receive published messages.\nTo subscribe to a specific channel it\'s enough to call the function   (defined in the PubNub SDK), passing as parameter the channel name and a callback function that will be called when a message is received on the specified channel. The device defines a function which parses messages received from PubNub on channel \"cc\":  . The function uses the   library for parsing \"JSON\" messages and receives a   object as parameter, which corresponds to the message sent from an authenticated smartphone application.\nAs an example, this is a valid JSON message which is used to change the username/password pair of the device: The function initially checks the   parameter, and depending on that it proceeds to extract other expected parameters, in this case   and  . The information is then either cached to be handled on the next multitasking loop, or immediately applied from within the current function. The vulnerable code exists while parsing any JSON element, the following example is the disassembly of the path for the \"s_auth\" command: Looking at the pseudocode: The   parameter for   is unconstrained, and can lead to a buffer overflow, in the above example a stack-based one.\nThis same sequence of vulnerable instructions is present for every supported keyword in the message handler. To send a message, an HTTP GET should be used which embeds the JSON string in the \"path\" portion of the URL: Example: The following is a list of vulnerable   calls and their Proof-of-Concept.\nEach PoC shows only the payload portion of the request and uses the placeholder \"OVERFLOW\" to highlight the vulnerable parameter, which can be replaced with   to make the device crash.\nAll buffer overflows below happen on the stack, and allow for overwriting arbitrarily all $s-registers, saved-pc and saved-fp.\nA key with value \"x\" means that its value is irrelevant. At 0x9d014cc0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 20 bytes large, sending anything longer will cause a buffer overflow. At 0x9d014dd8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d014e4c the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d014e84 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d014ebc the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d014f28 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d014f7c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d015430 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d015478 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d015714 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d015864 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d015a8c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d015cfc the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d016104 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d016530 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d016578 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d0165c0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01672c the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01679c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d016c94 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d016cf0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be exactly \"1\" At 0x9d016fa8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d017364 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01758c the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d0175f4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d017658 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01815c the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d0181a4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d0181ec the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d018234 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01827c the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d0188a8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d018958 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d018e58 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d018ea0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d018f00 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. Note: \'dststart\' must be 5 characters long. At 0x9d018f60 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: both \'dststart\' and \'dstend\' must be 5 characters long. At 0x9d0193ac the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01980c the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d019854 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d019c50 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01a010 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01a144 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d01a18c the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d01a1d4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d01a21c the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d01a264 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. Note:   needs to be either a hex number lower than 0x3e9 (e.g. \"grp\": \"3e8\"), or any invalid hex digit. At 0x9d01aad8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ac74 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ad14 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ad78 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01addc the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ae40 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01b20c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01b2ac the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01b310 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01b374 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01b3d8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01b7b0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 100 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01bb64 the value for the   key is copied using   to the buffer at  .\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01c028 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c084 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . Note:   needs to be a hex number lower than 0x100. At 0x9d01c1cc the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c3a0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c898 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01d068 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01d16c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . Note: \"g_group\" can be either \"0\" or \"00\" At 0x9d01d7a8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01ddd4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e050 the value for the   key is copied using   to the buffer at  .\nThis buffer is 8 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e228 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e2f4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e368 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e3a8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e5f4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. Note: in place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01ea88 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01eb08 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01eb44 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01eb8c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ebd4 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ec34 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ed7c the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01edb8 the value for the   key is copied using   to the buffer at  .\nThis buffer is 244 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ee70 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01eeb0 the value for the   key is copied using   to the buffer at  .\nThis buffer is 244 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01ef24 the value for the   key is copied using   to the buffer at  .\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. 2017-11-27 - Vendor Disclosure \n2017-11-28 - Vendor Acknowledged \n2018-01-02 - 30 day follow up with vendor for status \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on timeline for fix \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0483');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (102, 'Insteon Hub HTTPExecuteGet Firmware Update host Parameter Buffer Overflow Vulnerability', 'None', '2018-6-19', 'An exploitable buffer overflow vulnerability exists in Insteon Hub running firmware version 1012. The HTTP server implementation incorrectly handles the host parameter during a firmware update request, leading to a buffer overflow on a global section. An attacker can send an HTTP GET request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 5.3 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called  . Developers can use this task to handle HTTP requests but they have to implement a few functions on their own. One of these is the   function, which is called when a GET request is received. The   task fills the global structure  , which has type  . The developer implementing the   function can thus access   to implement its logic.\nNote that   is only reached if a valid basic-auth string is provided. The function calls   at [1] passing a local array of pointers ([2]): this function reads the GET parameters from   and inserts a pointer to each parameter into the array of pointers. It also returns the number of extracted parameters in   ([3]).\nThe requested path is then saved to   by calling   and if the requested file doesn\'t exist in the MPFS (Microchip Proprietary File System),   will contain 0xff (  [4]). The function continues by checking a few constraints on the parameters. An interesting path exists with these conditions: After these checks, the function copies parameter 2 to the global variable at   (variable containing the update host [8]) and parameter 4 to the global variable at   (variable containing the update URL [9]).\nIf parameter 1 is either equal to \"up bin\" or \"up_PLM\", the device will later perform an HTTP GET request using the global URL and host, in order to request a firmware update. As we can see, the   at [10] is performed using parameter 4 as source, which can be fully controlled by an attacker.\nNevertheless, Microchip\'s \"Libraries for Applications\" implements a basic buffer overflow check on HTTP requests, which limits the size of the HTTP data received to a maximum of 100 bytes. The following proof of concept shows how to overflow the global update-host buffer. 2017-12-05 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0494');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (103, 'Insteon Hub HTTPExecuteGet Firmware Update URL Parameter Code Execution Vulnerability', 'None', '2018-6-19', 'An exploitable buffer overflow vulnerability exists in Insteon Hub running firmware version 1012. The HTTP server implementation incorrectly handles the URL parameter during a firmware update request, leading to a buffer overflow on a global section. An attacker can send an HTTP GET request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called  . Developers can use this task to handle HTTP requests but they have to implement a few functions on their own. One of these is the   function, which is called when a GET request is received. The   task fills the global structure  , which has type  . The developer implementing the   function can thus access   to implement its logic.\nNote that   is only reached if a valid basic-auth string is provided. The function calls   at [1] passing a local array of pointers ([2]): this function reads the GET parameters from   and inserts a pointer to each parameter into the array of pointers. It also returns the number of extracted parameters in   ([3]).\nThe requested path is then saved to   by calling   and if the requested file doesn\'t exist in the MPFS (Microchip Proprietary File System),   will contain 0xff (  [4]). The function continues by checking a few constraints on the parameters. An interesting path exists with these conditions: After these checks, the function copies parameter 2 to the global variable at   (variable containing the update host [8]) and parameter 4 to the global variable at   (variable containing the update URL [9]).\nIf parameter 1 is either equal to \"up bin\" or \"up_PLM\", the device will later perform an HTTP GET request using the global URL and host, in order to request a firmware update. As we can see, the   at [10] is performed using parameter 4 as source, which can be fully controlled by an attacker.\nNevertheless, Microchip\'s \"Libraries for Applications\" implements a basic buffer overflow check on HTTP requests, which limits the size of the HTTP data received to a maximum of 100 bytes. Despite this limit, it\'s possible to combine this bug with TALOS-2017-0492 in order to point parameter 4 to any unconstrained attacker-controlled buffer and effectively achieve code execution on the device. The following proof of concept shows how to overflow the buffer and combines with TALOS-2017-0492 to overwrite a big portion of the global section and crash the device. A first request can be done to spray a payload on the global section: the \"HTTPServer\" task is saving received data at around 0xa0002ca0, so it\'s enough to send any HTTP request without authentication. After that we point parameter 4 to 0xa0002ca0 (by exploiting TALOS-2017-0492), so that   will write past the update-URL buffer and will crash the device. 2017-12-05 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline>br>\n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0493');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (104, 'Insteon Hub MPFS Upload Firmware Update Vulnerability', 'None', '2018-6-19', 'An exploitable firmware update vulnerability exists in Insteon Hub running firmware version 1013. The HTTP server allows for uploading arbitrary MPFS binaries that could be modified to enable access to hidden resources which allow for uploading unsigned firmware images to the device. To trigger this vulnerability, an attacker can upload an MPFS binary via the \"/mpfsupload\" HTTP form and later on upload the firmware via a POST request to \"firmware.htm\". Insteon Hub 2245-222 - Firmware version 1013 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-489: Leftover Debug Code Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called  . Developers can use this task to handle HTTP requests but they have to implement a few functions on their own to handle for example \"GET\" and \"POST\" requests. The   task fills the global structure  , which has type  . The developer implementing GET and POST handler functions can thus access   to implement its logic.\nNote that these handlers are only reached if a valid basic-auth string is provided. Pages served by the   are located in an \"MPFS\" image (Microchip Proprietary File System) which contain both static and dynamic resources. Insteon stores the \"MPFS\" image at offset 0x40000 in one of the three SPI flashes. By default, the Microchip\'s   defines an   path that can be used to upload any arbitrary \"MPFS\" binary: It\'s easy to see that Insteon left this functionality available: The structure of an \"MPFS\" file is described in the file \"MPFS2.c\" of Microchip\'s \"Libraries for Applications\": As we can see there is no signature involved, so it\'s possible to add any new file to the MPFS Structure (note that the filename hash has to be updated too).\nThe issue with leaving the MPFS upload feature enabled is that it could be used to alter the execution of an existing MCU firmware. Indeed, in this case it is even possible to write persistent code to the device by exploiting this feature. Let\'s have a look at an interesting path in the HTTP POST handler defined by Insteon: As we can see, the requested path is present in   [1] and it\'s saved to   by calling  .\nIf the requested file is \"firmware.htm\" [2], the device will follow the path that performs a firmware update by calling  .\nNormally this file doesn\'t exist in the device, but it\'s possible to upload an \"MPFS\" image that contains it: this would effectively re-enable an unsigned firmware update functionality. At [3] the TCP buffer is checked to contain \"\\r\\n\" and at [4] every byte is discarded up to and including \"\\r\\n\".\nThe same then happens at [5] and [6], where any input is discarded up to and including \"\\r\\n\\r\\n\". Then, if data is available [7], the TCP buffer is checked to contain \":0200\" [8]. This sequence is present at the beginning of an Insteon firmware since it\'s using the Intel HEX format.\nFinally, if the correct sequence is found, the   variable will contain 1 [9]. The execution continues by reading the whole POST body: The POST body is saved in RAM at   [10] and the data is read in 64-byte chunks [11] until the size defined by the \"Content-Length\" header is reached [12]. After the   is filled with the firmware, the   is checked to be 1 [13] and the firmware is passed as first parameter [15] to the function that actually writes the firmware to the internal memory [16].\nNo signature checks are performed throughout the entire operation, so an attacker can upload any arbitrary firmware image. By exploiting this bug, an attacker could follow these steps to flash a custom firmware to the device: 2018-01-16 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 30 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0511');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (105, 'Insteon Hub PubNub \"cc\" Channel Message Handler Multiple Global Overflow Code Execution Vulnerabilities', 'None', '2018-6-19', 'Multiple exploitable buffer overflow vulnerabilities exist in the PubNub message handler for the \"cc\" channel of Insteon Hub running firmware version 1012. Specially crafted commands sent through the PubNub service can cause a buffer overflow on a global section overwriting arbitrary data. An attacker should send an authenticated HTTP request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. To enable remote interaction via the Internet, Insteon Hub uses an online service called PubNub ( ).\nEnd-users install the \"Insteon for Hub\" application on their smartphone. Both the smartphone application and Insteon Hub include the PubNub SDK, which allows for a bi-directional communication using PubNub\'s REST API. The interaction with PubNub happens by means of publish/subscribe methods. Each device has a series of channels it can subscribe to, in order to receive published messages.\nTo subscribe to a specific channel it\'s enough to call the function   (defined in the PubNub SDK), passing as parameter the channel name and a callback function that will be called when a message is received on the specified channel. The device defines a function which parses messages received from PubNub on channel \"cc\":  . The function uses the   library for parsing \"JSON\" messages and receives a   object as parameter, which corresponds to the message sent from an authenticated smartphone application.\nAs an example, this is a valid JSON message which is used to set the volume on \"sonos\" speakers connected to Insteon Hub: The function initially checks the   parameter, and depending on that it proceeds to extract other expected parameters, in this case   and  . The information is then either cached to be handled on the next multitasking loop, or immediately applied from within the current function. The vulnerable code exists while parsing any JSON element, the example below follows the disassembly of the path for the \"s_sonos\" command: Looking at the pseudocode: The   parameter for   at [1] is unconstrained, and can lead to a buffer overflow on the global section in RAM. In the example above the overflow happens on the   variable which is at 0xa0001700 [2].\nThis same sequence of vulnerable instructions is present for every supported keyword in the message handler. To send a message, an HTTP GET should be used which embeds the JSON string in the \"path\" portion of the URL: Example: The following is a list of vulnerable   calls and their Proof-of-Concept.\nEach PoC shows only the payload portion of the request and uses the placeholder \"OVERFLOW\" to highlight the vulnerable parameter, which can be replaced with   to make the device crash.\nAll buffer overflows happen on a global section in RAM, defined from 0xa0000000 to 0xa001ffff, so they allow for overwriting global objects used both by custom and Microchip\'s library code.\nA key with value \"x\" means that its value is irrelevant. At 0x9d01bad0 the value for the   key is copied using   to the buffer at 0xa00016e0.\nThis buffer is 32 bytes large, sending anything longer will cause a buffer overflow. In this case the device won\'t crash right away since the overwritten global structures are not normally used.\nSome of the structures are related to TCP networking functionality. To trigger the crash it is thus enough to connect to the device on any TCP port. At 0x9d01bb1c the value for the   key is copied using   to the buffer at 0xa00016a0.\nThis buffer is 64 bytes large, sending anything longer will cause a buffer overflow. At 0x9d01c0e8 the value for the   key is copied using   to the buffer at 0xa000180c.\nThis buffer is 6 bytes large, sending anything longer will cause a buffer overflow. Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . Note:   needs to be a hex number lower than 0x100. At 0x9d01c224 the value for the   key is copied using   to the buffer at 0xa0000418.\nThis buffer is maximum 8 bytes large (this is the maximum size it could be, it is possible other global variables are stored between this variable and the next one that we could identify), sending anything longer will cause a buffer overflow. Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c254 the value for the   key is copied using   to the buffer at 0xa0000514.\nThis buffer is 4 bytes large, sending anything longer will cause a buffer overflow. Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c284 the value for the   key is copied using   to the buffer at 0xa0000510.\nThis buffer is 4 bytes large, sending anything longer will cause a buffer overflow. Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c2c8 the value for the   key is copied using   to the buffer at 0xa0001a0c.\nThis buffer is 16 bytes large, sending anything longer will cause a buffer overflow.\nThe destination can also be shifted by using an   parameter between \"0\" and \"3\". Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c318 the value for the   key is copied using   to the buffer at 0xa00017f4.\nThis buffer is 6 bytes large, sending anything longer will cause a buffer overflow.\nThe destination can also be shifted by using an   parameter between \"0\" and \"3\". Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01c368 the value for the   key is copied using   to the buffer at 0xa000170c.\nThis buffer is 25 bytes large, sending anything longer will cause a buffer overflow.\nThe destination can also be shifted by using an   parameter between \"0\" and \"3\". Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . At 0x9d01e7d4 the value for the   key is copied using   to the buffer at 0xa0001700.\nThis buffer is maximum 12 bytes large (this is the maximum size it could be, it is possible other global variables are stored between this variable and the next one that we could identify), sending anything longer will cause a buffer overflow. Note: In place of the cmd  , it\'s also possible to use  ,  ,  ,  ,  ,  . 2017-11-27 - Vendor Disclosure \n2017-11-28 - Vendor Acknowledged \n2018-01-02 - 30 day follow up with vendor for status \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline status \n2018-04-12-  Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0484');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (106, 'Insteon Hub PubNub Firmware Downgrade Vulnerability', 'None', '2018-6-19', 'An exploitable firmware downgrade vulnerability exists in Insteon Hub running firmware version 1013. The firmware upgrade functionality, triggered via PubNub, retrieves signed firmware binaries using plain HTTP requests. The device doesn\'t check the firmware version that is going to be installed and thus allows for flashing older firmware images. To trigger this vulnerability, an attacker needs to impersonate the remote server \"cache.insteon.com\" and serve any signed firmware image. Insteon Hub 2245-222 - Firmware version 1013 8.6 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N CWE-284: Improper Access Control Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. To enable remote interaction via the Internet, Insteon Hub uses an online service called PubNub ( ).\nEnd-users install the \"Insteon for Hub\" application on their smartphone. Both the smartphone application and Insteon Hub include the PubNub SDK, which allows for a bi-directional communication using PubNub\'s REST API. Using the phone application, an user can decide to force an update. In this case, the phone will first retrieve the latest firmware for a given device using an HTTP GET request: The answer contains the URL for the firmware in Intel HEX format. In this case there are 2 of them: one for the main PIC32MX MCU (\"FW\") and one for the PLM, we\'re interested in the former. The phone will then communicate with the device via PubNub, asking to perform a firmware update using the FW URL. When the device receives this message, it will fetch the firmware using a plain HTTP request to \"http://cache.insteon.com/software/insteon/hub2/prod/PROD 03 1013.hex\". The device will then perform a signature check on the firmware, and if this check passes, the firmware will be flashed without verifying that the current firmware version is lower than the one downloaded. An attacker which is able impersonate the HTTP server for \"cache.insteon.com\" (e.g. via MITM) would be able to serve any old firmware and later exploit any vulnerability available for it. Discovered by Claudio Bozzato of Cisco Talos.\nhttp://talosintelligence.com/vulnerability-reports/ An exploitable firmware update vulnerability exists in Insteon Hub running firmware version 1013. The HTTP server allows for uploading arbitrary MPFS binaries that could be modified to enable access to hidden resources which allow for uploading unsigned firmware images to the device. To trigger this vulnerability, an attacker can upload an MPFS binary via the \"/mpfsupload\" HTTP form and later on upload the firmware via a POST request to \"firmware.htm\". Insteon Hub 2245-222 - Firmware version 1013 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-489: Leftover Debug Code Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called  . Developers can use this task to handle HTTP requests but they have to implement a few functions on their own to handle for example \"GET\" and \"POST\" requests. The   task fills the global structure  , which has type  . The developer implementing GET and POST handler functions can thus access   to implement its logic.\nNote that these handlers are only reached if a valid basic-auth string is provided. Pages served by the   are located in an \"MPFS\" image (Microchip Proprietary File System) which contain both static and dynamic resources. Insteon stores the \"MPFS\" image at offset 0x40000 in one of the three SPI flashes. By default, the Microchip\'s   defines an   path that can be used to upload any arbitrary \"MPFS\" binary: It\'s easy to see that Insteon left this functionality available: The structure of an \"MPFS\" file is described in the file \"MPFS2.c\" of Microchip\'s \"Libraries for Applications\": As we can see there is no signature involved, so it\'s possible to add any new file to the MPFS Structure (note that the filename hash has to be updated too).\nThe issue with leaving the MPFS upload feature enabled is that it could be used to alter the execution of an existing MCU firmware. Indeed, in this case it is even possible to write persistent code to the device by exploiting this feature. Let\'s have a look at an interesting path in the HTTP POST handler defined by Insteon: As we can see, the requested path is present in   [1] and it\'s saved to   by calling  .\nIf the requested file is \"firmware.htm\" [2], the device will follow the path that performs a firmware update by calling  .\nNormally this file doesn\'t exist in the device, but it\'s possible to upload an \"MPFS\" image that contains it: this would effectively re-enable an unsigned firmware update functionality. At [3] the TCP buffer is checked to contain \"\\r\\n\" and at [4] every byte is discarded up to and including \"\\r\\n\".\nThe same then happens at [5] and [6], where any input is discarded up to and including \"\\r\\n\\r\\n\". Then, if data is available [7], the TCP buffer is checked to contain \":0200\" [8]. This sequence is present at the beginning of an Insteon firmware since it\'s using the Intel HEX format.\nFinally, if the correct sequence is found, the   variable will contain 1 [9]. The execution continues by reading the whole POST body: The POST body is saved in RAM at   [10] and the data is read in 64-byte chunks [11] until the size defined by the \"Content-Length\" header is reached [12]. After the   is filled with the firmware, the   is checked to be 1 [13] and the firmware is passed as first parameter [15] to the function that actually writes the firmware to the internal memory [16].\nNo signature checks are performed throughout the entire operation, so an attacker can upload any arbitrary firmware image. By exploiting this bug, an attacker could follow these steps to flash a custom firmware to the device: 2018-01-16 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 30 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0512');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (107, 'Insteon Hub PubNub \"ad\" Channel Message Handler Code Execution Vulnerability', 'None', '2018-6-19', 'An exploitable buffer overflow vulnerability exists in the PubNub message handler for the \"ad\" channel of Insteon Hub running firmware version 1012. Specially crafted commands sent through the PubNub service can cause a stack-based buffer overflow overwriting arbitrary data. An attacker should send an authenticated HTTP request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. To enable remote interaction via the Internet, Insteon Hub uses an online service called PubNub ( ).\nEnd-users install the \"Insteon for Hub\" application on their smartphone. Both the smartphone application and Insteon Hub include the PubNub SDK, which allows for a bi-directional communication using PubNub\'s REST API. The interaction with PubNub happens by means of publish/subscribe methods. Each device has a series of channels it can subscribe to, in order to receive published messages.\nTo subscribe to a specific channel it\'s enough to call the function   (defined in the PubNub SDK), passing as parameter the channel name and a callback function that will be called when a message is received on the specified channel. The device defines a function which parses messages received from PubNub on channel \"ad\":  . The function uses the   library for parsing \"JSON\" messages and receives a   object as parameter, which corresponds to the message fetched from PubNub.\nAs an example, this is a valid JSON message which is used to set the host and URL used by the device to request a firmware update: The \"ad\" channel is used specifically for managing firmware operations. The function first checks that the   parameter is defined. Then it reads the   parameter, and depending on its value it proceeds to extract other expected parameters, in this case   and  . Host and URL are then saved in a global variable for later processing. The vulnerable code exists while handling the   parameter: Looking at the pseudocode: The   parameter for   at [1] is unconstrained, and can lead to a stack-based buffer overflow. The following proof of concept shows how to overflow the buffer and overwrite   to jump to \"0x9d008d30\": this simulates a call to the   function, so that a series of packets on UDP port 30303 can be seen upon successful exploitation. To send a message, an HTTP GET should be used which embeds the JSON string in the \"path\" portion of the URL: The \"cmd\" buffer is at   while   is saved at  . The saved   already points to the parent function which has the most significant byte set to \"0x9d\", so in order to overwrite the return address with \"0x9d008d30\", this command could be used: 2017-12-05 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0496');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (108, 'Insteon Hub PubNub control Channel Message Handler Code Execution Vulnerabilities', 'None', '2018-6-19', 'Multiple exploitable buffer overflow vulnerabilities exists in the PubNub message handler for the \"control\" channel of Insteon Hub running firmware version 1012. Specially crafted replies received from the PubNub service can cause buffer overflows on a global section overwriting arbitrary data. An attacker should impersonate PubNub and answer an HTTPS GET request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. To enable remote interaction via the Internet, Insteon Hub uses an online service called PubNub ( ).\nEnd-users install the \"Insteon for Hub\" application on their smartphone. Both the smartphone application and Insteon Hub include the PubNub SDK, which allows for a bi-directional communication using PubNub\'s REST API. The interaction with PubNub happens by means of publish/subscribe methods. Each device has a series of channels it can subscribe to, in order to receive published messages.\nTo subscribe to a specific channel it\'s enough to call the function   (defined in the PubNub SDK), passing as parameter the channel name and a callback function that will be called when a message is received on the specified channel. The device defines a function which parses messages received from PubNub on channel \"control\":  . The function has a similar signature to the callbacks defined in PubNub\'s SDK.\nA peculiarity of this function is that it\'s only called after factory reset, in order to configure the device: a request is made to PubNub to retrieve channels and a key to use during normal operation, and PubNub should answer with a \"JSON\" containing these information. Example: Note that \"ak\" is an authentication key represented as 16 hex-encoded bytes, while \"112233\" corresponds to the insteon-id (lower 3 octets of the MAC address). As we can see, PubNub answers with a \"JSON\" file containing 6 elements. The function   simply has to parse this string and save it into a global object for later use. The function stores at [1] the pointer to  , which contains data used to communicate with the remote PubNub servers.\nAt [2] PubNub\'s answer is saved into   and at [3] the code ensures that the answer is not empty. The answer is then passed to   [4] and the resulting   object is saved in  . The function then retrieves every expected element from the \"JSON\" ([5], [6], [7], [8], [9], [10]) and ensures that they exist.\nEach parameter is then copied into the global   structure (which is at  ) for later use. Note this structure is bigger than 0x1000 bytes and includes not only strings and callbacks pointers, but also 3   structures that again contain several string and function pointers. This clearly makes this buffer a good target for exploitation. As we can see at [14], [15], [16], [17], [18], [19], each parameter is copied unsafely using   and this might be used by an attacker to overwrite portions of the   structure and execute arbitrary code. However, despite the fact that the   calls at [14] and [15] are unsafe, they turn out to be not exploitable, give the restriction imposed at [13]: the sum of the length of \"cc\" [11] and \"ad\" [12] must not exceed 29. This still allows for an overflow to occur but it will only overwrite a few bytes in the   structure that an attacker already normally controls. The following is a list of vulnerable   calls and their Proof-of-Concept.\nEach PoC shows only the payload portion of the request and uses the placeholder \"OVERFLOW\" to highlight the vulnerable parameter, which can be replaced with   to make the device crash.\nA key with value \"x\" means that its value is irrelevant. The   at [16] overflows the buffer  , which has a size of 16 bytes.\nAn attacker can send an arbitrarily long \"cc_r\" parameter [6] in order to exploit this vulnerability: The   at [17] overflows the buffer  , which has a size of 16 bytes.\nAn attacker can send an arbitrarily long \"ad_r\" parameter [8] in order to exploit this vulnerability: The   at [18] overflows the buffer  , which has a size of 16 bytes.\nAn attacker can send an arbitrarily long \"al\" parameter [9] in order to exploit this vulnerability: The   at [19] overflows the buffer  , which has a size of 16 bytes.\nAn attacker can send an arbitrarily long \"ak\" parameter [10] in order to exploit this vulnerability: 2017-12-05 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0502');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (109, 'Insteon Hub HTTPExecuteGet Parameters Extraction Code Execution Vulnerability', 'None', '2018-6-19', 'An exploitable stack-based buffer overflow vulnerability exists in Insteon Hub running firmware version 1012. The HTTP server implementation unsafely extracts parameters from the query string, leading to a buffer overflow on the stack. An attacker can send an HTTP GET request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 8.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called  . Developers can use this task to handle HTTP requests but they have to implement a few functions on their own. One of these is the   function, which is called when a GET request is received. The   task fills the global structure  , which has type  . The developer implementing the   function can thus access   to implement its logic.\nNote that   is only reached if a valid basic-auth string is provided. The function calls   at [1] passing a local array of pointers ([2]): this function is used for extracting GET parameters from the query string, inserting a pointer for each of them in the local array [2], which has room for 5 pointers in total. After the call, the first slot of the array is used for the HTTP path requested [3], which in Insteon\'s case is aways just a filename.\nNote that the path is saved into the   variable by calling   [4]. This means that the maximum number of GET parameters assumed is 4. The function\'s logic is very simple: As we can see, the only existing stop condition [9] is checking that the next string in   is NULL. Since there is no check on the size of the destination buffer, this bug leads to a buffer overflow on the stack when more than 4 parameters are supplied, allowing an attacker to arbitrarily overwrite the saved   and saved  -  registers in the context of the   function. The following proof of concept shows how to overflow the buffer and crash the device. 2017-12-05 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0495');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (110, 'Insteon Hub Reboot Task Denial Of Service Vulnerability', 'None', '2018-6-19', 'An exploitable denial of service vulnerability exists in Insteon Hub running firmware version 1012. Leftover demo functionality allows for arbitrarily rebooting the device without authentication. An attacker can send an UDP packet to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-489: Leftover Debug Code Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called \"RebootTask\": this is a simple demonstrative tasks that checks for incoming UDP messages on port 69 and reboots the device when any packet is received. An attacker can exploit this vulnerability by continuously sending UDP packets on port 69, keeping the device always unreachable. The following proof of concept shows how to reboot the device. 2017-11-27 - Vendor Disclosure \n2017-11-28 - Vendor Acknowledged \n2018-01-02 - 30 day follow up with vendor for status \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12-  Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-04-20 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0485');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (111, 'Insteon Hub HTTPExecuteGet Firmware Update Information Leak Vulnerability', 'None', '2018-6-19', 'An exploitable information leak vulnerability exists in Insteon Hub running firmware version 1012. The HTTP server implementation incorrectly checks the number of GET parameters supplied, leading to an arbitrarily controlled information leak on the whole device memory. An attacker can send an authenticated HTTP request to trigger this vulnerability. Insteon Hub 2245-222 - Firmware version 1012 9.6 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:H CWE-457: Use of Uninitialized Variable Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. One of the default tasks defined by Microchip\'s \"Libraries for Applications\" is called  . Developers can use this task to handle HTTP requests but they have to implement a few functions on their own. One of these is the   function, which is called when a GET request is received. The   task fills the global structure  , which has type  . The developer implementing the   function can thus access   to implement its logic.\nNote that   is only reached if a valid basic-auth string is provided. The function calls   at [1] passing a local array of pointers ([2]): this function reads the GET parameters from   and inserts a pointer to each parameter into the array of pointers. It also returns the number of extracted parameters in   ([3]).\nThe requested path is then saved to   by calling   and if the requested file doesn\'t exist in the MPFS (Microchip Proprietary File System),   will contain 0xff (  [4]). The function continues by checking a few constraints on the parameters. An interesting path exists with these conditions: After these checks, the function copies parameter 2 to the global variable at   (variable containing the update host [8]) and parameter 4 to the global variable at   (variable containing the update URL [9]).\nIf parameter 1 is either equal to \"up bin\" or \"up_PLM\", the device will later perform an HTTP GET request using the global URL and host, in order to request a firmware update. As we can see, the   at [10] is performed using parameter 4 as source, but this path needs at least 3 parameters to be reached.\nThis leads to an exploitable uninitialized variable condition, that allows an attacker to easily extract any NULL-terminated string from the device memory and have it sent to the desired host via HTTP GET. The following proof shows how to read arbitrary memory, in this example the string \"600\" will be read, which is at 0x9d061b30. After this request, the device will connect to   on port 80 to request the URL pointed by the uninitialized variable, which now points to the injected value (0x9d061b30). As we can see the string \"600\" was leaked. 2017-12-05 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 60 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0492');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (112, 'Insteon Hub PubNub Firmware Upgrade Confusion Permanent Denial Of Service Vulnerability', 'None', '2018-6-19', 'An exploitable permanent denial of service vulnerability exists in Insteon Hub running firmware version 1013. The firmware upgrade functionality, triggered via PubNub, retrieves signed firmware binaries using plain HTTP requests. The device doesn\'t check the kind of firmware image that is going to be installed and thus allows for flashing any signed firmware into any MCU. Since the device contains different and incompatible MCUs, flashing one firmware to the wrong MCU will result in a permanent brick condition. To trigger this vulnerability, an attacker needs to impersonate the remote server \"cache.insteon.com\" and serve a signed firmware image. Insteon Hub 2245-222 - Firmware version 1013 8.7 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:H CWE-284: Improper Access Control Insteon produces a series of devices aimed at controlling and monitoring a home: wall switches, led bulbs, thermostats, cameras, etc.\nOne of those is Insteon Hub, a central controller which allows an end-user to use his smartphone to connect to his own house remotely and manage any other device through it.\nThe Insteon Hub board utilizes several MCUs, the firmware in question is executed by a Microchip PIC32MX MCU, which has a MIPS32 architecture. The firmware uses Microchip\'s \"Libraries for Applications\" as core for the application code.\nIts functionality resides on a co-operative multitasking loop, which continuously executes all the existing tasks: the library already defines several tasks, e.g. for reading and sending network packets and calling the relative callbacks.\nCustom applications building on this library simply need to add new functions at the end of the loop, taking care of executing tasks as quickly as possible, or splitting them in several loop cycles, in order to let other tasks running smoothly. To enable remote interaction via the Internet, Insteon Hub uses an online service called PubNub ( ).\nEnd-users install the \"Insteon for Hub\" application on their smartphone. Both the smartphone application and Insteon Hub include the PubNub SDK, which allows for a bi-directional communication using PubNub\'s REST API. Using the phone application, an user can decide to force an update. In this case, the phone will first retrieve the latest firmware for a given device using an HTTP GET request: The answer contains the URL for the firmware in Intel HEX format. In this case there are 2 of them: one for the main PIC32MX MCU (\"FW\") and one for the \"PLM\". The phone will then communicate with the device via PubNub, asking to perform a firmware update using the FW URL. When the device receives this message, it will fetch the firmware using a plain HTTP request to \"http://cache.insteon.com/software/insteon/hub2/prod/PROD 03 1013.hex\". The device will then perform a signature check on the firmware, and if this check passes, the firmware will be flashed. There is no check on the kind of firmware (\"FW\" or \"PLM\") that is going to be flashed: both the \"FW\" and the \"PLM\" .hex files are signed with the same private key, and thus the signature check can\'t help with discerning between the two.\nNo further checks are performed on the firmware image, which is saved on an external SPI flash. So, if the \"PLM\" firmware is served in place of the \"FW\" one, the device will not notice it and it will try to flash the \"PLM\" firmware into the PIC32MX MCU.\nUpon reboot, if a firmware is ready to be flashed from the SPI, the internal flash will first be erased and then the firmware will be written. Since the addresses specified in the \"PLM\" firmware are not compatible with the PIC32MX MCU, the flashing routine will exit, leaving the main MCU in a completely erased state. An attacker which is able impersonate the HTTP server for \"cache.insteon.com\" (e.g. via MITM) would be able to serve any \"PLM\" firmware image when a \"FW\" firmware is requested, effectively bricking the device permanently. 2018-01-16 - Vendor Disclosure \n2018-01-18 - Vendor advised issues under evaluation                                                                                                                                                                                                                                                                                                                                                          2018-02-12 - 30 day follow up with vendor  \n2018-03-09 - Vendor advised working on course of action \n2018-04-06 - Follow up with vendor on fix/timeline \n2018-04-12 - Vendor advised issues addressed & plan for beta testing                                                                                                                                                                                                                                                                                                                                                                 2018-06-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0513');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (113, 'Pixar Renderman IT Display Service 0x69 Command Denial-of-Service Vulnerability', 'None', '2018-6-14', 'A denial-of-service vulnerability exists in the Pixar Renderman IT Display Service 21.6. The vulnerability is present in the parsing of a network packet without proper validation of the packet. The data read-in is not validated, and its use can lead to a null pointer dereference. The IT application is opened by a user and then listens for a connection on port 4001. An attacker can deliver an attack once the application has been opened. Renderman 21.6 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L CWE-476: Null Pointer Dereference Renderman is a rendering application used in animation and film production. It is widely used for advanced rendering and shading in many large-scale environments. The application takes a custom file format known as a RIB, parses it, and then passes it along to one of various servers. An application included with Renderman is called the \"IT Display Service\". This application accepts connections and receives a packet containing information about where to find the image for rendering. The application listens on port 4001 for connections from any host. An example of the communications is below. The first byte is parsed in a command loop, and functionality is called depending on the value. The vulnerability arises because validation is not checked after a direct socket read in the 0x69 command. The relevant code is shown below. A socket read takes place, directing the code to the 0x69 command. At this point, a standard library call is made with no validation if the string passed in is not null. This leads to offset 0x68 of a null pointer to be dereferenced, and results in a denial-of-service condition. 2018-02-07 - Vendor Disclosure \n2018-06-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0524');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (114, 'Pixar Renderman IT Display Service 0x67 Command Denial of Service Vulnerability', 'None', '2018-6-14', 'A denial-of-service vulnerability exists in the Pixar Renderman IT Display Service 21.6. The vulnerability is present in the parsing of a network packet without proper validation of the packet. The data read by the application is not validated, and its use can lead to a null pointer dereference. The IT application is opened by a user and then listens for a connection on port 4001. An attacker can deliver an attack once the application has been opened. Renderman 21.6 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L CWE-476: Null Pointer Dereference Renderman is a rendering application used in animation and film production. It is widely used for advanced rendering and shading in many large-scale environments. The application takes a custom file format known as a RIB, parses it, and then passes it along to one of various servers. An application included with Renderman is called the \"IT Display Service\". This application accepts connections and receives a packet containing information about where to find the image for rendering. The application listens on port 4001 for connections from any host. An example of the communications is below. The first byte is parsed in a command loop and functionality is called depending on the value. The vulnerability arises due to no validation after a direct socket read in the 0x67 command. The relevant code is shown below. At [1], a socket read takes place reading in controlled data. Looking at the documentation, we see that this function returns the number of bytes read or zero when there is no more data for reading. There is no check to verify any data has been read, [2]. This value is then dereferenced, [3], causing a null pointer dereference and a denial of service. 2018-02-06 - Initial Vendor Contact \n2018-02-06 - Vendor acknowledged (reports issued) \n2018-04-06 - 60 day follow up with vendor \n2018-06-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0523');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (115, 'Microsoft wimgapi LoadIntegrityInfo Code Execution Vulnerability', 'None', '2018-6-12', 'An exploitable heap corruption exists in the LoadIntegrityInfo function of wimgapi version 10.0.16299.15 (WinBuild.160101.0800).\nA crafted WIM image can lead to a heap corruption, resulting in direct code execution. WIMGAPI 10.0.16299.15 (WinBuild.160101.0800) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow This vulnerability is present in the   DLL, which is used for performing operations on Windows Imaging Forma (WIM) files. \nWIM is a file-based disk image format created by Microsoft to simplify the deployment of Windows systems.\nThere is a vulnerability in the LoadIntegrityInfo function that manifests during the parsing of the WIM file header. A specially crafted WIM file can lead to a heap corruption and remote code execution.\nThe vulnerability triggers even on the simplest operations performed on malformed WIM file because its related to file header parsing.\nIt triggers just after we try to obtain a WIM file handle via: Internally, the   will try to load part of the WIM header, which is the  . This operation is performed in the   function: All values in the   structure come from the file and are fully controlled by attacker.\nThe most important fields in the above code in our proof of concept have the following values: At line 34, we see a heap buffer allocation. Its size is based on the   field coming from   structure.\nThere is no check whether   is bigger than the   field which turns out to be crucial, because further inside  ,\nthe   value indicates how many bytes should be read from file into the buffer allocated based on the   value. This situation leads to a fully controllable heap corruption, and can be turned into remote code execution by an attacker. 2018-03-27 - Vendor Disclosure \n2018-06-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0545');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (116, 'Ocularis Recorder VMS_VA Denial of Service Vulnerability', 'None', '2018-6-5', 'An exploitable denial of service vulnerability exists in the Ocularis Recorder functionality of Ocularis 5.5.0.242. A specially crafted TCP packet can cause a process to terminate resulting in denial of service. An attacker can send a crafted TCP packet to trigger this vulnerability. Ocularis Recorder 5.5.0.242 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-250 - Execution with Unnecessary Privileges This binary listens for incoming TCP connections. When a client connects to this binary and sends any non expected data, the binary will respond with \"Hello World!\". If the server receives the dispose command it will terminate the VMS_VA process. The binary has a check to see if the receiving data starts with \"dispose\". If it does the \"this.Running\" variable will be set to false which results in the process killing itself. There is no authentication required for this command to go through. N/A This vulnerability can be mitigated by not allowing VMS_VA.exe from accepting inbound connections. It is unclear if this will have any adverse affect on the Ocularis Recorder module as the product documentation explicitly states to allow inbound traffic to this binary. 2018-03-05 - Vendor Disclosure \n2018-06-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0535');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (117, 'Natus Xltek EEG NeuroWorks ItemList Deserialization Denial-of-Service Vulnerability', 'None', '2018-5-31', 'An exploitable denial-of-service vulnerability exists in the unserialization of lists functionality of Natus Xltek NeuroWorks 8. A specially crafted network packet can cause an out-of-bounds read, resulting in a denial of service. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-125 - Out-of-bounds Read Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. Upon reception of data, NWStorage attempts to unserialize the data passed to it. NWStorage recognizes a variety of data types, two of which are a string and itemlist. The serialized format for the string type is shown below: The serialized format for the itemlist type is similar and shown below: The process of unserializing the items in the list can be summarized in the following pseudocode: NWStorage honors the number of elements specified in the itemlist header and proceeds to attempt to unserialize that many items. The next item to be unserialized is determined by the length specified in that item\'s header. The unserialization of a generic item is shown below: By providing an invalid length on an item, NWStorage will attempt to add a wrong number of bytes to the current serialized buffer. If this new location is out of bounds, the comparison at   will crash the service, resulting in a denial of service. 2017-07-15 - Vendor Disclosure \n2017-10-06 - Vendor Acknowledged \n2018-05-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0354');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (118, 'Natus Xltek EEG NeuroWorks ItemList Traversal Denial-of-Service Vulnerability', 'None', '2018-5-31', 'An exploitable denial-of-service vulnerability exists in the traversal of lists functionality of Natus Xltek NeuroWorks 8. A specially crafted network packet can cause an out-of-bounds read, resulting in a denial of service. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-125 - Out-of-bounds Read Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. Modules used in this advisory are below: Upon reception of data, NWStorage attempts to unserialize the data passed to it. NWStorage recognizes a variety of data types, one of which is the itemlist. The serialized format for the itemlist type is similar, and shown below: When traversing a list, the following idiom is used to retrieve elements of the list: The   function is shown below: The   function is shown below: An example of an empty itemlist after unserialization is shown below:  can return a NULL value. This value can then be passed to  , which attempts to dereference the   offset. This will cause an access violation resulting in a denial of service in the NWStorage service. 2017-07-15 - Vendor Disclosure \n2017-10-06 - Vendor Acknowledged \n2018-05-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0362');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (119, 'Natus Xltek EEG NeuroWorks Invalid KeyTree Entry Denial-of-Service Vulnerability', 'None', '2018-5-31', 'An exploitable denial-of-service vulnerability exists in the lookup entry functionality of KeyTrees in Natus Xltek NeuroWorks 8. A specially crafted network packet can cause an out-of-bounds read, resulting in a denial of service. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-125 - Out-of-bounds Read Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. The module used in this advisory is shown below: One of the key data structures in Neuroworks is the KeyTree. Internally, a KeyTree is a list of lists. The list and KeyTree structs are shown below: Python pseudocode for this construct for a valid KeyTree is shown below: Above, we see a KeyTree with a key of   with value of 0x1234, as well as a key of   with a value of   (which would be defined elsewhere). The key feature here is that the KeyTree assumes that each of its elements is an  . One component of the traversal of the the KeyTree is shown below: This snippet shows the beginning of the retrieval of the value in the first element of the first itemlist in a KeyTree. This code assumes that the first element of a KeyTree is an itemlist. If the first element of the KeyTree is a string data structure, for instance, the dereference at   doesn\'t necessarily point to a valid memory address. Passing an invalid address to the function at   will cause a crash of Neuroworks, resulting in a denial-of-service condition. For example with pseudocode, replacing the valid pseudocode above, will trigger this vulnerability. 2017-07-15 - Vendor Disclosure \n2017-10-06 - Vendor Acknowledged \n2018-05-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0364');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (120, 'Adobe Acrobat Reader DC ANFancyAlertImpl Remote Code Execution Vulnerability', 'None', '2018-5-15', 'A specific Javascript script embedded in a PDF file can lead to a pointer to previously freed object to be reused when opening a PDF document in Adobe Acrobat Reader DC 2018.009.20044. With careful memory manipulation, this can potentially lead to sensitive memory disclosure or arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.009.20044 6.8 - CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H CWE-908: Use of Uninitialized Resource Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. The method calls required to trigger this vulnerability are privileged and can only be called from trusted functions. Adobe Acrobat Reader DC supports embedded Javascript scripts in the PDF to allow for interactive PDF forms This give the potential attacker the ability to precisely control memory layout and poses additional attack surface. While executing a following piece of javascript code a specific condition leading to memory corruption can occur (it should be noted that all three of these lines require higher privileges, meaning they must be executed in a trusted PDF file): Upon calling   a memory object will be allocated. The pointer to this object is later passed to other functions without it being initialized. This leads to undefined behaviour that depends on the previous contents of the same memory region, leading to memory corruption and ultimately to arbitrary code execution. Two pointers from the object end up being used as second two arguments in a   call which can easily be abused to cause a heap-based buffer overflow: Stepping back a couple of function calls reveals where the   arguments come from: In the above debugging log, we break at   to reveal   being passed as argument to the function call points to a newly allocated and uninitialized buffer. With page heap enabled, the contents of the allocated memory will be filled with  . The code and memory layout after corruption just happen to line up in such a way to allow for easy   control by simply adjusting the size and contents of environment variables: Crash output with PageHeap enabled: 2018-01-23 - Vendor Disclosure \n2018-05-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0518');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (121, 'Adobe Acrobat Reader DC Net.Discovery.queryServices Remote Code Execution Vulnerability', 'None', '2018-5-15', 'A specific Javascript script embedded in a PDF file can lead to a pointer to previously freed object to be reused when opening a PDF document in Adobe Acrobat Reader DC 2018.009.20044. With careful memory manipulation, this can potentially lead to sensitive memory disclosure or arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.009.20044 7.1 - CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability.\nAdobe Acrobat Reader DC supports embedded Javascript scripts in the PDF to allow for interactive PDF forms. This give the potential attacker the ability to precisely control memory layout and poses additional attack surface.\nWhen executing a following piece of Javascript in a suitable PDF document, a Use-After-Free condition can be triggered: With page heap enabled, this leads to a crash: The memory pointed to by   is freed an invalid, leading to a crash.\nThe method   requires privileges, and by default it would be blocked by security permissions. But if the source of the document is trusted, it will execute without problems and lead to a crash. In order to trigger a crash, the first argument needs to be an invalid service name. An empty string suffices. If we track back the allocations, we can see that pointer in   is actually used as   in previous function calls. The pointer in   actually comes from an array of size 0x30 allocated at  : Setting a write access breakpoint on the dword where the final dereferenced pointer is stored reveals where it comes from: This 0x1c chunk of memory is subsequently freed but is later reused resulting in a crash: With page heap disabled, this stale pointer dereference will usually succeed and result in further memory corruption. With proper memory layout manipulation, it could be abused to achieve arbitrary code execution. Do note that in order for the PoC to trigger this memory corruption, the PoC file needs to be added to trusted locations list in “Security(Enhanced)” in preferences. 2018-01-23 - Vendor Disclosure \n2018-05-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0517');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (122, 'Multi-Master Replication Manager for MySQL mmm_agentd Remote Command Injection Vulnerabilities', 'None', '2018-5-7', 'Multiple exploitable remote command injection vulnerabilities exist\nin the MySQL Master-Master Replication Manager (MMM) mmm_agentd\ndaemon 2.2.1. mmm_agentd commonly runs with root privileges and does not\nrequire authentication by default.  A specially crafted MMM protocol\nmessage can cause a shell command injection resulting in arbitrary\ncommand execution with the privileges of the mmm_agentd process.  An\nattacker that can initiate a TCP session with mmm_agentd can trigger\nthese vulnerabilities. MMM 2.2.1 http://mysql-mmm.org/ 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-77: Improper Neutralization of Special Elements used in a Command (\'Command Injection\') MMM, the Multi-Master Replication Manager for MySQL, provides high\navailability to MySQL database clusters.  Though superseded by more\nmodern approaches, MMM was commonly used in high availability MySQL\nenvironments up through MySQL version 5.5.  In an MMM environment,\neach MySQL server host runs the mmm_agentd agent.  In its default\nconfiguration, mmm_agentd does not require authentication and\ntypically runs as root because it requires sufficient privileges to\nreconfigure network interfaces. mmm_agentd contains multiple remotely exploitable command injection\nvulnerabilities.  Therefore, in many MMM environments, if an\nunauthenticated network attacker can make a TCP connection to the\nmmm_agentd process, they can run arbitrary commands as root.  This\nvulnerability occurs because mmm_agentd includes attacker-supplied\ninput in shell commands in multiple locations without appropriate\nsanitization. For example, the MMM   protocol message can be used to\nassign a number of roles to an mmm_agentd host.  Roles are specified\nas a comma-separated list of   pairs\n(e.g.  ).\n  in   uses the\nfollowing regular expression to parse the role name and IP address:\n .  Thus, everything before the last opening\nparenthesis will interpreted as the role name and all remaining\ncharacters up to the last closing parenthesis will be interpreted as\nthe role IP address.  An attacker can construct malicious IP address\nvalues that will cause subsequent role handling code to invoke\narbitrary commands.  For example: Malicious IP address values are subject to interpretation by the shell\nboth in mmm_agentd and in helper applications called by mmm_agentd. Role IP address values should be validated to ensure that only\nexpected values are specified.  However, because other data flows may\nallow malicious input to reach vulnerable functions, all dynamic\nvalues incorporated into shell commands should be sanitized to ensure\nthat shell metacharacters do not introduce additional arguments or\nexecute unintended commands. Limitations: The   function accepts a command and\nan string containing arguments for the command.  It constructs a\nBourne shell command line by concatenating the path to the requested\ncommand, the mmm_agentd config file, and the specified arguments.\n  runs the resulting command using the the Perl backtick\noperator as follows. Because   does not sanitize  , any shell\nmetacharacters present in   will be interpreted by the shell. There are several code paths that can cause   to be called\nwith untrusted input in the   variable.  To handle roles that\nhave been added and removed, mmm_agentd will invoke\n  for each added role and\n  for each deleted role with\n  set to the IP address value specified for the role.  Both,\nfunctions pass   to   without sanitization. As noted above role IP addresses can contain arbitrary content, modulo\na few character restrictions, allowing an attacker to execute\narbitrary shell commands. Additionally, the   and   MMM\nprotocol messages can be used to invoke\n  on the IP address value of\neach role.    also passes the untrusted   value to\n  without further sanitization. Because input may be derived from a variety of (potentially untrusted)\nsources,   should be modified to take an array of discrete\ncommand arguments and to either avoid shell interpretation by using\nexecv-like functionality or quote command arguments to prevent shell\ninterpretation. As seen above, in order to configure a new IP address mmm_agentd\ninvokes: To add the IP address to the specified interface, the  \nhelper command invokes  .\nWhich runs the following command on Linux hosts: As a result, a malicious role IP address value that has been quoted to\nprevent interpretation in   will\narrive to   in unquoted form allowing the execution of\narbitrary commands. As seen above, in order to configure a new IP address mmm_agentd\ninvokes: To add the IP address to the specified interface, the  \nhelper command invokes  .\nWhich runs the following command on Solaris hosts: As a result, a malicious role IP address value that has been quoted to\nprevent interpretation in   will\narrive to   in unquoted form allowing the execution of\narbitrary commands. As seen above, in order to configure a new IP address mmm_agentd\ninvokes: To add the IP address to the specified interface, the  \nhelper command invokes  .\nWhich runs the following command on FreeBSD hosts: As a result, a malicious role IP address value that has been quoted to\nprevent interpretation in   will\narrive to   in unquoted form allowing the execution of\narbitrary commands. As seen above, to remove a deleted role\'s IP address, mmm_agentd\ninvokes: To remove the IP address from the specified interface, the  \nhelper command invokes  .\nWhich runs the following command on Linux hosts: As a result, a malicious role IP address value that has been quoted to\nprevent interpretation in   will\narrive to   in unquoted form allowing the execution of\narbitrary commands. As seen above, to remove a deleted role\'s IP address, mmm_agentd\ninvokes: To remove the IP address from the specified interface, the  \nhelper command invokes  .\nWhich runs the following command on Solaris hosts: As a result, a malicious role IP address value that has been quoted to\nprevent interpretation in   will\narrive to   in unquoted form allowing the execution of\narbitrary commands. As seen above, to remove a deleted role\'s IP address, mmm_agentd\ninvokes: To remove the IP address from the specified interface, the  \nhelper command invokes  .\nWhich runs the following command on FreeBSD hosts: As a result, a malicious role IP address value that has been quoted to\nprevent interpretation in   will\narrive to   in unquoted form allowing the execution of\narbitrary commands. After a new IP address has been configured successfully, the\nimplementation of the   helper command will send\ngratuitous ARPs:  does not sanitize the value of   before interpolating\nit into shell commands on Solaris systems.  While dangerous, this\nparticular instance may not be currently exploitable because\n  is only called if   succeeds and   will\nreturn with failure if  \ncannot verify that the IP address configuration attempt succeeded.\n  currently attempts to match the the full text of the role\nIP address against the value obtained from the operating system.\nThus, additional non-IP address characters in   will cause\n  to return false: Nevertheless,   should be fixed to sanitize its shell\ncommand arguments as well, because this behavior may change in\nsubsequent releases. The impact of these vulnerabilities can be lessened by configuring\nmmm_agentd to require TLS mutual authentication and by using network\nACLs to prevent hosts other than legitimate mmm_mond hosts from\naccessing mmm_agentd. To enable TLS mutual authentication follow the steps below (examples\nprovided using gnutls certtool): 2017-12-07 - Initial vendor contact \n2018-01-11 - 2nd vendor contact \n2018-03-06 - 3rd vendor contact (90 day notice) \n2018-04-17 - Vendor acknowledged \n2018-05-04 - Vendor confirmed patch \n2018-05-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0501');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (123, 'Hyland Perceptive Document Filters DOC to HTML updateNumbering Code Execution Vulnerability', 'None', '2018-4-26', 'An exploitable stack-based buffer overflow exists in the DOC-to-HTML conversion functionality of the Hyland Perceptive Document Filters version 11.4.0.2647. A crafted .doc document can lead to a stack-based buffer, resulting in direct code execution. Perceptive Document Filters 11.4.0.2647 - x86/x64 Windows/Linux\nPerceptive Document Filters 11.2.0.1732 - x86/x64 Windows/Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow This vulnerability is present in the Hyland Document filter conversion, which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services. \nIt can convert common formats, such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a .doc document to HTML. A specially crafted .doc file can lead to a stack-based buffer overflow and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious DOC using the Hyland library, we see the following state: As we can see, stack data has been completely overwritten by value   inside the   function.\nShowing this function in pseudo-code, it looks like this: The values of significant arguments are equal: With the arguments having the above mentioned values, we pass both checks at lines   and   and later assign a pointer to the first element of the   table to the   variable.\nInside the loop at   just after the first iteration, the   pointer will be set to an address before the beginning of  , causing an out-of-bounds write at  , and will result in corruption of stack values. The loop for the following parameters will be executed 255 times. The vulnerability exists because the check at   is not sufficient, and does not consider values under zero other than -1.\nThe vulnerability would not occur if the check at   would be done for  . Tracking where the value of   was set we land in the following place : So   value of   (according of some getter function name it is exactly  ) is a default value set inside the \"Text Paragraph Properties\" constructor.\nFurther investigation showed that this default value is only overwritten if a particular paragraph has corresponding   (Paragraph Property Exceptions) record, which contains   (Property Modifier)\nhaving a value of  . That   according to the   format specification is  .\nAlso, looking at the call stack before the corruption: We can deduce that the paragraph is inside a shape object, and that is one of the crucial requirements to trigger the vulnerability. An attacker who provides a malicious .doc document for conversion to HTML could trigger this vulnerability, and potentially gain code execution on the system. 2018-03-16 - Vendor Disclosure \n2018-03-22 - Vendor patched \n2018-04-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0538');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (124, 'Hyland Perceptive Document Filters OpenDocument to JPEG conversion SkCanvas Code Execution vulnerability', 'None', '2018-4-26', 'An exploitable double free exists in the OpenDocument to JPEG conversion functionality of the Hyland Perspective Document Filters version 11.4.0.2647.\nA crafted OpenDocument document can lead to a SkCanvas object double free resulting in direct code execution. Perceptive Document Filters 11.4.0.2647 - x86/x64 Windows/Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-415: Double Free It can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of an OpenDocument document to JPEG. A specially crafted OpenDocument file can lead to a SkCanvas object double free and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious OpenDocument using the Hyland library we see the following state: Showing more context We see an obvious attempt of a virtual function call on a previously freed object. Further examination confirms our assumptions: Checking the Linux version we can obtain a bit more information from partial-symbols : Tracking this object’s life cycle we can see its creation inside   method: Further inside the   function we can observe a call at address   to   virtual destructor which deallocates the vulnerable object: Next, during destruction of   object a call to   virtual destructor is made again: resulting in the double free of   object.\nAn attacker who properly manipulates the heap state between the object\'s first deallocation and its second deallocation can easily turn this double free vulnerability into arbitrary code execution. 2018-02-22 - Vendor Disclosure \n2018-03-22 - Vendor patched \n2018-04-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0528');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (125, 'Hyland Perceptive Document Filters DOCX to HTML Code Execution Vulnerability', 'None', '2018-4-26', 'An exploitable use after free exists in the DOCX to HTML conversion functionality of the Hyland Perspective Document Filters version 11.4.0.2647.\nA crafted DOCX document can lead to a use-after-free resulting in direct code execution. Perceptive Document Filters 11.4.0.2647 - x86/x64 Windows/Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free This vulnerability is present in the Hyland Document filter conversion which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a DOCX document to HTML. A specially crafted DOCX file can lead to a use-after-free and remote code execution.\nLet’s investigate this vulnerability. After we attempt to convert a malicious DOCX using the Hyland library we see the following state: Showing more context We see an obvious attempt of a virtual function call on a previously freed object. Further examination confirms our assumptions: Checking the Linux version we can obtain a bit more information from partial-symbols : Tracking this object’s life cycle we can see its creation inside   method: Further during   object destruction\ninside the   function we can observe a call at address   which deallocates the vulnerable object: Next, few instruction below at   a call to   method is made: which internally as we could see on the   listing calls   causing in the same way re-usage of the freed stream object.\nAn attacker who properly manipulates the heap state between object deallocation and its re-usage can easily turn this use after free vulnerability into arbitrary code execution. 2018-02-22 - Vendor Disclosure \n2018-03-22-  Vendor patched \n2018-04-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0527');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (126, 'Hyland Perceptive Document Filters Microsoft Word CDATA Code Execution Vulnerability', 'None', '2018-4-26', 'An exploitable heap corruption exists in the Microsoft Word to many types conversion functionality of the Hyland Perspective Document Filters version 11.4.0.2647.\nA crafted Microsoft Word (XML) document can lead to heap corruption resulting in remote code execution. An attacker can provide a specially crafted file to trigger this vulnerability. Perceptive Document Filters 11.4.0.2647 - x86/x64 Windows/Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write This vulnerability is present in the Hyland Document filter conversion which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services. \nIt can convert common formats such as Microsoft\'s document formats into more usable and easily viewed formats.\nThere is a vulnerability in the conversion process of a Microsoft Word (XML) to JPEG, HTML5 and several other formats. A specially crafted Microsoft Word (XML) file can lead to heap corruption and remote code execution.\nLet’s investigate this vulnerability: After we attempt to convert a malicious Microsoft Word (xml) using the Hyland library we see the following state: As we can see, an out of bounds write appeared during a   operation causing access violation. Stepping back we see that the   function was called with the following parameters: So the   parameter is set to 0xffffffff (   ) which explains why the   operation ended up with an access violation. Why does the  \nparameter have that value? Tracking code execution back, we end up in the place where it is calculated: The     parameter value is calculated at   which is an argument for the   function call.\nGenerally speaking, this fragment of code is responsible for finding the   section in an XML document and measuring the text length that this section contains.\nIn our example the   section does not contain any text, so the calculations made at   where: will end up with a value equal  .\nLater, as we saw above, so huge unsigned value is used in the   operation leads to heap corruption and which an attacker could potentially leverage to gain remote code execution. 2018-02-27 - Vendor Disclosure \n2018-03-22 - Vendor patched \n2018-04-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0534');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (127, 'Foxit PDF Reader JavaScript createTemplate Remote Code Execution Vulnerability', 'None', '2018-4-19', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software Foxit PDF Reader version 9.0.1.1049. A specially crafted PDF document can trigger a previously freed object in memory to be reused resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit PDF Reader 9.0.1.1049. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature rich PDF reader it supports JavaScript for interactive documents and dynamic forms. JavaScript support posses an additional attack surface. Additionally, Foxit PDF Reader supports XFA or XML Forms Architecture which is a new way of making interactive PDF forms. Closing the currently active PDF document via JavaScript   call results in a clean-up of a lot of object. A stale reference to an already freed object can result in a use-after-free condition. If a document tries to create a template, but fails, an object is allocated and freed, but a stale reference to it is kept. When closing the document, this reference is reused, which can lead to memory corruption. This particular vulnerability lies in combinations of   and   methods which trigger a use after free:   app.alert(\"alloc and free follow\");\n  this.createTemplate(\"temp\");\n  app.alert(\"uaf follows\");\n  this.closeDoc(1); Opening the proof of concept PDF document in Foxit Reader with PageHeap enabled results in the following crash (note that Foxit Reader will pop up a warning that the file is damaged, due to malformed XFA objects, which is of no consequence to triggering the vulnerability): Analyzing the heap state clearly shows that   points into a freed memory region. If we examine the life of the object more closely, by setting breakpoints before and after calls to   and   we can observe the following: Above shows the object was allocated before a call   and is being freed during this call. This limits the window of opportunity that a potential attacker has to manipulate the memory and change the contents of the freed heap chunk, but it is\nstill possible that careful manipulation of the document layout could lead to greater control. At the time of the crash, pointer pointing to already freed memory is used as   pointer, if contents of this memory are under control, a vtable dereference could result in control flow hijacking and ultimately in arbitrary code execution. 2018-03-05 - Vendor Disclosure \n2018-04-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0536');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (128, 'Foxit PDF Reader JavaScript XFA Clone Remote Code Execution Vulnerability', 'None', '2018-4-19', 'An exploitable use-after-free vulnerability exists in the JavaScript engine Foxit Software Foxit PDF Reader version 9.0.1.1049. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If a browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit PDF Reader 9.0.1.1049. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support posses an additional attack surface. Additionally, Foxit PDF Reader supports XFA or XML Forms Architecture, which is a new way of making interactive PDF forms. If a document containing XFA forms executes JavaScript code that closes the active document, a specific XFA method is invoked, which keeps a stale reference to a now freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in   method, which triggers a use-after-free condition when the following code is executed in a regular PDF document: Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash (note that Foxit Reader will pop up a warning that the file is damaged due to malformed XFA objects, which is of no consequence to triggering the vulnerability): Analyzing the heap state clearly shows that   points to a freed memory region. If we examine the next few instructions we can see the following: We can see that there is a   instruction immediately after the dereference of  , which we know to be free. With proper memory layout control, a memory chunk pointed to by   can be reallocated before it is reused, which gives full control over its content, and can ultimately result in EIP control and arbitrary code execution. 2018-02-26 - Vendor Disclosure  \n2018-04-01 - Vendor pushed release to mid April  \n2018-04-19 - Vendor patch released  \n2018-04-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0532');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (129, 'Foxit PDF Reader JavaScript setPersistent Remote Code Execution Vulnerability', 'None', '2018-4-19', 'An exploitable use of an uninitialized pointer vulnerability exists in the JavaScript engine in Foxit PDF Reader version 9.0.1.1049. A specially crafted PDF document can lead to a dereference of an uninitialized pointer which, if under attacker control, can result in arbitrary code execution. An attacker needs to trick the user to open a malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 9.0.1.1049 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-457: Use of Uninitialized Variable Foxit PDF Reader is one of the most popular PDF document readers and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support posses an additional attack surface. Additionally, Foxit PDF Reader supports XFA or XML Forms Architecture which is a new way of making interactive PDF forms. When processing a specially crafted PDF document that contains XFA forms, executing the following JavaScript code leads to a dereference of an uninitialized pointer: This results in the following crash: Note that   is a PageHeap magic value for allocated but uninitialized memory.\nTracking back to see where this pointer in   comes from reveals the following: In the above output, we can see that at   a call is being made to a simple dereferencing function, which grabs a pointer from   and puts it into  . As we can see from the memory output, this pointer is uninitialized. The object pointed to by   is actually allocated: Further on, the pointer from   ends up in   and ends up being used as   pointer in a   function call: Finally, the crash will happen when the uninitialized   value is used to dereference a vtable in the function  : .text:00C095F3 mov     eax, [ebp+arg C6BE10\n.text:00C095FC push    esi\n.text:00C095FD mov     edi, eax\n.text:00C095FF call    sub The crash actually occurs in the sub_C6BE10 call, comprised of just two instructions, that perform an object table dereference: The target of double dereference above ends up in  . If we follow this value through registers, it ends up being saved in  , which is later dereferenced again into   and is used as the destination of an indirect call: Following this, we can conclude that if, with careful memory layout manipulation, an attacker can control the contents of memory that gets used uninitialized it will eventually lead to control of the contents of   at the above call instruction leading to arbitrary code execution. 2018-02-12 - Vendor Disclosure  \n2018-02-14 - Discussion with vendor on issues  \n2018-04-01 - Vendor pushed release to mid April  \n2018-04-19 - Vendor patch released  \n2018-04-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0525');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (130, 'Foxit PDF Reader AssociatedFile Annotation Type Confusion', 'None', '2018-4-19', 'An exploitable type confusion vulnerability exists in the way Foxit PDF Reader version 9.0.1.1049 parses files with associated file annotations. A specially crafted PDF document can lead to an object of invalid type to be dereferenced, which can potentially lead to sensitive memory disclosure, and possibly to arbitrary code execution. An attacker needs to trick the user into opening the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit PDF Reader 9.0.1.1049 6.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N CWE-843 - Access of Resource Using Incompatible Type Foxit PDF Reader is one of the most popular PDF document readers and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. While initially parsing a specially crafted PDF file with a malformed associated file PDF object, the use of a memory object of an incompatible type can be triggered, which initially leads to out-of-bounds memory access.\nA shortened version of PDF file that triggers this bug is as follows: In the above PDF, the   dictionary in   refers to object   which is expected to be of type  . A stray   string makes the object malformed leading to the following crash while parsing: The process crashes due to an out-of-bounds access of  . Examining the memory pointed to by   reveals the following: We can see that an access violation happens because   points four bytes after the end of a buffer of size 0x18. If we examine the function where the crash occurs, we can see the following: Since this function is of type  , at [1] we see a pointer to   being saved into  . So, at the time of the crash at [2],   is used as  . Since the allocated object is smaller, the out-of-bounds access leads to a crash if PageHeap is enabled. Without PageHeap, and if the adjacent memory is carefully manipulated, the invalid read will succeed, leading to further memory corruption. With careful memory layout manipulation and object placement, it could be possible to abuse this to leak arbitrary memory content or write to arbitrary memory. 2018-02-12 - Vendor Disclosure  \n2018-04-01 - Vendor pushed release to mid April  \n2018-04-19 - Vendor patch released  \n2018-04-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0526');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (131, 'SAP BPC Web Application Information Disclosure Vulnerability', 'None', '2018-4-19', 'An exploitable XML external entity vulnerability exists in the reporting functionality of SAP BPC. A specially crafted XML request can cause an XML external entity to be referenced, resulting in information disclosure and potential denial of service. An attacker can issue authenticated HTTP requests to trigger this vulnerability. SAP BPC 6.4 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:L CWE-611 - Improper Restriction of XML External Entity Reference It was identified that the web application was vulnerable to an XML External Entity injection attack. While making malformed requests to most parts of the application appeared to produce error messages that indicated that XML validation was occurring, one location was identified where this was not the case: In this instance, two different responses were seen, which appeared to vary depending on whether the XXE entity was defined as a valid (as in this case) or invalid local file. In the event that an invalid file was referenced, an error was instead returned. The vulnerability could also be used to trigger a CPU or memory exhaustion attack through recursively defined XML entities.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/SAP');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (132, 'Foxit PDF Reader Javascript Search Query Remote Code Execution Vulnerability', 'None', '2018-4-19', 'An exploitable use-after-free vulnerability exists in the JavaScript engine of Foxit Software\'s Foxit PDF Reader version 8.3.2.25013. A specially crafted PDF document can trigger a previously freed object in memory to be reused, resulting in arbitrary code execution. An attacker needs to trick the user to open the malicious file to trigger this vulnerability. If the browser plugin extension is enabled, visiting a malicious site can also trigger the vulnerability. Foxit Software Foxit PDF Reader 8.3.2.25013. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Foxit PDF Reader is one of the most popular PDF document readers, and has a widespread user base. It aims to have feature parity with Adobe’s Acrobat Reader. As a complete and feature-rich PDF reader, it supports JavaScript for interactive documents and dynamic forms. JavaScript support poses an additional attack surface. When executing embedded JavaScript code, a document can be closed, which essentially frees a lot of used objects, but the JavaScript can continue to execute. Invoking a method which keeps a stale reference to a now-freed object can lead to a use-after-free condition, which can be abused to execute arbitrary code. This particular vulnerability lies in   method, which triggers a use-after-free condition when the following code is executed in a regular PDF document: Opening this proof-of-concept PDF document in Foxit Reader with PageHeap enabled results in the following crash: Analyzing the heap state clearly shows that   points into a freed memory region. If we examine the next few instructions we can see the following: We can observe from the above listing that twice-dereferenced address from  , through   ends up in   which is then used as argument to   instruction. This makes this vulnerability easy to exploit, since we can control the contents of  . With a bit of memory layout control, and with PageHeap off, we can get full EIP control: Closing the document via JavaScript frees objects, but JavaScript continues to execute, and some stale references can cause a use after free, which is what happens in this case. Since the memory pointed at by   is freed, a careful heap manipulation can put it under attacker control, indirectly giving the control over  , leading to arbitrary code execution. 2017-12-12 - Vendor Disclosure  \n2017-12-12 - Discussion with vendor on issues  \n2018-01-29 - Vendor advised issue fixed in code scheduled for next release early April  \n2018-04-01 - Vendor pushed release to mid April  \n2018-04-19 - Vendor patch released  \n2018-04-19 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0506');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (133, 'Foscam IP Video Camera Firmware Recovery Unsigned Image Vulnerability', 'None', '2018-4-17', 'Insufficient security checks exist in the recovery procedure used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. An attacker who is in the same subnetwork of the camera or has remote administrator access, can fully compromise the device by performing a firmware recovery using a custom image. Foscam Indoor IP Camera C1 Series 9.6 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-287: Improper Authentication Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. In case the flash contents of the device get corrupted, making it impossible to perform a clean boot of the system, the C1 camera offers two ways to recover without the need of physical access: The SD-Card method requires an administrator access on the web interface to upload files via FTP. On the other hand, the TFTP server method only requires the TFTP server to be in the same subnetwork of the device, without the need of any privilege. We analyze the TFTP recovery procedure since it\'s the most interesting from an attack perspective: the relevant function has been renamed to  . At [1] the recovery image filename is set to \"recover_image.bin\" and at [2] the load address of the image is set to \"0x82000000\". At [3] the recovery file is retrieved from the TFTP server and loaded into its load address. After that, the function   is called to decrypt the image [4]. The function   takes the image data and its size as first and second parameter, and XORs every couple of bytes starting from the end of the image. At this point, the image is decrypted and has the following form (assuming only one chunk exists): Back to the   function, the first bytes of the decrypted image are checked to be   [5], and the platform string is checked to be   [6]. The function then enters a loop that is executed for every chunk defined in the image [7]. For every chunk, a checksum is verified to ensure the integrity of the image, by calling the function   [8]. If the checksum matches, the chunk is flashed [9].  receives as arguments the pointer to the chunk data, the chunk\'s length and the expected checksum. The MD5 of the chunk is calculated [10] and the resulting digest is concatenated with the string \"#foscam&*234\" [11]. On this resulting string, another MD5 is calculated [12]. Finally the function returns the result of the comparison [13] between the calculated checksum and the expected one. Using an abstract notation this translates to: Given that no signatures are applied to the recovery procedure, anyone aware of the encryption and hashing scheme will be able to create a custom image and flash it. We show two ways to exploit this bug over the network. An attacker needs to setup a TFTP server to provide a recovery image to the device.\nThe TFTP server address expected by the device is fixed and can be discovered by looking at ARP requests originating from the MAC address 00:00:23:34:45:66. Upon reboot the device will look for a TFTP server, load the recovery image, decrypt it and perform integrity checks. If all checks are passed, the new image is flashed and booted. Alternatively, a recovery can be performed using the SD-Card, but requires administrator privileges. First, the FTP server needs to be started: A custom recovery image can then be sent via FTP: Upon reboot the device will load the recovery image, decrypt it and perform integrity checks. If all checks are passed, the new image is flashed and booted. 2017-07-13 - Vendor Disclosure \n2017-08-08 - Discussion with vendor regarding issues reported \n2017-10-29 - Vendor provided Feb 2018 as planned date for fix \n2018-02-09 - Patch date pushed to March 2018 per vendor \n2018-03-14 - Vendor patched \n2018-04-17 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0378');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (134, 'Moxa EDR-810 Web Server Cross-Site Request Forgery Vulnerability', 'None', '2018-4-13', 'An exploitable cross-site request forgery vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP packet can cause cross-site request forgery. An attacker can create malicious HTML to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317  8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-352 - Cross-Site Request Forgery (CSRF) In order to trigger the CSRF a logged in user needs to visit a page with malicious code on it. The malicious code will be able to do anything the logged in user can do. For example the malicious code could add a user, modify firewall rules, etc. This could also be chained with a command injection to get a root shell on the device. This problem is compounded by the fact that users cannot log out of the device, meaning that a user\'s session will remain valid long after they\'ve stopped interacting with the device. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0478');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (135, 'Moxa EDR-810 Web Server Certificate Signing Request Command Injection Vulnerability', 'None', '2018-4-13', 'An exploitable command injection vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP POST can cause a privilege escalation resulting in root shell. An attacker can inject OS commands into the CN= parm in the \"/goform/net_WebCSRGen\" uri to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78 -  Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Once logged in to the device\'s web interface, a user can generate a X.509 CSR for the VPN via a POST to \"/goform/net_WebCSRGen\". One of the parameters that gets sent with this post request is the CN parameter. An attacker can inject OS commands to get a root shell. Vulnerable URI: /goform/net_WebCSRGen\nVulnerable Parameter: CN= The following POST will start a root shell on port 5000. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0477');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (136, 'Moxa EDR-810 Cleartext Transmission of Password Vulnerability', 'None', '2018-4-13', 'An exploitable clear text transmission of password vulnerability exists in the web server and telnet functionality of Moxa EDR-810 V4.1 build 17030317. An attacker can look at network traffic to get the admin password for the device. The attacker can then use the credentials to login as admin. Moxa EDR-810 V4.1 build 17030317 5.7 - CVSS:3.0/AV:A/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N CWE 317 - Cleartext Transmission of Sensitive Information By default the device uses HTTP instead of HTTPS. Passwords are sent in clear text. An attacker can monitor network traffic for a password. The following POST is sent with plain text credentials. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0475');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (137, 'Moxa EDR-810 Web Server ping Command Injection Vulnerability', 'None', '2018-4-13', 'An exploitable command injection vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP POST can cause a privilege escalation, resulting in a root shell. An attacker can inject OS commands into the ip= parm in the \"/goform/net_WebPingGetValue\" URI to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78 -  Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Once logged in to the device\'s web interface, a diagnostic ping page can be found. This page asks the user for an IP address to ping. There is input validation client-side, but it can be easily bypassed by using tools, such as cURL or Wget. There is no server-side validation of input. The page will call the system to run the Linux ping command. The system will run the following command with \'%s\' as user-controlled input. The code below shows user input being passed to system. Vulnerable URI: /goform/net_WebPingGetValue\nVulnerable Parameter: ip= The following POST will start a root shell on port 5000. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0472');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (138, 'Moxa EDR-810 Service Agent Multiple Denial of Service Vulnerabilities', 'None', '2018-4-13', 'Exploitable denial of service vulnerabilities exists in the Service Agent functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted packet can cause a denial of service. An attacker can send a large packet to 4000/tcp and 4001/tcp to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-20 - Improper Input Validation The Moxa EDR Service Agent listens on port 4000 (tcp/udp) and 4001 (tcp). Moxa MXconfig, a Windows program, interacts with the EDR via the ServiceAgent. Sending large amounts of random data to these ports causes a crash. In order to crash port 4000 (both TCP & UDP) a large packet needs to be sent to tcp/4000. This causes a consistent crash. In order to crash port 4001 a large packet needs to be sent to tcp/4001. The crash does not always occur on the first try so an attacker may need to run this attack multiple times in order to cause a crash. This python script will crash the Service Agent 2017-11-30 - Vendor Disclosure \n2017-12-04 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0487');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (139, 'Moxa EDR-810 Web Server Weak Cryptography for Passwords Vulnerability', 'None', '2018-4-13', 'An exploitable Weak Cryptography for Passwords vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. An attacker could intercept weakly encrypted passwords and could brute force them. Moxa EDR-810 V4.1 build 17030317 3.5 - CVSS:3.0/AV:A/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N CWE-216 - Weak Cryptography for Passwords After the initial login, each authenticated request sends a HTTP packet with a MD5 hash of the password. This hash is not salted and can be cracked, revealing the device\'s password. In the Cookie there is a PASSWORD= parameter. This parameter contain a MD5 of the users password. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0481');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (140, 'Moxa EDR-810 Web Server OpenVPN Config Multiple Command Injection Vulnerabilities', 'None', '2018-4-13', 'An exploitable command injection vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP POST can cause a privilege escalation resulting in root shell. An attacker can inject OS commands into various paramaters in the \"/goform/net_Web_get_value\" uri to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78 - Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Once logged in to the device\'s web interface, a user can configure OpenVPN via a POST to \"/goform/net get_value\". An attacker can inject commands via POST parameters. The web server is running as a root user, therefor injected commands will run as root. This following parameter is vulnerable to a command injection. This following parameter is vulnerable to a command injection. This following parameter is vulnerable to a command injection. In order to exploit this vulnerability the following POST request can be sent. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0482');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (141, 'Moxa EDR-810 Plaintext Password Storage Vulnerability', 'None', '2018-4-13', 'An password storage vulnerability exists in the operating system functionality of Moxa EDR-810 V4.1 build 17030317. An attacker with shell access could extract passwords in clear text from the device. Moxa EDR-810 V4.1 build 17030317 4.4 - CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N CWE-256 - Plaintext Storage of a Password The device stores credentials in plaintext in /magicP/cfg4.0/cfg_file/USER_ACCOUNT.CFG. This file mirrors the contents of /etc/shadow, except all the passwords are in plaintext. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0479');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (142, 'Moxa EDR-810 Web RSA Key Generation Command Injection Vulnerability', 'None', '2018-4-13', 'An exploitable command injection vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP POST can cause a privilege escalation resulting in root shell. An attacker can inject OS commands into the rsakey_name= parm in the \"/goform/WebRSAKEYGen\" uri to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78 -  Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Once logged in to the device\'s web interface, a user can generate RSA key via a POST to \"/goform/net_WebRSAKEYGen\". One of the parameters that gets sent with this post request is the rsakey_name= parameter. An attacker can inject OS commands to get a root shell. Vulnerable URI: /goform/net_WebRSAKEYGen\nVulnerable Parameter: rsakey_name= The following POST will start a root shell on port 5000. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0473');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (143, 'Moxa EDR-810 Web Server strcmp Multiple Denial of Service Vulnerabilities', 'None', '2018-4-13', 'An exploitable denial of service vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP URI can cause a null pointer dereference resulting in denial of service. An attacker can send a GET request to \"/MOXA_LOG.ini, /MOXA_CFG.ini, or /MOXA_CFG2.ini\" without a cookie header to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-476 - NULL Pointer Dereference This device is marketed as a secure ICS (Industrial Control System) router. This device will likely be found in industrial environments such as power generation/distribution, water treatment, manufacturing, etc. This specific vulnerability causes the web server to crash. A GET request to /MOXA_LOG.ini, /MOXA_CFG.ini, or /MOXA_CFG2.ini without a cookie header will cause the binary to crash. Authentication is not required for this vulnerability. In the following code snippet, R0 is nil if the cookie header is not set. In the following code snippet, R0 is nil if the cookie header is not set. In the following code snippet, R0 is nil if the cookie header is not set. OR OR 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0474');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (144, 'Moxa EDR-810 Web Server URI Denial of Service Vulnerability', 'None', '2018-4-13', 'An exploitable denial of service vulnerability exists in the web server functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted HTTP URI can cause a null pointer dereference resulting in the web server crashing. An attacker can send a crafted URI to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-20 - Improper Input Validation When the web server is processing HTTP requests it checks the first character of the URI for a / (0x2F). If the first character is not a 0x2F the service will crash. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0476');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (145, 'Moxa EDR-810 Server Agent Information Disclosure Vulnerability', 'None', '2018-4-13', 'An exploitable information disclosure vulnerability exists in the Server Agent functionality of Moxa EDR-810 V4.1 build 17030317. A specially crafted TCP packet can cause information disclosure. An attacker can send a crafted TCP packet to trigger this vulnerability. Moxa EDR-810 V4.1 build 17030317 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N CWE-213 - Intentional Information Exposure If 0x21 is set to the device over TCP/4000 the device will reply with: When the server detects 0x21 it calls the \"DoShowInfo\" function. This function first gathers system info, then sends it back to the client. In order to trigger the information disclosure vulnerability send 0x21 to the device over TCP/4000. 2017-11-15 - Vendor Disclosure \n2017-11-19 - Vendor Acknowledged \n2017-12-25 - Vendor provided timeline for fix (Feb 2018) \n2018-01-04 - Timeline pushed to mid-March per vendor \n2018-03-24 - Talos follow up with vendor for release timeline \n2018-03-26 - Timeline pushed to 4/13/18 per vendor \n2018-04-12 - Vendor patched & published new firmware on website \n2018-04-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0480');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (146, 'NASA CFITSIO `ffghbn` and `ffghtb` Stack Overflow Code Execution Vulnerabilities', 'None', '2018-4-12', 'Exploitable buffer overflow vulnerabilities exist in image parsing functionality of the CFITSIO library version 3.42. Specially crafted images parsed via the library, can cause a stack-based buffer overflow overwriting arbitrary data. An attacker can deliver an FIT image to trigger this vulnerability and potentially gain code execution. NASA CFITSIO 3.42 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow CFITSIO is a library written in C, for reading and writing data files in FITS data format. This format is the standard astronomical data format endorsed by both NASA and the IAU. FITS is primarily designed to store scientific data sets consisting of multi-dimensional arrays and 2-dimensional tables containing rows and columns of data. This software is used extensively and is the primary library used when writing an application to handle the FITS format. Among other things CFITSIO is widely used in ground-based observatories as well as orbiting astronomical observatories in their ground data processing pipeline systems. For more users see,  . The vulnerabilities arise in the   and ffghtb function. CVE-2018-3848 - ffghbn The ffghbn responsible for getting data from a binary table inside a FITS image. This function\'s main purpose is to parse the header keywords and validate them to ensure they conform to the FITS standard. The function also returns the necessary data to parse the rest of the table. Below is a look at the function responsible for parsing. Location 0 defines the buffer variables used throughout the function. At 3, we see the function read in the keyword directly from the header. This value is then compared with the expected value, 2, and if it does not match we fall into the if statement. There is then a vulnerable call to the function sprintf, 3. Looking at the sprintf manual page it states, Due to the lack of bounds checking as stated above this call will cause a buffer overflow. The name parameter is taken directly from the user and although restricted in size to 75 bytes at 0, the added error message makes it longer than the 81 bytes of available space in the buffer. This causes an exploitable stack based buffer overflow. CVE-2018-3849 - ffghtb This vulnerability is similar to the vulnerability discussed in CVE-2018-3848. This instance occurs in the   function responsible for the parsing of an ascii table inside a FITS image. The same vulnerable pattern as above is present. The buffers are defined at 4 and at location 5 the value is read in from the image. Location 6 compares the value for validity and if the check fails it falls into the vulnerable sprintf call, 7. 2018-02-23 - Vendor Disclosure \n2018-03-21 - Vendor patched \n2018-04-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0531');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (147, 'NASA CFITSIO Multiple Stack Overflow Code Execution Vulnerabilities', 'None', '2018-4-12', 'Multiple exploitable buffer overflow vulnerabilities exist in image parsing functionality of the CFITSIO library version 3.42. Specially crafted images parsed via the library, can cause a stack-based buffer overflow overwriting arbitrary data. An attacker can deliver an FIT image to trigger this vulnerability and potentially gain code execution. NASA CFITSIO 3.42 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow  CFITSIO is a library written in C, for reading and writing data files in FITS data format. This format is the standard astronomical data format endorsed by both NASA and the IAU. FITS is primarily designed to store scientific data sets consisting of multi-dimensional arrays and 2-dimensional tables containing rows and columns of data. This software is used extensively and is the primary library used when writing an application to handle the FITS format. Among other things CFITSIO is widely used in ground-based observatories as well as orbiting astronomical observatories in their ground data processing pipeline systems. For more users see,  . The vulnerabilities arise in the   and   functions. The   function is responsible for getting the primary header data from a FITS image. This functions main purpose is to parse the header keywords and validate them to ensure they conform to the FITS standard. The function also returns the necessary data to parse the rest of the image. Below is a look at the basic template for parsing seen throughout. At location 0 and 1, the defines used throughout the function are given to help better understand the sizes being used. Likewise at 2, the local variables that will be used for the function are defined. At 3, we see the function read in the keyword directly from the header. This value is then compared with the expected value at 4 and if it does not match we fall into the if statement. There is then a vulnerable call to the function sprintf at 5. Looking at the sprintf manual page it states, Due to the lack of bounds checking as stated above this call will cause a buffer overflow. The name parameter is taken directly from the user and although restricted in size to 75 bytes, 0, the added error message makes it longer than the 81 bytes of available space in the buffer, 1. This causes an exploitable stack based buffer overflow. Below is a list of the locations inside of the   function in which this vulnerability arises. 2778:           unknown = 1;  / / 2842:   if (strcmp(name, \"BITPIX\")) 2850:   if (ffc2ii(value,  &longbitpix, status) > 0) 2950:   if (fftrec(name, status) > 0)  / / 2961:   if (!strcmp(name, \"BSCALE\") && bscale) 2978:   else if (!strcmp(name, \"BZERO\") && bzero) 2995:   else if (!strcmp(name, \"BLANK\") && blank) 3012:   else if (!strcmp(name, \"PCOUNT\") && pcount) 3025:   else if (!strcmp(name, \"GCOUNT\") && gcount) The vulnerability again arises in the   function. The relevant code is shown below. As before the name is taken directly from the image supplied at 6. If the value fails to be converted to an integer at 7, the error status is set. The function subsequently goes into the if statement at 8 and the vulnerable sprintf function is called. 2018-02-23 - Vendor Disclosure \n2018-03-21 - Vendor Patched \n2018-04-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0529');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (148, 'NASA CFITSIO `ffgkyn` Stack Overflow Code Execution Vulnerability', 'None', '2018-4-12', 'Multiple exploitable buffer overflow vulnerabilities exist in image parsing functionality of the CFITSIO library version 3.42. Specially crafted images parsed via the library, can cause a stack-based buffer overflow overwriting arbitrary data. An attacker can deliver an FIT image to trigger this vulnerability and potentially gain code execution. NASA CFITSIO 3.42 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow CFITSIO is a library written in C, for reading and writing data files in FITS data format. This format is the standard astronomical data format endorsed by both NASA and the IAU. FITS is primarily designed to store scientific data sets consisting of multi-dimensional arrays and 2-dimensional tables containing rows and columns of data. This software is used extensively and is the primary library used when writing an application to handle the FITS format. Among other things CFITSIO is widely used in ground-based observatories as well as orbiting astronomical observatories in their ground data processing pipeline systems. For more users see,  . The vulnerability is present in the   function responsible for reading a key value pair from a FITS image. This functions main purpose is to read a keyword returning the name value and comment from the image. The error is present when an illegal character is found. At location 0, the defines used throughout the function are given to help better understand the sizes being used. Likewise at 1, the local variables that will be used for the function are defined. At 2, we see the function read in the keyword directly from the image record. The value is then tested to ensure it does not contain any illegal characters. By passing in a specially crafted image the attacker can cause this check to fail. There is then a vulnerable call to the function sprintf at 4. Looking at the sprintf manual page it states, The sprintf() functions are easily misused in a manner which enables malicious users to arbitrarily change a running program\'s functionality through a buffer overflow attack.  Because sprintf() assume an infinitely long string, callers must be careful not to overflow the actual space; this is often hard to assure.  For safety, programmers should use the snprintf() interface instead. Due to the lack of bounds checking as stated above this call will cause a buffer overflow. The   parameter is taken directly from the image and although restricted in size to 72 bytes due to the define at 0, the added error message makes it longer than the 81 bytes of available space in the buffer, defined at location 1. This causes an exploitable stack based buffer overflow. 2018-02-23 - Vendor Disclosure \n2018-03-21 - Vendor Patched \n2018-04-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0530');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (149, 'Computerinsel Photoline TIFF Bits Per Pixel Parsing Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the TIFF parsing functionality of Computerinsel Photoline 20.53. A specially crafted TIFF image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a TIFF image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image-processing tool used to  modify and edit images, as well as other graphic-related material. This product has a large user base, and is popular in its field. The vulnerable component is in the handling of TIFF images. TIFF is a raster-based image format used in graphics editing projects, thus making it a very common file format for such an application. The vulnerability arises in the parsing of a compressed tiled TIFF image. TIFF supports tiled images as part of the later extension and revision to the specification. Through this, images are able to have multiple tiles inside of a single image. The vulnerability arises in the processing and reading of these tiles. Each image is able to specify a specific bits per sample and by crafting a TIFF image an attacker can lead the code into a vulnerable path shown below. The function that calls into the parsing of a tile is show above. Data taken from the TIFF image is shown at [0], and subsequently passed directly into the next call. The   parameter is also specified via the image, allowing an attacker to control the specified program path. Below is the relevant code for the parsing loop. At location [2], the variable has been taken from the provided tag inside of the image. This then allows the specific case to be selected where   [3] is passed in from the code shown above. This address is able to be influenced by the image, and can thus be taken out of bounds. This address is then written to at location [4]. This creates an arbitrary out-of-bounds write, leading to an exploitable condition. 2018-03-27 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0547');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (150, 'Computerinsel Photoline PCX Color Map Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the PCX-parsing functionality of Computerinsel Photoline 20.53. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image processing tool used to modify and edit images, as well as other graphic-editing functions. This product has a large user base and is popular in its specific field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers, and although it has been replaced by more sophisticated formats, it is still in use and is fully supported inside of Canvas Draw. The vulnerability arises in the parsing of the PCX image, specifically dealing with decompressing the color map of the image. The compression scheme is determined via the file header and by choosing \"run length encoding\" as the compression, the program writes out of bounds using user-controlled data. The error comes in due to the incorrect calculation of the size of the compressed data. The relevant code is shown below. The image data is read at location [0] and written into memory. The memory is then incremented by three [1] and the loop continues. This appears to be a means of extracting information about the PCX colormap stored in sets of three. However, with a crafted image, the   variable may be an overly large value. This causes the loop to write out of bounds and an exploitable condition is created. This vulnerability could be leveraged to gain code execution. 2018-04-09 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0563');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (151, 'Computerinsel Photoline TIFF Samples Per Pixel Parsing Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the TIFF parsing functionality of Computerinsel Photoline 20.53. A specially crafted TIFF image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a TIFF image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image-processing tool used to  modify and edit images, as well as other graphics-related material. This product has a large user base, and is popular in its field. The vulnerable component is in the handling of TIFF images. TIFF is a raster-based image format used in graphics editing projects, thus making it a very common file format for such an application. The vulnerability arises in the parsing of a compressed tiled TIFF image. TIFF supports tiled images as part of the later extension and revision to the specification. Through this, images are able to have multiple tiles inside of a single image. The vulnerability arises in the processing and reading of these tiles. The code responsible for reading the tiles is shown below. The tile information is calculated at [0], and a read loop is entered. The address to read data from is directly calculated from the TIFF image with no validation. Therefore at location [1], this value return is fully controlled by the attacker. This allows an arbitrary integer to be specified and leads to an erroneous value to be calculated. At location [2], this out-of-bounds space is written with other data taken from the image, thus creating an arbitrary out-of-bounds write. This could be exploited to gain code execution. 2018-03-27 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0546');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (152, 'Computerinsel Photoline PCX Bits Per Pixel Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the PCX-parsing functionality of Computerinsel Photoline 20.53. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image processing tool used to modify and edit images, as well as other graphic-editing functions. This product has a large user base, and is popular in its specific field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers, and although has been replaced by more sophisticated formats, it is still in use and fully supported inside of Canvas Draw. The vulnerability arises in parsing the PCX image, specifically dealing with the decompression of the color map of the image. The compression scheme is determined via the file header and by choosing \"run length encoding\" as the compression, the program writes out of bounds using user-controlled data. The error comes due to incorrectly calculating the size of the compressed data. In the main parsing loop, there is a function selector based on the value below. Both values represented are taken directly from the image header itself. If passed in a crafted image, a vulnerable function can be called. The code from the vulnerable function is shown below. The   value [0] is read in from the image itself and is used as a loop counter without validation. By passing in successively large   values, this buffer can be taken out of bounds. Subsequently, [1] an out-of-bounds write is created and an exploitable condition arises. This then could be used to gain code execution. 2018-04-09 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0564');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (153, 'Computerinsel Photoline PCX Run Length Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the PCX-parsing functionality of Computerinsel Photoline 20.53. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image processing tool used to modify and edit images, as well as other graphic-related material. This product has a large user base, and is popular in its specific field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers, and although it has been replaced by more sophisticated formats, it is still in use and fully supported inside of Canvas Draw. The vulnerability arises in parsing the PCX image, specifically dealing with the compression of the image. The compression scheme is determined via the file header, and by choosing \"run length encoding\" as the compression, the program writes out of bounds using user-controlled data. The error comes in due to the incorrect calculation of the size of the compressed data. The relevant code is shown below. At location [0], the compressed image data is read and compared against 0xC0. If this check is true, it goes into the if statement and writes directly to the image buffer [1]. There is no verification that the buffer is within bounds after this increment. Then, when the loop is entered again and the value is below 0xC0 [0], an out-of-bounds write occurs creating an exploitable condition. This vulnerability could be leveraged to gain code execution. 2018-04-09 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0562');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (154, 'Computerinsel Photoline PSD Blending Channels Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the PSD parsing functionality of Computerinsel Photoline 20.53. A specially crafted PSD document processed via the application can lead to an out of bounds write overwriting arbitrary data. An attacker can deliver a PSD document to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image processing tool used to  modify and edit images as well as other graphic related material. This product has a large user base and is popular in its specific field. The vulnerable component is in the handling of PSD documents. PSD is a document  format used by Adobe Photoshop and supported by many third party applications throughout the industry. The vulnerability arises in parsing the PSD document. The application takes data directly from the document without verification and uses it to calculate an address. The document has a specially crafted blending channel value leading to this miscalculation. Below is the are of the crash. The buffer is written to at location 0, using the counter to maintain position. At location 1 it is shown that the loop is actually controlled by a decrementing variable. By crafting a document the   value can be set to an excessively large number causing this loop to go out of bounds. Furthermore,   will get converted to an unsigned int causing an overflow and allowing this loop to write out of bounds with multiple scenarios, 2. This will lead to an out of bounds write and can be used to gain code execution. 2018-03-29 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0550');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (155, 'Computerinsel Photoline PCX Decompress Code Execution Vulnerability', 'None', '2018-4-11', 'A memory corruption vulnerability exists in the PCX-parsing functionality of Computerinsel Photoline 20.53. A specially crafted PCX image processed via the application can lead to an out-of-bounds write, overwriting arbitrary data. An attacker can deliver a PCX image to trigger this vulnerability and gain code execution. Computerinsel Photoline 20.53 for OS X 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Photoline is an image processing tool used to modify and edit images, as well as other graphic-editing functions. This product has a large user base, and is popular in its specific field. The vulnerable component is in the handling of PCX images. PCX was a popular image format with early computers, and although it has been replaced by more sophisticated formats, it is still in use and is fully supported inside of Canvas Draw. The vulnerability arises in parsing the PCX image, specifically dealing with the compression of the image. The compression scheme is determined via the file header, and by choosing \"run length encoding\" as the compression, the program writes out of bounds using user-controlled data. The error comes in due to incorrectly calculating the size of the compressed data. The relevant code is shown below. At location [0], the compressed image data is read, and a binary operation is performed to calculate the counter for the inner loop [1]. The outer loop counter at location [3] has been passed into the function but has been calculated via controlled image data. This allows a specially crafted image to iterate through the loop more than desired. This creates an out-of-bounds write at location [2] and an exploitable condition arises. This vulnerability can be exploited to gain code execution. 2018-04-09 - Vendor Disclosure \n2018-04-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0561');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (156, 'Simple DirectMedia Layer SDL2_Image IMG_LoadPCX_RW Information Disclosure Vulnerability', 'None', '2018-4-10', 'An exploitable information disclosure vulnerability exists in the PCX image rendering functionality of SDL2_image-2.0.2. A specially crafted PCX image can cause an out-of-bounds read on the heap, resulting in information disclosure . An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 5.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N CWE-126: Buffer Over-read LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When parsing and storing an PCX image file, the LibSDL2 library implements a custom RLE inflater for the compressed PCX data. In order to this, however, the library must first parse the PCX headers, such that it can allocate the correct amount of memory for the color data buffer. The structure of the PCX headers is listed below: It should be noted that these values are all taken directly from the PCX file itself, as one might expect. Also, for the purposes of this bug, the most important fields are the Xmin, Xmax, and BytesPerLine parameters, however (pcxh.BitsPerPixel == 8 && pcxh.NPlanes == 3) must also be true in order to hit the buggy code path. When creating the SDL_Surface object used to store the image information, the dimensions of the image are generated as such: The width is multiplied by the height inside of [1], in order to generate the appropriate size buffer for the surface.pixels buffer, which is where the image data ends up being stored. But immediately after the pixel buffer is malloced with size (width*height), the library also mallocs another buffer: At [1], the size of this new buffer is calculated. As mentioned before, pcxh.Nplanes must be 3, however there is no such restriction on the pcxh.BytesPerLine parameter, which is read in from the input image. For purposes of the discussion, assume pcxh.BytesPerLine = 0x200. Thus, when the buf variable is populated with heap memory at [2], the size of the heap chunk is 0x600. The library then reads in the actual image data from the file into the buf variable, one row at a time. After this, the data is taken from the tmp buffer \'buf\' and de-interlaced into the actual SDL_Surface.pixels buffer from before. During the de-interlace phase, at [2], the temporary buffer \'buf\' is walked with the innerSrc pointer, with each row taking \'width\' bytes [1]. When looking back, we can see that the \'width\' variable is created as such:  , while the \'buf\' buffer is created as such:\n .  Since there\'s not really any checks or comparisons between the sizes of the buffer an width, if width is greater than the BytesPerLine, the loop starts to read out of bounds into the rest of the heap, resulting in an information disclosure, as the SDL_surface.pixel buffer now contains heap data. Program received signal SIGSEGV, Segmentation fault. 2018-02-06 - Vendor Disclosure \n2018-02-07 - Vendor patched \n2018-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0519');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (157, 'Simple DirectMedia Layer SDL2_Image load_xcf_tile_rle bpp Code Execution Vulnerability', 'None', '2018-4-10', 'An exploitable code execution vulnerability exists in the XCF image rendering functionality of SDL2_image-2.0.2. A specially crafted XCF image can cause an out-of-bounds write on the heap, resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 6.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-122: Heap-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When parsing and storing an XCF  file (the native file type for Gimp), the LibSDL2 library implements a custom RLE inflater for the compressed XCF data. The code that handles this is listed below: From the above, it should be noted that the  , , and   parameters are all under the file\'s control, along with the   field. The   parameter in particular is taken from the   struct. This structure has it\'s fields populated directly from the XCF image file being rendered as such: Thus, we know that the   variable can be anything from 0x0 to 0xffffffff, so going back to the load_xcf_tile_rle function, an issue quickly arises: Since x, y, and bpp are all of integers, when all multiplied at [1], the resulting value passed into SDL_malloc is also of type integer. As noted before, since bpp can be 0x0-0xffffffff, this results in an integer overflow for a high enough value of  , causing the value passed into SDL_malloc to be less than bpp itself. This causes the subsequent usages of   to be outside the bounds of the allocated buffer and possible memory corruption. Due to line [2], bpp does have some bounds, such that (bpp < 0) => causes the corruption loop to skip. The tricky part with this bug is how much one could actually get away with corrupting as the writes in memory occur with the following code: So while it is technically a controlled write, since we control the value of   at [1], remember that bpp must be rather large, and also cannot be negative. Thus, when the destination pointer   is incremented by bpp at [2], the odds of hitting unmapped memory increase exponentially for each loop iteration. On a 32-bit machine, the probability of successful exploitation with this bug would increase tremendously though as the pointer   would wrap around a lot faster, leaving less chance for segfaulting due to unmapped memory access. (Note: Compiled with ASAN) 2018-02-06 - Vendor Disclosure \n2018-02-07 - Vendor Patched  \n2018-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0521');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (158, 'Simple DirectMedia Layer SDL2_Image load_xcf_tile_rle Information Disclosure Vulnerability', 'None', '2018-4-10', 'An exploitable information vulnerability exists in the XCF image rendering functionality of SDL2_image-2.0.2. A specially crafted XCF image can cause an out-of-bounds read on the heap, resulting in information disclosure. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 5.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N CWE-126: Buffer Over-read LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When parsing and storing an XCF  file (the native file type for Gimp), the LibSDL2 library implements a custom RLE inflater for the compressed XCF data. The code that handles this is listed below: From the above, it should be noted that the  , , and   parameters are all under the file\'s control, along with the   field, which is derived from the calling function as such: To sum up the above, each XCF surface can have multiple layers, and these layers have a hierarchy, which is read in at [1] and dictates the order in which the image layers are rendered. Then, each layer has a set of tiles (which are just blocks of image data), which must be read in first before rendering. These tiles can be different sizes, so an array of file offsets are read in at [2], such that the parsing can be done correctly. After this, the library loops over the tile offsets, and seeks for the tile data in the file, reading the tile data at [3]. \'load_tile\'  is a function pointer to the load_xcf_tile_rle function that we were at before. Of most note for this bug, is the fact that the \'len\' parameter from the load_xcf_tile_rle function is calculated from  , as long as level->tile_file_offsets[j+1] is != 0. Thus, if we make our XCF file have two consecutive tile_file_offsets that are equivalent, our call to load_xcf_tile_rle becomes load_xcf_tile_rle(src,0,hierarchy->bpp,ox,oy). This causes issues further down inside load_xcf_tile_rle as we end up doing a call to malloc(0) for our source buffer: Since SDL_malloc is a simple wrapper around normal malloc, this depends on the specific implementation of malloc for the system, but at least on Debian Linux, m0560874168f86c7aeeee2edcf2cea202alloc(0) returns a valid buffer of the minimum chunk size possible for the given architecture, which is usually 16 bytes on a 64 byte system. But regardless of the exact byte count, the amount of bytes read in from this malloc(0) buffer for data is going to be far greater for any image of reasonable size, as the destination buffer\'s size is x bpp. This results in a large user-controlled amount of data being read from the heap and populated into the XCF tile for further processing, creating an out of bounds read. (Note: Compiled with ASAN) 2018-02-06 -  Vendor Disclosure \n2018-02-07 -  Vendor patched \n2018-04-10 -  Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0520');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (159, 'Zabbix Server Config Proxy Request Information Disclosure Vulnerability', 'None', '2018-4-9', 'An information disclosure vulnerability exists in the iConfig proxy request of Zabbix server 2.4.X. A specially crafted iConfig proxy request can cause the Zabbix server to send the configuration information of any Zabbix proxy, resulting in information disclosure. An attacker can make requests from an active Zabbix proxy to trigger this vulnerability. Zabbix Server 2.4.8.r1 3.7 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N CWE-200: Information Exposure If an attacker can send packets to a Zabbix server from the IP address of a\nconfigured Zabbix proxy, whether through spoofing, legitimate access, or other\nmeans, then an attacker can request the database configuration information for\nany configured Zabbix proxy, assuming that the hostname of the Zabbix proxy can\nbe guessed or brute-forced. This database configuration information contains sensitive materials that could be used for further exploitation and discovery purposes. The following is a subset of the sensitive information disclosed:\n1. All configured monitored Zabbix agents and corresponding IP addresses.\n2. All items that can be used to query data from the Zabbix agent, including user-configured UserParameters (potentially dangerous).\n3. Hostmacros Example Request (from any valid proxy IP): 2017-04-22 - Vendor Disclosure \n2018-04-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0327');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (160, 'IBM DB2 Shared Memory Insecure Permissions Vulnerability', 'None', '2018-4-6', 'An exploitable shared memory permissions vulnerability exists in the functionality of IBM DB2 10.5.0.7. An attacker can access the shared memory without any specific permissions to trigger this vulnerability. IBM DB2 10.5.0.7 5.1 - CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L CWE-277: Insecure Inherited Permissions As part of the initialization of DB2 instances, it creates a shared memory segment  which used to support certain diagnostic features, such as health monitoring (by db2acd) and tracing of DB2 operations (by db2trc). It was identified that these shared memory segments have world-read and world-write permissions set (667) which means that any user can read and write to the segment without any specific OS privileges being required. Whilst typically the shared memory segment is created containing only a header and ~32Mb of NULL bytes, under some conditions (such as when tracing is turned on), it is populated by DB2 with information relating to the current operations being performed by the instance which can then be extracted with db2trc dump. In a general sense, overwriting the shared memory segment with smaSHeM* is enough to completely break parts of DB2 since the structure it holds contains data that directly affects aspects of how processes using it may behave. For example, the segment contains metadata including the size of the allocated shared memory segment (maxBufferSize) at at a fixed location within the segment which is then checked for a sane value (which need not be the same as the actual segment size) when you call db2trc on). A simple PoC of how an attacker may be able to trigger more useful conditions by exploiting the initial permissions weakness can be seen below. 1) As the db2inst1 OS user, enable tracing: 2) (As another OS user), write to the shared memory: 3) As the db2inst1 OS user, request trace info: 4) Observe the following: In this instance, we use smaSHeM to overwrite data such that subsequent accesses of the shared memory segment result in db2trc failing within the internal function displayHeaderInfo( FILE )() due to a corruption of the $rdi.\nWhilst db2trc is itself setUID/GID to the db2inst1/dbiadm1 OS user, when executed, the binary first checks you are in SYSADM, SYSCTRL or SYSMAINT DB2 groups before memory corruption occurs (which limits impact to other DB2 trusted OS users) There are likely are many more attack paths (some more reliable than others) however essentially, if an attacker can persuade the db2inst1 OS user to execute db2trc info, or the attacker is in a DB admin group (but doesn\'t have full access to db2inst1) then it may be possible to execute arbitrary code as the db2inst1 OS user. smaSHeM can be found here: https://labs.portcullis.co.uk/tools/smashem/. 2016-12-13: Initial contact with IBM \n2016-12-14: IBM responded and assigned Advisory ID 7441 \n2016-12-20: Further information requested and provided \n2017-01-25: Chaser sent \n2017-06-22: Advisory Published by IBM \n2018-03-22: Advisory received by Talos \n2018-04-06: Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0558');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (161, 'Natus Xltek EEG NeuroWorks OpenProducer Code Execution Vulnerability', 'None', '2018-4-4', 'An exploitable code execution vulnerability exists in the OpenProducer functionality of Natus Xltek NeuroWorks 8. A specially crafted network packet can cause a stack buffer overflow resulting in code execution. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. The modules used in this advisory are shown below: One of the key data structures in Neuroworks is the KeyTree. Internally, a KeyTree is a List of Lists. The List and KeyTree structs are shown below: During the processing of the   command, a client supplied KeyTree is parsed looking for a   key. This extraction is shown below: The actual item is returned, [1] and cast into a C string, [2]. Finally its length is checked to be non zero to ensure there is data to be processed, [3]. This data is then passed through a combination of splitpath and makepath shown below. The resulting   call will put the entire filename into the filename local variable, [5]. However the user supplied string, [4], is not checked to ensure it does not overstep this boundary. This results in a stack based buffer overflow and an exception triggered. Due to the overflow, the exception handlers have been overwritten giving direct control of the program. 2017-07-15 - Initial Contact \n2017-10-06 - Vendor Acknowledged \n2018-04-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0375');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (162, 'Natus Xltek EEG NeuroWorks RequestForPatientInfoEEGfile Code Execution Vulnerability', 'None', '2018-4-4', 'An exploitable Code Execution vulnerability exists in the RequestForPatientInfoEEGfile functionality of Natus Xltek NeuroWorks 8. A specially crafted network packet can cause a stack buffer overflow resulting in arbitrary command execution. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 10 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-121 - Stack-based Buffer Overflow Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. Modules associated with this advisory are below: During the processing of the   command,   attempts to open an EEG file based on a path requested by the client. This path construction is shown below:  extracts the wanted filename by calling   on client supplied data [0]. This, along with a temp directory [1], are used in a   call [2] to create the wanted EEG file to open. The destination of this   is a buffer on the stack [3]. The combination of temp directory and client supplied filename causes the   variable to be overrun, overwritting the Structured Exception Handler on the stack. The state of the SEH chain before the   call is shown below: The state of the SEH chain after the   call is shown below: By causing an exception before the stack cookie is checked, the overwritten exception handler is called, resulting in arbitrary code execution. 2017-06-16 - Vendor Disclosure \n2017-07-15 - Vendor Acknowledged \n2018-04-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0355');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (163, 'Circle with Disney WiFi Insecure Access Point Vulnerability', 'None', '2018-4-4', 'An exploitable vulnerability exists in the WiFi Access Point feature of Circle with Disney running firmware 2.0.1. A series of WiFi packets can force Circle to setup an Access Point with default credentials. An attacker needs to send a series of spoofed \"de-auth\" packets to trigger this vulnerability. Circle with Disney 2.0.1 6.5 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-284: Improper Access Control Circle with Disney is a network device used to monitor internet use of children on a given network. Circle can connect to a home network either via WiFi or wired connection.\nWhen no cable connection is possible, Circle will switch to WiFi, which was set-up during the initial configuration. When connected via WiFi, the   function in the   binary continuously checks for network connectivity by calling  .\nThis function verifies that the interface is associated with the Access Point and that it has an IP address assigned. If any of these checks aren\'t satisfied, the return value will be 0, meaning there\'s no available connection. Back in the   function, when there\'s no connection, function   will be called with argument \"Internet connection down\". At high level, the function works as follows: At [1] the   script is called to start an Access Point.\nContents of the script are the following: At [2]   is used to bring up an Access Point using the configuration below. The SSID used is \"Circle-\" prefixed with the last two hex digits of the MAC address.\nThe \"wpa_passphrase\" parameter is fixed. Indeed, the base   file is copied from   during boot time by the script  . The only modification applied is the SSID name. This feature allows an attacker to connect to a Circle Access Point, after forcing it out of its legitimate WiFi network.\nThe device will continue to function but won\'t be able to apply any filtering over the original network, moreover this allows an attacker to conduct further attacks against the device that may be possible only on a common subnetwork. As an example, this vulnerability would allow an external attacker to apply TALOS-2017-0396 and TALOS-2017-0371 to completely compromise the device. The following proof of concept shows how to make the device disconnect from its legitimate WiFi network and to start its own Access Point, by sending a series of \"deauth\" packets. After a new Access Point is detected with name starting with \"Circle-\" it\'s possible to connect to it using the password \"mycircle\". 2017-09-20 - Vendor Disclosure \n2018-03-29 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0447');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (164, 'Natus Xltek EEG NeuroWorks SavePatientMontage Code Execution Vulnerability', 'None', '2018-4-4', 'An exploitable code execution vulnerability exists in the SavePatientMontage functionality of Natus Xltek NeuroWorks 8. A specially crafted network packet can cause a stack buffer overflow resulting in code execution. An attacker can a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. The modules used in this advisory are shown below: One of the key data structures in Neuroworks is the KeyTree. Internally, a KeyTree is a List of Lists. The List and KeyTree structs are shown below: During the processing of the   command, a client supplied KeyTree is parsed looking for a   key. The extraction of the   element is shown below: This return value is an Item type. In order to extract the literal string from the Item,   is called as shown below: This string is finally passed to   in order to create a file path in preparation for setting a local variable.  does not guarantee that the resulting string will fit in the supplied buffer. The client can supply a string larger than the allocated stack buffer, causing a buffer overflow. Due to the overflow, the exception handlers have been overwritten giving direct control of the program. 2017-07-15 -  Initial Contact  \n2017 -10-06 - Vendor Acknowledged \n2018-04-04 -  Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0373');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (165, 'Natus Xltek EEG NeuroWorks NewProducerStream Use of Return Value Denial of Service Vulnerability', 'None', '2018-4-4', 'An exploitable Denial of Service vulnerability exists in the use of a return value in the NewProducerStream command in Natus Xltek NeuroWorks 8. A specially crafted network packet can cause an out of bounds read resulting in a denial of service. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-125 - Out-of-bounds Read Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. The modules used in this advisory is shown below: During the processing of the   command, a   data structure is expected. This data structure is a simple key-value structure similar to a  . A key of   is expected to have an   object that will be used for later processing. The pseudocode for this particular section of code is shown below: The   is extracted from the data stream [0] and then the   key is extracted [1]. The   value is converted to an   [2] and finally checked to ensure the conversion to an   was valid [3]. If the conversion to an ItemList was invalid, the event is logged. After logging the event, nothing changes about the return result from  . If there was an error, the return value would be  . Subsequently, this value is passed directly to   [5]. Assuming this value is a valid  , it is checked to ensure it is not empty by checking the   pointer of the  . Becuase the argument is  , this causes in an Access Violation [6] resulting in a Denial of Service. 2017-07-15 - Initial Contact \n2017-10-06 - Vendor Acknowledged \n2018-04-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0365');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (166, 'Natus Xltek EEG NeuroWorks NewProducerStream Code Execution Vulnerability', 'None', '2018-4-4', 'An exploitable code execution vulnerability exists in the NewProducerStream functionality of Natus Xltek NeuroWorks 8. A specially crafted network packet can cause a stack buffer overflow resulting in code execution. An attacker can send a malicious packet to trigger this vulnerability. Natus Xltek NeuroWorks 8 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Natus NeuroWorks 8 provides a networking solution for the Natus Xltek EEG products. In particular, it is used to monitor and review study data from anywhere on the network. This advisory looks into the NWStorage service bundled with NeuroWorks. The modules used in this advisory are shown below: One of the key data structures in Neuroworks is the KeyTree. Internally, a KeyTree is a List of Lists. The List and KeyTree structs are shown below: During the processing of the   command, a client supplied KeyTree is parsed looking for a   key. This extraction is shown below: The actual item is returned, [1] and cast into a C string, [2]. Finally its length is checked to be non zero to ensure there is data to be processed, [3]. This data is then passed through a combination of splitpath and makepath shown below. The resulting makepath call will put the entire filename into the filename local variable, [5]. However the user supplied string, [4], is not checked to ensure it does not overstep this boundary. This results in a stack based buffer overflow and an exception triggered. Due to the overflow the exception handlers have been overwritten giving direct control of the program. 2017-07-15 - Initial vendor contact \n2017-10-06 - Vendor Acknowledged  \n2018-04-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0374');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (167, 'Moxa AWK-3131A Multiple Features Login Username Parameter OS Command Injection Vulnerability', 'None', '2018-4-3', 'An exploitable OS Command Injection vulnerability exists in the Telnet, SSH, and console login functionality of Moxa AWK-3131A Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client in firmware versions 1.4 to 1.7 (current).  An attacker can inject commands via the username parameter of several services (SSH, Telnet, console), resulting in remote, unauthenticated, root-level operating system command execution. Moxa AWK-3131A Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client versions 1.4 - 1.9 In addition, versions prior to 1.4 appear similarly vulnerable to injection, but not as easily exploitable (described below).  Other models in the AWK product line may likewise be vulnerable but have not been tested. 10.0 (Critical) - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\')\nhttps://cwe.mitre.org/data/definitions/78.html The Moxa AWK-3131A Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client is a wireless networking appliance intended for use in industrial environments.  The manufacturer specifically highlights automated materials handling and automated guided vehicles as target markets. It is possible to remotely inject operating system commands, without authentication, which the device will execute with root privileges. The vulnerability appears to be a result of code which creates a log of failed authentication attempts.  Any failed login of a service that relies on Busybox loginutils will trigger code similar to the following: Versions 1.4 - 1.7 The input from the username field is passed as to an argument to iw user, which is then passed to system(), allowing for command injection. Disassembly of some relevant code for a failed console login: When OS commands are injected in the username field of a login, execution of the command can be identified in the process list, as shown below. For example, when injecting   via Telnet, the below process will execute. Exploitation of this vulnerability has been confirmed via Telnet, SSH, and the local console port.  It is suspected that the web application may also be vulnerable as it relies on loginutils and examination of the iw user binary reveals \"fail\" messages for \"WEB\", \"TELNET\", and \"SSH\". By default, the device displays stderr output to the console, even without authentication.  Redirecting stdout to stderr (using  ) allows the attacker to receive console output when injecting OS commands. Older versions of the firmware (1.3 and earlier) appear vulnerable but not as easily exploitable.  For example, entering   or   via the console port on version 1.0 will cause the console to hang/freeze and requires a power cycle to recover.  The differences in exploitability between versions is likely due to a slight difference in the way in which log events were generated in v1.4 and earlier. Versions 1.0 - 1.4 The simplest proof-of-concept involves entering sh enclosed by backticks as the username of either the Telnet or console port login prompt.  The result is temporary remote shell access with root privileges. Redirecting stdout to stderr will provide console output to the attacker. The below example injects the reboot command in the login parameter via SSH, causing the device to reboot. A backslash is used before each backtick. Bypassing space limitations and input filters to upload and execute code To significantly mitigate risk of exploitation disable all remote services prior to the device being deployed. This includes SSH, Telnet, and the web application. An attacker with physical access may still exploit the vulnerability via the device\'s console port; physical access should be restricted. With all remote services disabled, making remote configuration changes or firmware updates may require that the device be reset to factory defaults following the processes outlined in the device documentation.  Ensure that the device configuration is exported prior to disabling remote services as it may be necessary to restore the configuration after a reset. 2017-12-21 - Vendor Disclosure \n2018-04-03 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0507');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (168, 'Allen Bradley Micrologix 1400 Series B Ethernet Card Malformed Packet Denial of Service Vulnerability', 'None', '2018-3-28', 'An exploitable denial of service vulnerability exists in the Ethernet functionality of the Allen Bradley Micrologix 1400 Series B FRN 21.2 and below. A specially crafted packet can cause a device power cycle resulting in a fault state and deletion of ladder logic. An attacker can send one unauthenticated packet to trigger this vulnerability. Allen Bradley Micrologix 1400 Series B FRN 21.2\nAllen Bradley Micrologix 1400 Series B FRN 21.0\nAllen Bradley Micrologix 1400 Series B FRN 15 8.6 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H CWE-248: Uncaught Exception If a packet containing the bytes 0xe8 0xff in position 3 and 4 (referred to here as the crash section) is sent to a Micrologix 1400 over port 44818/TCP, it will cause the PLC to power cycle, enter a fault state, and clear the existing ladder logic. The device will additionally follow the same crash procedure if there is a multiple of 24 null bytes sent before the crash section. This vulnerability can be triggered without authentication over a network, provided that the device is accessible over port 44818 (default). Send the packet displayed below to the device over TCP port 44818 Where  is the ip address of the device Additionally, the crash can be triggered by prepending any number of 24 byte blocks of null characters to the crash string. 2017-09-22 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0440');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (169, 'Allen Bradley Micrologix 1400 Series B Ladder Logic Program Download Device Fault Denial of Service Vulnerability', 'None', '2018-3-28', 'An exploitable denial of service vulnerability exists in the program download functionality of Allen Bradley Micrologix 1400 Series B FRN 21.2 and before. A specially crafted packet can cause a device fault resulting in halted operations. An attacker can send an unauthenticated packet to trigger this vulnerability. Allen Bradley Micrologix 1400 Series B FRN 21.2\nAllen Bradley Micrologix 1400 Series B FRN 21.0\nAllen Bradley Micrologix 1400 Series B FRN 15 8.6 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H CWE-399 - Resource Management Errors When a new program is downloaded to the PLC it must go through a specific routine to obtain and lock the editing rights for the PLC. If errors are encountered during that process, the PLC enters a fault state. By sending the \'Execute Command List\' packet used during a standard download process without the accompanying \'download complete\' packet, we can force the device to halt in the download state for one minute and then transition into the fault state.    Where the elements are as follows: NOTE: If testing against a real device, the PLC must be in the REMOTE keyswitch mode 2017-09-22 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0441');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (170, 'Nvidia D3D10 Driver Pixel Shader Heap Memory Corruption Vulnerability', 'None', '2018-3-28', 'An exploitable heap memory corruption vulnerability exists in the NVIDIA D3D10 Driver 22.21.13.8607. A specially crafted pixel shader can cause heap memory corruption, resulting in at least denial of service, and potential code execution. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability is present in the Nvidia Driver and can be triggered on a regular system as well as from a VMware guest, and the VMware host will be affected (potentially leading to VMware crash or guest-to-host escape) NVIDIA nvwgf2umx.dll 22.21.13.8607 (x64) on Windows 10 x64\nVMware Workstation 14 (14.0.0 build-6661328) with Windows 10 x64 as guestVM 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) to the NVIDIA nvwgf2umx.dll driver. Such an attack can be triggered from a local machine (usermode), from a VMware guest usermode (to cause memory corruption on VMware host) or theoretically through WEBGL (remote website) — assuming the browser will not use ANGLE, and will somehow supply the malformed shader to the vulnerable NVIDIA driver. A specifically crafted shader file causes the nvwgf2umx.dll driver to write data beyond the designated heap memory region. This happens in the following code: Note how the heap destination region is calculated (instructions at 0x025C7A6-0x25C7B3). As you can see, there is an index value that is increased every time the \"preBUG_BUG\" function is called (instruction at 0x25C83A). This index is multiplied by 0xB0 (imul instruction) and added to the correct heap memory region address. This calculated memory address is used for further write operations. An attacker can control the number of times this function (preBUG_BUG) will be executed. This is achieved by the structure of the supplied shader itself. Therefore, when the index is high enough, a memory corruption will occur. The memory corruption itself is done through memset(dest, 0, 0xB0) inside a different function, and by single dword memory writes, like at 0x25C7C8. Whether such \"limited\" control for the attacker is enough to turn this bug into code execution is questionable, but cannot be excluded entirely. 2018-01-22 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0514');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (171, 'Allen Bradley Micrologix 1400 Series B Unauthenticated Data/Program/Function File Improper Access Control Vulnerability', 'None', '2018-3-28', 'An exploitable access control vulnerability exists in the data, program, and function file permissions functionality of Allen Bradley Micrologix 1400 Series B FRN 21.2 and before. A specially crafted packet can cause a read or write operation resulting in disclosure of sensitive information, modification of settings, or modification of ladder logic. An attacker can send unauthenticated packets to trigger this vulnerability. Allen Bradley Micrologix 1400 Series B FRN 21.2\nAllen Bradley Micrologix 1400 Series B FRN 21.0\nAllen Bradley Micrologix 1400 Series B FRN 15 10 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-284: Improper Access Control Numerous files within the PLC contain permissions that allow for read and/or write access by unauthenticated users. With this access it is possible to do things such as change ladder logic, insert invalid values, trigger device faults, determine the master password and read the PLC\'s ladder logic. This can be accomplished through use of CIP encapsulated PCCC commands using any of the function codes associated with reading to a file (0xa1, 0xa2) or writing to a file (0xa7, 0xa9, 0xaa, 0xab). Below is a description of notable discovered exploitable conditions. Required Keyswitch State: REMOTE or PROG (also RUN for some)\nDescription: Allows an attacker to enable SNMP, Modbus, DNP, and any other features in the channel configuration. Also allows attackers to change network parameters, such as IP address, name server, and domain name. Required Keyswitch State: REMOTE or PROG\nAssociated Fault Code: 0012\nFault Type: Non-User\nDescription: A fault state can be triggered by overwriting the ladder logic data file (type 0x22 number 0x02) with null values. Required Keyswitch State: REMOTE or PROG\nAssociated Fault Code: 0001\nFault Type: Non-User\nDescription: A fault state can be triggered by setting the NVRAM/memory module user program mismatch bit (S2:9) when a memory module is NOT installed. Required Keyswitch State: REMOTE\nDescription: Any input or output can be forced, causing unpredictable activity from the PLC. Required Keyswitch State: REMOTE or PROG\nDescription: The filetype 0x03 allows users write access, allowing the ability to overwrite the Master Password value stored in the file. Required Keyswitch State: REMOTE\nDescription: Live rung edits are able to be made by an unauthenticated user allowing for addition, deletion, or modification of existing ladder logic. Additionally, faults and cpu state modification can be triggered if specific ladder logic is used. Required Keyswitch State: REMOTE or PROG\nDescription: This ability is leveraged in a larger exploit to flash custom firmware Required Keyswitch State: REMOTE or PROG\nAssociated Fault Code: 0028\nFault Type: Non-User\nDescription: Values 0x01 and 0x02 are invalid values for the user fault routine. By writing directly to the file it is possible to set these values. When this is done and the device is moved into a run state, a fault is triggered. NOTE: This is not possible through RSLogix. Required Keyswitch State: REMOTE or PROG or RUN\nDescription: The value 0xffffffff is considered NaN for the Float data type. When a float is set to this value and used in the PLC, a fault is triggered. NOTE: This is not possible through RSLogix. Required Keyswitch State: REMOTE or PROG\nAssociated Fault Codes: 0023, 002e, and 0037\nFault Type: Recoverable\nDescription: The STI, EII, and HSC function files contain bits signifying whether or not a fault has occurred. Additionally there is a bit signaling the module to auto start. When these bits are set for any of the three modules and the device is moved into a run state, a fault is triggered. Required Keyswitch State: Any\nDescription: Requests a specific set of bytes from an undocumented data file and returns the ASCII version of the master password Required Keyswitch State: Any\nDescription: Reads the encoded ladder logic from its data file and print it out in HEX PoCs for each of the above documented elements are grouped into the below script. Follow the usage guidance below or that contained within the script and choose the command associated with the condition you want to cause. Usage: python .py -i  [-p ] -c \nWhere the elements are as follows: Valid Write Commands:\n enable ip logic        :  overwrites all ladder logic with null bytes\n nvram output           :  forces O0:0/0 on\n force master edit            :  modifies ladder logic to perform a divide by 0\n load module err :  sets S2:1/10 allowing program load from EEPROM\n fault fault    :  sets the fault routine to an invalid value (0x01)\n write nan        :  sets F8:0/0 to NaN (0xffffffff), causing a fault\n invalid fault      :  sets the \'Auto Start\' and \'Error Detected\' bit\n invalid fault      :  sets the \'Auto Start\' and \'Error Detected\' bit\n invalid fault      :  sets the \'Auto Start\' and \'Error Detected\' bit Valid Read Commands:\n read logic      :  returns the master password in ASCII\n read password   :  returns the encoded ladder logic in HEX 2017-09-22 - Vendor Disclosure \n2018-03-28D - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0443');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (172, 'Nvidia D3D10 Driver Pixel Shader Functionality Denial Of Service', 'None', '2018-3-28', 'An exploitable denial-of-service vulnerability exists in the Nvidia D3D10 Driver 22.21.13.8607. A specially crafted pixel shader can cause a stack overflow exception, resulting in at least denial of service. An attacker can provide a specially crafted shader file (either in binary or text form) to trigger this vulnerability. This vulnerability is present in the Nvidia Driver and can be triggered on a regular system as well as from a VMware guest, and will affect a VMware host (leading to the vmware-vmx.exe process to crash on the host). Nvidia nvwgf2umx.dll 22.21.13.8607 (x64) on Windows 10 x64\nVMware Workstation 14 (14.0.0 build-6661328) with Windows 10 x64 as guestVM 7.7 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H CWE-674: Uncontrolled Recursion This vulnerability can be triggered by supplying a malformed pixel shader (in text or binary form) to the Nvidia nvwgf2umx.dll driver. Such an attack can be triggered from local machine (usermode), from VMware guest usermode (to cause a memory denial-of-service attack on vmware-vmx.exe process on host) or theoretically through WEBGL (remote website) — assuming the browser will not use ANGLE, and will somehow supply the malformed shader to the vulnerable Nvidia driver. In short, it is possible to create a shader in such a way that it will cause a function (sub_038B150) to call itself recursively without any validation of the number of recursions/stack memory borders,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \\\\\\   which finally leads to denial of service due to stack memory exhaustion. Attached to the package 2018-02-06 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0522');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (173, 'Allen Bradley Micrologix 1400 Series B PLC Session Communication Insufficient Resource Pool Denial of Service Vulnerability', 'None', '2018-3-28', 'An exploitable insufficient resource pool vulnerability exists in the session communication functionality of Allen Bradley Micrologix 1400 Series B Firmware 21.2 and before. A specially crafted stream of packets can cause a flood of the session resource pool resulting in legitimate connections to the PLC being disconnected. An attacker can send unauthenticated packets to trigger this vulnerability. Allen Bradley Micrologix 1400 Series B FRN 21.2\nAllen Bradley Micrologix 1400 Series B FRN 21.0\nAllen Bradley Micrologix 1400 Series B FRN 15 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L CWE-410: Insufficient Resource Pool The Micrologix 1400 can support up to ten active connections at any point in time. When ten active connections already exist and another connection request comes in, the PLC will disconnect the oldest connection and allow the new connection. By creating a loop of \'Register Session\' packets (the same kind used by RSLinx to create a connection) it is possible to disconnect an existing RSLinx/RSLogix session, preventing the user from accessing the PLC. When this occurs the PLC continues to operate in whatever state it was previously in. A user in an online RSLogix session will be notified that their connection has been disconnected through the normal communications loss alert. Within this alert the user has the ability to reconnect. If this is done the new RSLogix session will push out one of the malicious sessions, however if the malicious \'Register Session\' packets are flooding the system, the legitimate session will quickly be pushed out of the queue again. Usage: python .py -i  [-p ] [-n ]\nWhere the elements are as follows:\n-    :  whatever name you give the script\n-     :  ip address of the plc\n-        :  EtherNet/IP port (defaults to 44818)\n-  :  the number of packets to send (defaults to 10000) 2017-09-22 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0445');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (174, 'Allen Bradley Micrologix 1400 Series B Memory Module Store Program File Write Vulnerability', 'None', '2018-3-28', 'An exploitable file write vulnerability exists in the memory module functionality of Allen Bradley Micrologix 1400 Series B FRN 21.2 and before. A specially crafted packet can cause a file write resulting in a new program being written to the memory module. An attacker can send an unauthenticated packet to trigger this vulnerability. Allen Bradley Micrologix 1400 Series B FRN 21.2\nAllen Bradley Micrologix 1400 Series B FRN 21.0\nAllen Bradley Micrologix 1400 Series B FRN 15 3.7 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N CWE-200: Information Exposure When a memory module is installed in a Micrologix 1400, it is possible to instruct the PLC to write its program to that module without authentication. A program that is written to the memory module can be used in a few different ways: as just a backup, as the program to load when an error occurs, and as the program to load every time the device powers on. By leveraging unauthenticated file write vulnerabilities and the device crash vulnerability in conjunction with this write, it is possible to change device settings and flash new firmware. Usage: python .py -i  [-p ]\nWhere the elements are as follows:\n-   :  whatever name you give the script\n-    :  ip address of the plc\n-       :  EtherNet/IP port (defaults to 44818) Simply disabling EtherNet/IP on the device through RSLogix will not prevent this attack as it uses a different technique from that used in standard traffic. While the above technique is used during legitimate operations, this activity should be rare and should not occur without the knowledge of the PLC operators. As such, monitoring of traffic to and from the Micrologix 1400 and other sensitive hosts is recommended. Further, organizations should implement proper network segmentation to help prevent unauthorized users from accessing the PLC. 2017-09-22 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0444');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (175, 'Allen Bradley Micrologix 1400 Series B SNMP-Set Processing Incorrect Behavior Order Denial of Service Vulnerability', 'None', '2018-3-28', 'An exploitable denial of service vulnerability exists in the processing of snmp-set commands of the Allen Bradley Micrologix 1400 Series B FRN 21.2 and below. A specially crafted snmp-set request, when sent without associated firmware flashing snmp-set commands, can cause a device power cycle resulting in downtime for the device. An attacker can send one packet to trigger this vulnerability. Allen Bradley Micrologix 1400 Series B FRN 21.2\nAllen Bradley Micrologix 1400 Series B FRN 21.0\nAllen Bradley Micrologix 1400 Series B FRN 15 7.7 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H CWE-696: Incorrect Behavior Order During a firmware update, the SNMP OID .1.3.6.1.4.1.95.2.3.1.1.1.1.0 gets set to the integer 2 right before the device reboots and enters the flashing state. If only this SNMP request is sent, the device will still perform a reboot without attempting to perform any flashing operations. Firmware versions 16.2 and below support this functionality with both SNMPv1 and SNMPv2c, however as of firmware version 21.0 it is only supported in SNMPv1. While this vulnerability requires a priviliged SNMP community string to exploit, it is possible to use the backdoor priviliged string \'wheel\' disclosed in CVE-2016-5645 (TALOS-2016-0184) to perform the snmp-set operation even if the \'private\' string has been changed. Set the OID value to 2 using snmpset Where  is the ip address of the device Additionally, the following script can be used to trigger the condition. The process is the same for both PoCs. Usage: python .py -i  [-p ] [-c ]\nWhere the elements are as follows: 2017-09-22 - Vendor Disclosure \n2018-03-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0442');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (176, 'VMware VNC Lock Count Denial of Service Vulnerability', 'None', '2018-3-15', 'An exploitable Denial of Service vulnerability exists in the remote management functionality of VMware . A large amount of VNC connections can cause an exception in the server to trigger, resulting in a shutdown of the virtual machine. An attacker can initiate VNC sessions to trigger this vulnerability. VMware Workstation Pro 12.5.7, Linux/Windows 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-772: Missing Release of Resource after Effective Lifetime VMware\'s VNC implementation is used for remote management, remote access, and automation purposes in VMware products, such as Workstation, Player, and ESXi, which share a common VMW VNC code base between them all. Since the VMware VNC server is naturally multi-threaded, there are locks and semaphores and mutexes to deal with shared variables. The VNC server also maintains a global variable that indicates the amount of locks that are currently used, that is incremented by certain events. The relevant disassembly is listed below: The above truncated disassembly is called at least twice in the course of any VNC connection, which, to summarize, just checks to makes sure there isn\'t a really large number of locks,  since that would be bad. Presumably. Regardless, the important thing to note here is that the incrementing instruction (lock xadd cs:MxLockCounter, eax;) is the only cross-reference to the MxLockCounter global variable, meaning it never gets decremented. Thus, as long as and attacker can initiate a bunch of TCP connection to the VNC server (each successful connection increments it twice), without even sending any other datagrams, an attacker can eventually shutdown the connected virtual machine. 2017-07-13 - Vendor Disclosure \n2018-03-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0376');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (177, 'Dovecot IMAP Server rfc822_parse_domain Information Leak Vulnerability', 'None', '2018-3-1', 'An exploitable out of bounds read vulnerability exists in the RFC822 parser as implemented in Dovecot IMAP Server 2.2.33.2. A specially crafted email delivered over SMTP and passed on to Dovecot by MTA can trigger an out of bounds read resulting in potential sensitive information disclosure and denial of service. In order to trigger this vulnerability, an attacker needs to send a specially crafted email message to the server. Dovecot IMAP Server 2.2.33.2 5.9 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:H CWE-125: Out-of-bounds Read Dovecot is a very popular IMAP server with performance and security oriented design. In combination with Postfix as its mail transfer agent, it is a popular choice for robust email servers. When an email is delivered by MTA to the mailbox, Dovecot parses and indexes it for fast retrieval. Parsing of email messages marked with content type “rfc822” will eventually call the function   when   and   fields are encountered. Messages can have multiple of these fields and each need to be parsed separately. Also, according to the RFC, address fields can have quoted strings, comments, complex domains… so the parser isn’t straightforward. Three interesting functions are called after  , namely:  ,   and  . If we take a closer look at   we can see the following: In the above code, at [1], exit condition of the   loop checks to make sure   doesn’t get past   before it’s incremented. No check is performed to make sure   doesn’t point past   before entering the for loop. Indeed, if we take a look at   (an indirect caller of  ) we can see the following code: In the above code, at [2] a check is made against   currently pointing to   character. At [3]   pointer is incremented unconditionally. Note that no check is performed to ensure   isn’t past   at this point. Further calls at [4], [5] and after the function returns end up calling  ,   and   where this vulnerability manifests itself. For example, in order to trigger the vulnerability in function   an email with following content can be sent:   Content-Type: message/rfc822   From: aaaa@(\n  From: a(aa Note that the length of the second   value is just 4, but due to the way Dovecot reuses memory buffers, the second string will actually overwrite the first. In memory , this will actually become   since the actual copied string isn’t null terminated. In general, this isn’t a problem, because   pointer will keep the parser from reaching out of bounds. But in this special case, condition [2] in the previously quoted code will be satisfied, and since   is already equal to   , at [3] it will be incremented past it. When   is called, the for loop at [1] will be entered with an already invalid condition, as   is already higher than  , causing an almost unbounded out-of-bounds read. Due to the break conditions present in the for loop, if a closing bracket is encountered in the memory, a loop will terminate, otherwise it will crash when it hits a guard page. A simple way of testing this is via   program in the testsuite. Similarly, to trigger this vulnerability in   a following message can be sent:   Content-Type: message/rfc822   From: aaaaaaaaaaa@[\n  From: aaa(aaaaaaa In the above, a similar alignment to   character causes the problem, but the opened   bracket causes the bug to manifest in  . Again, to trigger this vulnerability in   a following message can be sent:   Content-Type: message/rfc822   From: a@,\"\n  From: \" Same alignment, just using a quoted string instead of round brackets. An example SMTP exchange that actually delivers the malformed email messages to the mailbox can be as follows:   HELO smtpserver\n  MAIL FROM: attacker@nevermind\n  RCPT TO: victim@smtpserver\n  data\n  From: attacker@nevermind\n  Subject: test\n  Content-Type: message/rfc822   From: aaaa@(\n  From: a(aa This vulnerability can potentially be abused to leak sensitive information from the process. In order to do so, an authenticated IMAP server user needs to invoke specific commands to trigger the vulnerable code path in the parser. As mentioned previously, if a condition to break out of the   loop in the functions where the bug manifests itself is satisfied (a closed bracket somewhere in the memory past the end of buffer) additional heap memory can be returned to the user, including memory pointers possibly other sensitive information. An example set of commands sent to the IMAP server that trigger this behaviour can be :   a login user password\n  x select inbox\n  x UID SEARCH ALL\n  x UID FETCH 57 (BODYSTRUCTURE) After the last command, the server will reply with body structure of the message, which can leak information from heap. Due to the design of Dovecot, in most usual configurations, the information leak side of this vulnerability is partially mitigated by the fact that the vulnerable code is invoked in the low privileged   process which has limited to no access to sensitive data. However, this can potentially be abused as an info leak component when exploiting another vulnerability in order to bypass other exploit mitigations. Address sanitizer output for   case:   SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/user/dovecot/core/src/lib-imap/test-imap-bodystructure+0x512f3d)\n  Shadow bytes around the buggy address: Address sanitizer output for   case:   SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/user/dovecot/core/src/lib-imap/test-imap-bodystructure+0x51613a)\n  Shadow bytes around the buggy address:   Shadow byte legend (one shadow byte represents 8 application bytes): Address sanitizer output for   case:   SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/user/dovecot/core/src/lib-imap/test-imap-bodystructure+0x515136)\n  Shadow bytes around the buggy address:   Shadow byte legend (one shadow byte represents 8 application bytes): 2017-12-22 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0510');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (178, 'Simple DirectMedia Layer SDL2_image ILBM CMAP Parsing Code Execution Vulnerability', 'None', '2018-3-1', 'An exploitable code execution vulnerability exists in the ILBM image rendering functionality of SDL2_image-2.0.2. A specially crafted ILBM image can cause a stack overflow resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators, including “Angry Birds”, “Unreal Tournament”, “VisualBoyAdvance” and “VLC”. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120.  The LibSDL2_Image library subcomponent deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When reading an ILBM file to be displayed, as per the ILBM file format (https://en.wikipedia.org/wiki/ILBM#BMHD: Header)[ https://en.wikipedia.org/wiki/ILBM#BMHD: Header], a “CMAP” attribute must be parsed. LibSDL2_Image does this by doing a memcmp of four bytes with the current offset into the file read, and then reading the following bytes into the colormap variable with the following code: The SDL_Rwread function is essentially a call to fread as such: Unfortunately, the size variable, which determines how much is read from the image file into the colormap stack variable, has no checks on it whatsoever. It\'s taken as 4 bytes straight from the file [1] and then reversed in byte order [2]. As mentioned before, once a “CMAP” tag is found inside of the file, it will attempt to copy \'size\' bytes into the &colormap, which is defined as such: With the MAXCOLOR macro defined as 255. Thus, for any \'size\' variable greater than 0x300,  there will be an unrestricted stack based overflow with attacker controlled data. 2017-11-28 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0489');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (179, 'Simple DirectMedia Layer SDL2_Image IMG_LoadLBM_RW Code Execution Vulnerability', 'None', '2018-3-1', 'An exploitable code execution vulnerability exists in the ILBM image rendering functionality of SDL2_image-2.0.2. A specially crafted ILBM image can cause a heap overflow resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When LibSDL2 Image first looks for the Bitmap Headers of the file, and then reads the values into a BMHD structure. This looks like such: The above 0x28 bytes of a ILBM file will result in a bmhd structure (size 0x14) as such:\ntype = struct { With the input essentially being a direct read from the file into the structure. After this read has been performed, LibSDL2 Load_RW functions that the data is converted correctly from the given  to the RGBSurface type, which is given as follows: Which is created by the following line of code, converting from bmhd to SDL_Surface: During runtime of the crash, this ends up looking like: The SDL Surface is what contains the actual RGB data, and this is stored inside of the SDL Surface, which is defined as such: The SDL_Color *color array contains the raw bit data, and is allocated by the following line: The size of a given SDL AllocPalette function, and is given by (1<<0x8 == 0x100): The BitsPerPixel field is taken from the depth parameter passed into SDL malloc is (0x4 * (1<<0x8)), or 0x400. Interestingly, when the data is actually taken from the file and thrown into the heap data of size 0x400, the following loop occurs: The nbrcolorsfinal variable is populated with the following code: The assumption is that the bmhd.planes (which is 0x15 in our structure) corresponds exactly with the depth parameter passed to SDL REAL, such that the structure has enough space allocated to store the raw rgb data, however this assumption is not true for all bhmd.plane\nvalues: It is only true if the Uint8 planes field is equal to 24 or is less than 8 (assuming the flagHAM flag is not set), providing another value results in a constrained heap overflow of user controlled data during the color population loop that was previously listed. 2017-11-28 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0488');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (180, 'Simple DirectMedia Layer SDL2_image do_layer_surface Double-Free Vulnerability', 'None', '2018-3-1', 'A double-Free vulnerability exists in the XCF image rendering functionality of SDL2_image-2.0.2. A specially crafted XCF image can cause a Double-Free situation to occur. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-415: Double Free LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When reading in an XCF file, the file type used natively by GIMP, LibSDL2 must read in all the layers of the image before rendering them on top of each other, and then blitting them directly to the SDL surface. A portion of the code is given below: Given offsets from the file, the program seeks to that spot and reads an XCF Layer, which is then parsed, resulting in the memory therefore being allocated and written, inside of [2]. Further more, a hierarchy object is created from the \'hierarchy offset\' inside of the layer object. The definitions for both of these structures are given below: Of most interest is the \'bpp\' field inside of the hierarchy struct at [1]. When this is set to 0x2, assuming that the rest of the layer parses correctly, the code ends up at a peculiar switch statement. The image controls the head->image type is not IMAGE GREEYSCALE, then the code frees hierarchy->level offsets at [2], and then calls free hierarchy at [3]. The source for free hierarchy is given below: And as given at [1], the code ends up freeing the same level offsets hierarchy as before, resulting in a double free vulnerability. It is questionable whether or not this code path has ever been hit or reviewed before, given the relative lack of distance between the two frees. It should be noted that most modern implementations of malloc in system libraries will catch a double free error and throw an assertion error immediately, however, this is dependent on the memory allocator that developers may use when linking with this library. 2017-11-28 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0498');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (181, 'Simple DirectMedia Layer SDL2_image Image Palette Population Code Execution Vulnerability', 'None', '2018-3-1', 'An exploitable code execution vulnerability exists in the BMP image rendering functionality of SDL2_image-2.0.2. A specially crafted BMP image can cause a stack overflow resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When reading in a BMP file, libSDL2_Image must populate a color palette object for the image.\nAs per the BMP file format, one of the headers read in is the “biClrUsed” field, which designates how many colors are within the color palette. This is read by the following code: At [1], the biClrUsed field is read in as an unsigned 32-bit integer. After this, the variable is never mentioned again, at least until it is used to populate the palette array as such: Since there isn\'t any validation on the “biClrUsed” field at all, the result is a stack based buffer overflow completely under control of an attacker. 2017-11-28 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0491');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (182, 'Simple DirectMedia Layer SDL2_image ICO Pitch Handling Code Execution Vulnerability', 'None', '2018-3-1', 'An exploitable code execution vulnerability exists in the ICO image rendering functionality of SDL2_image-2.0.2. A specially crafted ICO image can cause an integer overflow, cascading to a heap overflow resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When reading in an ICO file, in order to allocate enough space for the input, the dimensions of the image, as read from the image headers, will obviously be used. The interesting thing is that for a lot of image types, this is not simply (height * width), as one would expect, it\'s actually (width * pitch). Pitch is the distance in bytes between two memory addresses that represent the beginning of one bitmap line and the next, essentially resulting in: pitch = (width + padding), which is usually just done for alignment reasons. The pitch is calculated inside of LibSDL with the following function: If we look at how the values   and surface->format->BytesPerPixel are read in, we can see that there are not really any checks on the BytesPerPixel field: Or the   file (which is 4 bytes read straight from the image): Thus, going back to how the pitch is generated: We can easily input a width and BytesPerPixel that cause an integer overflow, for example, if width == 0x40000020, and BytesPerPixel == 0x80, then the resulting pitch will be (0x2000001000 & 0xFFFFFFFF), or 0x1000, since the pitch field is a 32-bit integer, resulting in a huge desync between the width and pitch variables, which will come into play in the following function: The above code is the only check on the resulting size of the pallet buffer. Notice that the pitch is used to generate the allocated buffer, and also that there is no check on the width of the surface. This results in the following allocation at src/video/SDL_surface.c+107: The actual corruption of the heap is within the following loop: Starting at the bottom of the pixel buffer [1], the image is read in backwards, as it attempts to unpack the raw data into the allocated buffer. Unfortunately, it uses the surface->w parameter [2] to determine how long each bitmap line is, which was never checked or validated. Thus, when the program actually writes the data, the counter variable   will eventually pass the allocated heap boundaries causing an OOB write at [3]. An example of this in action is given below: Whereby the heap metadata struct becomes controlled by the attacker (0x22aa2b0->0x22aa2c0 in this example). 2017-11-28 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0490');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (183, 'Simple DirectMedia Layer SDL2_image load_xcf_tile_rle Decompression Code Execution Vulnerability', 'None', '2018-3-1', 'An exploitable code execution vulnerability exists in the XCF image rendering functionality of SDL2_image-2.0.2. A specially crafted XCF image can cause a heap overflow resulting in code execution. An attacker can display a specially crafted image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When parsing and storing an XCF  file (the native file type for Gimp), the LibSDL2 library implements a custom RLE inflater for the compressed XCF data. The code that handlese this is listed below: From the above, it should be noted that the  , , and   parameters are all under the file\'s control, and also that the   parameter is calculated from  .  At [1], memory is allocated to read in the compressed RLE data at [2]. Interestingly, the reallen parameter is never checked, so if the read fails, this RLE decompression will occur on the bytes already located in memory. At [3], space is allocated for the decompressed pixel data to be written. As expected, the size is the dimensions multiplied by the bytes-per-pixel. The code then proceeds to loop and populate the pixel data in the new buffer. Continuing from the previous code: The outer loop at [1] designates that it is writing to the i\'th byte for each pixel. Thus, if there are 8 bytes per pixel, the loop is going to be writing to the 0th,8th,16th.... N bbp\'th byte has been written to or not. Continuing on from this block: Using the \'size\' variable to determine how many pixels have been written to, the code starts to read in the RLE compressed data and write to the newly allocated memory at \'data\'. The first byte read at [1], \'length\', is used to determine how many pixels to write into the image. There are three different cases for this byte, the above code covers the cases of \'length\' >= 0x80.  If \'length\' > 0x80, then the length is two\'s complimented and the program assumes that the following data has not been compressed, and writes in different consecutive bytes. For example, if the following byte sequence was first read in, 0xFE 0xAA 0xBB, then the program would write 0xAA to the i\'th byte of the allocated image memory, and 0xBB to the (x*bpp)+i  byte, for x in range(0,length). After this, the program would look for another \'length\' byte, since (0xFF – (0xFE-1)) == 2. If the \'length\' byte is 0x80, this designates that the program must read in the next two bytes as the length instead. Thus, for the byte sequence 0x80 0x30 0x30 0xAA 0xBB... The program would read in 0x3030 as the amount of bytes to write, and then write 0xAA to the i\'th byte, 0xBB to the (length bpp)+i. In cases where \'length\' < 0x80, it\'s almost the same, except that the program assumes a compressed string of pixel data. Thus, for a byte sequence of 0x7f 0x30 0x30 0xAA, the program would write 0x30 to i\'th byte of the first 0x7f pixels, and then 0xAA to the i\'th byte of the next 0x30 pixels. But before all this writing occurs at [2], after the bytes have been parsed, the size variable is decremented by the length variable at [1]. Remember that the \'size variable is used to determine if the program should use to continue writing. Unfortunately, there are no checks in between the size subtraction and the data writing, so if the length variable goes past the total size of the allocated buffer, the write will still occur, resulting in a heap-based overflow. Program received signal SIGSEGV, Segmentation fault.\n0x00007ffff784a196 in load tile xcf.c:510\nwarning: Source file is more recent than executable.\n510             size -= length;\n---------------[ registers ]----\n$rax   : 0x0000000000c8d000\n$rbx   : 0x0000000000000000\n$rcx   : 0x00007ffff781f620 -> 0x0000000100000000\n$rdx   : 0x0000000000000000\n$rsp   : 0x00007fffffffde80 -> 0x00007fffffffdef0 -> 0x00007fffffffdfa0 -> 0x00007fffffffe060 -> 0x00007fffffffe0a0 -> 0x00007fffffffe0d0 -> 0x00007fffffffe110 -> 0x0000000000000000\n$rbp   : 0x00007fffffffdef0 -> 0x00007fffffffdfa0 -> 0x00007fffffffe060 -> 0x00007fffffffe0a0 -> 0x00007fffffffe0d0 -> 0x00007fffffffe110 -> 0x0000000000000000\n$rsi   : 0x0000000000000039\n$rdi   : 0x00007ffff7dd4540 -> 0x000000000000003a (\":\"?)\n$rip   : 0x00007ffff784a196 -> <load tile start+0> xor ebp, ebp\n$r13   : 0x00007fffffffe1f0 -> 0x0000000000000002\n$r14   : 0x0000000000000000\n$r15   : 0x0000000000000000\n$eflags: [carry parity adjust zero sign trap INTERRUPT direction overflow RESUME virtualx86 identification]\n-------------------[ stack ]----\n0x00007fffffffde80|+0x00: 0x00007fffffffdef0 -> 0x00007fffffffdfa0 -> 0x00007fffffffe060 -> 0x00007fffffffe0a0 -> 0x00007fffffffe0d0 -> 0x00007fffffffe110 -> 0x0000000000000000        <-$rsp\n0x00007fffffffde88|+0x08: 0x0000004000000040 (\"@\"?)\n0x00007fffffffde90|+0x10: 0x0000309b00000003\n0x00007fffffffde98|+0x18: 0x0000000000c63b00 -> 0x00007ffff7aace48 -> <stdio xcf rle+260> mov    rax, QWORD PTR [rbp-0x8]\n   0x7ffff784a187 <load tile xcf rle+268> mov    QWORD PTR [rbp-0x8], rdx\n   0x7ffff784a18f <load tile xcf rle+275> mov    rax, QWORD PTR [rbp-0x10]\n->0x7ffff784a196 <load tile xcf rle+281> mov    eax, DWORD PTR [rbp-0x60]\n   0x7ffff784a19b <load tile xcf rle+286> add    QWORD PTR [rbp-0x10], rax\n   0x7ffff784a1a1 <load tile xcf rle+293> lea    edx, [rax-0x1]\n----[ source:IMG_xcf.c+510 ]---- -> 510           size -= length; -----------------[ threads ]----\n[#0] Id 5, Name: \"img plain\", stopped, reason: SIGSEGV\n[#1] Id 4, Name: \"img plain\", stopped, reason: SIGSEGV\n[#2] Id 3, Name: \"img plain\", stopped, reason: SIGSEGV\n[#3] Id 2, Name: \"img plain\", stopped, reason: SIGSEGV\n[#4] Id 1, Name: \"img plain\", stopped, reason: SIGSEGV\n-------------------[ trace ]----\n[#0] 0x7ffff784a196->Name: load tile layer tile=0x7ffff784a07f )\n[#2] 0x7ffff784ae24->Name: IMG RW(src=0xc63b00)\n[#3] 0x7ffff78287ef->Name: IMG RW(src=0xc63b00, freesrc=0x1, type=0x7fffffffe4eb \"(x Load(file=0x7fffffffe4ea \"(x_ x)\") 2017-11-28 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0497');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (184, 'Simple DirectMedia Layer SDL2_Image LWZ Decompression Buffer Overflow Vulnerability', 'None', '2018-3-1', 'A buffer overflow vulnerability exists in the GIF image parsing functionality of SDL2_image-2.0.2. A specially crafted GIF image can lead to a buffer overflow on a global section. An attacker can display an image to trigger this vulnerability. Simple DirectMedia Layer SDL2_image 2.0.2 7.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:H CWE-121: Stack-based Buffer Overflow LibSDL is a multi-platform library for easy access to low level hardware and graphics, providing support for a large amount of games, software, and emulators. The last known count of software using LibSDL (from 2012) listed the number at upwards of 120. The LibSDL2_Image library is an optional component that deals specifically with parsing and displaying a variety of image file formats, creating a single and uniform API for image processing, regardless of the type. When reading in a GIF image, LibSDL2_Image allocates a buffer of appropriate size and then proceeds to populate the buffer with the appropriate pixel data, as expected. When dealing with GIF images, the color data is LZW compressed, and decompression must naturally occur before the image data buffer can be populated. For an in-depth overview of LZW, please refer to  . Needless to say, the code for this is a little complex, so it will hopefully broken down into easier pieces below. The code starts here: The ReadImage function decompresses the GIF image via the LWZReadBytes function called at [1] and [2]. At [1], the first call is just used to initialize the state of the LWZReadBytes function, and all of the static variables inside, this is what the \'TRUE\' bool is used for. After this, LWZReadBytes is called inside of a loop at [2], to actually grab the data from the file and begin to populate the pixel data, whose code we will ignore, as the bug path leads into the LWZReadByte funtion: As mentioned, the code is going to get somewhat complex here, so heres a quick overview of the more relevant variables above: At [1], the   is given, which describes the current LZW code. This can be a value in the range of (1, 1<<code size,FALSE) call at [3]. The table variable at [4] is used to store the known LZW code sequences, and is typically known as a LZW code table. The stack variable at [5] is used to store a stack of LZW sequences, with the   pointer being assigned to the address of \'stack\' at initialization. Regardless of of all of this, the bug just mainly involves the following code segment: Assuming that the LWZ code found is greater than the clear code (0x100) at [1], the decompression algorithm will start to unpack the LWZ codes into the LWZ stack, which is done at [3]. The underlying issue lies in that, even though there\'s a check on buffer overruns at [2], if we insert a value into table[0][code] such that (table[0][code] == code && code >= clear_code), then the while loop at [1] will never exit, and   will be continually advanced past the bounds of stack variable, causing an overflow. It should be noted that there are quite a few restrictions to this OOB write,  since the \'stack\' variable is a static variable, the OOB write actually occurs in the global variable section in memory for the LibSDL2_image library, and not the stack itself, such that only other global library variables below \'stack\' can be written. Also, the values written can only be valid LWZ codes, such that the range is restricted to values (1,1<<(code_size)), as mentioned before, which is (0x1,0x200). Also of note is that the pointer being incremented is a (int  ) pointer, so the values in memory will look as such (for code 0x77):    0x7ffff782b536 <LWZReadByte+974> movsxd rdx, edx\n   0x7ffff782b539 <LWZReadByte+977> add    rdx, 0x1000\n   0x7ffff782b540 <LWZReadByte+984> lea    rcx, [rdx 1]\n   ->0x7ffff782b552 <LWZReadByte+1002> mov    DWORD PTR [rax], edx\n   0x7ffff782b554 <LWZReadByte+1004> mov    eax, DWORD PTR [rbp-0x14]\n   0x7ffff782b557 <LWZReadByte+1007> cdqe  \n   0x7ffff782b559 <LWZReadByte+1009> lea    rdx, [rax 1] 2017-11-27 - Vendor Disclosure \n2018-03-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0499');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (185, 'Adobe Acrobat Reader DC Document ID Remote Code Execution Vulnerability', 'None', '2018-2-23', 'A specific Javascript script embedded in a PDF file can cause the document ID field to be used in an unbounded copy operation leading to stack-based buffer overflow when opening a specially crafted PDF document in Adobe Acrobat Reader DC 2018.009.20044. This stack overflow can lead to return address overwrite, which can result in arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2018.009.20044 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. Adobe Acrobat Reader DC supports embedded Javascript scripts in the PDF to allow for interactive PDF forms This give the potential attacker the ability to precisely control memory layout and poses additional attack surface. When parsing a PDF file with overly large Document ID field specified in the trailer, it is parsed correctly initially, but when it’s referenced in javascript, a stack-based buffer overflow can occur when encoding the bytes to a hex string. A sample document ID: A simple one line of javascript is enough to trigger this vulnerability: Initially, the specified part of document ID field is hex-decoded into a sequence of bytes. When a   is dereferenced  in javascript, this byte sequence is encoded back into an ascii hex string again function at  . The following code is where the overflow happens: For each byte from  , two bytes are written to memory pointed to by  , while   is used to track length, no check is performed to make sure overflow doesn’t happen. This leads to write beyond the limits of the stack buffer, ultimately overwriting the return address on the stack leading to a following crash: While this function is protected with   which partially mitigates this vulnerability this protection can be bypassed leading to arbitrary code execution. 2017-12-07 -   Vendor Disclosure \n2018 -02-13 - Vendor patched \n2018-02-23 -    Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0505');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (186, 'Walt Disney Per-Face Texture Mapping faceInfoSize Code Execution Vulnerability', 'None', '2018-1-26', 'An exploitable out of bounds write vulnerability exists in version 2.2 of the Per Face Texture mapping application known as PTEX. The vulnerability is present in the reading of a file without proper parameter checking. The value read in, is not verified to be valid and its use can lead to a buffer overflow, potentially resulting in code execution. Walt Disney Animation Studios PTEX 2.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow PTEX is a texture mapping system developed by Walt Disney Animation Studios for production-quality rendering. PTEX is able to store hundreds of thousands of texture mappings in a single file. This library is used in many applications including Pixar\'s RenderMan,  giving it a large user base thus making it a valuable target. The vulnerability arises when the value,  , is read in from the file header and used without verification. At location 0, the header is being read into the structure. Then, at 1, the position of the face information is calculated and the function   is called, at 2. At 3, the   value is used directly from the header and has not been verified for validity. Looking at the   function the vulnerability becomes apparent. The value   is of the type integer, 4, thus allowing it to potentially be a negative number. If this value is negative then it will always pass the check at 5. It is then converted to a large positive number implicitly when used for reading. This allows attacker controlled data to be read in beyond the bounds of the buffer leading to a buffer overflow and an exploitable condition. There is a patch file included to check to ensure the   is greater than 0 before processing the vulnerable block. 2018-01-22 - Vendor Disclosure \n2018-01-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0515');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (187, 'Leptonica gplotMakeOutput Command Injection Vulnerability', 'None', '2018-1-22', 'An exploitable command injection vulnerability exists in the gplotMakeOutput function of Leptonica 1.74.4.\nA specially crafted gplot rootname argument can cause a command injection resulting in arbitrary code execution.\nAn attacker can provide a malicious path as input to an application that passes attacker data to this function to trigger this vulnerability. Leptonica 1.74.4 7.0 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Leptonica is an open source library mainly used for image processing and analysis.  An OS Command Injection vulnerability exists in gplotMakeOutput function. A lack of sanitization of the   field could allow an attacker to inject an arbitrary command which is later executed via the   function. Let us take a closer look at the vulnerable function: At   we can see a call to the   function which takes   as parameter. This variable is created based on the   application name and the content of the   field.\nThe   field is initialized inside the   function : At   we see that the argument   is copied to  . The variable   should represent the root path name for all plotting operations, but\nbecause this parameter can be dynamically set based on data coming from a user it should be sanitized..\nA malicious user can create a path containing one of several special characters [ | , &,   ] which allows for adding additional command and which in consequence can lead to arbitrary code execution. 2018-01-22    -  Vendor Disclosure \n2018-02-01    - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2018-0516');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (188, 'Tinysvcmdns Multi-label DNS mdns_parse_qn Denial Of Service Vulnerability', 'None', '2018-1-17', 'An exploitable NULL pointer dereference vulnerability exists in the tinysvcmdns library version 2017-11-05. A specially crafted packet can make the library dereference a NULL pointer leading to server crash and denial of service. An attacker needs to send a DNS query to trigger this vulnerability. tinysvcmdns 2017-11-05 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-476: NULL Pointer Dereference The tinysvcmdns library is a MDNS responder implementation optimized for size, and is essentially a mini and embedded version of Avahi or Bonjour. The   function in   is used to continuously send and receive MDNS packets: At [1] data is received and stored in  , which is then sent to function   at [2] for parsing.\n  will return the parsed packet as an   structure which is later processed at [3] by  .  in   internally allocates space for the new   structure at [4] which is populated by calling   at [5] for every defined question (the   field).\nNote that   is used to keep track of the position of the current MDNS query to parse within the raw packet buffer.  is used for parsing the MDNS questions section of the packet buffer. At [6] the function   is called and its return value is stored in the   field of the new   at [7]. The   function is used to parse a name label and return its uncompressed form. The compression format implemented is described in RFC 1035.\nThis function takes as parameter the packet buffer, its size, and the offset in the packet where the label to uncompress is found. The check at [8] ensures that the offset specified is within the bounds of the packet buffer. If the offset is out of bounds, NULL is returned.\nAs we can see, no checks are performed at [6] on the return value of  , thus allowing for storing NULL in   at [7]. Later on, the   field could get dereferenced, causing a denial of service. Indeed this happens inside  , which is called at [3], right after the packet is parsed. Note that other paths that lead to a NULL dereference might exist. The function cycles over the list of parsed MDNS queries, and extracts at [9] the name of an   using  . As we can see   doesn\'t expect to receive a NULL   since it is dereferenced at [10]. The following proof of concept shows how to crash the tinysvcmdns daemon. The packet is composed as follows: Since no \"question\" chunk is defined at the end of the packet,   will be equal to   and this will make   return NULL. 2017-11-12 - Vendor Disclosure \n2018-01-16 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0486');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (189, 'Blender Sequencer imb_loadiris Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the IRIS loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads an IRIS file as a resource for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. When loading a   file, the following function,  , will be called. This function will first verify that the file-magic of the file matches the required one for the IRIS file format [6]. Afterwards, the header will be read at [7]. This header contains the values that will be used to trigger the integer overflow. After reading and validating the magic within the header, the following code will be executed. This will be used to determine how the image data that is decoded is stored. First, the image is checked if it\'s encoded with run-length-encoding followed by checking the bits-per-pixel [8] of the header. Within the provided proof-of-concept, the value read from the file that is stored to the   variable is 0. Eventually, the application will use the values read from the header to allocate an image buffer at [9]. This will take use the product of the   and   variables and use them to allocate a buffer that will contain the decoded image data. If the product of these variables with the value 4 is larger than 32-bits, then the size for the allocation will overflow. Later at [10], a buffer overflow may occur when writing to the image-buffer. This can lead to code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-01 - Vendor Disclosure \n2017-09-14 - Vendor patched \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0408');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (190, 'Blender BKE_vfont_to_curve_ex Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the way that the Blender open-source 3d creation suite v2.78c converts text rendered as a font into a curve. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use the file as a library in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application converts rendered text into a   when editing a  . When allocating space for wide-character form of text to be rendered, the application will perform some arithmetic which can overflow. This result will be used to perform an allocation which can allow for an undersized buffer due to the overflow. Immediately after, when the application tries to convert the UTF-8 string to wide-character within this buffer, a heap-based buffer overflow will occur. After loading a .blend file, the application will immediately try to update the scene and all of it\'s objects in order to render it in the user-interface. Within the provided proof-of-concept is a   object which actually describes text which is to be rendered. When the application opens the file, the   that was specified in the   structure will be used to determine the entry-point of the project. Within this  , the default   will be specified along with the list of  s that compose the  . These  s are wrapped in a   structure. After opening up a .blend file, the application will proceed to update the scene in the rendering viewport using the   function. This function will update all the objects within a   that have the   flag specified in it\'s   field. To do this, the application will recurse through all the objects and call a number of functions at [1], [2], [3], and [4]. Once [4] is reached, the application will have pushed a function pointer to the   function into it\'s task-scheduler\'s stack. Finally at [5], the   is called. Inside the   function, the application will check if the object has data that needs to be recalculated [6]. To do this, it will call the   function which will then determine the   of the object. If the type is an  ,  , or   then it will call the   function at [7]. The provided-proof-of-concept uses the   value as the object\'s  . The   function is simply a wrapper that ensures the object\'s   field is allocated and allocate one if it isn\'t. Once this is done, at [8] the application will call the   function. The   will first cast the   field into a pointer to a   structure. Once this is done, the application will against use the object type to determine how to convert the object. Due to the   field being an  , the application will choose the next case which will call the   function [9]. This function is simply a wrapper around the   function [10]. The   function is the function directly responsible for the vulnerability described in this advisory. Now within the   function, the application will again grab the   structure out of the   field as well as dereference the   field from the   structure. At [11], the application will check to see if the   field is defined or not. Due to this being the first time that the application is interacting with this structure, the field will result as NULL. This causes the application to proceed to initialize an   structure. At [12], the application will grab the   field from the   structure and assign it to the   variable. This variable is used by the allocation at [13] and is directly responsible for triggering the vulnerability. The application will take the   variable, add 1 to it, and then multiply it by the size of a   or 2 in order to allocate enough space for converting a UTF-8 string into a wide-char string. It the result of this arithmetic is larger than 32-bits, then an overflow will occur which can result in an undersized buffer. The provided proof-of-concept specifies   as 2147483647 (0x7fffffff) which results in a zero-sized allocation. To convert this string, the application will then use the   field from the   structure and the   variable as arguments to the   function. This happens at [14]. The   function will explicitly trust the   argument and use it to terminate the loop at [15]. This loop will iterate through each UTF-8 character pointed to by the  \'s   field and hand it off to the   function. This function will determine the size of the UTF-8 character, and return the character as a unicode glyph. Each glyph will then be written to the undersized buffer at [16] causing a buffer overflow. This can lead to code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file, treat it as a library and import the Curve object, or pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted .blend files in the application. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0455');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (191, 'Blender Object CustomData_external_read Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the   Mesh loading functionality of the Blender open-source 3d creation suite. A .blend file with a specially crafted external data file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to edit an object within a .blend library in their Scene in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads a   layer from a   object within a Blender library file (.blend). When allocating space for the layer data within a  , the application will perform some arithmetic which can overflow. This result will be used to perform an allocation which can allow for an undersized buffer. Later, when the application attempts to read data from the external data file into this buffer, a heap-based buffer overflow will occur. When attempting to edit a   object that has been imported into the user\'s scene, the application will attempt to read each layer that composes the   object. One of the options of a layer is to use   data. When opening up a file, the application will iterate through all the data-blocks that use the   (0x454d0000) code type. After identifying a data-block of the  , the application will execute the following code to map the pointers within the structure that was de-serialized from the data-block to the correct positions in memory. At [1], the application will fix the pointers that are stored within a   structure. Inside this function at [2], the application will fix-up both the pointers for the   field and the   fields.  The layer field points to a structure  . This structure contains the   of the layer as well as any flags associated with it in the   field. If the   field has the   (8) bit set, then the application will assume that the layer\'s contents will be stored in the   pointer. This pointer points to a   structure which contains the filename to load the data from. Later when the application attempts to read data from thus layer such as when editing the  , the application will execute the following function. This function will ensure that the   field is set [4], and that one of the layers defined in the   argument has the   (8) flag set [5]. If this flag is set, the application will read the filename from the structure and then convert it to an absolute path at [6]. At [7], the application will finally attempt to open up the external file. To open up the file, the application will execute the   function.  This function will open up a stream to the file, and then hand it off to the   function [8]. At the beginning of this function, the application will read the header [9], followed by checking it\'s header for it\'s fingerprint and version number at [10]. Once the byte order is determined, the application will then validate at [11] that the   field is of either CDF IMAGE(0) or CDF MESH(1). At [12], depending on this type the application will read a  , or a   from the file. After this is done, the application will attempt to read the number of layers embedded within this file. To allocate space for this, the application will read the   field from the   and multiply it by the size of a   structure [13]. This structure has a size of 84-bytes. If the product of the   field and the number 84 is larger than 32-bits, then this allocation size will overflow resulting in a size that is smaller than expected. Later at [14] when the application attempts to read data from the file into this undersized buffer, a buffer overflow will occur. This can lead to code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. This will also generate a file that will be imported as the   layer with the suffix  . To trigger the vulnerability, one can import the Mesh object from the .blend file into their scene. Once the user tries to edit or interact with the   that utilizes the   object, the application will crash. In order to mitigate this vulnerability, it is recommended to not use untrusted library files in their Scene. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0434');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (192, 'Blender BKE_curve_bevelList_make Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the way that the Blender open-source 3d creation suite v2.78c converts curves to polygons. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use the file as a library in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application converts various curve types into polygons . When allocating space for a   structure, the application will perform some arithmetic which can overflow. This result will be used to perform an allocation which can allow for the buffer to be undersized. When the application tries to write values into this buffer, a heap-based buffer overflow will occur. After loading a .blend file, the application will immediately try to update the scene and all of it\'s objects in order to render it in the user-interface. When the application opens the file, the   that was specified in the   structure will be used to determine the entry-point of the project. Within this  , the default   will be specified along with the list of  s that compose the  . These  s are wrapped in a   structure. After opening up a .blend file, the application will proceed to update the scene in the rendering viewport using the   function. This function will update all the objects within a   that have the   flag specified in it\'s   field. To do this, the application will recurse through all the objects and call a number of functions at [1], [2], [3], and [4]. Once [4] is reached, the application will have pushed a function pointer to the   function into it\'s task-scheduler\'s stack. Finally at [5], the   is called. Inside the   function, the application will check if the object has data that needs to be recalculated [6]. To do this, it will call the   function which will then determine the   of the object. If the type is an  ,  , or   then it will call the   function at [7]. The provided-proof-of-concept uses the   value as the object\'s  . The   function is simply a wrapper that ensures the object\'s   field is allocated and allocate one if it isn\'t. Once this is done, at [8] the application will call the   function. The   will first cast the   field into a pointer to a   structure. Once this is done, the application will against use the object type to determine how to convert the object. Due to the   field being an  , the application will choose the next case which will call the   function [9]. This function contains the vulnerability described by this advisory. Within the   function, the application will again grab the   structure out of the   field [10]. Following this, the application will set a flag,  , depending on whether or not the   or   fields belonging to the   structure are set as \'SEGMENT\' or \'SPLINE\' [11]. Once this is determined, the application will then enter a loop which will iterate through the linked list of   structures that were passed as an argument. At [12], the application will then validate some of the fields within the   structure. Once this is done, the application will then branch to one of the cases at [13] based on the type of the  . Each one of these cases contains a similar instance of the vulnerability. The provided proof-of-concept exercises the   case. This case executes the following code. At [14], the application will read the   field from the   and then use this in the allocation that follows. This allocation will allocate space for the size of a   of 36-bytes which includes an array of   structures which are each 80-bytes. If the number of   structures as specified by the   field causes the expression at [14] to have a result that is larger than 32-bits, then this arithmetic will overflow which will result in an undersized allocation being made. At [15] when the application tries to write to this structure, an out-of-bounds write will occur which can lead to code execution under the context of the application. The case for   contains a similar vulnerability which calculates the number of   structures using the   and   fields [16]. The case for   also contains a similar vulnerability without the addition of the number 1 as in the   case [17]. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file, treat it as a library and import the Curve object, or pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted .blend files within the application. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0454');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (193, 'Blender BKE_mesh_calc_normals_tessface Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the   functionality of the Blender open-source 3d creation suite. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open a .blend file in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application fixes the normals within a   object when loading an older version of a .blend file. When allocating space for the faces and vertices of a   object, the application will perform some arithmetic which can overflow. This will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to calculate the normals for the vertices and faces of the mesh, the application will write outside the bounds of the buffer resulting in a heap-based buffer overflow. After initially loading the file, the application will call the   function. This function will check the version of the file as specified in the   structure. At [1], if the version is less than 256 (exclusive) or the version is equal to 256 and sub-version is less than 6 then the application will iterate through all of the Mesh data-blocks with the Code \'ME\\x00\\x00\' that were read from the file. For each of these   objects, the function   will be called at [2]. The arguments that are passed to this function come from the   object. The fields that are directly responsible for this vulnerability are the   and the   fields of the   structure. Once inside the   function, the application will take the values from the   and   fields and use them to perform a multiplication at [3] in order to allocate space for the calculations required for both the faces and vertices of the mesh. The size of both fields are a 4 for a float, and 3 for three of them. This results in the multiplication for both allocations being 12 and the   field or the   field. If the result of this product is larger than 32-bits then an integer overflow will occur. This will cause the memory that is allocated to be undersized. Later at [4], the application will use one of these undersized buffers to calculate the normals of each face of the  . Also at [5], the normals for each vertex will be calculated. The provided-proof-of-concept utilizes the calculation of the normal for each vertex in order to corrupt memory and trigger the vulnerability. At [6], the application will store the normal that was calculated into the buffer that was allocated corrupting memory outside the bounds of the allocated buffer. This type of memory corruption could allow for code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file or use it as a library. It can also be passed as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted blender files. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0438');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (194, 'Blender vcol_to_fcol Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the upgrade of a legacy Mesh attribute of the Blender open-source 3d creation suite v2.78c. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use it as a library in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. During the initial load of a   file, a version check of the file is triggered in order to adjust legacy features. Blender has a series of fixes isolated by blocks based off of the version, shown below. The numbers 250 - 270 correspond to checks pertaining to that particular version block. During the checks for version before 2.5 [0], a transformation of the   within   objects occurs. If the current   file contains a   object that also has a valid   [1], then a call to   is issued in order to upgrade from the old   array to the newer version. The   struct is shown below with a few highlighted attributes. Three key attributes of note:  ,  , and  .   is an array of object mode faces for tessellation,   is an array of colors to color those faces, and   is the total number of faces. The code that handles the transformation of old   to new   is shown below. The new   array ( ) is first allocated using using the   from the   object read from the file [1]. The loop immediately after the allocation is then used to populate the newly created array [2]. Each entry into the new   array is 4 integers. In order to calculate the total size of the array, the total number of faces is multipled by the total size of each entry. When provided with a large number of total faces, this multiplication can result in an integer overflow, causing a smaller than necessary array to be created. The loop then iterates over the large number of faces, overflowing the heap allocation, potentially causing code execution. Initial allocation of   bytes Initial state of the allocation State of the allocation after overflow Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability with the provided proof-of-concept, run   with the newly created proof-of-concept. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0433');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (195, 'Blender Sequencer imb_loadtiff Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the TIFF loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads a TIFF file as a resource for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. Once the application checks the magic and determines that the file to be loaded is of the TIFF format, the   function will be dispatched to. At [6], the application will utilize the   library to open the file. After doing this successfully, the dimensions for the image will be fetched from the tags within the TIFF image\'s directory. The   field will be used to determine the number of bits for each decoded pixel [7]. Afterwards these values will be combined in order to allocate space for the buffer to decode the image into [8]. This structure is later copied. If the product of the  ,  , and   variables are larger than 32-bits then the image buffer will be undersized when trying to decode into it. At [9], the application will call the   function decode the TIFF image with. When actually decoding the TIFF file format, the application will read a couple more fields from the TIFF file\'s directory [10]. These fields determine which decoder to choose from. Afterwards, the application will make a copy of the image buffer that was allocated at [8]. This is done by grabbing the original values and multiplying them. Due to the application not checking to see if these values can be larger than 32-bits, this will result another undersized buffer. Depending on the value of   or the   tag, one of the pieces of code at [12] will be used to decode the image. Due to the undersized buffer as a result of an integer overflow, this can cause a heap-based buffer overflow which can lead to code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0406');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (196, 'Blender draw_new_particle_system PART_DRAW_AXIS Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the way that the Blender open-source 3d creation suite v2.78c draws a Particle object. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use the file as a library in order to trigger this vulnerability. Blender v2.78c (32-bit) \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application draws a   object as a   type. When allocating space for the number of particles, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for the resulting heap-buffer to be undersized. When the application tries to write values into this undersized buffer, a heap-based buffer overflow will occur. When drawing an object, the application will call the following function. The   function will figure out whether or not to draw particles or the object that the particles are emitted from. At [1], the application will first check to see if the   field contains any elements in its linked list. This is used to set the   flag. The provided proof-of-concept attempts to skip unnecessary code when triggering the vulnerability and so various flags were set in order to achieve the desired result. The flags specified for the \'mode\' field are set to zero which results in   being equivalent to  . This causes the   field to be set to true which skips rendering some objects. Eventually at [3], the application will iterate through all the   objects within the   and hand it off to the   function. At the beginning of the   function, the application will assign a few variables and then check some flags of the respective objects. The provided proof-of-concept sets the   field to the value  . This results in the   field being assigned to the   variable [4]. The shortest path discovered by the author to the vulnerability was to use   as the value for  . A little bit later at [5], the application will use some fields from both the   and   objects to perform a calculation. This uses the   field and the   field to calculate the total number of children. After that, the application will assign the   field to the local   variable [6]. It is these three fields that are used by the proof-of-concept to trigger the vulnerability. After assigning those variables, at [7] the application will assign a true value to the   field. This variable is used to control the case for the allocation that contains the vulnerability. Finally at [8], the application will perform some arithmetic that is used to make the vulnerable allocation. This code may already result in an overflow, but at both [9] and [10] are more calculations that influence the buffer that will be allocated. If the result of the arithmetic at [8], [9], and [10] is larger than 32-bits then an integer overflow will occur. Due to this integer overflow, the allocations at [11] can all be made to be undersized. This can result in a heap-based buffer overflow when either of them are used. Continuing execution after the vulnerable allocation is made, the application will check to see if the   variable is not equal to   [12]. After verifying a few more fields and that the   of the   field is larger than 1, then the function   at [13] will be called. The   function is a very simple function that will specially handle the   constant, and then wrap the call to the   function at [14]. Finally inside the   function, the application will assign a pointer from the   field. This is one of the undersized heap-buffers that was allocated earlier. Immediately afterwards, the application will check the   argument [15]. If   argument is set to   then the application will write to the pointer that was assigned at [15]. Due to the heap-buffers being undersized as a result of the 32-bit integer overflow, this will result in a heap-based buffer overflow which can lead to code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file, treat it as a library and import the Curve object, or pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted .blend files within the application. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0456');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (197, 'Blender mesh_calc_modifiers eModifierTypeType_OnlyDeform Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the way that the Blender open-source 3d creation suite v2.78c applies a particular object modifier to a Mesh. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use the file as a library in order to trigger this vulnerability. Blender v2.78c (32-bit) \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application applies a specific modifier type to a  . When allocating space for the number of vertices in a   in order to apply the modifier, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for the heap-buffer to be undersized. When the application tries to write values into this undersized buffer, a heap-based buffer overflow will occur. After loading a .blend file, the application will immediately try to update the scene and all of it\'s objects in order to render it in the user-interface. When the application opens the file, the   that was specified in the   structure will be used to determine the entry-point of the project. Within this  , the default   will be specified along with the list of  s that compose the  . These  s are wrapped in a   structure. After opening up a .blend file, the application will proceed to update the scene in the rendering viewport using the   function. This function will update all the objects within a   that have the   flag specified in it\'s   field. To do this, the application will recurse through all the objects and call a number of functions at [1], [2], [3], and [4]. Once [4] is reached, the application will have pushed a function pointer to the   function into it\'s task-scheduler\'s stack. Finally at [5], the   is called. Inside the   function, the application will check if the object has data that needs to be recalculated [6]. To do this, it will call the   function which will then determine the   of the object. If the type is an   then it will call the   function at [7]. This function is simply a wrapper around a function responsible for building the data for the function. At [8], the   function will call  . The   function is primarily a wrapper around the   function at [9]. Once inside the   function, the application will first grab the   structure from the   at [10]. After assigning some default variables, the application will then enter a loop which iterate through all of the   objects [11] associated with the   that\'s being processed. The application will then check to see that the modifier is enabled for the particular scene [12], and then check to see if the   modifier\'s type-info is set to   at [13]. With the provided proof-of-concept, the   modifier that was used to support this value was a   type of   which results in the modifier having the structure of a  . At the end of this advisory, a list of the   types with this particular attribute will be enumerated. Finally at [14], the   function (which contains the vulnerability) is called. Inside the   function, the application will first grab the number of vertices out of the   and assign it to the   variable. This variable will be used in the allocation at [15] to allocate an array of   elements. If the product of the size of a   (12 bytes) and the number of vertices stored in   is larger than 32-bits, then this arithmetic can overflow. When this result is used in the allocation, an undersized buffer will be allocated on the heap. Later at [16], when the application attempts to copy the vertex coordinates from the   into this array, a heap-based buffer overflow will occur. This will write outside the bounds of the buffer which can allow for code execution under the context of the application. As described previously, there are a handful of   types that result in the   field being set to   which is required to trigger this vulnerability. To enter the vulnerable case, the   field must be set to one of the following types. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file, treat it as a library and import the Curve object, or pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted .blend files within the application. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0457');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (198, 'Blender BKE_image_acquire_ibuf Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the Image loading functionality of the Blender open-source 3d creation suite v2.78c. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use it as a library in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application allocates space for an Image type when rendering a .blend file. When allocating space for the Image, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. Due to it\'s flexibility, the .blend file format is capable of storing a vast number of data structures and is capable of completely serializing the state of the application to disk. This means that a data structure in C will have the exact same format as the version on disk. In the following file, the structure for an   record is described. This data structure is populated using data from the file. When loading an Image record from a .blend file, the function   in the   file will be called. This function will be passed two structures. One of which is the   record that was read from the file. The other of which is the   record which is used to identify the image from either a Texture/Material, Background Image, or the Image Window. This function will call the   function at [1] in order to allocate space for it. Once inside the   functon, the application will first check a field named \"ok\" within the   and   structures [2]. After this is done, the   structure will have it\'s   and   fields checked. The provided proof-of-concept uses an image   of  . This will cause the case at [3] to be used to handle the acquiring of the   structure. Once the  ,  , and   fields are validated, the   function will be called [4]. It is prudent to note that at [5] another similar vulnerability can be found for the   image source. This will be discussed later. The   function will then take the   and   fields that came from   and   and then pass them to the   function at [6]. This function will take the product of these fields and the size of an  (4) and use them to calculate the size of a heap-buffer. If the result of this is larger than 32-bits, then an integer overflow will occur. This can result in an undersized buffer that when written to will cause a heap-based buffer overflow. At [7], the application will then write data into this buffer. Each of the functions at [7] will then be used to populate the undersized buffer. At [8], the application will hand off initialization of the buffer to a thread. This will wrap a call to   at [9] and then later one of the loops at [10] will be used to write into the buffer. The proof-of-concept that is included chooses the non-  loop to overflow the buffer. There is a path to similar bug if the   field is   and the   field is set to  . At [11], the   function will get called. After selecting the   index of the   array at [12], the application will use the   and   fields to allocate an   at [13]. Immediately afterwards, the application will assign the Image to the undersized buffer. This will also cause a heap-based buffer overflow. The structure for the   is located within the   function. The   and   fields are multiplied with the size of an   in order to calculate the size for the target buffer for the second bug. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability with the provided proof-of-concept, one can simply add it as a library and attempt to use the Image. Another way is to open the file and navigate to the DataBlocks view. To automate triggering the vulnerability without user-interaction, apply the Image to a Texture and then include the texture in a Scene. In order to mitigate this vulnerability, it is recommended to not open a .blend file or use a .blend file as a library from an untrusted user. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0425');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (199, 'Blender Sequencer dpxOpen Buffer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the DPX loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-120 - Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads a DPX file as a resource for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. After determining that the file is of a DPX or CINEON file, the function at [6] will be called. This will execute the   function which will check the header of the file in order to determine whether to call   or   functions. If a DPX image file was detected, then the   function will be called at [7] Once inside the   function, the application will read the   from the file into a   structure [8]. This structure is composed of 5 different headers that are constantly sized. At [9], the   field is declared as the   structure. This structure contains a constant-sized array in the   field [10]. This structure only allocates up to 8 elements for the   structure. After the application finishes reading the header, it will begin to check its magic at [11], and collect the image dimensions at [13]. At [12], however, the application will read a 16-bit unsigned integer from the header and use it to determine the number of elements to read from the header. Due to a lack of bounds checking, this value can be used to write outside the bounds of the   field. If this value is larger than 8, then a buffer overflow can be made to occur. After storing the number of elements and the dimensions of the image, the following loop will be entered to extract information from the   field. Due to a missing bounds check on the   field, this loop can write outside the bounds of the   array [14]. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0409');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (200, 'Blender Sequencer imb_bmp_decode Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the bmp loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads a   file as an asset for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. When a   file is determined, the function   is used to load the image from memory. First, the application will read the   to determine where the pixel data is [6]. Aftewards the  structure function will be read to determine the dimensions of the bitmap image [7]. This structure contains the sizes that will be combined to trigger the integer overflow. Once the dimensions in the   structure have been read, the application will allocate space for the image data at [8]. This will take the   and   variables and multiply them by the  . If the product of all of these variables is larger than 32-bits, then an integer overflow will occur. This will result in an undersized heap-buffer. At [9], the application will enter a loop in order to read each row of pixel data from the file. At [10], the application will write to the buffer that was under-allocated resulting in a heap-based buffer overflow. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0412');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (201, 'Blender Sequencer imb_loadpng Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the PNG loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads a PNG image file as an asset for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. When a PNG formatted file is determined, the function   is used to load the image from memory. First, the application will allocate a structure using   to initialize the state used to interact with the PNG file [6]. Afterwards the   function will be used to allocate the structure for reading the image [7]. Once the initial structures are initialized, the application will read the   chunk from the image file [8]. This chunk contains various information about the file such as the image dimensions, the compression method, and the image\'s pixel depth. The  ,  , and   variables which are read here are later combined via a multiplication that can cause an integer overflow. After reading the   chunk from the file, the application will begin to prepare reading the image\'s contents into a buffer. It does this by allocating an   structure using the   and   variables that were read earlier [9]. This function will assign the dimensions to the   and   fields of the structure. Later at [10], the function uses these dimensions to allocate space for the image data that composes the image. Due to the values for each dimension in the header being 32-bits, this calculation can be made to overflow which will result in an undersized value being used to allocate the buffer. At [11], another allocation that may be overflown is made. This allocation contains the pointer to each row within the image buffer. Finally, the application will attempt to decompress data from the file into the undersized buffer at [12]. If the product of the   and   variables from the format\'s   chunk is larger than 32-bits then the call to   will write outside the bounds of the image buffer which can cause a buffer overflow [13]. These can allow for an aggressor to execute code from within the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-17 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0407');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (202, 'Blender Sequencer imb_loadhdr Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the RADIANCE loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads a RADIANCE file as a resource for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. A RADIANCE image file is prefixed with the \"#?\" characters. Once this is determined, the application will execute the   function. At [6], the application will verify that the fingerprint matches the \"#?\" characters. After this is done, the application will scan over the length of the file looking for an empty line of white space [7]. As described in the comments, the resolution immediately follows. At [8], the application will read the dimensions for the image. Once the dimensions for the image are read, the application can then allocate a buffer to decode the image into. At [9], the application will take the product of the   and   that was read earlier and multiply them by the number of bytes-per-pixel which is specified as 32-bits. If the product is larger than 32-bits, then this image buffer can be made to overflow resulting in an undersized buffer. Afterwards, the application will begin to read data from the file and use them to write into this buffer [10]. This can lead to a heap-based buffer overflow which can lead to code execution under the context of the application. There is also another vulnerability that may occur due to the application explicitly trusting the  . At [11], the application will take the width and multiply it by the size of the   variable which is 4 bytes. Due to the   being a signed 32-bit value read from the file using  , an aggressor can specify any size that they wish. If the product of the   and the integer 4 is larger than 32-bits, then this can also trigger a undersized allocation leading to a buffer overflow. Later when the application reads data from the file into the   variable, another buffer overflow will occur [12]. (2c80.332c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=031afa9c ebx=00000000 ecx=0e9aaff8 edx=0e9aaff8 esi=10410ff4 edi=00010000\neip=0205827f esp=0050eb9c ebp=0050eba0 iopl=0         nv up ei pl nz na po nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202\nblender!PyInit aud+0x519eaf:\n0205827f f30f10460c      movss   xmm0,dword ptr [esi+0Ch]\n02058284 0f2ec1          ucomiss xmm0,xmm1\n02058287 f30f11450c      movss   dword ptr [ebp+0Ch],xmm0 To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-17 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0411');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (203, 'Blender Directory Browsing Thumbnail Viewer Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the thumbnail functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to render the thumbnail for the file while in the File->Open dialog. Blender v2.78c \n 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads the thumbnail for a .blend file when browsing directory contents. When allocating space for the thumbnail image within a .blend file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to copy the thumbnail data into this buffer, a heap-based buffer overflow will occur. When loading a thumbnail from a .blend file, the   is called. Near the beginning of this function, the application will call the   function to read the header from the file [1]. The header from the file contains a magic value which determines the pointer-size and byte order used within the file. Immediately afterwards at [2], the application will call the   function. This function will search for the block-header matching the value \"TEST\" [3]. After this is determined, the application will validate the length of the block. During this process, the application will read two signed 32-bit numbers. Afterwards, the application will validate that the block\'s length is smaller than the result of the   macro [4]. This macro will multiply the two numbers together, add the constant  , and then multiply them by the size of an int. Due to the application failing to check that the product of these values can result in more than 32-bits, this test can overflow thus bypassing the validation. Once validating the thumbnail header and then returning a pointer to the thumbnail data, the application will resume execution of the   function. Using the data returned from  , the application will then pass both of the signed 32-bit numbers to the   macro [5]. This macro will multiply the two numbers together along with the size of an int. Afterwards, the size of a   structure will be added to the result. Due to the application not checking that this result may be larger than 32-bits, an integer overflow may occur. Once this overflown size is calculated, an allocation will be made which may be undersized due to this vulnerability. The overflow is then triggered by the assignments to  ,  , or the   operation that happens at [6]. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply browse to the same directory as the file via the File->Open dialog and then view thumbnails by enabling it on the toolbar. In order to mitigate this vulnerability, it is recommended to not use thumbnails when browsing a directory of projects. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0415');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (204, 'Blender Sequencer avi_format_convert Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the animation playing functionality of the Blender open-source 3d creation suite version 2.78c. A specially created   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application renders a frame from an   file within the sequencer. When allocating space for a frame within the   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to decode data from the video file into this buffer, a heap-based buffer overflow will occur. When trying to play a file, the application will first try to determine what whether the file is an animation or a picture format. An animation is checked at [1] using the   function. Inside this function, the application will determine the animation type. This is done by the   function within the   file [2]. The next function will dispatch to a number of tests in order to determine what format the animation is actually in. One of these tests is a call to the function   [3]. This function is simply a wrapper that calls   [4]. Once inside the   function, the application will check various chunks within the file to ensure they are of sane values. When this is done, the application will have determined it is an   animation and will proceed to actually process the video. Returning back to the caller, the application will then call the   function [5]. This function does two things. One of which is to open up the file and collect information from the header chunk that is needed to render it [6]. The second which occurs after determining the animation type is to actually fetch an image buffer and decode a frame [7]. When opening the   file to collect information about the header, the   function will be called. Inside this function, the application will again determine which animation type the file is of and then hand off the current animation state to the   function at [8]. Inside  , the movie will actually be opened in order to extract information needed to render the file followed by saving the dimensions and number of frames available [10]. Before this, however, the   function will be called at [9]. The   function will open the file in order to prepare the number of streams encoded within the file [11]. Once opening the file, the initial headers will be checked in order to locate the AVI header (identified by the \"hdrl\" chunk) which contains general information about the   file [12]. This data which includes the video\'s dimensions is then assigned to the   field [13]. These fields can be up to 32-bits in size. It is these two fields that when multiplied will be overflown. After storing the general information about the file, the application will then proceed to read information about each sample from the sample headers within the file [14]. After that information is stored, the application will then save the file offset to the sample data [15] to the   and   variables and then proceed to load the index from the file if one is included. After collecting all of this information about the file, this function will return back to   and then back to  . Back in the   function, the information that was collected by   will then be passed to the   function [16]. This function will take the fields that were assigned earlier and use them to allocate a buffer based on the video dimensions at [17]. Once allocating the buffer, the application will then proceed to read the first frame out of the file into the allocated buffer using the   function. This function will first seek to the correct frame by navigating the index that was read earlier, and then hand off the sample stream to the   function at [18]. The   function will determine the video\'s format type and then use that to call one of functions at [19]. Each of these functions will allocate space for the destination of the sample data that is to be decoded and then will decompress the sample data from the file into said buffer. The provided proof-of-concept will actaully dispatch into the   function. Once inside the   function, the application will actually decode the sample data into a frame. At [20], the application will allocate a buffer based on the   and   fields that were read earlier from the general AVI header. Due to the application not checking that the product of these fields with the size of 3 is larger than 32-bits, this allocation can be made to underflow which will result in an undersized buffer being assigned to the   variable. Later at [21] when the application tries to decode the sample data into this buffer, both will write outside the bounds of the buffer which will cause a heap-based buffer overflow. This can lead to code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted animation files as an asset when composing a scene. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0414');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (205, 'Blender Sequencer imb_get_anim_type Streams Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the animation playing functionality of the Blender open-source 3d creation suite version 2.78c. A specially created   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application verifies the type of animation when adding or playing a video via the sequencer. When allocating space for the number of audio/video streams within a   file the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to load data from the file into this buffer, a heap-based buffer overflow will occur. When determining the animation type, the function   in the   file will be called. Inside this function, the application will call various functions in order to determine the animation type. Within these various tests is a call to the function   [1]. This function is simply a wrapper which will then call  . The   function contains the integer overflow described in this advisory. At the beginning of the function, the application will first open up the filename [3] followed by validating different parts of the header in order to determine it is a   file type. After confirming it has a proper header, various fields are read from the file. One of these fields is the number of streams at [4]. This field is used to determine the number of audio or video streams that may follow. Within the same function, the application will then check to see if the number of streams are they are greater or equal to 1 [5]. This checks that a file is not malformed due to having a signed value in the field. However, immediately afterwards the application will multiply this value by the size of an   header. When compiled, this size is 0x4c bytes in length. Due to a failure to accommodate for the overflow, this multiply can cause the size to wrap which may result in a size that is smaller then an   being used for an allocation. Later, the application will then use the number of streams as a terminator for a loop [7] in order to read contents from the file into the   buffer. If the number of streams multiplied by the size of an   is larger than 32-bits, then this loop will write outside the bounds of the buffer leading to a heap-based buffer overflow. (76c.2520): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=146c0fdc ecx=00000000 edx=0b42d8c0 esi=00000000 edi=04335298\neip=0172b39a esp=0490f1d4 ebp=0490f288 iopl=0         nv up ei pl zr na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246\nblender!osl set code+0x4010a:\n0172b39a 894324          mov     dword ptr [ebx+24h],eax ds:002b:146c1000=???????? 0:000> !heap -p -a @ebx Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted animation files as an asset when composing a scene. 2017-09-06 - Vendor Disclosure \n2017-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0413');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (206, 'Blender Sequencer imb_load_dpx_cineon Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the DPX loading functionality of the Blender open-source 3d creation suite version 2.78c. A specially crafted   file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to use the file as an asset via the sequencer in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability exists with how the Blender application loads an DPX file as a resource for the video sequencer. When allocating space for the image data within a   file, the application will perform some arithmetic which can overflow. This result will then be used to perform an allocation which can allow for an undersized buffer. Later when the application attempts to render the image data into this buffer, a heap-based buffer overflow will occur. When loading an image file, the function   in the   file will be called. Inside this function, the application will first open the file and then call the   function [2]. Inside the   function, the application will first map the whole file into memory using the   system-call [3]. After the file is successfully mapped into memory, the resulting pages will be passed to the   function [4]. This function is responsible for figuring out which file-format handlers to use, and then to call its respective loader. Inside the following function, the application will iterate through a global list that contains different handlers for all of the image files that the application supports. At [5], the application will call the function responsible for loading the image out of memory. After determining that the file is of a DPX or CINEON file, the function at [6] will be called. This will execute the   function which will check the header of the file in order to determine whether to call   or   functions. If a DPX image file was detected, then the   function will be called at [7] Once returning from  , the application will execute the following code. This code will first extract the dimensions and color-depth at [8]. Afterwards, it will allocate a buffer using these values at [9]. Due to a failure to check to see if the product of the  ,   and 4 (for 32-bits) will be larger than a 32-bit value, this will result in an undersized buffer being used. At [10], when the application attempts to decode image data into this undersized buffer a buffer overflow may occur. When trying to decode the image data, the   function will be called. This function iterates through the number of elements defined in the header and uses it to determine how to decode the image data that\'s stored after it. At [11], the application will call the   function. Inside the   function, the application will determine the current element\'s   and then call the respective function to decode the image data. The provided proof-of-concept uses a   of 1. Finally the application will enter a loop which will decode the data from the file into the undersized buffer that was allocated. At [13], this buffer will be written to which will trigger the heap-based buffer overflow. This can allow for code execution under the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the   file to. To trigger the vulnerability, one can simply add it as an asset or they can pass it as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted image files as an asset when using the sequencer. 2017-09-06 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0410');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (207, 'Blender modifier_mdef_compact_influences Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the   functionality of the Blender open-source 3d creation suite v2.78c. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open a .blend file in order to trigger this vulnerability. Blender v2.78c (32-bit) \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. The following module was audited to discover this vulnerability: This vulnerability occurs when loading an old   structure from a   into the new format. When creating  , the total number of vertex influences (vertex and weight) is used for the calculation to determine the size of allocation necessary to hold the influences. This value can be crafted to cause an overflow resulting in an allocation smaller than the total number of influences. When populating the array with the necessary values, the application can write beyond the bounds of the allocation, causing a heap-based buffer overflow. After loading all the basic-blocks in a file, the application will call the   function. This function will check the version of the file as specified in the   structure and use it to perform various transformations on the data-structures in the file in order to provide backwards compatibility. At [1], the application will check if the version is less than 253. After this is verified, the main object is passed to   at [2]. Once inside the   function, at [3] the application will loop through the modifiers in each available object searching for a modifier with type   [4]. If this modifier has a   array [5], then the application proceeds to try to upgrade this deprecated field by passing the modifier to   [6]. The   function is responsible for, among other things, creating a   array for the given  . At [7], the application will create the array by multiplying the   field from the passed in object (read from the file) by the size of   objects that will populate this array. This product could overflow resulting in a much smaller than indended array. During the initialization of the array at [8], the index into the array can be such that the value written will write beyond the bounds of the allocation, resulting in a heap-based buffer overflow potentially leading to code execution within the context of the application. Call to malloc with size 8 Page Heap detailing that the allocation was being written out of bounds Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file or use it as a library. It can also be passed as an argument to the blender executable. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0453');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (208, 'Blender multires_load_old_dm base vertex map Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the   functionality of the Blender open-source 3d creation suite v2.78c. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open a .blend file in order to trigger this vulnerability. Blender v2.78c (32-bit) \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. This vulnerability occurs when loading an old   structure from a   into a newer format. When handling an older version of a .blend file, the application will call a function to initialize the base vertices used for multi-resolution meshes. When allocating space for these vertices, the application will use the total number of vertices in some arithmetic which can overflow. This will then be used to perform an allocation which can be made to be smaller than the total number of vertices used to initialize an array. When initializing this array, the application can then write outside the bounds of the array which causes a heap-based buffer overflow. After loading all the basic-blocks in a file, the application will call the   function. This function will check the version of the file as specified in the   structure and use it to perform various transformations on the data-structures in the file in order to provide backwards compatibility. At [1], the application will check if the version is less than or equal to 250 and that the   field is less than 1 (exclusive). After this is verified, the application will iterate through all the   data-blocks in the file and at [2] check to see if its   field is set to  . If so, then the object and its associated   that\'s pointed to by the   field is then passed the   function at [3]. Once inside the   function, at [4] the application will assign a pointer to a   structure from the   structure\'s   field. Dereferencing the   field results in a   structure that contains a number of fields that are re-assigned to the   structure. In these fields, the value of   is significant to note as it is used to trigger this vulnerability. Once re-assigning the fields at [5], the application will then convert the faces defined by the   into polygons which is then used to create a   object. This and the   itself are passed as arguments to   at [6]. The   function is responsible for converting the old  -formatted structure into its newer format. At [7], the application will assign the   field belonging to the   to a pointer.  At [8], the application will extract the total number of vertices defined within the   that was made earlier using the fields from the   structure and assign the result to the   variable. Once this is done, at [9] the application will use this variable to calculate a product using the size of an int (4) with the number of vertices and pass this as a size for an allocation. If the result of this arithmetic has a result larger than a 32-bit number, then this allocation will overflow resulting in an undersized buffer. At [10], when the application attempts to initialize this array, the application will use the difference between the total number of vertices in the first   and the total number of vertices in the second   from the file to write into the array. During this, an out-of-bounds write can occur resulting in a heap-based buffer overflow. Within the provided proof-of-concept, the value used for the level 1   field is 1. This type of overwrite can allow for code execution within the context of the application. Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability, one can simply open the file or use it as a library. It can also be passed as an argument to the blender executable. In order to mitigate this vulnerability, it is recommended to not use untrusted blender files. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0452');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (209, 'Blender customData_add_layer__internal Integer Overflow Code Execution Vulnerability', 'None', '2018-1-11', 'An exploitable integer overflow exists in the upgrade of the legacy Mesh attribute   of the Blender open-source 3d creation suite v2.78c. A specially crafted .blend file can cause an integer overflow resulting in a buffer overflow which can allow for code execution under the context of the application. An attacker can convince a user to open the file or use it as a library in order to trigger this vulnerability. Blender v2.78c \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190 - Integer Overflow or Wraparound Blender is a professional, open-source 3d computer graphics application. It is used for creating animated films, visual effects, art, 3d printed applications, and video games. It is also capable of doing minimalistic video editing and sequencing as needed by the user. There are various features that it provides which allow for a user to perform a multitude of actions as required by a particular project. During the initial load of a   file, a version check of the file is triggered in order to adjust legacy features. Blender has a series of fixes isolated by blocks based off of the version, shown below. The numbers 250 - 270 correspond to checks pertaining to that particular version block. During the checks for version before 2.5 [0], there are a few fixes for versions before 2.42 [1]. One of which fixes specific CustomData for   objects [2] If the current   object claims to have a number of total layers in its   and has the deprecated field  , then a particular fix is applied. Because   is deprecated, the new   and   must be created. This is done via the   API. Note that   is from the   object created from file data [3].   calls an internal API   to allocate the memory necessary for the new   and   objects [4]. During the creation of this customData layer, the size of the layer is calculated by multiplying the total elements (  from above) by the size of the structure. By supplying a large enough value, this   variable can be overflown to be a much smaller number than required [5]. This overflown   value is used in the   call [6]. This newly created allocation is then set in the   element [7] and is then returned back to the call of  . This layer is then filled by leveraging old   data [8]. Because the allocated segments are too small to hold the requested data, the allocations are overflown causing a heap corruptions, potentially leading to code execution. Initial allocation before overflow State of the allocation after partial overflow Included with this advisory is a generator for the vulnerability. This proof-of-concept requires python and takes a single-argument which is the filename to write the .blend file to. To trigger the vulnerability with the provided proof-of-concept, run   with the newly created proof-of-concept. 2017-09-27 - Vendor Disclosure \n2018-01-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0451');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (210, 'rails_admin rails gem XSS vulnerability', 'None', '2018-1-10', 'An exploitable XSS vulnerability exists in the add filter functionality of the rails_admin rails gem version 1.2.0.\nA specially crafted URL can cause an XSS flaw resulting in an attacker being able to execute arbitrary javascript on the victim’s browser. An attacker can phish an authenticated user to trigger this vulnerability. rails_admin 1.2.0 \n 6.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N CWE-79: Improper Neutralization of Input During Web Page Generation (\'Cross-site Scripting\') The rails_admin gem has functionality which allows a user to create custom filters to find values within the admin interface. When a new filter is created using the UI, it redirects to a new url containing that filtering information in the form of localhost:3000/admin/model?model_name=model&utf8=%E2%9C%93&f%5B\npassword%5D%5B91178%5D%5Bv%5D=+%22%3E%3Cimg+src%3D%22%22+onerror%3D%22\nalert(1)%22%3E&query= This URL can them be used to phish an authenticated user and execute arbitrary javascript on their behalf. This vulnerability was shown to occur using Chrome, Safari, and Firefox. 2017-09-20 - Vendor Disclosure \n2017-09-28 - 2nd Vendor contact attempt \n2017-10-11 - 3rd Vendor contact attempt \n2017-12-05 - Final Vendor contact \n2018-01-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0450');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (211, 'delayed_job_web rails', 'None', '2018-1-10', 'An exploitable XSS vulnerability exists in the filter functionality of the delayed_job_web rails gem version 1.4.\nA specially crafted URL can cause an XSS flaw resulting in an attacker being able to execute arbitrary javascript on the victim’s browser. An attacker can phish an authenticated user to trigger this vulnerability. delayed_job_web 1.4 \n 6.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N CWE-79: Improper Neutralization of Input During Web Page Generation (\'Cross-site Scripting\') The delayed_job_web gem allows users to filter output based on the query string of the GET request.\nThis looks similar to. localhost:3000/delayed_job/overview?queues=\">+<script>alert(1)<%2Fscript> This URL can them be used to phish an authenticated user and execute arbitrary javascript on their behalf.\nThis vulnerability is caught by the built in XSS protections of Safari and Chrome., however it is exploitable\nusing Firefox. Discovered by Zachary Sanchez of Cisco ASIG 2017-09-20 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0449');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (212, 'CPP-Ethereum JSON-RPC admin_peers improper authorization Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in admin_peers API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass. \nAn attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 4.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:N CWE-285: Improper Authorization One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe in details improper/consistency check of authorization. As we can see there is no check for calling user privileges which is done in couple other APIs via   macro.\nSame functionality is exposed over   API where at the beginning of API body, privileges check is made: We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-12-06 - Vendor Disclosure \n2017-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0466');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (213, 'CPP-Ethereum JSON-RPC admin_addPeer Authorization Bypass Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in admin_addPeer API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass.  An attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 4.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:N CWE-285: Improper Authorization CPP-Ethereum is a C++ ethereum client, one of the 3 most popular clients for the ethereum platform.\nOne of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe the improper authorization check in detail: As we can see there is no user privileges check, which is done in a couple of other APIs via the   macro.\nThe same functionality is exposed over the   API where at the beginning of API body, a privilege check is performed: We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-12-06 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0464');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (214, 'CPP-Ethereum libevm create2 Information Leak Vulnerability', 'None', '2018-1-9', 'A specially crafted smart contract code can cause an out-of-bounds read leading to memory disclosure or denial of service. An attacker can create/send malicious smart contract to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 8.2 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H CWE-125: Out-of-bounds Read One of the components that is a part of cpp-ethereum is libevm ( Ethereum Virtual Machine ). Improper handling of smart contract code\nin the `create2 opcode handler can lead to an out-of-bounds read. The vulnerability can be used to leak memory or to perform DoS attack\non all nodes in the Ethereum network using this implementation of the virtual machine. The   opcode is currently associate with   fork and its implementation looks as follows: In pseudo code we can represent the opcode handler as follows: Its purpose is to give a devoloper the possibility to create a new contract from inside a contract where code for a new contract is loaded inside EVM memory   at the specified offset.  \nIn above code we can observe that 4th parameter   represents size of the new contract code, it is read directly from input at   and not sanitized in any way before it is used at  .\nAt   we see that a new object of type   is created : The parameters being passed to the constructor for this are a pointer to a memory buffer   and, as a size of this buffer, the   variable.\nAs you can imagine, the object can have a wrong size fully controllable by the attacker in the range of a 64-bit unsigned integer.\nTracking down further usage of this object we can see that based on its content a SHA1 hash is calculated: The corrupted object in the function above is passed as an   argument. The incorrect size of this object in that scenario can lead to: Example of opcodes triggering this vulnerability: disassembling we get: 2017-11-03 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0503');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (215, 'CPP-Ethereum JSON-RPC miner_stop improper authorization Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in miner_stop API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 4.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:N/A:L CWE-285: Improper Authorization One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe in details improper/consistency check of authorization. As we can see there is no check for calling user privileges which is done in couple other APIs via   macro.\nSame functionality is exposed over   API where at the beginning of API body, privileges check is made: We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-12-06 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0470');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (216, 'CPP-Ethereum JSON-RPC miner_setEtherbase improper authorization Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in miner_setEtherbase API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 6.8 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N CWE-285: Improper Authorization One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe in details improper/consistency check of authorization. As we can see there is no check for calling user privileges which is done in couple other APIs via   macro.\nSame functionality is exposed over   API where at the beginning of API body, privileges check is made: We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-11-03 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0467');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (217, 'CPP-Ethereum JSON-RPC Denial Of Service Vulnerabilities', 'None', '2018-1-9', 'An exploitable unhandled exception vulnerability exists in multiple APIs of CPP-Ethereum\'s JSON-RPC. Specially crafted JSON requests can cause a unhandled exception resulting in denial of service. An attacker can send malicious JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-248: Uncaught Exception One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage\nclient/node functionality. A lack of proper exception handling in the implementation of some APIs allows a\nremote attacker to send malformed JSON requests and crash the client/node. The following list of APIs are vulnerable: To handle JSON objects, the   project (https://github.com/open-source-parsers/jsoncpp) is used and the definition of the   method looks as follows: for both ints there is an assertion for which the condition is checked by the   method: The   method distinguishes between integer types but based on exception message thrown for the proof of concepts below, we know that type of this particular   object during construction was set to  .\nIf so the value should pass the check at  . Here it also looks like JsonCpp developers made a mistake and wrongly took constant value of   instead of   for the comparison. Nevertheless in both cases we can pass a value which will fail the above checks.\nIn the current situation with the   defined above, we just need to pass integer bigger than   to trigger an exception. If it were implemented correctly, then we need to pass along a value larger than 0xFFFFFFFF. The following documents each vulnerable API below and provides a POC: At   everything except the first parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the second parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the second parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the second parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the second and fifth parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: At   the third parameter passed to   API is an integer value. To enforce that, the JSON object calls the   method to convert the current value to an integer one.\nExample of a request that triggers this vulnerability: 2017-11-03 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0471');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (218, 'CPP-Ethereum JSON-RPC admin_nodeInfo improper authorization Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in admin_nodeInfo API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass. \nAn attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 4.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:N CWE-285: Improper Authorization One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe in details improper/consistency check of authorization. As we can see there is no check for calling user privileges which is done in couple other APIs via   macro.\nSame functionality is exposed over   API where at the beginning of API body, privileges check is made: We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-12-06 - Vendor Disclosure \n2017-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0465');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (219, 'Parity Ethereum Client Overly Permissive Cross-domain Whitelist JSON-RPC vulnerability', 'None', '2018-1-9', 'An exploitable overly permissive cross-domain (CORS) whitelist vulnerability exists in JSON-RPC of Parity Ethereum client version 1.7.8.\nAn automatically sent JSON object to JSON-RPC endpoint can trigger this vulnerability. A victim needs to visit malicious website to trigger this vulnerability. Parity 1.7.8 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-942: Overly Permissive Cross-domain Whitelist Parity is a Rust ethereum client, one of the 3 most popular clients for the ethereum platform.\nOne of the components that is a part of Parity is a JSON-RPC interface. Its turned on by default\nand exposes significant number of APIs due to an overly permissive cross-domain (CORS) whitelist, which by default is set to \'*\'.\nA user running Parity wallet visiting malicious websites is exposed to exploitation of this JSON-RPC daemon misconfiguration\nwhich can lead to: sensitive data leak of existing accounts, parity settings and network configuration but can also lead to modification of accounts and parity settings if certain APIs have been turned on.\nLet\'s see how the JSON-RPC daemon behaves for XHR request: Next we visit a website at address: 192.168.217.155 which serves a page with a simple script: Successfully execution of the XHR should leak us information about existing accounts related with this node.\nLet\'s check how an automatically executed request by the browser would look like: The server allows that kind of request from our orgin \'Access-Control-Allow-Origin: http://192.168.217.155\'. So next the browser sends the final request: As you can see, we managed to steal information about existing accounts. Turn off/block possibility for CORS request to JSON-RPC interface. 2017-12-22 - Vendor Disclosure \n2018-01-02 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0508');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (220, 'CPP-Ethereum JSON-RPC miner_start improper authorization Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in miner_start API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 4.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:L/A:N CWE-285: Improper Authorization One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe in details improper/consistency check of authorization. As we can see there is no check for calling user privileges which is done in couple other APIs via   macro.\nSame functionality is exposed over   API where at the beginning of API body, privileges check is made: We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-12-06 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0469');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (221, 'CPP-Ethereum JSON-RPC miner_setGasPrice improper authorization Vulnerability', 'None', '2018-1-9', 'An exploitable improper authorization vulnerability exists in miner_setGasPrice API of cpp-ethereum\'s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768).\nA JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability. Ethereum commit 4e1015743b95821849d001618a7ce82c7c073768 6.8 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N CWE-285: Improper Authorization One of the components that is part of cpp-ethereum is a JSON-RPC server which exposes various APIs to manage client/node functionality.\nImproper authorization checks in the implementation of the   API allows a remote attacker without any credentials to triggers functionality reserved only for a user with administrator privileges.\nWe can observe a similar approach in two other clients (lack of any kind of authorization)\nbut in this case the situation is exacerbated by the fact that: For comparison let us take geth (the go ethereum client) which also implements a JSON-RPC interface but using much better security practices: Let us take a look at   and describe in details improper/consistency check of authorization. We are aware that this client is not recommended for mining and that the mentioned functionality related with the administrator interface is turned off by default.\nHowever when enabled the default behavior is insecure and can allow a remote attacker to perform unauthenticated RPC requests. 2017-12-06 - Vendor Disclosure \n2018-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0468');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (222, 'VMware VNC Dynamic Resolution Request Code Execution Vulnerability', 'None', '2017-12-19', 'An exploitable code execution vulnerability exists in the remote management functionality of VMware . A specially crafted set of VNC packets can cause a heap overflow resulting in heap corruption. An attacker can create a VNC session to trigger this vulnerability. Vase, Linux/Windows 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer VMware\'s VNC implementation is used for remote management, remote access, and automation purposes in VMware products, such as Workstation, Player, and ESXi, which share a common VMW VNC code base between them all. Along with the standard VNC messages that all VNC servers are required to serve, as specified in the RFB RFC\'s, VMware uses a custom and proprietary VNC extension, designated by the byte ì\\x7fî, which I will refer to as the vmw-vnc protocol during the course of this write-up. It should be noted that the vmw-vnc protocol reimplemented a few different VNC features, including MouseActions and KeyActions, the benefits of which could not be ascertained. But it also has some interesting messages, including ìVMWAudioî, ìVMWTouchEventî, however these were not supported within the vmw-vnc at the present.\nVMware VNC messages all follow the general format: It should also be noted that the size field just has to be larger than the message type\'s minimum.\nFor example, the VMWClientAck request is as such: With ì\\x00\\x00\\xAB\\xCDî being the duration of the ACK, but the size ì\\x00\\x08î just needs to be greater than a hardcoded 0x8. This specific vulnerability takes place within the VMWDynResolution request. Not surprisingly, this is one of the few messages that causes the VNC server to read in a user-supplied amount of bytes. The VMWDynResolution request is as follows: These rectangles contribute to dynamically sizing the resolution and each rectangle consists of four dwords. These seem to refer to the bounds of the rectangle: The location of the crash occurs when the VNC server handles the data. When the server allocates space the ìVNCChannelî object, there is a statically sized space (0xac0) for the contents of any given VNC packet. It only reads in 0xaaa bytes at any given time, so the buffer never overflows, however the NumRectangle field is never validated, leading to a situation where the heap can still be corrupted. When formatting the rectangle data, a pseudo python example is shown below: As noted above, since there\'s no check on the number of rectangles, and there\'s also a static buffer size, even though the buffer cannot be overflowed (fixed-size read), the heap can be corrupted by\ncausing the server to treat heap metadata as a rectangle. While it does do some validation, such that you cannot go all the way down the heap, curiously, it only checks two of the co-ordinates for a valid/positive value, and it also doesn\'t validate before swapping the bytes. It should also be noted that the server does not error completely upon heap corruption, it will keep reading in VNC packets in a loop until there is no more data. An attacker could use this vulnerability to corrupt the heap, which could lead to code execution. An important factor in this vulnerability is that it requires a successful VNC authentication beforehand, but by default, VMware does not require a username/password for VNC sessions. Turning on VNC authentication should mitigate this, turning it from a no-auth bug to a single-auth one. 2017-07-12 - Vendor Disclosure \n2017-12-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0368');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (223, 'VMware VNC Pointer Decode Code Execution Vulnerability', 'None', '2017-12-19', 'An exploitable code execution vulnerability exists in the remote management functionality of VMware . A specially crafted set of VNC packets can cause a type confusion resulting in stack overwrite, which could lead to code execution. An attacker can initiate a VNC session to trigger this vulnerability. VMware Workstation Pro 12.5.7, Linux/Windows 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-843: Access of Resource Using Incompatible Type VMware\'s VNC implementation is used for remote management, remote access, and automation purposes in VMware products, such as Workstation, Player, and ESXi, which share a common VMW VNC code base between them all. As specified by the RFB protocol[1], all VNC servers have to support a specific set of VNC messages. The relevant messages for the purposes of this write-up are listed (format: [byteLen,Varname]): The high level overview of this bug is that we request the VNC server to create a frame buffer (a screenshot essentially), and then we cause the mouse cursor to have to be re-rendered. During this period, we also ask the VNC server to turn off “TrueColor” mode (as gathered from the VncServerInit packet) via the VncSetPixelFormat message. Turning TrueColor mode off causes the server to mis-interpret the type of the cursor when it tries to decode the cursor, leading to a high value (0xff00000) getting written into the cursor\'s PNG infoStruct. This value is later mis-interpreted as the amount of palettes or pixels,  causing a loop which reads and writes to the stack to overflow. A few small details that are required for this crash to occur: It should also be noted that basically any order of these packets will work, the only way I could get it to not crash was to have the FrameBufferUpdate request first, followed by a .2 second sleep between it and the PixelFormat request. The position of the VNCPointer message is not important. But now onto the lower level details: the following is the disassembly that overwrites the variable on the stack that is eventually used as the loop counter: The main indicators of this being a type confusion were the above hardcoded values (which also  seem to be RGB color bitmasks). Interestingly, before this assignment, there is a check on a byte [rdi+0x413] within a custom VMware structure that also contains PNG struct info, the assumption being that this byte determines whether or not the PNG cursor is currently in TrueColor mode or not. Since it seems that if you wait long enough in between sending the FrameBuffer and SetPixelFormat VNC messages (>.20 seconds) this crash does not occur, the current running theory is that there is a race condition between the thread handling the rendering of the cursor onto the frame buffer, and the thread handling the updating of encoding of the cursor and the Framebuffer, such that there is a type mismatch, where one is TrueColor and one is not. Interestingly, in the Linux version of this bug, there is a possibility for exploitation, while for the windows version, there is a lot less of a chance. The disassembly of the crashing loop for Windows and Linux is respectively listed below: Since the Linux version reads in the loop counter off the stack with each iteration, eventually the loop counter gets overwritten with another value. If this value ever happens to be less than the current counter, the loop will exit and the program would resume with a modified stack. Since the vmware-vmx binary was compiled without stack-smashing protection, this makes exploitation easier for an attacker. An important factor in this vulnerability is that it requires a successful VNC authentication beforehand, but by default, VMware does not require a username/password for VNC sessions. Turning on VNC authentication should mitigate this, turning it from a no-auth bug to a single-auth one. 2017-07-12 - Vendor Disclosure \n2017-12-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0369');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (224, 'ACDSee Ultimate 10 IDE_PSD PSD Parsing Code Execution Vulnerability', 'None', '2017-12-8', 'A memory corruption vulnerability exists in the .PSD parsing functionality of ACDSee Ultimate 10.0.0.292. A specially crafted .PSD file can cause an out of bounds write vulnerability resulting in potential code execution. An attacker can send a specific .PSD file to trigger this vulnerability. ACDSee Ultimate 10,0,0,292 (IDE_PSD 5,7,690,1) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write Code responsible for the vulnerability is provided below: And this is how it looks in action (before & after actual memmove): In short byte value is taken directly from the .PSD file (see address 0x007BE521). This value is later used as a size argument to memmove function. This gives the attacker the opportunity to cause a memory corruption, potentially resulting in code execution. 2017-08-08 - Vendor Disclosure \n2018-12-08 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0393');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (225, 'Tinysvcmdns Multi-label DNS Heap Overflow Vulnerability', 'None', '2017-11-20', 'An exploitable heap overflow vulnerability exists in the tinysvcmdns library version 2016-07-18. A specially crafted packet can make the library overwrite an arbitrary amount of data on the heap with attacker controlled values. An attacker needs send a dns packet to trigger this vulnerability. tinysvcmdns 2016-07-18 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-122 – Heap-based Buffer Overflow The tinysvcmdns library is a MDNS responder implementation optimized for size, and is essentially a mini and embedded version of Avahi or Bonjour. It was found to be inside of the mdnsd daemon on the Circle with Disney device, and is used to enumerate devices within the same network as the Circle, such that it can later monitor or filter their traffic if the administrator/parent desires. While the majority of this bug is written in the context of the Circle with Disney device, this bug does apply to the tinysvcmdns library itself. The mdnsd binary is bound to the normal IPv4 addressf of the Circle device, and also the hardcoded IPv6 link local address  . Since there is already another binary called mdns-scan, that is bound UDP port 224.0.0.251:5353, and also a modified dnsmasq server on UDP 0.0.0.0:53, it is believed that the only purpose of the mdnsd binary is to provide IPv6 auto-discovery. Regardless, the mdnsd binary also responds and processes normal unicast DNS requests to UDP:5353, which is where this vulnerability lies. It does not appear that the disassembly is different from the tinysvcmdns source code in this vulnerable section. The   function in mdns.c is used to turn a series of name labels into a dotted representation of the domain name. For instance, when trying to  , the dns request will be separated into parts, as there is more than one suffix. The previous domain would look like this: Where by each portion of the domain is separated by a 1-byte field describing the length of the next  segment (\\x04 => abcd, etc). Normally, multi-label DNS names have some restrictions, as set forth by the RFC. However, the   function does not do any sort of filtering on this input: We can see there is a fixed heap allocation of size 256 at [1], however, there\'s no limitation to how many bytes can be copied. As long as the end of a given label is not “\\x00” [2], the strncpy\'s just keep flowing, allowing for an arbitrary write on the heap by anyone with network connectivity to the device. 2017-11-09 - Vendor Disclosure \n2017-11-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0439');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (226, 'libxls xls_getfcell Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable stack based buffer overflow vulnerability exists in the xls_getfcell function of libxls 1.3.4.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious XLS file to trigger this vulnerability. libxls 1.3.4 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow libxls is a C library supported on windows, mac, cygwin which can read Microsoft Excel File Format ( XLS ) files. The library is used by the readxl package of the Microsoft R programming language. However this particular vulnerability does not impact the readxl package. A stack based buffer overflow is present in the xls_getfcell function. Let\'s take a look at the vulnerable code: As the comment at   states, this fragment of code is responsible for parsing   cells. According to the definition in the   in the  : The cell which causes an overflow in our PoC is located at offset : 0x11957\nIts values look as follows: Based on the cell\'s   field which in code is represented as the   field, the   is located in the   record. We see that operation performed at   is  a\nclassic stack based buffer overflow, because as we can see   array has fixed size  , where string coming from     record can exceed that size and cause an overflow. 2017-08-29 - Vendor Disclosure \n2017-11-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0426');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (227, 'libxls xls_preparseWorkSheet MULBLANK Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable integer overflow vulnerability exists in the xls_preparseWorkSheet function of libxls 1.4 when handling a MULBLANK record.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious XLS file to trigger this vulnerability. libxls 1.4\nreadxl package 1.0.0 for R (tested using Microsoft R 4.3.1) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-680: Integer Overflow to Buffer Overflow libxls is a C library supported on windows, mac, cygwin which can read Microsoft Excel File Format ( XLS ) files. The library is used by the readxl package\nthat can be installed in the R programming language. The general purpose of the   function is to obtain the maximal size of   and   value from records present in the worksheet and update the   and   fields with that value.\nAs we can see in lines   an integer overflow can occur. This can have two potential impacts. In one case, the maximum value stored in   will not be updated even if the MULBLANK   field is greater than the value in  .\nThe other case will result in the   value being updated to the overflowed value. The malformed   record is located at offset : 0xCB1F and looks as follows: Setting breakpoint at   we can obtain the following information: stepping further after  : We see that   field has been updated with overflowed value 0x2.\nIt has further consequences in function   where based on the   field an array for cells is allocated: next during the final parsing of the malformed   record in  , an out of bound write occurs because the   value being used as index for the   array is greater than amount of allocated elements for that array. At   the   element points to a value outside of the array range which leads to an out-of-bounds write at  . 2017-10-25 - Vendor Disclosure \n2017-11-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0460');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (228, 'libxls xls_addCell Formula Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable out-of-bounds vulnerability exists in the xls_addCell function of libxls 1.4.\nA specially crafted XLS file with a formula record can cause memory corruption resulting in remote code execution.\nAn attacker can send a malicious XLS file to trigger this vulnerability. libxls 1.4 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-787: Out-of-bounds Write libxls is a C library supported on windows, mac, cygwin which can read Microsoft Excel File Format ( XLS ) files. The library is used by the readxl package that can be installed in the R programming language. However this particular vulnerability does not impact the readxl package. To analyze this vulnerability, we need to start at the   function. The   function iterates over all existing records and tries to find a maximum value for the   and   fields, these values are stored in   and  , respectively.\nThese values are later used for buffers allocations inside the   function: Later in the   function, the   function is called for nearly the same set of records that we saw in the   but with one exception,  : We did not see   with id   in  the  function. This means that for this record, the fields   and   have not been checked whether\ntheir value exceed the current maximum values stored in  ,  .\nThat lack of check for this type of record leads to an out of bound write in the   function. Let\'s take a look at the vulnerable code: The   value coming from the record is used as an index for the   array at  .\nThe malformed   record is located at offset : 0xCB1F Because this value has not been checked, it can easily exceed array\'s range. Write operations at lines   can subsequently cause an out-of-bounds write which subsequently leads to memory corruption. 2017-10-25 - Vendor Disclosure \n2017-11-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0463');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (229, 'libxls read_MSAT Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable out-of-bounds write vulnerability exists in the read_MSAT function of libxls 1.4.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious XLS file to trigger this vulnerability. libxls 1.4\nreadxl package 1.0.0 for R (tested using Microsoft R 4.3.1) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-787: Out-of-bounds Write libxls is a C library supported on Windows, Mac and Linux which can read Microsoft Excel File Format (XLS) files. The library is used by the readxl package\nthat can be installed in the R programming language.\nAn out-of-bounds write appears in the read_MSAT function. Let\'s take a look at the vulnerable code: As we can see in     buffer is allocated based on   and   value. The   value is read directly from the file (in our PoC   has value 0x1) where lsector has fixed size 0x200.\nNext in   we see that further \"sectors\" are read from the file (via sector_read) to the   buffer in the amount of  . We can observe a lack of any check\nwhether the new calculated offset for \"sector\" inside the   buffer does not exceed the buffer size allocated earlier. This thus leads to out of bounds writes and heap memory corruption, which can potentially\nlead to arbitrary code execution. Crash in Microsoft R platform: directly in libxls lib: 2017-08-29 - Vendor Disclosure \n2017-11-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0404');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (230, 'libxls xls_preparseWorkSheet MULRK Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable integer overflow vulnerability exists in the xls_preparseWorkSheet function of libxls 1.4 when handling a MULRK record.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious XLS file to trigger this vulnerability. libxls 1.4\nreadxl package 1.0.0 for R (tested using Microsoft R 4.3.1) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-680: Integer Overflow to Buffer Overflow libxls is a C library supported on windows, mac, cygwin which can read Microsoft Excel File Format ( XLS ) files. The library is used by the readxl package\nthat can be installed in the R programming language. As we can see in lines   an integer overflow can occur. This can have two potential impacts. In one case, the maximum value stored in   will not be updated even if the MULRK   field is greater than the value in  .\nThe other case will result in the   value being updated to the overflowed value. The malformed   record is located at offset : 0xCB1F and looks as follows: 0xCB1F      BD 00 20 00 AA AA FF FF Setting breakpoint at   we can obtain the following information: stepping further after  : We see that   field has been updated with overflowed value 0x2. It has further consequences in function   where based on the   field an array for cells is allocated: Next during the final parsing of the malformed   record in  , an out of bound write occurs because the   value being used as index for the   array is greater than amount of allocated elements for that array. At   the   element points to a value outside of the array range which leads to an out-of-bounds write at  . 2017-10-25 - Vendor Disclosure \n2017-11-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0461');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (231, 'libxls xls_mergedCells Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable out-of-bounds write vulnerability exists in the  xls_mergedCells function of libxls 1.4.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious xls file to trigger this vulnerability. libxls 1.4\nreadxl package 1.0.0 for R (tested using Microsoft R 4.3.1) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write libxls is a C library supported on Windows, Mac and Linux which can read Microsoft Excel File Format (XLS) files. The library is used by the readxl package\nthat can be installed in the R programming language.\nAn out-of-bounds write appears in the xls_mergedCells function. Let\'s take a look at the vulnerable code: Important variables and especially their content are:   and   which have been read in raw form from a file.\nWe see at   that the   value, which is exactly  , controls a loop.\nNext further parts of the   buffer are pointed to by the   variable at  . Because the   structure is based on data directly read from file, an attacker\nnot only fully controls the amount of executions of the   at lines 616 and 617 but also the offsets during writes to the   structure.\nUsing our PoC we can observe the following values during a crash: MergedCell record starts at offset : 7ED4Ch\nAnd has form :\n[BOF][SPAN][SPAN]...BOF.size*sizeof(MERGEDCELLS)...[SPAN] Crash in the Microsoft R platform: 2017-08-29 - Vendor Disclosure \n2017-11-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0403');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (232, 'libxls xls_appendSST Code Execution Vulnerability', 'None', '2017-11-15', 'An exploitable integer overflow vulnerability exists in the xls_appendSST function of libxls 1.4.\nA specially crafted XLS file can cause memory corruption resulting in remote code execution.\nAn attacker can send a malicious XLS file to trigger this vulnerability. libxls 1.4\nreadxl package 1.0.0 for R (tested using Microsoft R 4.3.1) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-787: Out-of-bounds Write libxls is a C library supported on windows, mac, cygwin which can read Microsoft Excel File Format ( XLS ) files. The library is used by the readxl package\nthat can be installed in the R programming language.\nBefore we will discuss the location where the out-of-bounds write appears, first let\'s check code where space allocation for that array takes place: As you can see at   space for   array is allocated based on the   value. This value is obtained at   from  .\nThe   structure passed as argument is fully controlled by attacker. By controlling the   structure, we can force allocation for any size, for example 1.\nThe malformed   record is located at offset 0x088F: The   strcture looks as follows in memory: The   field is at offset 0x897. With an   structure where values are set like these above, the   array will have space for just one element.\nGoing further inside the   function. Each string entry in  , after optional conversion, will be assigned (its address exactly) to separate entry in   array.\nThese string entries look as follows: We can observe this in the code below, where the   variable at   containing a \"decoded\" string address is assigned to the   array entry at  .\nNotice that for each string,   field value is increased being used as a index in   array. In our case, the attempt to assign a second string to that array will cause an out-of-bounds write, resulting in memory corruption and potential code execution. 2017-10-25 - Vendor Disclosure \n2017-11-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0462');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (233, 'Adobe Acrobat Reader DC PDF Structured Hierarchy ActualText Structure Element Remote Code Execution Vulnerability', 'None', '2017-11-14', 'An exploitable type confusion vulnerability exists in code responsible for parsing PDF documents with marked structure elements of Adobe Acrobat Reader DC 2017.009.20044. A specially crafted PDF file can trigger an out of bounds access on the heap potentially leading to arbitrary code execution. In order to trigger this vulnerability, the victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2017.009.20044 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-843: Access of Resource Using Incompatible Type (\'Type Confusion\') Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. Structured content elements are used in marked PDF documents to represent document structure which can be used when processing the document for future use. Some of these elements can influence the presentation of the content stream being rendered to the screen for accessibility, linguistic or other practical purposes. There exists a vulnerability in a way Acrobat Reader handles malformed content streams that have marked structure content elements attached to them. Specifically, when processing a content stream which refers to a non existing font, structure element with ActualText attribute specifying a Unicode encoded soft hyphen can cause a buffer for a structure to be allocated which is then used in part of the code that expects a pointer to a different, bigger, structure leading first to out of bounds access and then further heap corruption. Part of our proof of concept PDF file for this vulnerability is as follows: Above, in content stream in object 6, we see a   operator, which sends font and font size, referencing a non-existent font object. Then, we see two references to   numbered elements. These stand for Marked Content ID and refer to objects 10 and 11. When processing structured content, these structure elements are applied to the part of content stream they are part of. It should be pointed out that structure content element object 10 specifies   key with unicode value of 0xfeff00ad (code for soft hyphen) which is to be used instead of the text rendered to the screen. If we take a look with a debugger, we can see a memory area of size 0x18 being allocated: In the above debugging output, we break after a call to   which is basically a wrapper around  . After this allocation, the returned chunk is examined with   where we can see its user size is 0x18 bytes. If we continue the execution we can observe the following crash: Register   holds a pointer to the previously allocated object, but the current instruction is trying to allocate a dword  at offset 0x20 which is 8 bytes after the end of our buffer. This is clearly a read access violation that has crashed the process because of PageHeap, but if the out of bounds memory was readable, or another object was already there, the process could continue leading to further object misuse and further heap corruption which could be controlled to lead to arbitrary code execution. If a correct font, instead of a non-existent one, was referenced in the content stream, execution takes a different route and a memory chunk of correct size (0x28 bytes) is allocated. 2017-06-05 - Vendor Disclosure \n2017-11-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0356');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (234, 'Foscam IP Video Camera CGIProxy.fcgi Firmware Upgrade Code Execution Vulnerability', 'None', '2017-11-13', 'Insufficient security checks exist in the recovery procedure used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A HTTP request can allow for a user to perform a firmware upgrade using a crafted image. Before any firmware upgrades in this image are flashed to the device,  binaries as well as arguments to shell commands contained in the image are executed with elevated privileges. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43  \nPlug-In Version: 3.3.0.26 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-287: Improper Authentication Foscam  produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device provides a way to upgrade the firmware by sending a new image via an HTTP multipart request.\nHTTP requests are first handled by the \"CGIProxy.fcgi\" process, that will dispatch messages to the interested component.\nWhen handling the command \"fwUpgrade\", the function   in the \"webService\" binary will be called. A user account with privilege level 2 (administrator) is needed to invoke this command.\n  is responsible for shutting down all the components that might interfere with the upgrade process. After that, the multipart data is read and its contents are stored in the file \"/tmp/upgrade.bin\". Execution is then handed over to the function  , inside the binary \"FirmwareUpgrade\". At [1] the function that performs the actual upgrade is called.  kills most of the running processes on the device, unloads unused modules, and cleans temporary directories.\nAfter that, the directory \"/tmp/FWUpgrade\" is created at [2] and two strings are de-obfuscated at [3] by using the \"ReformString\" function. Those strings are then used to compose a command which will be sent to   [4]. The function performs this kind of de-obfuscation several times and it\'s enough to look at the shell commands executed to understand the functionality.\nThe upgrade image is sent to \"openssl\" for decryption, using the \"aes-128-cbc\" cipher and key \"WWzift*v2\". The resulting file is a gzipped tar archive which contains all the unencrypted files needed for the upgrade. Given that no signatures are applied to the upgrade procedure, anyone aware of the AES encryption key will be able to create a custom image. They will then be able to run custom binaries on the device as root, including   which is extracted from the image. The XML file    also contain filenames that are used as parameters to system() without any scrubbing, also resulting in potential command injection. Next to these command injections, attackers can also provide a custom firmware image to replace whatever is currently on the device. This vulnerability is reachable by the \"fwUpgrade\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to invoke the command. 2017-07-13 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0379');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (235, 'Foscam IP Video Camera webService dyndns.com DDNS Client Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the DDNS client used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. On devices with DDNS enabled, an attacker who is able to intercept HTTP connections will be able to fully compromise the device by creating a rogue HTTP server. Foscam, Inc. Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device can be configured to use a DDNS client to associate to a hostname the public IP address of the network hosting the camera. Clients have to be configured via the web interface by choosing between one of the supported DDNS providers together with a hostname, username and password.\nWhen the \"webService\" process starts it creates several threads, one of them is the \"DDNS update thread\", function  .\nAt [1]   contains the seconds elapsed since the last loop execution. Every 10 seconds [2], the function retrieves the public IP address [3] and if it detects a difference the new IP is updated [4].\nThe function   takes a pointer to the global structure at 0xa8074 as parameter [5]. This structure is located in the   segment and has a size of 140 bytes. The function  , checks if the configured hostname is not empty [6], then it retrieves the \"ddnsServer\" which is currently set [7]: this is a number between 0 and 5. 0 means that no DDNS is set [8], and retrieving the public IP address with DDNS number 3 is not supported [9]. Using this index, another function is called [10] that returns the \"ddnsServer\" instance (using a singleton pattern). The function responsible for retrieving the public IP address is then called [11], passing as arguments the \"ddnsServer\" instance and a buffer for storing the IP address [12]. This buffer starts at offset 0x58 in the global structure at 0xa8074.\nNote that for every provider a different function is used to retrieve the public IP address. When the DDNS provider in use is \"dyndns.com\" (DDNS number 4), the function   is called. This function calls   [13] to establish a connection with \"checkip.dyndns.com\" on port 80. An HTTP request is built [14] and sent to the socket by calling   [15]. The response from the remote server is then retrieved using   [16], which will read at most 1024 bytes [17]. The function then ensures that the string \"200 OK\" is present anywhere in the response [18], then finds \"\\r\\n\\r\\n\" [19] and ensures that after it the string \"Current IP Address: \" exists [20]. After this string the function expects to find the IP address.\nFrom this point every character is copied in the buffer passed to the function [21] using a loop, which will only exit when the character \"<\" [22] is found. Since the size of the destination buffer is not taken into account, a malicious HTTP server could exploit this vulnerability to write out of bounds. Prerequisite for this attack is that the device is setup to use the DDNS number 4. For this, the following query can be used: To trigger the vulnerability, an attacker needs to be able to intercept the device\'s HTTP requests and answer with a malicious payload. The following command will make the service crash. 2017-07-17 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0359');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (236, 'Foscam IP Video Camera CGIProxy.fcgi SoftAP Configuration Command Injection Vulnerability', 'None', '2017-11-13', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during the SoftAP configuration resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device allows for configuring a SoftAP to enable users to configure the camera for the first time via WiFi. This feature is configurable using the web interface.\nHTTP requests are first handled by the \"CGIProxy.fcgi\" process, that will dispatch messages to the interested component.\nWhen handling the command \"setSoftApConfig\", the function   in the \"webService\" binary will be called. A user account with privilege level 2 (administrator) is needed to invoke this command. The function extracts the parameters from the query [1], then it ensures that the \"psk\" parameter is at least 7 characters long [2] and that it doesn\'t contain \"\\n\" or \"\\r\" characters [3]. Finally the request is forwarded to another component, using the message code \"0x607F\" [4]. Message code \"0x607F\" is handled by the function   in the \"devMng\" binary.\nThis function copies a fixed SSID and the user-supplied PSK into the \"CNetworkService\" object [5]. Then at [6] it calls another function that modifies the configuration file of the SoftAP.  copies again SSID and PSK and calls   which is in charge of actually configuring the SoftAP.\nThis function first updates the file \"/mnt/mtd/app/config/SoftApConfig.xml\" at [7] with the new SoftAP parameters, then it proceeds to update \"/mnt/mtd/app/etc/RT2870AP.dat\". This is done using the command   via a call to   [8]. Since the PSK parameter at [9] is controlled by the user, an attacker could exploit this bug to inject arbitrary shell commands. This vulnerability is reachable by the \"setSoftApConfig\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-07-13 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0380');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (237, 'Foscam IP Video Camera webService 3322.net DDNS Client Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the DDNS client used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. On devices with DDNS enabled, an attacker who is able to intercept HTTP connections will be able to fully compromise the device by creating a rogue HTTP server. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device can be configured to use a DDNS client to associate to a hostname the public IP address of the network hosting the camera. Clients have to be configured via the web interface by choosing between one of the supported DDNS providers together with a hostname, username and password.\nWhen the \"webService\" process starts it creates several threads, one of them is the \"DDNS update thread\", function  .\nAt [1]   contains the seconds elapsed since the last loop execution. Every 10 seconds [2], the function retrieves the public IP address [3] and if it detects a difference the new IP is updated [4].\nThe function   takes a pointer to the global structure at 0xa8074 as parameter [5]. This structure is located in the   segment and has a size of 140 bytes. The function  , checks if the configured hostname is not empty [6], then it retrieves the \"ddnsServer\" which is currently set [7]: this is a number between 0 and 5. 0 means that no DDNS is set [8], and retrieving the public IP address with DDNS number 3 is not supported [9]. Using this index, another function is called [10] that returns the \"ddnsServer\" instance (using a singleton pattern). The function responsible for retrieving the public IP address is then called [11], passing as arguments the \"ddnsServer\" instance and a buffer for storing the IP address [12]. This buffer starts at offset 0x58 in the global structure at 0xa8074.\nNote that for every provider a different function is used to retrieve the public IP address. When the DDNS provider in use is \"3322.net\" (DDNS number 2), the function   is called. This function calls   [13] to establish a connection with \"ip.3322.net\" on port 80. An HTTP request is built [14] and sent to the socket by calling   [15]. The response from the remote server is then retrieved using   [16], which will read at most 1024 bytes [17]. The function then ensures that the string \"200 OK\" is present anywhere in the response [18] and then finds the string \"\\r\\n\\r\\n\" [19]. After this string the function expects to find the IP address.\nFrom this point every character is copied in the buffer passed to the function [20] using a loop, which will only exit when a carriage return [21] is found. Since the size of the destination buffer is not taken into account, a malicious HTTP server could exploit this vulnerability to write out of bounds. Prerequisite for this attack is that the device is setup to use the DDNS number 2. For this, the following query can be used: To trigger the vulnerability, an attacker needs to be able to intercept the device\'s HTTP requests and answer with a malicious payload. The following command will make the service crash. 2017-07-17 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0358');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (238, 'Foscam IP Video Camera webService 9299.org DDNS Client Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the DDNS client used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. On devices with DDNS enabled, an attacker who is able to intercept HTTP connections will be able to fully compromise the device by creating a rogue HTTP server. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device can be configured to use a DDNS client to associate to a hostname the public IP address of the network hosting the camera. Clients have to be configured via the web interface by choosing between one of the supported DDNS providers together with a hostname, username and password.\nWhen the \"webService\" process starts it creates several threads, one of them is the \"DDNS update thread\", function  .\nAt [1]   contains the seconds elapsed since the last loop execution. Every 10 seconds [2], the function retrieves the public IP address [3] and if it detects a difference the new IP is updated [4].\nThe function   takes a pointer to the global structure at 0xa8074 as parameter [5]. This structure is located in the   segment and has a size of 140 bytes. The function  , checks if the configured hostname is not empty [6], then it retrieves the \"ddnsServer\" which is currently set [7]: this is a number between 0 and 5. 0 means that no DDNS is set [8], and retrieving the public IP address with DDNS number 3 is not supported [9]. Using this index, another function is called [10] that returns the \"ddnsServer\" instance (using a singleton pattern). The function responsible for retrieving the public IP address is then called [11], passing as arguments the \"ddnsServer\" instance and a buffer for storing the IP address [12]. This buffer starts at offset 0x58 in the global structure at 0xa8074.\nNote that for every provider a different function is used to retrieve the public IP address. When the DDNS provider in use is \"9299.org\" (DDNS number 5), the function   is called. This function calls   [13] to establish a connection with \"ip.9299.org\" on port 80. An HTTP request is built [14] and sent to the socket by calling   [15]. The response from the remote server is then retrieved using   [16], which will read at most 1024 bytes [17]. The function then ensures that the string \"200 OK\" is present anywhere in the response [18], then finds \"\\r\\n\\r\\n\" [19] and ensures that after it the string \"Current IP Address:\" exists [20]. After this string the function expects to find the IP address.\nFrom this point every character is copied in the buffer passed to the function [21] using a loop, which will only exit when a carriage return [22] is found. Since the size of the destination buffer is not taken into account, a malicious HTTP server could exploit this vulnerability to write out of bounds. Prerequisite for this attack is that the device is setup to use the DDNS number 5. For this, the following query can be used: To trigger the vulnerability, an attacker needs to be able to intercept the device\'s HTTP requests and answer with a malicious payload. The following command will make the service crash. 2017-07-17 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0360');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (239, 'Foscam IP Video Camera webService oray.com DDNS Client Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the DDNS client used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. On devices with DDNS enabled, an attacker who is able to intercept HTTP connections will be able to fully compromise the device by creating a rogue HTTP server. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device can be configured to use a DDNS client to associate to a hostname the public IP address of the network hosting the camera. Clients have to be configured via the web interface by choosing between one of the supported DDNS providers together with a hostname, username and password.\nWhen the \"webService\" process starts it creates several threads, one of them is the \"DDNS update thread\", function  .\nAt [1]   contains the seconds elapsed since the last loop execution. Every 10 seconds [2], the function retrieves the public IP address [3] and if it detects a difference the new IP is updated [4].\nThe function   takes a pointer to the global structure at 0xa8074 as parameter [5]. This structure is located in the   segment and has a size of 140 bytes. The function  , checks if the configured hostname is not empty [6], then it retrieves the \"ddnsServer\" which is currently set [7]: this is a number between 0 and 5. 0 means that no DDNS is set [8], and retrieving the public IP address with DDNS number 3 is not supported [9]. Using this index, another function is called [10] that returns the \"ddnsServer\" instance (using a singleton pattern). The function responsible for retrieving the public IP address is then called [11], passing as arguments the \"ddnsServer\" instance and a buffer for storing the IP address [12]. This buffer starts at offset 0x58 in the global structure at 0xa8074.\nNote that for every provider a different function is used to retrieve the public IP address. When the DDNS provider in use is \"oray.com\" (DDNS number 1), the function   is called. This function calls   [13] to establish a connection with \"ddns.oray.com\" on port 80. An HTTP request is built [14] and sent to the socket by calling   [15]. The response from the remote server is then retrieved using   [16], which will read at most 1024 bytes [17]. The function then ensures that the string \"200 OK\" is present anywhere in the response [18] and then finds the string \"Current IP Address:\" [19]. After this string the function expects to find the IP address.\nFrom this point every character is copied in the buffer passed to the function [20] using a loop, which will only exit when the character \"<\" [21] is found. Since the size of the destination buffer is not taken into account, a malicious HTTP server could exploit this vulnerability to write out of bounds. Prerequisite for this attack is that the device is setup to use the DDNS number 1. For this, the following query can be used: To trigger the vulnerability, an attacker needs to be able to intercept the device\'s HTTP requests and answer with a malicious payload. The following command will make the service crash. 2017-07-17 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0357');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (240, 'Foscam IP Video Camera CGIProxy.fcgi logOut Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted HTTP request can cause a buffer overflow resulting in overwriting arbitrary data. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device has a web interface that requires authentication in order to access specific features. Log-in and log-out operations are performed by means of a CGI call.\nHTTP requests are first handled by the \"CGIProxy.fcgi\" process, that will dispatch messages to the interested component.\nWhen handling the command \"logOut\", the function   in the \"webService\" binary will be called. Any kind of user account can be used to issue this command (the less privileged one being the \"visitor\" account, level 0). The function extracts the parameter \"usrName\" from the query. This is done using the function   [1], which ensures that at most 0x40 [2] characters are placed in the destination buffer [3]. The buffer is then copied again [4] and sent to a different process via an IPC call with code \"0x400A\" [5]. Message code \"0x400A\" is handled by the function   in the \"storage\" binary.\nThis function copies the username passed via IPC, the IP address, and the number \"4\" into a structure of size 0x2c, which is then passed to a function [6] for logging the \"logOut\" action.\nIn particular, the username is copied into the structure using   [7]. The space reserved for the username is 0x20 bytes, which is smaller than the maximum size extracted by function   (0x40 bytes). This difference is enough to allow for overwriting the saved PC on the stack. This vulnerability is reachable by the \"logOut\" command and requires a valid user account with (at least) \"visitor\" privileges. The following proof of concept overwrites the saved PC and the register  , in order to call \"system(\"reboot\")\". Multiple attempts are needed to succeed. 2017-08-03 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0385');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (241, 'Foscam IP Video Camera devMng Multi-Camera Port 10001 Command 0x0064 Empty AuthResetKey Vulnerability', 'None', '2017-11-13', 'A missing error check exists in the Multi-Camera interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted request on port 10001 could allow an attacker to reset the user accounts to factory defaults, without authentication. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-392: Missing Report of Error Condition Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device has a Multi-Camera feature that allows cameras to communicate with each other, in order to display multiple streams on a unique web interface.\nCommunication between cameras happen on UDP ports 10000 and 10001 and is handled by the binary \"devMng\".  is the threaded function that manages incoming messages on both ports using   [1].\nIf a message is sent to port 10001, the function   is called [2].  receives the \"CIPCamDiscovery\" object [3], the message [4] and its length [5] as parameters. The message header \"MO_I\" is checked [6] and the 16bit command identifier is extracted [7].\nIf the \"discovery\" command (\"0x0064\") is used [8], the 32bit payload size is extracted and verified against the length of the whole message minus 0x17 (the header length) [9].\nIf all checks are passed, the function   is called [10] passing the message payload as second parameter [11].  allows for resetting the user accounts in the device, given a valid \"authResetKey\" is supplied. Usually this key can be retrieved with the CGI command \"getAuthResetKey\", which is in charge of generating a random key and to send it to the \"devMng\" process, which stores it in a global variable. To invoke this CGI command, administrator privileges are required. At [12] the key, passed as second parameter, is stored in  . At [13] the expected key buffer is stored in   and is cleared [14]. The function   is then called passing a global structure [15] and the expected key buffer as arguments.  copies the expected key from the global structure to the buffer if the \"authResetKey\" is set [16]. If not, the function prints an error, but the return value is 0 in both cases. Back in the parent function, there\'s no way to check whether the previous call was successful or not: the execution continues and the key and expected key buffers are compared [17]. If equal, the password reset request is sent via an IPC call with code 0x4028 [18]: this invokes the function \"OnWebServiceMsgRestoreUserAccount\" in the \"webService\" binary, which resets the user accounts to factory defaults. Because function   fails to return an error code, an attacker could reset the users\' database by sending a request with a 1-byte null value as key. This vulnerability is reachable on port 10001 by command 0x0064 and doesn\'t require any privilege.\nThe following proof of concept sends a request with an empty key (\"\\x00\") which should reset the accounts to factory defaults when no \"authResetKey\" is set. 2017-07-13 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0384');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (242, 'Foscam IP Video Camera devMng Multi-Camera Port 10000 Command 0x0002 Username Field Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the Multi-Camera interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted request on port 10000 can cause a buffer overflow resulting in overwriting arbitrary data. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device has a Multi-Camera feature that allows cameras to communicate with each other, in order to display multiple streams on a unique web interface.\nCommunication between cameras happen on UDP ports 10000 and 10001 and is handled by the binary \"devMng\".  is the threaded function that manages incoming messages on both ports using   [1].\nIf a message is sent to port 10000, the function   is called [2].  receives the \"CIPCamDiscovery\" object [3], the message [4] and its length [5] as parameters. The message header \"MO_I\" is checked [6] and the 16bit command identifier is extracted [7].\nIf the \"discovery\" command (\"0x0002\") is used [8], the 32bit payload size is extracted and verified against the length of the whole message minus 0x17 (the header length) [9].\nIf all checks are passed the function   is called [10].  expects a message containing the MAC address of the receiving device. If the MAC is correct [11], username [12] and password [13] fields are extracted from the message and stored in a buffer [14] that will be sent to another process using an IPC call with code 0x400C [15]: this invokes the function \"OnWebSericeUsrCheck\" in the \"webservice\" binary, which is used to check username and password correctness. At [13] the password is placed in the IPC buffer on the stack using an unsafe  , which doesn\'t take into account the maximum length of the destination buffer. Since the maximum message length is 233 bytes and the buffer is smaller than that, this bug could be used by an attacker to overwrite sensitive data in the stack and execute arbitrary code. This vulnerability is reachable by the \"discovery\" command (0x0002) and doesn\'t need authentication.\nThe following proof of concept overwrites the saved PC on the stack and jumps to a piece of code that reboots the device. 2017-07-13 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0382');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (243, 'Foscam IP Video Camera UPnP Discovery Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the UPnP implementation used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted UPnP discovery response can cause a buffer overflow resulting in overwriting arbitrary data. An attacker needs to be in the same subnetwork and reply to a discovery message to trigger this vulnerability. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 7.5 - CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device implements the UPnP protocol, which is used to communicate with the network gateway in order to make the camera\'s web interface remotely accessible.\nWhen UPnP is enabled, the device sends the following UPnP discovery message to the multicast address 239.255.255.250 on port 1900, every 30 seconds. When a reply to this message is received, the device parses it, extracts the control URL and connects to it in order to continue the communication. Function   in the \"webService\" binary is run in a dedicated thread. It continuously tries to discover new UPnP enabled devices by calling function   [1] which in turn calls  . Function   builds an UPnP discovery message [2] and sends it [3] to the multicast address \"239.255.255.250\". When an answer is received [4], the message at [5] is parsed. The buffer at [5] is copied and checked to contain: Finally,   is called [9] passing as third parameter the pointer to an \"std::string\" object containing the message starting at \"http://\". Function   parses the control URL and sends an HTTP request to it.\nTo do this, the control URL [10] is first tokenized by function  , which places host [11], port [12] and path [13] in three different buffers.\nThe HTTP request is then built by composing the extracted tokens with   [14] and is placed in a destination buffer which has a size of 200 bytes [15]. Since   does not impose a maximum length and since the parameters passed to   haven\'t had their size checked, the destination buffer can be overflown with an overlong control URL. When UPnP is enabled, this vulnerability can be triggered with a simple UDP message, upon reception of an UPnP discovery. The following proof of concept will make the web service crash. 2017-08-03 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0386');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (244, 'Foscam IP Video Camera devMng Multi-Camera Port 10000 Command 0x0002 Password Field Code Execution Vulnerability', 'None', '2017-11-13', 'An exploitable buffer overflow vulnerability exists in the Multi-Camera interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted request on port 10000 can cause a buffer overflow resulting in overwriting arbitrary data. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device has a Multi-Camera feature that allows cameras to communicate with each other, in order to display multiple streams on a unique web interface.\nCommunication between cameras happen on UDP ports 10000 and 10001 and is handled by the binary \"devMng\".  is the threaded function that manages incoming messages on both ports using   [1].\nIf a message is sent to port 10000, the function   is called [2].  receives the \"CIPCamDiscovery\" object [3], the message [4] and its length [5] as parameters. The message header \"MO_I\" is checked [6] and the 16bit command identifier is extracted [7].\nIf the \"discovery\" command (\"0x0002\") is used [8], the 32bit payload size is extracted and verified against the length of the whole message minus 0x17 (the header length) [9].\nIf all checks are passed the function   is called [10].  expects a message containing the MAC address of the receiving device. If the MAC is correct [11], username [12] and password [13] fields are extracted from the message and stored in a buffer [14] that will be sent to another process using an IPC call with code 0x400C [15]: this invokes the function \"OnWebSericeUsrCheck\" in the \"webservice\" binary, which is used to check username and password correctness. At [12] the username is placed in the IPC buffer on the stack using an unsafe  , which doesn\'t take into account the maximum length of the destination buffer. Since the maximum message length is 233 bytes and the buffer is smaller than that, this bug could be used by an attacker to overwrite sensitive data in the stack and execute arbitrary code. This vulnerability is reachable by the \"discovery\" command (0x0002) and doesn\'t need authentication.\nThe following proof of concept overwrites the saved PC on the stack and jumps to a piece of code that reboots the device. 2017-07-13 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0383');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (245, 'Foscam IP Video Camera devMng Multi-Camera Port 10000 Command 0x0000 Information Disclosure Vulnerability', 'None', '2017-11-13', 'An information disclosure vulnerability exists in the Multi-Camera interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.43. A specially crafted request on port 10001 can allow for a user to retrieve sensitive information without authentication. Foscam Indoor IP Camera C1 Series \nSystem Firmware Version: 1.9.3.18 \nApplication Firmware Version: 2.52.2.43 \nPlug-In Version: 3.3.0.26 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N CWE-200: Information Exposure Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The device has a Multi-Camera feature that allows cameras to communicate with each other, in order to display multiple streams on a unique web interface.\nCommunication between cameras happen on UDP ports 10000 and 10001 and is handled by the binary \"devMng\".  is the threaded function that manages incoming messages on both ports using   [1].\nIf a message is sent to port 10001, the function   is called [2].  receives the \"CIPCamDiscovery\" object [3], the message [4] and its length [5] as parameters. The message header \"MO_I\" is checked [6] and the 16bit command identifier is extracted [7].\nIf the \"find\" command (\"0x0000\") is used [8], the 32bit payload size is extracted and verified against the length of the whole message minus 0x17 (the header length) [9].\nIf all checks are passed the function   is called [10].  retrieves information from the camera like the MAC address [11], the camera name [12], firmware version [13] and put them in a buffer that is sent back as an answer [14]. As demonstrated in TALOS-2017-0382 and TALOS-2017-0383, the MAC address is needed for sending commands on port 10000 and the existence of this bug enables remote exploitation outside the local network. This vulnerability is reachable by the \"find\" command (0x0000) and doesn\'t need authentication. The following proof of concept retrieves the MAC address, camera name and firmware version. 2017-07-13 - Vendor Disclosure \n2017-11-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0381');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (246, 'Circle with Disney WiFi Restart SSID Parsing Command Injection Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the WiFi configuration functionality of Circle with Disney running firmware 2.0.1. A specially crafted SSID can cause the device to execute arbitrary shell commands. An attacker needs to send a couple of HTTP requests and setup an access point reachable by the device to trigger this vulnerability. Circle with Disney 2.0.1 9.0 - CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-77: Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Circle with Disney is a network device used to monitor internet use of children on a given network. Circle can connect to a home network either via WiFi or wired connection. WiFi is set-up during the initial configuration but can also be modified in a later stage via API commands. When the wired interface is working, WiFi is not in use. The monitor function   in the   binary keeps track of the wired interface connectivity by reading the file   every second.\nIf a disconnection is detected (e.g. when the ethernet cable gets disconnected), it tries to switch to the WiFi interface by calling  . At high level this function works as follow: Note that   refers to the operation of retrieving an element from \"configure.xml\". In short,   retrieves the configured SSID from \"configure.xml\", then using   ( ) [2] retrieves the current channel, security (WPA2, WEP or none) and whether the SSID is hidden or not, from a recent Access Point scan. These parameters are then passed without sanitization to the   script using   [3].  [1] will be called if \"ap_list.out\" doesn\'t exist, but can be also arbitrarily invoked using the API command  .\nThe contents of   are:  [4] prints a list of Access Points detected by  , every entry has the following form: Then   [2] parses each of these entries in \"ap_list.out\", to find the expected SSID and returns its related \"Encryption\" and \"Channel\" values. At high level it works as follows: An SSID field in an 802.11 frame has a maximum length of 32 bytes and can contain any character.\nMoreover,   will print the characters found in the SSID without escaping.\nThis means that an attacker may use an SSID containing new-line characters to add arbitrary lines to the   output. Example: If the SSID above is broadcasted,   will output an entry like the following: This allows an attacker to control the encryption string returned by  , which gets passed to   at [3].\nSince the maximum SSID length is 32 bytes, and the custom string starts at byte 24th, an attacker can inject a maximum of 8 characters. The following proof of concept shows how to run an arbitrary command on the device, in this case the script   is executed. Some conditions need to be satisfied for this PoC to work, even though other less restrictive methods might exist: Steps: The command executed by   in this case will be This will in turn execute the command  .\nExecution happens from the directory   which has the following contents: The command   will then expand to  :  will establish a connection with the attacker\'s machine on port 0, which will be internally redirected to port 8888.\nAfter the connection is closed, the output of the conversation will be executed as a command because of the backticks surrounding the   command. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0422');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (247, 'Circle with Disney check_circleservers Code Execution Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the servers update functionality of Circle with Disney running firmware 2.0.1. Specially crafted network packets can cause the device to overwrite sensitive files, resulting in code execution. An attacker needs to impersonate a remote server in order to trigger this vulnerability. Circle with Disney 2.0.1 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-73: External Control of File Name or Path Circle with Disney is a network device used to monitor internet use of children on a given network. A cronjob exists which executes the script \"check_circleservers.sh\" every 4 hours: The script above downloads an encrypted tar archive using an HTTP request, which gets then decrypted and extracted in the \"/tmp\" directory.\nSince the encryption password is known and the http connection is not authenticated, an attacker able to impersonate the remote server could overwrite any file in the \"/tmp\" directory.\nSince the script itself executes \"/tmp/aescrypt\", one of the ways to exploit this bug is to overwrite \"aescrypt\" with a custom executable: this allows an attacker to execute arbitrary code on the next call of the script. The following proof of concept shows how to execute the \"power_down.sh\" script on the device.\nAn attacker needs to impersonate the server \"download.meetcircle.co\" in order to answer to the HTTP requests. 2017-08-02 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0389');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (248, 'Circle with Disney Backup API Command Injection Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the /api/CONFIG/backup functionality of Circle with Disney. Specially crafted network packets can cause an OS command injection. An attacker can send an HTTP request trigger this vulnerability. Circle with Disney 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-77: Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Vulnerable code exists in the backup api handler of the apid deamon (\"/api/CONFIG/backup\"). Looking at the pseudocode of the above, we see the following: As we can see   parameter coming from user as GET parameter is passed direcly to   call without any sanitization leading in that way to command injection.\nThis API is accessible for authenticated users. But taking into account the weak authentication vulnerability (TALOS-2017-0370/CVE-2017-2864) anyone can use this API. An example of a url that contains the command injection can look like this: 2017-07-13 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0372');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (249, 'Circle with Disney Database Updater Code Execution Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the database update functionality of Circle with Disney running firmware 2.0.1. Specially crafted network packets can cause the device to execute arbitrary code. An attacker needs to impersonate a remote server in order to trigger this vulnerability. Circle with Disney 2.0.1 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-300: Channel Accessible by Non-Endpoint (\'Man-in-the-Middle\') Circle with Disney is a network device used to monitor internet use of children on a given network. A cronjob exists which executes the script \"firmware_updater.sh\" every hour: The script above installs updates for the device if new versions are available. Latest versions are retrieved using an HTTP request. If the update script is called within 1am and 4am and no API commands were issued in the last hour, the database will be updated when a new version is available. The new version for the database is retrieved using an HTTP request: an archive is downloaded from \"download.meetcircle.co\", it is extracted in \"/mnt/tmp\" and, if a few conditions are met, the script \"update_database.sh\" present in the archive is executed. Since both HTTP requests are unauthenticated, an attacker able to impersonate the remote server could return a malicious archive containing a custom \"update_database.sh\" script. The following proof of concept shows how to execute the \"power_down.sh\" script on the device.\nAn attacker needs to impersonate the server \"download.meetcircle.co\" in order to answer the HTTP requests. 2017-08-02 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0390');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (250, 'Circle with Disney Startup WiFi Channel Parsing Command Injection Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the WiFi Channel parsing of Circle with Disney running firmware 2.0.1. A specially crafted SSID can cause the device to execute arbitrary sed commands. An attacker needs to setup an access point reachable by the device to trigger this vulnerability. Circle with Disney 2.0.1 7.4 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H CWE-77: Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Circle with Disney is a network device used to monitor internet use of children on a given network. At the end of the boot process, the script \"/mnt/shares/usr/bin/startcircle\" is executed.\nThe script configures NTP, network interfaces, firewall rules and starts cronjobs. Part of the script configures an Access Point, which is actually useful only for the initial configuration of the device. At [1] the script calls  , which has the following contents: After creating \"ap_list.out\" at [1], the initial script will select the channel that has the best signal.\nThe channel is extracted as a string, using   with its default field separators [2]. Finally at [3] the channel is used in a   substitution command, without any sanitization. An SSID field in an 802.11 frame has a maximum length of 32 bytes and can contain any character.\nMoreover,   will print the characters found in the SSID without escaping.\nThis means that an attacker may use an SSID containing new-line characters to add arbitrary lines to the   output. This allows an attacker to control the channel string returned by  , which gets passed to   at [3]. The following proof of concept shows how to freeze the box on startup by broadcasting a specific SSID.\nThe box will need manual power-cycling to boot again. The SSID above is injected in the   substitution command. Since semicolons are not escaped, they can be used to inject a new   command. In this example the injection creates an infinite loop by defining a \"x/g\" label and by jumping to it using \"bx/g\" (the ending \"/g\" is added by circle\'s script at [3]). 2017-09-20 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0446');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (251, 'Circle with Disney Configuration Restore Photos File Overwrite Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the /api/CONFIG/restore functionality of Circle with Disney running firmware 2.0.1. Specially crafted network packets can cause an arbitrary file to be overwritten. An attacker can send an HTTP request trigger this vulnerability. Circle with Disney 2.0.1 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-59: Improper Link Resolution Before File Access (\'Link Following\') Circle with Disney is a network device used to monitor internet use of children on a given network. Circle allows for backing up and restoring configuration backups using API commands.\nBackups can be performed using the command \"/api/CONFIG/backup\", which will return an encrypted archive. Encryption is performed using the   binary and the password used is the one extracted from the   parameter of the API command.\nBefore encryption, the backup binary is a gzipped tar archive with the following contents: The archive contains a copy of \"configure.xml\", the \"backup.version\" file to ensure compatibility, and a \"photos\" directory containing profile\'s photos. Vulnerable code exists in the \"/api/CONFIG/restore\" command, which executes the script \"/mnt/shares/usr/bin/scripts/restore backup.sh\": where \"postfile.bin\" is the encrypted binary and \"appid\" is taken from the request.\nContents of \"restore_backup.sh\" are shown below: Note that the value of \"CIRCLE_ROOT\" is \"/mnt/shares/usr/bin/\".\nAt [1] the binary is decrypted and at [2] it\'s extracted in \"/mnt/shares/usr/bin/backup\".\nAfter a few checks files are copied from the temporary backup directory to their real destinations.\nIn particular at [3] all the files contained in the \"photos\" directory will be copied to \"/mnt/shares/usr/bin/photos\". No restrictions are in place on the contents of the \"photos\" directory: an attacker may include a symbolic link to any file in the system which might cause future operations to have an unexpected behavior. Indeed, this would allow an attacker to overwrite any file in the system.\nConsider the following symbolic link is copied to \"photos/\": An attacker, using the API command \"/api/UPDATE/users/user/photo\" can overwrite the photo for user with pid 123, which will in turn overwrite the file \"check time.sh\" with arbitrary data. The following proof of concept shows how to run an arbitrary command on the device, in this case the script   is executed. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0423');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (252, 'Circle with Disney libbluecoat.so SSL TLD MITM Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in filtering functionality of Circle with Disney. SSL certificates for specific domain names can cause the Bluecoat library to accept a different certificate than intended. An attacker can host an HTTPS server with this certificate to trigger this vulnerability. Circle with Disney 2.0.1 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-300: Channel Accessible by Non-Endpoint (\'Man-in-the-Middle\') Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins arp poisoning all filtered devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. Libbluecoat.so is a shared library linked into the timetracker and filterd binaries within the Disney Circle, and is the communications mechanism through which the Disney Circle can talk to the Blue Coat Systems API. If the Circle doesn\'t know what to do with a given DNS name or IP address that has been requested by a filtered device, it will ask the Blue Coat infrastructure, and take the appropriate action as determined by Blue Coat. Whenever a new destination address is seen, and it is not found within the local \'bluecache\' (a custom hash table cache stored on the device) libbluecoat will query outbound to find the designated action, and then cache the result. The timetracker and filterd services act on different network activities, however the end result is the same. In total, they end up covering TCP, UDP, and the IP protocols used for VPNs, ESP and GRE. It\'s also worth noting that there are more product specific codeflows, such as one for the Google Mobilizer Proxy. In more detail, both binaries call the same library function,  , which leads to the main control flow, inside of the   function. This function sets up an SSL connection to sp.cwfservice.net, a Blue Coat Systems controlled domain, and then does a rather simple request. Where by the first \'%s\' is the unique mac address of the Circle making the request, and the second \'%s\' is the DNS name in question, which could potentially be some sensitive information. Regardless, backing up a little bit, there is some SSL validation that occurs before this information is ever transmitted. As shown at [1] libbluecoat.so gets the X509 subject name of the certificate, and then at [2], uses this to call X509 oneline, which grabs a lot of the information from the certificate attributes, joins it all into one line, and then stores it into a buffer on the stack [3] of max size 0x400. An example return string might be: While the interesting behavior of the X509 oneline can lead to some other vulnerabilites, like including the string \'CN=*.sp.cwfservice.net” inside of another attribute  ( For a great writeup of this:  [https://langui.sh/2016/01/29/x509-name-oneline/])(https://langui.sh/2016/01/29/x509-name-oneline/) ) , however, due to reasons mentioned a little further down, the binary was not vulnerable to this, as we could not get a certificate signed by the specific CA to be formed as such. However, due to how they actually check the Common Name attribute of the SSL cert, the binary was left vulnerable to another attack vector: Picking up from where we left off, we continue from immediately after the X509 oneline() function call [1], with the X509 online string stored in $s0. This string is compared is compared against “CN=sp.cwfservice.net” [2], with the strstr() function [3], which returns a pointer to the first match of register $a1 in $a0 (and NULL otherwise). Since this is the only check upon the Common Name attribute, it becomes possible to bypass this check by buying the following domain:  . The return value from X509 name will look as such: And then the resulting call to strstr will return  . It should be cautioned that certificate presented by the MITM server needs to have its trust chain signed by the Entrust CA. The binary has a CA DER-encoded cert chain located inside that is read into memory and then utilized to validate the outbound SSL connection. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0420');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (253, 'Cesanta Mongoose Websocket Protocol Fragmented Packet Code Execution Vulnerability', 'None', '2017-10-31', 'An exploitable memory corruption vulnerability exists in the Websocket protocol implementation of Cesanta Mongoose 6.8. A specially crafted websocket packet can cause a buffer to be allocated while leaving stale pointers which leads to a use-after-free vulnerability which can be exploited to achieve remote code execution. An attacker needs to send a specially crafted websocket packet over network to trigger this vulnerability. Cesanta Mongoose 6.8 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-416: Use After Free Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. It’s HTTP implementation includes upgrade support required for websocket applications. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. A websocket frame can be fragmented over multiple packets. Flags in the websocket header specify if the packet is fragmented and it’s order. When encountering a first frame fragment, a buffer reallocation causes several pointers to become invalid, but the code doesn’t invalidate or update them leading to potential use after free condition which can lead to further memory corruption. In function   responsible for parsing the websocket packet we observe the following code: In the above code, if the packet is marked for reassembly (checked at [1]) and is first fragment (checked at [2]), receive buffer is resized at [3]. Function   actually calls   to resize the buffer. Calling   on a buffer to resize it doesn’t guarantee that the same memory would be used, a different heap chunk can be chosen and original data would be copied there. This effectively makes old pointers - pointing to original buffer - invalid. In the above code, stale pointers are reused at [4],[5],[6] and [7] to do memory reads, writes and a memory copy. Pointers  ,  , ,sizep wsm.data nc->recv_mbuf` buffer at the beginning of the function: Calling   won’t invalidate a pointer always but, in this case steps can be taken make that probability higher, like multiple simultaneous network connections. Not invalidating and updating pointers after   leads to a use after free condition which can be abused to cause denial of service and ultimately remote code execution. 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0429');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (254, 'Cesanta Mongoose Websocket Protocol Packet Length Code Execution Vulnerability', 'None', '2017-10-31', 'An exploitable memory corruption vulnerability exists in the Websocket protocol implementation of Cesanta Mongoose 6.8. A specially crafted websocket packet can cause an integer overflow resulting leading to heap buffer overflow resulting in denial of service and potential remote code execution. An attacker needs to send a specially crafted websocket packet over network to trigger this vulnerability. Cesanta Mongoose 6.8 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. Its HTTP implementation includes upgrade support required for websocket applications. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. After the initial websocket handshake and while parsing a websocket packet, an integer overflow involving header length and packet size can occur. Insufficient checks after the potential overflow can later lead to very large memory overwrite which can result in heap memory corruption, process crash and potentially in remote code execution. In the above code, we can see at [1] local variables  ,   and   being declared as 64bit unsigned integers. At [2] header length is calculated since websocket protocol specifies variable length headers. At [3], 8 bytes from the packet are used as   directly. At [4], total   is calculated and at [5] basic sanity checks are performed. If everything is ok, and the packet has mask bit set, at [6] all the data in the buffer is XORed with 4 byte mask. An insufficient check above at [5] can allow for an integer overflow to pass undetected. In case  is a very large value, adding   to it can lead to integer wraparound , resulting in small   value. Small   value passes   check, while   is still huge and bigger than the actual buffer size. This results in a large heap overflow at [6] as the for loop is bounded by   only. This causes the process to crash, leading to denial of service and in some cases potentially to remote code execution. 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0428');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (255, 'Cesanta Mongoose MQTT SUBSCRIBE Topic Length Information Leak', 'None', '2017-10-31', 'An exploitable arbitrary memory read vulnerability exists in the MQTT packet parsing functionality of Cesanta Mongoose 6.8. A specially crafted MQTT SUBSCRIBE packet can cause an arbitrary out-of=bounds memory read potentially resulting in information disclosure and denial of service. An attacker needs to send a specially crafted MQTT packet over the network to trigger this vulnerability. Cesanta Mongoose 6.8 8.2 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H CWE-190: Integer Overflow or Wraparound Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. While parsing an MQTT packet SUBSCRIBE command, topic string size as encoded in the packet is trusted without any additional validation. This arbitrary length value is used in pointer arithmetic and can cause out-of-bounds memory access. The vulnerability occurs in function  : In the above code, at [1] two bytes from message buffer are read as   and then immediatelly used at [2] to calculate offset to  . No check is performed to insure it would be inside the bounds of the buffer which is limited in size. This issue can be triggered multiple times and with careful control of the memory layout could be abused to leak memory and cause denial of service. The vulnerability can be triggered by sending the supplied proof of concept packet to the sample   application supplied with the library. 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0402');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (256, 'Cesanta Mongoose MQTT SUBSCRIBE Multiple Topics Remote Code Execution', 'None', '2017-10-31', 'An exploitable stack buffer overflow vulnerability exists in the MQTT packet parsing functionality of Cesanta Mongoose 6.8. A specially crafted MQTT SUBSCRIBE packet can cause a stack buffer overflow resulting in remote code execution. An attacker needs to send a specially crafted MQTT packet over the network to trigger this vulnerability. Cesanta Mongoose 6.8 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. MQTT SUBSCRIBE command packet can contain multiple topics to subscribe to. If a MQTT SUBSCRIBE packet with upwards of 512 topic subscriptions is sent to the server, an overflow of a stack buffer can lead to an overwrite of adjacent variables or the return address ultimately leading to remote code execution. In function   topics are handled one by one: In the above code, an array of 512 bytes is allocated at [1]. Then, in a for loop at [2] the QOS value is stored inside that buffer and an index is incremented. No check to make sure that   doesn’t overflow is present, so a SUBSCRIBE with more than 512 subscriptions will overflow the array and write past it corrupting the stack frame. This vulnerability can be triggered by running the supplied proof of concept to the sample   application supplied with the library.   This frame has 3 object(s): perl -e \'print \"\\x80\\xff\\x0f\" . \"\\x00\\x00\\x00\\x01a\\x02\\x00\"x400 \' | nc   2017-08-31 - Vendor Disclosure \n2017-10-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0401');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (257, 'Cesanta Mongoose MQTT SUBSCRIBE Command Denial Of Service', 'None', '2017-10-31', 'An exploitable NULL pointer dereference vulnerability exists in the MQTT packet parsing functionality of Cesanta Mongoose 6.8. An MQTT SUBSCRIBE packet can cause a NULL pointer dereference leading to server crash and denial of service. An attacker needs to send a specially crafted MQTT packet over the network to trigger this vulnerability. Cesanta Mongoose 6.8 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-476: NULL Pointer Dereference Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. In the MQTT protocol, a client initiates the connection by sending a CONNECT command, to which a server replies with CONNACK and then client proceeds with other commands. In the case of the mongoose MQTT server, if an out of order SUBSCRIBE packet is received by the server certain uninitialized structures are accessed which can lead to NULL pointer dereference and server crash. Specifically, in the function   : In the above code, at [1] we see   being initialized to point to   which can be null. At [2]   pointer is dereferenced to access the   field which causes a NULL pointer dereference and leads to a server crash.\nThis vulnerability can be triggered by sending bytes from the proof of concept to the sample   application supplied with the library. perl -e \'print \"\\x80\\x86\\x00\\x00AAAA\"\'  | nc    2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0400');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (258, 'Cesanta Mongoose MQTT Payload Length Remote Code Execution', 'None', '2017-10-31', 'An exploitable arbitrary memory read vulnerability exists in the MQTT packet parsing functionality of Cesanta Mongoose 6.8. A specially crafted MQTT packet can cause an arbitrary out-of-bounds memory read and write potentially resulting in information disclosure, denial of service and remote code execution. An attacker needs to send a specially crafted MQTT packet over network to trigger this vulnerability. Cesanta Mongoose 6.8 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. While parsing an MQTT packet with variable length header no check is performed to assure the calculated payload length corresponds to the actual received packet. An arbitrary length is used in pointer arithmetic leading to arbitrary memory access. Variable payload length in mqtt packet is encoded by 7 bit fields with 8th bit in a byte being used as continuation bit. The following code from the   function decodes this: In the above code, no check is performed on the calculated   value which can be arbitrarily large. By the MQTT standard, the largest MQTT packet can be at most 256 megabytes. Further, a following check is performed: In the above code,   should point to the end of message, and the   tries to check if it’s in bounds of the buffer, but since the check is comparing pointers, an integer overflow can cause   to wrap around and point before the start of message buffer, while still having huge   value calculated before. This can cause further memory corruption down the line when actually handling the commands sent in the packet. For example, this can be exploited by sending a “PUBLISH” command, which ends up notifying all the clients subscribed to a certain topic. Still in the   function we see: The above code deals with the “PUBLISH” command and uses the   pointer and   to calculate the length, due to the previous integer overflow ,   can point to before   leading to a large   value which is later used when sending the notification to subscribed clients. With precise memory layout control, this can be abused to cause an arbitrary write which could lead to remote code execution. On the other hand, there is a potential to abuse this vulnerability to leak large amount of data from the process as the overflown value is used when sending data to clients. The vulnerability can be triggered by sending the supplied proof of concept packet to sample   application supplied with the library. It should be noted that depending on memory layout, the proof of concept packet might not crash the application, but it does trigger the bug. 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0399');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (259, 'Cesanta Mongoose HTTP Server CGI Remote Code Execcution Vulnerability', 'None', '2017-10-31', 'An exploitable use-after-free vulnerability exists in the HTTP server implementation of Cesanta Mongoose 6.8. An ordinary HTTP POST request with a CGI target can cause a reuse of previously freed pointer potentially resulting in remote code execution. An attacker needs to send this HTTP request over network to trigger this vulnerability. Cesanta Mongoose 6.8 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-416: Use After Free Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, MDNS and others. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. While parsing a specific type of POST request that targets a CGI script, a use-after-free vulnerability is triggered, if compiled with CGI support which is the default. When doing the initial parsing, a structure of type   is allocated in function  . Then, while working on a reply and since this is a CGI request (target of the request just needs to end with set CGI extension, “.cgi” by default), a CGI handler is invoked in the function  : In function   a new connection structure is allocated and a previous one is added to it: In above code, at [1], a new connection structure is created and at [2], the old   is set as the   field. Since the initial client connection is deemed done, it’s being cleaned and the first   structure is freed by calling   in function  . This leaves the   pointer set at [2] pointing to freed memory. Then, when executing the actual CGI event handler function   this freed data will be accessed in different places depending on the event: In the above code, at [3] the pointer to the original connection structure is retrieved (which at this time points to freed memory) and is dereferenced at [4] which ultimately leads to read and write over unallocated memory. If a second request happens at the right time, this freed memory might contain different data or point to other structures leading to server crash and potential remote code execution with multiple carefully controlled post requests. This vulnerability can be demonstrated via the example web server application supplied with the library. Since the server may not immediately crash, the vulnerability can be observed by running the server under memory debugger such as valgrind or AddressSanitizer. echo -ne \"POST /a.cgi HTTP/1.1\\r\\n\\r\\n\"| nc localhost 8000 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0398');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (260, 'Circle with Disney Restore API Command Injection Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the /api/CONFIG/restore functionality of Circle with Disney running firmware 2.0.1. Specially crafted network packets can cause an OS command injection. An attacker can send an HTTP request trigger this vulnerability. Circle with Disney 2.0.1 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-77: Improper Neutralization of Special Elements used in a Command (\'Command Injection\') The vulnerable code exists in the restore api handler of the \"apid\" deamon (\"/api/CONFIG/restore\"), function  : Looking at the pseudocode of the whole function, we see the following: As we can see the   parameter, coming from the user as a multipart parameter, is passed direcly to   call without any sanitization leading in that way to command injection.\nThis API is accessible for authenticated users. The following proof of concept shows how to execute the \"power_down.sh\" script on the device.\nAn attacker needs use a valid token in order to trigger the vulnerability. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0397');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (261, 'Circle with Disney Apid Server Fork Denial of Service Vulnerability', 'None', '2017-10-31', 'An exploitable Denial of Service vulnerability exists in the API daemon of Circle with Disney running firmware 2.0.1. A large amount of simultaneous TCP connections causes the APID daemon to repeatedly fork, causing the daemon to run out of memory and trigger a device reboot. An attacker needs network connectivity to the device to trigger this vulnerability. Circle with Disney 2.0.1 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-400: Uncontrolled Resource Consumption (\'Resource Exhaustion\') The apid binary is a web server listening on the Disney Circle, that serves as the main API for user functionality. Through the apid server, all configurations and queries are made from the \'Circle Home\' application for the administrator\'s phone. Due to the fact that the socket that is listening on TCP:4567 for these API calls has a high limit of connections that it will accept: Coupled with the apid server forking with every one of these TCP connections, and there is a rather speedy consumption of all computing resources. After about 60 seconds of the process being locked, the Circle device will reboot, returning back to normal in about 40 more seconds. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0396');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (262, 'Circle with Disney WiFi Security Downgrade Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the WiFi management of Circle with Disney. A crafted Access Point with the same name as the legitimate one, can be used to make Circle connect to an untrusted network. An attacker needs to setup an Access Point reachable by the device and to send a series of spoofed \"deauth\" packets to trigger this vulnerability. Circle with Disney 2.0.1 6.5 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-284: Improper Access Control Circle with Disney is a network device used to monitor internet use of children on a given network. Circle can connect to a home network either via WiFi or wired connection.\nWhen no cable connection is possible, Circle will switch to WiFi, which was set-up during the initial configuration. The monitor function   in the   binary keeps track of the wired interface connectivity by reading the file   every second.\nIf the ethernet cable is disconnected, the function switches to the WiFi interface by calling  . At high level this function works as follow: Note that   refers to the operation of retrieving an element from \"configure.xml\". In short,   retrieves the configured SSID from \"configure.xml\", then using   ( ) [2] retrieves the current channel, security (WPA2, WEP or none) and whether the SSID is hidden or not, from a recent Access Point scan. These parameters are then passed to the   script [3].  [1] will be called to make sure that \"ap_list.out\" is filled with a list of existing Access Points. Its contents are shown below.  [4] prints a list of Access Points detected by  , every entry has the following form: What   [2] does is parsing each of these entries in \"ap_list.out\", for finding the expected SSID and returning its related \"Encryption\" and \"Channel\" values. At high level it works as follows: When calling   [3] the wireless interface tries to establish a connection to the configured Access Point.\nIts main function is to populate the configuration file in   based on the parameters passed to it, and finally restart  . When the   output for the configured Access Point contains the line \"Encryption: WPA2 PSK (CCMP)\", a generated   looks as follows: Whereas if the line contains \"Encryption: none\" the generated configuration will be: As we can see from the   logic, the only variable used to identify the configured Access Point is its ESSID, and the encryption defined in   is not taken into account. This way an attacker to setup a crafted Access Point with the same name as the legitimate one and to make Circle connect to it.\nThe device will continue to function but won\'t be able to apply any filtering over the original network, moreover this allows an attacker to conduct further attacks against the device that may be possible only on a common subnetwork. As an example, this vulnerability would allow an external attacker to apply TALOS-2017-0396 and TALOS-2017-0371 to completely compromise the device. The following proof of concept shows how to make the device to connect to a fake Access Point managed by an attacker. First an Access Point is created with the same name of the legitimate Access Point to which Circle is currently connected to, but without encryption. Then, a series of spoofed \"deauth\" packets are sent to the device, so that Circle will drop the active connection.\nCircle will then rescan the available Access Points and should eventually connect to the attacker\'s one. 2017-09-20 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0448');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (263, 'Circle with Disney Token Routing Vulnerability', 'None', '2017-10-31', 'An exploitable routing vulnerability exists in the Circle with Disney cloud infrastructure. A specially crafted packet can make the Circle cloud route a packet to any arbitrary Circle device. An attacker needs network connectivity to the Internet to trigger this vulnerability. Circle with Disney 2.0.1 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-807: Reliance on Untrusted Inputs in a Security Decision The apid binary is a web server listening on the Disney Circle, that serves as the main API for user functionality. Through the apid server, all configurations and queries are made from the \'Circle Home\' application from the administrator\'s phone. This is done via meetcircle.co domain servers, that essentially act as routers, piping data from a phone to the correct Circle device. By default, when the “Circle Home” application wants to do something as simple as query for the status of the Circle, a connection is made to  . It should be quickly noted that the remote circle servers are now seperated by region. For instance if you try to talk to a Circle in Europe, you\'ll get HTTP redirected to \"remote-eu-central-1.meetcircle.co\".\nRegardless, this is done with an SSL  certificate that is given to the phone by another meetcircle server that will be examined shortly. After the SSL connection is made, the phone sends out it\'s HTTP API request, which then gets piped to the correct device.  An example of this connection from the phone\'s side looks like this: It should be noted that this is not the same as it appears on the Circle\'s end, as there is an encapsulating backdoor protocol as described in TALOS-2017-0436. Back on track though, it becomes evident that there was nothing that evident being used for the decision of “Where do I send this phone\'s request”. That is, the question still remains of how the cloud servers were routing the API requests. After examining the application itself, some more information was gathered. Let\'s take a look at how the cloud servers route the API request to the Circle device. Within the data directory of the application, there is a Base 64 encoded PKCS12 blob living inside of a database that was being used during the connection. A dump of this cert is listed below (it has an empty password): This is most definitely atypical for a secure connection, just looking at the SSL attributes:  \n \n Whereby the Mac address and appid of our circle device are included inside of the certificate, which means that there is some way to generate an SSL cert that is signed by the Circle Go Root Authority. As it turns out, there is an API on a Circle Server that can generate these certificates: The only fields that are really dependent on each other are the gotoken and circleid fields. There seems to be an algorithm for generating the gotoken from the circleid on the servers, as if one doesn\'t send a matching pair, no certificate is returned. Interestingly, we could generate a cert with anything inside the \'devid\' and \'host\' fields, and still get it signed by the Circle Go Root Authority. After testing and generating a certificate with our own credentials, we were able to successfully communicate with our Circle device through the cloud infrastructure.\nUpon then just generating a random SSL certificate and sending the same request to remote.meetcircle.co, we were still able to talk with our Circle device. Which brings us back to that initial packet dump that was sent: The only thing that is unique to this request is the token that is provided for authentication. But once again, if it actually does rely on the full token, then this would not be exploitable, as the token format is as such: There\'s not much of a chance of brute forcing this token, but only the MAC is used for routing, thus allowing us to communicate with any device.\nThe following API call was made towards the remote.meetcircle.co host: The following reply was received: It must be restated here that this is through a reverse SSL tunnel on the Circle\'s side, one that is initiated by the APID daemon when a UDP beacon gets a response from the remote.meetcircle.co domain, meaning that as long as UDP access is allowed outbound from a network, the meetcircle.co servers can talk with the device. Thus, in summary, all that is needed to connect to the APID daemon on any Disney Circle in the world, in any network, as long as it has UDP outbound access, is with a Mac Address of the device. 2017-09-12 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0437');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (264, 'Circle with Disney configure.xml Notifications Command Injection Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the notifications functionality of Circle with Disney running firmware 2.0.1. Specially crafted network packets can cause an OS command injection. An attacker can send an HTTP request trigger this vulnerability. Circle with Disney 2.0.1 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-77: Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Circle with Disney is a network device used to monitor internet use of children on a given network. Circle allows for backing up and restoring configuration backups using API commands.\nBackups contain a file named \"configure.xml\", which contains most of the device\'s configuration. When restoring a backup using the API command \"/api/CONFIG/restore\", the \"configure.xml\" file contained in the backup is copied to \"/mnt/shares/usr/bin/configure.xml\" with very little checks: the file is considered valid if it\'s not empty and it contains the following strings: After a backup configuration is restored, the device is rebooted. Vulnerable code exists in the   binary in function  , which configures the device based on the existing \"configure.xml\".\nAt [1] \"configure.xml\" is opened and at [2] the temporary notifications directory is cleared.\nSeveral functions are then used (e.g. at [3]) to navigate the XML configuration to get to the first \"notification\" element.\nThen a format string is built at [4] and is passed to   at [5] together with the \"id\" property, for every \"notification\" element. In short the function finds all \"notification\" elements in the XML path \"config/overall/activeNotifications\". Then, for each element, the \"id\" property is extracted and a file is created using: Since \"id\" is never sanitized and is used in  , an attacker may use this vulnerability to arbitrarily execute code on the device. The following proof of concept shows how to execute a command on the device.\nAn attacker needs a valid token in order to trigger the vulnerability. In this case the command executed after reboot will make the device\'s led blink rapidly. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0424');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (265, 'Circle with Disney Goclient SSL TLD MITM Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in remote control functionality of Circle with Disney running firmware 2.0.1. SSL certificates for specific domain names can cause the goclient daemon to accept a different certificate than intended. An attacker can host an HTTPS server with this certificate to trigger this vulnerability Circle with Disney 2.0.1 7.4 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N CWE-300: Channel Accessible by Non-Endpoint (\'Man-in-the-Middle\') Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins arp poisoning all filtered devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. The goclient binary provides an interface to subscribe users to the “Circle Go” functionality of the product. If a parent subscribes to the “Circle Go” service, and then registers their child\'s device, they can filter and monitor the child\'s phone even when they are not on the same subnet as the Circle device, providing a “cloud”  functionality. This functionality relies on an app, \'MyCircle\', being installed on the child\'s phone that will act as the filtering and limiting agent, enforcing restrictions based on decisions made by the Circle device itself. In order to allow remote functionality, goclient talks with the   domain, which in turn talks with the administrator\'s phone. In order to provide this persistent and remote administrative capability, the goclient binary will consistently send a \'ping\' message via udp:8988 to vpncc.meetcircle.co, to which the server will reply with \'pong\'. This allows the server to reach the Circle device whenever necessary, since firewalls will typically allow return UDP traffic of this nature.  When the admin needs to perfrom any task remotely, the server will send a \'connect\' message over this UDP \'tunnel\', to which the goclient will initiate an SSL connection on port 8988 to the vpncc.meetcircle.co domain. Through this SSL connection, the actual management occurs, there is no messages of import that occur over the UDP communications (only ping and connect). Unfortunately, there is an issue that lies within the SSL certificate checking of the goclient binary, the disassembly of which is listed below: As shown at [1], the goclient grabs the remote server\'s SSL certificate, and then at [2], the server gets the X509 subject name, which is typical behavior for SSL verification. X509 oneline [3] then grabs a lot of the information from the certificate attributes, joins it all into one line, and then stores it into a buffer on the heap [4]. An example return string might be: While the interesting behavior of the X509 oneline can lead to some other vulnerabilites, like including the string \'CN=*.meetcircle.com” inside of another attribute  ( For a great writeup of this:  [https://langui.sh/2016/01/29/x509-name-oneline/])(https://langui.sh/2016/01/29/x509-name-oneline/) ) , however, due to reasons mentioned a little further down, the binary was not vulnerable to this, as we could not get a certificate signed by the specific CA to be formed as such. Interestingly due to how they actually check the Common Name attribute of the SSL cert, the binary was left vulnerable to another attack vector: As shown above, we continue from immediately after the X509 oneline() function call [1]. The return value of this function is compared is compared against “CN=*.meetcircle.com” [2], with the strstr() function [3], which returns a pointer to the first match of register $a1 in $a0 (and NULL otherwise). Since this is the only check upon the Common Name attribute, it becomes possible to bypass this check by buying the following domains (as per Wikipedia): The return value from X509 name will look as such: And then the resulting call to strstr will look like such: With the return value being our malicious domain name [1]. It should be cautioned that certificate presented by the MITM server needs to have its trust chain signed by the Comodo CA. The binary has a barely obfuscated CA cert located inside that is extracted to /tmp/ca.goclient.pem and then utilized to validate the outbound SSL connection. This secondary validation tends to be trivial as the Comodo CA currently offers a free SSL Certificate trial, the hard part is getting the domain name. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0419');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (266, 'Circle with Disney Firmware Update Signature Check Bypass Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the signature verification of the firmware update functionality of Circle with Disney. Specially crafted network packets can cause an unsigned firmware to be installed in the device resulting in arbitrary code execution. An attacker can send a series of packets to trigger this vulnerability. Circle with Disney 2.0.1 9.9 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition Circle with Disney is a network device used to monitor internet use of children on a given network. Circle provides an API command to update its firmware, which is usually used by the \"Circle Home App\" installed on the device administrator\'s phone. The API command is \"/api/UPLOAD_FIRMWARE\" and is handled by the   binary in function  .\nAt high level, the function works as follow: The function ensures that the request comes from the network \"10.123.234\", then saves the uploaded firmware to \"/tmp/postfile.bin\" and continues the update using shell scripts. The \"install_firmware.sh\" contains the following code: First the firmware is decrypted using   resulting in a tar archive with a 0x200 bytes signature at its end. Then this archive is verified using   and if the output contains \"Verified signature\" then the archive is extracted in \"/mnt\", allowing for overwriting most of the device binaries.  performs a symmetric AES encryption and can be used by an attacker to create custom firmware images by using the switch \"-e\" in place of \"-d\".\nMoreover, since the signature verification and the update operations are not executed atomically, a race condition exists which could allow an attacker to supply an unsigned firmware that will be flashed without verification ([A] and [B] are used to refer to two parallel requests): The following proof of concept shows how to load an arbitrary unsigned firmware \"firmware.cust.bin\". An original, signed, firmware must exist as \"firmware.orig.bin\".\nAn attacker needs to be able to send requests from a \"10.123.234\" IP address (e.g. by spoofing the local network dhcp server responses) and use a valid token in order to trigger the vulnerability. 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0405');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (267, 'Circle with Disney Apid Photo Upload Denial of Service Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the user photo update functionality of Circle with Disney running firmware 2.0.1. A repeated set of specially crafted API calls can cause the device to corrupt essential memory, resulting in a bricked device. An attacker needs network connectivity to the device to trigger this vulnerability. Circle with Disney 2.0.1 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-400: Uncontrolled Resource Consumption (\'Resource Exhaustion\') The apid binary is a web server listening on the Disney Circle, that serves as the main API for user functionality. Through the apid server, all configurations and queries are made from the \'Circle Home\' application for the administrator\'s phone. Naturally, the unimportant API calls are run without authentication, whilst the critical API calls require a specific token, one that is unique to each phone that has synced to the Circle with the administrator app. However there is one API call that behaves slightly different. The \'/api/UPDATE/users/user/photo\' API call requires authentication as expected, however there is an extra action taken by the server in preparation for the photo upload, which is passed via HTTP POST params. Since the server needs to parse the POST parameters regardless of the photo, it allocates a new buffer to deal with the rest of the POST parameters. An example follows: For the above example, it finds the first occurrence of \'photo=\' (photo%3D) and then the first occurrence of “&” after that. Every character outside of those boundaries count towards the new allocation. Thus, if an attacker sends POST parameters with an extremely large number of characters, the behavior of the Circle starts to get unreliable. As much as a descriptive and detailed explanation would be satisfying, it can only suffice to say that the device gets bricked, somewhat. The LED will start blinking, and then device will reboot. The only ways back in are through ethernet (10.123.234.1 or IPV6), if you happen to have credentials, or through the console port. Regardless the Circle will be missing its /dev/sda flash drive, effectively rendering the device into a bare bones MIPS board with around 40 MB of space. 2017-08-02- Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0391');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (268, 'Circle with Disney Weak Authentication Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the generation of authentication token functionality of Circle with Disney. Specially crafted network packets can cause a valid authentication token to be returned to the attacker resulting in authentication bypass. An attacker can send a series of packets to trigger this vulnerability. Circle with Disney 2.0.1 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-307: Improper Restriction of Excessive Authentication Attempts Circle with Disney is a network device used to monitor internet use of children on a given network. When making any requests to the Circle, an authenticated token must be provided. To request a token, a client specifies an  , a unique string used to identify the client, as well as a  , a   hash to verify the client should have access to the device. One secret piece of information is a 4 digit pin. The   is calculated by the following: The client provides both the   and  . Because the key space for the   is only  , an attacker can brute force this pin to retrieve an authentication token. With the authentication token in hand, an attacker can make available API calls. Circle implements a lockout mechanism that allows to test only 3 pins every 15 minutes. This is implemented by the   binary, which writes to the file   the number of authentication attempts and the latest timestamp: This resource is saved in  , which is a \"tmpfs\" directory shared by many components of the system and has a size of 30MB. If no failed authentication attempts are made since system boot,   won\'t exist in  . This means that if an attacker is able to keep   completely filled, the   binary won\'t ever be able to create  , thus making the pin bruteforce possible in practice.\nMoreover note that if a DoS attack is available for rebooting the device, it can be used to clear the whole   directory. Since   is never saved in non-volatile storage, a slow bruteforce can be performed by testing 3 pins per reboot. Without using a DoS, an attacker needs to fill   before starting the bruteforce.\nTo achieve this, a combination of 4 techniques can be used. Once every hour,   is invoked to check for updates. This script downloads a file containing the latest version of the firmware via HTTP and stores it in  : By exploiting this behavior, an attacker can send a 31MB versions file and fill  . Unfortunately, since many components are using  , the   might still be written after some time: the main problematic file is  , which can shrink depending on the network activity.\nThis is why the techniques described in the following paragraphs are needed as well.  provides a way for restoring a previously-saved configuration and for upgrading the firmware. This can be done using the api command  , which is handled in function  . At high level it works as follows:  will save the uploaded firmware (or configuration file) to  . As we can see, this function is called before checking if the user supplied a valid token, allowing any unauthenticated user to upload such file. Note that even if the token turns out to be wrong, the file won\'t be deleted.\nThe size limit of the upload is almost 5MB, so it cannot be used alone to fill  . The   binary keeps a list of recently-seen hosts on the network by monitoring ARP requests and saves them in  . When operating on the file,   uses   with mode \"w+\". This means that as soon as   returns the   file will be truncated.\nIf, at the same time,   tries to create  , it will succeed since in that instant there will be some free space in  . To avoid space to be freed by  , it\'s important that the bruteforce attack only starts when   has a size of 0, so it won\'t ever be able to grow.\nTo do this, an attacker could upload a   file (to try to fill the little space left in  ) in the same moment that   gets truncated by  .\nIn order to maximize the likelihood of this condition, a series of spoofed ARP requests can be continuously sent to the device, forcing it to update  , while in parallel uploading a rather small configuration file. It\'s useful, during bruteforce, to know whether pin attempts are discarded because of the lockout mechanism.\nIndeed, it\'s possible to get this kind of feedback.\nAt high level this is a simplification of how the token request procedure works: As we can see, if a token request is sent without an   and requests are not locked out, the error returned is \"token request failure - no app id specified\". Note however that in this case pins are not tested.\nThis feedback can be used every once in a while, just to ensure that pins are effectively verified during bruteforce. A complete attack sequence could go like this: 2017-07-13- Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0370');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (269, 'Circle with Disney Rclient SSH Persistent Remote Access Vulnerability', 'None', '2017-10-31', 'A backdoor vulnerability exists in remote control functionality of Circle with Disney running firmware 2.0.1. A specific set of network packets can remotely start an SSH server on the device, resulting in a persistent backdoor. An attacker send an API call to enable the SSH server. Circle with Disney 2.0.1 8.0 - CVSS:3.0/AV:N/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H CWE-489: Leftover Debug Code Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins arp poisoning all filtered devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. The rclient binary provide a way for the admin of the device to control the device, even if the admin is not present, essentially providing a “cloud”  functionality. Rclient talks with the   domain, which in turn talks with the administrator\'s phone. In order to provide this persistent and remote administrative capability, the rclient binary will consistently send a \'ping2\' message via udp:8988 to F0.meetcircle.co, to which the server will reply with \'pong\'. This allows the server to reach the Circle device whenever necessary, since firewalls will typically allow return UDP traffic of this nature. A sample of this follows: When the admin needs to perfrom any task remotely, the server will send a \'connect\' message over this UDP tunnel, to which the rclient will initiate an SSL connection on port 4567 to the F0.meetcircle.co domain. Through this SSL connection, the actual management occurs, there are no messages of import that occur over the UDP communications (only ping2, ping, and connect). Upon utilizing an SSL mitm to sniff the management traffic, the following behavior was observed when a phone connected to it\'s corresponding Circle device: Aside from the redactions, it quickly became apparent that there was plain HTTP api requests flowing through the SSL tunnel. But there was still the question of the the wrapping protocol:  An approximation of the wrapping backdoor protocol is as follows: For extremely big messages and streams, the protocol maintained a max size, such that the messages were broken up into chunks. When observing other actions during the course of device usage, sometimes the Circle will also reach outbound by itself, using the same protocol. In order for the device to send its PIN over SMS for configuration of a new admin, the following occurs: Upon discovering this, it became apparent that this SSL tunnel actually has a lot more functionality than just redirecting for HTTP, so further exploration of the binary was needed. The function responsible for handling HTTPS traffic over the SSL tunnel was soon found in the Apid binary at 0x404d94. The function reads in 4 bytes at first, and verifies that it has the \'Z\' header, an opcode, and a size, and then reads in bytes corresponding to the given size. The opcode and subtype (if any) is then thrown against two different jump tables. Ignoring the main jumptable for now to get an idea of some of the capabilities, the subtype jumptable looks as such: Since there\'s the \'telnet all\' options, there\'s logically got to be telnet and something else located within the code base. The rest is found in the normal opcode jumptable, summarized below: Now thankfully, there\'s no Telnet server running on the device, but there does exist an instance of Dropbear SSH, and if we check in the authorized_keys file, we can plainly see: As of firmware version 2.0.1, Dropbear SSH is not enabled by default however, but with one of the more recent \'Circle Home\' app updates, a button was added to the settings: So while it\'s great that they publicly diclose that there is a “Remote Access” feature, this was not public until recently (August 10th 2017), but the SSH capabilities were there the whole time. Also, there\'s the fact about what the \'Remote Access\' switch inside the app actually does. It sends an API call to the Circle device Apid server:  , which causes configure.xml to be changed to Which then causes the configd daemon running on the device to switch on Dropbear: It should be noted that this API call does require a valid token for authentication, however when viewing the   call through an SSL MITM, we can see that the device actually discloses all of its tokens to the MeetCircle servers: Which essentially renders the \'Enable Remote Access\' option useless, since the SSH access can be enabled by anyone with a token (which includes Circle Media Inc.) 2017-09-12 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0436');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (270, 'Circle with Disney Apid Use-Between-Reallocs Information Disclosure Vulnerability', 'None', '2017-10-31', 'An exploitable information disclosure vulnerability exists in the apid daemon of the Circle with Disney running firmware 2.0.1. A specially crafted set of packets can make the Disney Circle dump strings from an internal database into an HTTP response. An attacker needs network connectivity to the Internet to trigger this vulnerability. Circle with Disney 2.0.1 5.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N CWE-416: Use After Free Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins arp poisoning all filtered devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. The apid binary is a web server listening on the Disney Circle, that serves as the main API for user functionality, it is forked from  , a rather robust web server that\'s optimized for embedded devices. Through the apid server, all configurations and queries are made from the \'Circle Home\' application from the administrator\'s phone. For all the under-the-hood and low level processing of HTTP headers, the majority of the code is from mini httpd has no support for an HTTP request with any Body parameters, it sort of just stops reading when it finds the end of the HTTP headers (“\\r\\n\\r\\n”).  Because the Circle needs Body params for certain api calls (/api/CONFIG/restore and /api/UPLOAD httpd. Both within mini_httpd and apid, the following code is used to parse the HTTP headers: The code will loop and continuously read in 0x2710 bytes until it finds either “\\r\\n\\r\\n” or “\\n\\n”, denoting the end of the HTTP headers, and for each section that it reads in, it\'ll add it to the request variable via  , which is listed below: Which then gets to the heart of the matter: At [1] we check to see if there\'s already an existing buffer with the user\'s request. Assuming this is the first iteration of the read loop in  , the function will malloc a buffer of sizeof(new size + sizeof(new_data) + 500) [3]. An issue exists with how mini_httpd was extended to handle Body parameters, due to how Circle reused the   function to handle the rest of the HTTP request. This, by itself, would not normally be an issue, however, between the first and second calls to  , a set of variables is assigned to HTTP headers for further use. Within a loop, the server looks for a given HTTP header, and then assigns a pointer to the address of that header\'s value within the original request. For example: It will look for \'Origin:\' in every line of the request[1], and then assign the value [3] if it\'s found [2].\nThis is done for \'Origin\', \'Cookie\', \'Host\',\'Authorization\', \'User Agent\', and \'Content-Length\', among other less important values. After these pointers have been assigned, if it\'s an HTTP POST request, Apid then reads in bytes equal to the given \'Content-Length\', using the   function just like before, acting on the same exact buffer as before, and this is where the problem lies. As per  : Since the heap implementation is a uClibc version of dlmalloc  , the conditions for when a realloc will return a different pointer than the one provided are not too complicated. Since the user controls the size of the HTTP request, the user can control the size of call to realloc to some degree. Going back to the realloc_loop disassembly (since this is Circle code now): Just like before, the HTTP server will keep reading in bytes from the SSL socket until it hits the end of the request, and then for every 0x3FF bytes, we will hit the add size + 0x3FF + 0x1F4 ). After enough of these reallocations, the heap pointer returned from realloc will actually change: As shown above, after reaching a big enough size, we can actually make the reallocation result in an mmap\'ed allocation instead of a normal heap allocation, and we can continuously repeat this. Which brings us back to those HTTP headers we mentioned before. Out of all the HTTP headers that are parsed and assigned to variables, five of them result in dangling pointers if we shift the underlying memory location with increasing reallocs: \'Host\',\'Cookie\',\'Origin\',”User-Agent\', and \'Authorization\'. Only \'Origin\' and \'User Agent\' are ever referenced in the code after their initial assignment, as a lot of features were stripped from mini_httpd when being forked into Apid. User-Agent gets read into a buffer with snprintf and then parsed and checked for a regex of “MSIE”, which doesn\'t really do much, since we already have control of \'User-Agent\'. Unfortunately, the only real opportunity is that the value of \'Origin\' is returned in the HTTP response to the user (assuming the value of \'Origin\' is initially valid). An example of this would be: Where   corresponds to the line in my initial HTTP request  . The value is written into the request response with  , which is taken straight from the dangling pointer from before. While this Use-After-Free is very limited in it\'s actual use, there\'s still the potential of being able to read something out of the heap remotely, assuming that we can get something to allocate into the freed slot that “Origin” is pointing to. The obvious thought of information to leak would be passwords or tokens or PINs, etc. Unfortunately for the purposes of this exploit, not much is actually done on the heap in this daemon. Aside from the two instances of our realloc loop, there\'s a call to strdup in between, another realloc_loop on another buffer (the response), and then anything that occurs inside of the API parsing. After looking through all the unauthenticated API calls, it was found that the \'/api/USERINFO\' api call will repeatedly use   and   to allocate space for reading  , which contains a decent amount of sensitive data. A sample of my configure.xml should suffice to explain: Regardless of what information it is, we still need a way to force the database\'s buffer to be read into where “Origin” is pointing. Coming full circle, as mentioned before, this is uClibc\'s version of dlmalloc, so it\'s pretty standard. If we can get our initial request to be within the same heap bin as the database read, then it should be smooth sailing after our realloc effectively frees our buffer. We don\'t know the size of the database, but it can be quickly brute forced, as the minimum size of the database is 2380 bytes (with the version in our test being about 4000), and also because of the binsizes of dlmalloc: So we only really need to brute force in 512 byte intervals after 2048, and then every 4096 bytes after that. If we had control of a malloc() and free() instead of realloc(), things would be simpler, as the size of our buffer would remain constant, and it would remain in the same bin, from start to finish. With realloc() however, this is not the case.  If a realloced buffer does not shift its underlying memory (i.e. input ptr != output ptr), it\'s still possible for it to shift bins. Put another way, even if a realloc crosses the boundary of a bin, the input pointer could still be equivalent to the output pointer.\nAnd this is a problem, since we need the realloc to shift memory in order for the UAF to work. So,  if we increase the size of our buffer to a point where we know that the memory location will shift after a realloc, it won\'t be in the same bin as the database, and we won\'t get anything useful from the UAF. But if we keep the HTTP request buffer at a size comparable to the database\'s buffer, we don\'t trigger the effective “free(req_ptr)” in the first place. The only option left is to try and force realloc to shift without having to increase it\'s size past a bin boundary, and this requires another allocation, which we can achieve using  . The most surefire way to force realloc() to shift memory is to have another chunk of memory allocated immediately after it. Given the context of this code flow, the only available allocation between the two realloc() loops was a call to strdup (starting from immediately after the first realloc loop on the HTTP headers): The above code will look for the first instance of \'\\r\\n\', and then null terminate it, resulting in a cstring of the HTTP method, path, query string and version. This new cstring is then taken and strdup\'ed, after which the new duplication is parsed further. Thankfully for our purposes, strdup() will allocate size for a copy of the argument string. Since apid does no validation of the \'HTTP/1.1\' portion of the request, we can pad it such that the length of the first line is within the same heap bin as the database. Also, since the Apid server doesn\'t need many HTTP heaers, we can minimize the rest of the request such that the strdup() and the HTTP header realloc() both land within the same bin, such that the heap looks something like this: And then, when the second realloc loop occurs, any slight increase of the HTTP request\'s size will cause it to move past the strdup, without changing which heap bin it is in: And after the database is read in, the heap looks like such: Allowing for us to disclose information from the database. It should be noted though, that due to the constraint of having the “Origin:” header below the gigantic “POST /api.....\\r\\n” line in the request means that we have a limited space in configure.xml to read from, but the most valuable information (phone number/name/email) occurs at the bottom of the file. While it\'s a limited information disclosure, it should be noted that, because of the constraints placed upon this bug (remote/unauthenticated), this exploit can be used in conjunction with TALOS-2017-0437, and can target any Circle in the world that has internet connectivity. Couple this with the fact that anyone can make a Circle send it\'s owner an SMS with the device\'s PIN inside (via /api/PASSCODE/sms), that can be used for further escalation, it would be plausible for the owner\'s phone number to be a valuable link in an exploit chain involving social engineering. 2017-09-12 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0435');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (271, 'Circle with Disney Apid Strstr Authentication Bypass Vulnerability', 'None', '2017-10-31', 'An exploitable authentication bypass vulnerability exists in the API daemon of Circle with Disney running firmware 2.0.1. A specially crafted token can bypass the authentication routine of the Apid binary, causing the device to grant unintended administrative access. An attacker needs network connectivity to the device to trigger this vulnerability. Circle with Disney 2.0.1 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-287: Improper Authentication The apid binary is a web server listening on the Disney Circle, that serves as the main API for user functionality. Through the apid server, all configurations and queries are made from the \'Circle Home\' application from the administrator\'s phone. A subset of the possible API calls require authentication in the form of a token passed usually in the URL string like such: The token is always 0x2d characters long and consists of three subsections (%s-%s-%s), with the first part being the mac address of the administrator\'s phone, the second part a randomized hash based off properties within the admin\'s phone, and the third part is the date and time that the token was generated. Needless to say, it should be rather difficult to guess such a token. When the APID server goes to check a provided token, it makes sure that the token is of length 0x2d. If not, we get an error, but otherwise it goes through the following code: Opening the “/mnt/shares/usr/bin/app_list” file [1] and then storing the file descriptor in $s1.  After this it starts reading, line-by-line. And then tries to match each line against the provided token: Where by the given line of our app list file, we can quickly see a potential issue: The app list file\'s components. The base format will always be the same, “%s %s %s”, where the last component is the token used for authentication and the first component is the mac address of the administrator\'s phone that has synced with the Circle. This leaves the second component, which is the “appid”. The appid is a SHA-1 hash generated by the admin\'s phone, and is saved upon initial syncing of the phone, when the admin needs to use the token api call (/api/TOKEN). Unfortunately, it\'s not quite length 0x2d, but it\'s almost there, being short by 5 bytes. If we take the spaces before and after, we\'re still 3 chars short, which could then probably be brute forced rather easily, but there\'s a simpler method. Since the next 3 bytes are the OUI portion of the Circle\'s Mac address, they\'re probably never going to change for the foreseeable future, so the authencation mechanism can be bypassed with the following string: This naturally leads to the question of where to get the appid, but there\'s actually a very interesting case in which this information is leaked. When the administrator\'s phone connects to the remote circle device, it\'s over a connection to remote.meetcircle.co over SSL. The client cert used by the phone contains the following SSL certificate attributes: Since this information is included in the client SSL certificate attributes, whenever an administrator connects to their Circle device, the appid is sent in plain text over the network, and can be used to gain administrative access to the Circle. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0421');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (272, 'Circle with Disney Rclient SSL TLD MITM Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in remote control functionality of Circle with Disney running firmware 2.0.1. SSL certificates for specific domain names can cause the rclient daemon to accept a different certificate than intended. An attacker can host an HTTPS server with this certificate to trigger this vulnerability. Circle with Disney 2.0.1 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-300: Channel Accessible by Non-Endpoint (\'Man-in-the-Middle\') Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins arp poisoning all filtered devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. The rclient binary provide a way for the admin of the device to control the device, even if the admin is not present, essentially providing a “cloud”  functionality. Rclient talks with the   domain, which in turn talks with the administrator\'s phone. In order to provide this persistent and remote administrative capability, the rclient binary will consistently send a \'ping2\' message via udp:8988 to F0.meetcircle.co, to which the server will reply with \'pong\'. This allows the server to reach the Circle device whenever necessary, since firewalls will typically allow return UDP traffic of this nature. A sample of this follows: When the admin needs to perfrom any task remotely, the server will send a \'connect\' message over this UDP tunnel, to which the rclient will initiate an SSL connection on port 4567 to the F0.meetcircle.co domain. Through this SSL connection, the actual management occurs, there is no messages of import that occur over the UDP communications (only ping2, ping, and connect). Unfortunately, there is an issue that lies within the SSL certificate checking of the rclient binary, the disassembly of which is listed below: As shown at [1], the rclient grabs the remote server\'s SSL certificate, and then at [2], the server gets the X509 subject name, which is typical behavior for SSL verification. X509 oneline [3]\nthen grabs a lot of the information from the certificate attributes, joins it all into one line, and then stores it into a buffer on the heap [4]. An example return string might be: While the interesting behavior of the X509 oneline can lead to some other vulnerabilities, like including the string \'CN=*.meetcircle.com” inside of another attribute  ( For a great writeup of this:  [https://langui.sh/2016/01/29/x509-name-oneline/])(https://langui.sh/2016/01/29/x509-name-oneline/) ) , however, due to reasons mentioned a little further down, the binary was not vulnerable to this, as we could not get a certificate signed by the specific CA to be formed as such. Interestingly due to how they actually check the Common Name attribute of the SSL cert, the binary was left vulnerable to another attack vector: As shown above, we continue from immediately after the X509 oneline() function call [1]. The return value of this function is compared is compared against “CN=*.meetcircle.com” [2], with the strstr() function [3], which returns a pointer to the first match of register $a1 in $a0 (and NULL otherwise). Since this is the only check upon the Common Name attribute, it becomes possible to bypass this check by buying the following domains (as per Wikipedia): The resulting call to X509 name will look as such: The call to strstr() is made with the following parameters: And then the return value is as such (indicating success): It should be cautioned that certificate presented by the MITM server needs to have its trust chain signed by the Comodo CA. The binary has a barely obfuscated CA cert located inside that is extracted to /tmp/ca.rclient.pem and then utilized to validate the outbound SSL connection. This secondary validation tends to be trivial as the Comodo CA offers a free SSL Certificate trial, the hard part is getting the domain name. Another note is that the rclient binary also authenticates to the remote server via a barely obfuscated certificate key pair located within the rclient itself. This is also the reason why the rclient name is not vulnerable to the X509 oneline attack previously mentioned, as any certificate generated and signed by the Comodo CA will look as such: Logging output of the rclient binary upon successful TLS connection: Interestingly after the SSL connection has been initialized, the Circle sends out the following messages to the server. Which contains, starting at offset 0x6 of the third message, a comma separated list of the tokens used to authenticate to the API as an administrator, allowing for an immediate escalation of permissions. 2017-08-29 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0418');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (273, 'Circle with Disney Firmware Update Command Injection Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the firmware update functionality of Circle with Disney. Specially crafted network packets can cause the product to run an attacker-supplied shell script. An attacker can intercept and alter network traffic to trigger this vulnerability. Circle with Disney 9.6 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-300: Channel Accessible by Non-Endpoint (\'Man-in-the-Middle\') Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins ARP poisoning all other devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. Periodically, the device will query outbound towards the meetcircle.co domain, checking to see if there is a firmware update available. Upon detection of a  new version, the server will grab the newest firmware updater.sh script are acquired via a \'wget\' over regular HTTP, such that it is possible to intercept and upload an arbitrary script to the device to be run as root. ARP poisoning is one of the easiest vectors to execute this attack with. 2017-07-13 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0371');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (274, 'Circle with Disney check_torlist.sh Update Code Execution Vulnerability', 'None', '2017-10-31', 'An exploitable vulnerability exists in the torlist update functionality of Circle with Disney running firmware 2.0.1. Specially crafted network packets can cause the product to run an attacker-supplied shell script. An attacker can intercept and alter network traffic to trigger this vulnerability. Circle with Disney 2.0.1 9.6 - CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-73: External Control of File Name or Path Circle with Disney is a network device used to monitor and restrict internet use of children on a given network. When connected to a given network and configured, it immediately begins arp poisoning all other devices on the network, such that it can validate and restrict all traffic as is seen fit by the parent/administrator of the device. Periodically, the device will query outbound towards the meetcircle.co domain, attempting to grab the latest list of known Tor addresses as a gunzipped tarball, shown below in the following snippet:    DEVID=$MAC&VER=$TORVER\" || exit Unfortunately, since this wget request is not using HTTPS, it becomes trivial for an attacker to supply their own tarball, which would be extracted, allowing an attacker to overwrite any file in the \"/tmp\" directory. A sample exploit would be to zip up a script named \'wget\', such that it would executed in subsequents run of this check_torlist.sh script, (which is scheduled via a cronjob). 2017-08-02- Vendor Disclosure \n2018-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0388');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (275, 'Cesanta Mongoose DNS Query Compressed Name Pointer Denial Of Service', 'None', '2017-10-31', 'An infinite loop programming error exists in the DNS server functionality of Cesanta Mongoose 6.8 library. A specially crafted DNS request can cause an infinite loop resulting in high CPU usage and Denial Of Service. An attacker can send a packet over network to trigger this vulnerability. Cesanta Mongoose 6.8 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-835: Loop with Unreachable Exit Condition (\'Infinite Loop\') Mongoose is a monolithic library implementing a number of networking protocols, including HTTP, MQTT, DNS and others. It is designed with embedded devices in mind and as such is used in many IoT devices and runs on virtually all platforms. In a DNS request packet, a name can be compressed to save space. The compression in question relies on pointers to parts of the domain name already present in the packet. When decompressing the names, the DNS server software must look up those pointers and substitute them accordingly. In the Mongoose library, the function   is responsible for decompressing names and a special case for pointers is handled: The name chunk pointer is encoded in a single byte having 2 most significant bits set (0xc0) and rest are an offset to the actual name. In the above code, at [1], a check is performed to see if the current chunk is actually a pointer, and if so, the offset is extracted instead. At [2], this offset is used to advance the parser by adding it to start of the packet. The loop then continues at [3]. In the above code, no check is performed to see if the calculated offset refers to the same position, or if the pointer points to another pointer. No valid DNS query should have a pointer pointing to another pointer and precisely that kind packet will cause an infinite loop in the above code.  An example packet: At offset 14 above, we have a start of name chunk, which specifies a  pointer (0xc0), followed by 0x0c which represents it’s offset from the start of the packet, past the 2 ID bytes. When parsing this packet, function   will enter an infinite loop, because the first chunk points to itself. This causes 100% CPU usage and Denial Of Service. 2017-08-30 - Vendor Disclosure \n2017-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0416');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (276, 'Computerinsel Photoline PCX Parsing Code Execution Vulnerability', 'None', '2017-10-30', 'An memory corruption vulnerability exists in the .PCX parsing functionality of Computerinsel Photoline 20.02. A specially crafted .PCX file can cause a vulnerability resulting in potential code execution. An attacker can send a specific .PCX file to trigger this vulnerability. Computerinsel Photoline 20.02 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write The code responsible for the vulnerability is provided below: An attacker can control the number of \"loop 2\" iterations because the max loop iteration value\nis obtained directly from the PCX file (instruction at 0x00B8D3D0). This can cause a memory\ncorruption where attacker controls the size and the source data. 2017-10-11 - Vendor Disclosure \n2017-10-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0459');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (277, 'Apache OpenOffice DOC ImportOldFormatStyles Code Execution Vulnerability', 'None', '2017-10-26', 'An exploitable out-of-bounds write vulnerability exists in the WW8RStyle::ImportOldFormatStyles functionality of Apache OpenOffice 4.1.3. A specially crafted doc file can cause a out-of-bounds write resulting in arbitrary code execution. An attacker can send/provide malicious doc file to trigger this vulnerability. Apache OpenOffice 4.1.3 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H CWE-787 - Out-of-bounds Write This vulnerability is present in Apache OpenOffice (formerly OpenOffice.org), a free open source office suite.  A specially crafted DOC file can lead to an out-of-bounds write and ultimately to remote code execution. Let\'s investigate this vulnerability. After opening Writer with a malformed doc file we see the following state: comphelper::SynchronousDispatch::dispatch(com::sun::star::uno::Reference<com::sun::star::uno     ::XInterface> const&, rtl::OUString const&, rtl::OUString const&, long, At   we see that   is initialized with a 0 value. Next, if read directly from the file,   value won\'t be bigger than 2,   won\'t be increased and stay with initialized value (0).\nBased on   at  , the   vector is allocated. The   variable value is read directly from the file at   and then used as a constrain in a while loop.\nThe while loop will be executed as many times as indicated by  , there is no check to see whether its value is greater than  , which leads to an out-of-bounds write at  .\nThat situation causes memory corruption and can lead to arbitrary code execution by the attacker. 2017-04-05 - Vendor Disclosure \n2017-10-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0301');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (278, 'Apache OpenOffice DOC WW8Fonts Constructor Code Execution Vulnerability', 'None', '2017-10-26', 'An exploitable out of bound write vulnerability exists in the WW8Fonts::WW8Fonts functionality of Apache OpenOffice 4.1.3. A specially crafted doc file can cause an out of bound write potentially resulting in arbitrary code execution. An attacker can send/provide a malicious doc file to trigger this vulnerability. Apache OpenOffice 4.1.3 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H This vulnerability is present in Apache OpenOffice (formerly OpenOffice.org), a free open source office suite.  A specially crafted DOC file can lead to an out of bound write and ultimately to remote code execution. Let\'s investigate this vulnerability. After OpenOffice Writer opens the malformed doc file we see the following state: So we see that write access violation appeared in the   constructor. The definition of this function is located in file  .\nChecking the   pointer value we see: When an attempt to write to the address pointed to by the   pointer, we encounter an access violation will because it points to mapped   library.\nLooking at source code we see (the lines here have different numbers than the lines in the original source code): The loop at line   is based on   value. Each time at the end of this loop (at line  )   pointer is set to new location based on the   field value.\n  is a pointer to a dynamically allocated buffer, which is allocated at line  , with a size equal to  . As we can see there is no check to see whether\nafter first iteration   is pointing outside buffer range or not. That situation leads to out of bound read/writes in certain places and finally can lead to remote code execution. A dump of some important fields: 2017-03-16 - Vendor Disclosure \n2017-10-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0295');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (279, 'Apache OpenOffice PPT PPTStyleSheet nLevel Code Execution Vulnerability', 'None', '2017-10-26', 'An exploitable out of bound write vulnerability exists in the PPTStyleSheet::PPTStyleSheet functionality of Apache OpenOffice.\nA specially crafted PPT file can cause an out of bound write resulting in arbitrary code execution.\nAn attacker can send/provide a malicious PPT file to trigger this vulnerability. Apache OpenOffice 4.1.3 x64\nApache OpenOffice 4.1.3 x86 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H This vulnerability is present in the Apache OpenOffice (formerly OpenOffice.org) a free open source office suite. \nA specially crafted PPT file can lead to an out of bound write and ultimately to remote code execution. As we can see an attempt to write is made in an address range of the mapped file libsd.so, which results in an access violation because of the pages that contain this mapped file are set to read and execute permissions, but not write.\nTo understand why this vulnerability appears, we will look at the vulnerable function in the source code: First of all code in the while loop at   searches for a PPT TxMasterStyleAtom record ( [MS-PPT] 2.9.35 TextMasterStyleAtom ). It finds it in the file at offset  . Next, we see that   is read at  . According to documentation: but in our case its value is equal: We also see the following: The lack of enforcement of the constraint that   must be less than 5 results in the vulnerability. The variables   and   are written to at lines  . Our invalid value will cause   to be bigger than 4 in the loop, which will result in an out of bound write. This can then lead to arbitrary code execution. Explanation: The target crashed on an access violation at an address matching the destination operand of the instruction. This likely indicates a write access violation, which means the attacker may control the write address and/or value. 2017-03-29 - Vendor Disclosure \n2017-10-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0300');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (280, 'Google PDFium TIFF Image Flate Decoder Code Execution Vulnerability', 'None', '2017-10-19', 'An off-by-one read/write on the heap vulnerability exists in the TIFF image decoder functionality of Pdfium as used by Google Chrome up to and including 60.0.3112.101. A specially crafted PDF file can trigger an off-by-one read and write on the heap resulting in memory corruption and a possible information leak and potential code execution. The victim needs to open a malicious PDF in the browser in order to trigger this vulnerability. Google Chrome 60.0.3112.101 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-193: Off-by-one Error Pdfium is an open source PDF renderer developed by Google and used extensively in the Chrome browser, online services as well as other standalone applications. This bug was triaged on the latest git version as well as the latest chromium address sanitizer build available (asan-linux-release-498039). A heap-buffer overflow is present in the code responsible for decoding a compressed TIFF image stream. While parsing pixel data of the flate decoded image stream, the function TIFF_PredictLine is reached: In the above code, during the for loop, 4 bytes will always be read from   even if the length of the buffer is less than that. This can potentially lead to an off-by-one read on the heap, followed immediately by an off-by-one write.\nIn order to reach the buggy code and trigger the vulnerable state, a couple of conditions need to be satisfied. In the previous function ,  , we see: At [1],   is calculated and is a multiple of 8. At [2], the data size of the last row is calculated, as input data might not have a multiple of   bytes available. When the last row is being used (if the next row would end up outside the data size)   is set to   at [3]. At [4], vulnerable function   is called with the calculated row row_size being 3, where   actually reads/writes 4 bytes from the data buffer , leading to off-by-one read/write. A sample PDF to trigger this bug is: The content of the stream above just needs to satisfy one condition and that is that it must decode to a length that would result in 3 in the calculation at [2] in the previously mentioned code. The lowest length that satisfies these and some of the previously mentioned conditions is 23. The values of  ,   and uncompressed stream lengths can be adjusted to control the sizes of the buffers, number of loops and bytes accessed and all ultimately get passed to their corresponding values to the functions that we mentioned. Depending on the underlying allocator and other variables, abusing this bug for information leaks or memory overwrite might or might not be possible, but it could potentially be combined with other vulnerabilities to cause further memory corruption. Address Sanitizer output from latest build at the time ( ) Official, latest version of Chrome on Windows crashes with the following when run with PageHeap enabled (output from BugId):   Stack: 2017-09-05 - Vendor Disclosure \n2017-10-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0432');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (281, 'Simple DirectMedia Layer Create RGB Surface Code Execution Vulnerability', 'None', '2017-10-10', 'An exploitable integer overflow vulnerability exists when creating a new RGB Surface in SDL 2.0.5. A specially crafted file can cause an integer overflow resulting in too little memory being allocated which can lead to a buffer overflow and potential code execution. An attacker can provide a specially crafted image file to trigger this vulnerability. Simple DirectMedia Layer 2.0.5 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound SDL is a cross-platform library that is designed to provide low-level access to various hardware using OpenGL and Direct3D. The various users of the library include games, video playback software (including VLC), and emulators. An integer overflow vulnerability exits when creating new RGB surfaces via the call to  . The function is defined at line 114 in src\\video\\SDL_surface.c: This function will subsequently call the function: SDL_CreateRGBSurfaceWithFormat(): This function will take the   and   arguments as well as the  , passed in by the file format, and use them all to allocate memory: It will calculate the pitch at line 58, which is essentially a multiplication of the   with the   with alignment. Then at line 83, it uses the pitch and the height to calculate the amount of memory that should be allocated: Given that there are no checks to make sure the multiplications don\'t overflow, this will result in an integer overflow where too little memory might be allocated, resulting in a heap-based buffer overflow when attempting to write to this memory. The   function is used in many image formats in SDL_Image and can thus result in potential buffer overflows in many file formats. As an example here we provide the use of the function in the XCF format. In SDL xcf.c the height and width will be read directly from the file in the function read header, defined at line 296: This function will be used in the function IMG RW defined at line 692: Next it will allocate a surface for the various layers that may exist in the file: And will then for each layer in the file, read in the layer and save it to the surface: The function   will subsequently write to the memory allocated in the   variable in loops: If an attacker has selected the height and width in such a way that the multiplication causes an integer overflow, then too little memory will have been allocated and the code at line 595 will result in an out of bounds write, potentially resulting in code execution. 2017-10-06 - Vendor Disclosure \n2017-10-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0395');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (282, 'Simple DirectMedia Layer SDL_image XCF Property Handling Code Execution Vulnerability', 'None', '2017-10-10', 'An exploitable buffer overflow vulnerability exists in the XCF property handling functionality of SDL_image 2.0.1. A specially crafted xcf file can cause a stack-based buffer overflow resulting in potential code execution. An attacker can provide a specially crafted XCF file to trigger this vulnerability. Simple DirectMedia Layer SDL_image 2.0.1 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow SDL_image is a library that handles image loading for the Simple DirectMedia Layer (SDL) library. SDL is a cross-platform library that is designed to provide low-level access to various hardware using OpenGL and Direct3D. The various users of the library include games, video playback software (including VLC), and emulators. A vulnerability exits in the SDL_image library\'s handling of XCF images. When an XCF image is read, its properties will be read from the file and used directly in a read operation, potentially resulting in a stack-based buffer overflow. This problem occurs in the read_xcf_property function of the IMG_xcf.c file: ... ... At line 254, it will read the id of the property from the file and then at line 255, it will read the length of the property. This length will then be used at line 277 to copy data from   into   which is 24 bytes in length, causing a buffer overflow if the length provided in the file is larger than 24. Adding a check to ensure that prop->length <= sizeof(prop->data) would fix the issue: 2017-10-06 - Vendor Disclosure \n2017-10-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0394');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (283, 'Computerinsel Photoline GIF Parsing Code Execution Vulnerability', 'None', '2017-10-4', 'An memory corruption vulnerability exists in the .GIF parsing functionality of Computerinsel Photoline 20.02. A specially crafted .GIF file can cause a vulnerability resulting in potential code execution. An attacker can send specific .GIF file to trigger this vulnerability. Computerinsel GmbH Photoline 20.02 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H The code responsible for the vulnerability is provided below: In short the byte value is taken directly from the .GIF file (see address 0x007BE521). This value is later\nmultiplied and used as a loop repeat number (see address 0x007BE585). This gives the attacker the\nopportunity to cause memory corruption and a memory overflow (instructions at 0x007BE578 and 0x007BE57D). 2017-08-02 - Vendor Disclosure \n2017-10-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0387');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (284, 'Computerinsel Photoline TGA Parsing Code Execution Vulnerability', 'None', '2017-10-4', 'A memory corruption vulnerability exists in the .TGA parsing functionality of Computerinsel Photoline 20.02. A specially crafted .TGA file can cause an out of bounds write resulting in potential code execution. An attacker can send a specific .TGA file to trigger this vulnerability. Computerinsel Photoline 20.02 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write The code responsible for the vulnerability is provided below: In short a dword value is taken directly from the .TGA file. This value is later used as a loop repeat number.\nWhich each loop iteration a memcpy operation is performed. This gives the attacker the opportunity to cause memory corruption\nand a buffer overflow. The data that is copied from the source for the memcpy function is based on attackers data 2017-09-26 - Vendor Disclosure \n2017-10-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0458');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (285, 'Computerinsel Photoline SVG Parsing Code Execution Vulnerability', 'None', '2017-10-4', 'An memory corruption vulnerability exists in the .SVG parsing functionality of Computerinsel Photoline 20.02. A specially crafted .SVG file can cause a vulnerability resulting in memory corruption, which can potentially lead to arbitrary code execution. An attacker can send a specific .SVG file to trigger this vulnerability. Computerinsel Photoline 20.02 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write The code responsible for the vulnerability is provided below: Memset execution: Memset function is executed with a size parameter that can be controlled by attacker.\nThe size parameter is calculated from the SVG Path\'s D attribute which is a string containing\na series of path descriptions (in this case Curveto). This value is later converted from float\nto int and then later used for multiplication purposes (instruction at 0x00822E0E). In this case the bug requires the feGaussianBlur filter to be attached to the path style. 2017-08-30 - Vendor Disclosure \n2017-10-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0427');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (286, 'ansible-vault Yaml Load Code Execution Vulnerability', 'None', '2017-9-14', 'An exploitable vulnerability exists in the yaml loading functionality of ansible-vault. A specially crafted vault can execute arbitrary python commands resulting in command execution. An attacker can insert python into the vault to trigger this vulnerability. ansible-vault 1.0.4 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-502 - Deserialization of Untrusted Data Ansible provides an easy solution for automating IT and network based tasks. The 3rd party python module, ansible-vault provides an encrypted format to contain potential secrets related to the automation. ansible-vault is leveraging the unsafe API   [0] for loading the yaml it decrypts. This yaml can contain a python directive to execute arbitrary commands. An example vault is shown below that, when loaded, will execute an arbitary command: A quick test leveraging the ansible-vault API shows the commands being executed: Replace   with  2017-04-07 - Vendor Disclosure \n2017-09-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0305');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (287, 'LibOFX Tag Parsing Code Execution Vulnerability', 'None', '2017-9-13', 'An exploitable buffer overflow vulnerability exists in the tag parsing functionality of LibOFX 0.9.11. A specially crafted OFX file can cause a write out of bounds resulting in a buffer overflow on the stack. An attacker can construct a malicious OFX file to trigger this vulnerability. LibOFX 0.9.11 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-120 - Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') OFX is the Open Financial Exchange format used by financial institutions to share financial data with clients. GnuCash is an open source financial-accounting software that has the capability to import OFX records using libOFX, an open source implementation of OFX. While parsing the tags of the given OFX record, libOFX attempts to strip any present OFX proprietary tags. After checking that the file begins with the correct OFX tag of  , the remaining tag is sent over to be sanitized by  . In this function, the tag is copied into a local stack variable called   as long as the parser is still within the opening tag [0]. Because the loop occurs over the size of the  , if the   is larger than  , then the stack variable is overflown and can potentially lead to code execution. 2017-04-14 - Vendor Disclosure \n2017-09-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0317');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (288, 'FreeXL read_biff_next_record Code Execution Vulnerability', 'None', '2017-9-11', 'An exploitable heap based buffer overflow vulnerability exists in the   of FreeXL 1.0.3.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious XLS file to trigger this vulnerability. freexl 1.0.3 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow FreeXL is a C library which can read Microsoft Excel File Format ( XLS ) files. The library is used by the SpatiaLite open source library.\nA heap-based buffer overflow appears in the   function. The vulnerability appears in a situation when a BIFF record size is bigger than   field.\nThe following code contains the vulnerability: At line 3775 the   is read directly from the file, which is used to control the loop at line 3808. Then at lines 3820 and 3826 data will be copied into the record which has a fixed size of 8224. Since there are no checks to ensure that the record_size is smaller than this declared value, this will result in a heap-based buffer overflow. 2017-09-06 - Vendor Disclosure \n2017-09-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0430');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (289, 'FreeXL BIFF Dimension Marker Code Execution Vulnerability', 'None', '2017-9-11', 'An exploitable heap-based buffer overflow vulnerability exists in the  read_legacy_biff function of FreeXL 1.0.3.\nA specially crafted XLS file can cause a memory corruption resulting in remote code execution.\nAn attacker can send malicious XLS file to trigger this vulnerability. freexl 1.0.3 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow FreeXL is a C library which can read Microsoft Excel File Format ( XLS ) files. The library is used by the SpatiaLite open source library.\nThe heap-based buffer overflow appears in read_legacy_biff function during parsing DIMENSION record. To reach the vulnerable code, the XLS file needs be in the old BIFF format. At line 2275   is read directly from the file: The vulnerability occurs in the   function: At  , workbook->record is read from the file, based on the size in the file that was read at line 2275. There are no checks to ensure that this value is smaller than the maximum size that a record can contain: Line 278     unsigned char record[8224];    / / This allows an attacker to fully control the heap overflow since both the content and the size are read directly from the file. The workbook object just after executing  : 2017-09-06 - Vendor Disclosure \n2017-09-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0431');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (290, 'Microsoft Edge Content Security Bypass Vulnerability', 'None', '2017-9-6', 'An exploitable information leak vulnerability exists in the Content Security Policy enforcement functionality of Microsoft Edge 40.15063.0.0. A specially crafted web page can cause a content security policy bypass resulting in an information leak. An attacker can create a malicious webpage to trigger this vulnerability. Microsoft Edge 40.15063.0.0 4.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N CWE-284: Improper Access Control An attacker can bypass the Content-Security-Policy header that is used to make the browser protect against information leakage from a web site. By loading a new document using window.open(\"\",\"_blank\") and document.write-ing into it, (being in about:blank) an attacker can circumvent the CSP restrictions put on the document that the original page\'s Javascript code was running on and reach out to other sites.\nOne could argue that the code was loaded with unsafe-inline in the CSP header, but that should still block any cross-site communication (e.g. 1x1px tracking image etc). The about:blank page has the same origin as its loading document, but CSP restrictions have been removed. The spec is pretty explicit that the CSP restrictions should be inherited: https://w3c.github.io/webappsec-csp/#initialize-document-csp. Tests show that e.g. Firefox does not show this behavior, but rather makes the new document inherit CSP from its loading document. This vulnerability was also present in Apple Safari (CVE-2017-2419) and Google Chrome (CVE-2017-5033) and was corrected there. 2016-11-29 - Initial vendor contact by Nicolai  \n2016-12-01 - Vendor confirms receipt  \n2017-01-04 - Follow up with Vendor  \n2017-01-04 - Vendor confirms reproduction  \n2017-03-06 - Follow up with Vendor  \n2017-03-07 - Vendor says this is by design and does not consider it a vulnerability  \n2017-03-07 - More information provided to vendor  \n2017-03-29 - Talos involvement, asks vendor to reconsider  \n2017-06-06 - Follow up with vendor  \n2017-06-07 - Vendor reopens case to reconsider  \n2017-08-22 - Vendor informed about pending release date  \n2017-09-06 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0306');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (291, 'Ledger CLI Account Directive Use-After-Free Vulnerability', 'None', '2017-8-30', 'An exploitable use-after-free vulnerability exists in the account parsing component of the Ledger-CLI 3.1.1. A specially crafted ledger file can cause a use-after-free vulnerability resulting in arbitrary code execution. An attacker can convince a user to load a journal file to trigger this vulnerability. Ledger HEAD\nLedger 3.1.1   \n \n 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free Ledger-cli is a plain-text, double-entry accounting system that is useable from the command line. It is based around a plain-text format known as a journal file that contains each transaction for each account. When parsing a malformed journal file, the application will misuse the std::unique_ptr type when exchanging objects between different parts of the parser. Due to this, when these pointers go out of scope they will be released and destroyed. However, due to the pointers still being retained by the application a use-after-free vulnerability will occur when the application attempts to process a user\'s commands. When first parsing a journal file, the application will execute the following code. This code will instantiate an instance_t, and then call its   method [1]. The   method will simply enter a loop that processes each line of the journal file using the   method [2]. The   method will iterate through each line of the journal file whilst looking at the first character to determine which command to process. If the first character is numeric, then the application will assume that it\'s an account directive and will call the   method to handle it [1]. Inside the   method, the application will call the   [1] method which will return a pointer. This pointer will then be assigned to a   [2]. Due to it being incorrectly initialized from a pointer, there are no references to it. When the variable goes out of scope at [3], it will then be freed. The   method, is responsible for allocating the   object [1]. Near the end of this function, the application will call the   method [2]. This method will allocate a   object, and then link the   object to the  . Afterwards, the returned   will then be linked back to the   object [3]. Inside the   method, the application will allocate a   via it\'s constructor [1], and then begin to parse any extra flags that were specified in the post. In order to reach the most vulnerable path which leads directly to code eecution, the   flag must be specified. This requires that there be an entry that begins and ends with the   and   characters [2]. Once the file is done parsing, the application will return back to the   method. At [1], the application will then proceed to apply any transactional information for the deferred posts in the   account that have been parsed by the   parser. This is done by the following code. At this point, the post object has already been freed due to it being out of scope due to lack of references. At [1], since the pointer was still assigned to the object, the application will iterate through all the deferred posts within the account. However, due to the object being released, the virtual method dereference at [2] will dereference memory that has gone out of scope. Simply run the ledger binary with the provided proof-of-concept as an argument followed by the command type. Both   and   will trigger the vulnerability. The proof-of-concept simply needs to have an account entry within it that includes a deferred posting. This means that a line must exist that begins with a number to specify an account directive. Then before the next account directive, there must be something within \'<\' and \'>\' symbols. This will enter the path that will dereference a function pointer. 2017-04-07 - Vendor Disclosure \n2017-08-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0304');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (292, 'Gdk-Pixbuf TIFF tiff_image_parse Code Execution Vulnerability', 'None', '2017-8-30', 'An exploitable integer overflow vulnerability exists in the tiff parse functionality of Gdk-Pixbuf 2.36.6 when compiled with Clang.\nA specially crafted tiff file can cause a heap-overflow resulting in remote code execution. An attacker can send a file or a URL to trigger this vulnerability. Gdk-Pixbuf 2.36.6 commit: aba8d88798dfc2f3856ea0ddda14b06174bbb2bc\ncompiled with clang -O3 flag\nlibtiff 4.0.6 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior The vulnerability exists in the TIFF parser and only manifests itself when the library is compiled with high optimization flags   (tested with Clang, gcc does not remove the check). Several defined  \ninside the   function  are responsible of integer overflow checks or at least that was their intention. Because the checks are made on signed integers, the condition cannot evaluate to false unless an\ninteger overflow occurs.  According to the C standard, a signed integer overflow is defined as \"Undefined Bahavior\", thus behaviour related to it is implementation dependent and in the case of Clang the check is removed.\nFinally the lack of proper integer overflows check leads to heap overflow and can allow attackers to obtain arbitrary code execution. The code below is removed from compilation process because it would be true if a   would occur which is  : in our case the variables have the following values: which causes an integer overflow at  : Then, based on the overflowed value, a buffer is allocated : Then all three parameters: width,height and the allocated   buffer are passed as arguments: Because buffer   was allocated based on overflowed value, width and height parameters mismatch the size of the buffer which leads to out of bound writes (Line 1362) inside the   function while reading RGB values: 2017-07-13 - Vendor Disclosure \n2017-08-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0377');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (293, 'Ledger CLI Tags Parsing Code Execution Vulnerability', 'None', '2017-8-30', 'An exploitable buffer overflow vulnerability exists in the tag parsing functionality of Ledger-CLI 3.1.1. A specially crafted journal file can cause a integer underflow resulting in code execution. An attacker can construct a malicious journal file to trigger this vulnerability. Ledger CLI 3.1.1 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-120 - Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Ledger CLI is an accounting system accessed via the command line. Ledger leverages data provided by the user to provide very detailed financial reports and analytics. When parsing the tags in a journal file, a size of the tag is constructed by subtracting two pointers pointing to the ends of the tag. This size is used directly to copy file data into a static buffer. This subtraction can result in an integer underflow, forcing a large value to be be used in the subsequent  . An example journal file exercising this vulnerability is shown below: Note the   that comes before   after the  . These resultant pointers cause the integer overflow resulting in the buffer overflow. 2017-04-07 - Vendor Disclosure \n2017-08-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0303');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (294, 'Gdk-Pixbuf JPEG gdk_pixbuf__jpeg_image_load_increment Code Execution Vulnerability', 'None', '2017-8-30', 'An exploitable heap overflow vulnerability exists in the gdk_pixbuf__jpeg_image_load_increment functionality of Gdk-Pixbuf 2.36.6.\nA specially crafted jpeg file can cause a heap overflow resulting in remote code execution. An attacker can send a file or url to trigger this vulnerability. Gdk-Pixbuf 2.36.6 commit: aba8d88798dfc2f3856ea0ddda14b06174bbb2bc\nlibjpeg-turbo 1.5.2 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-131: Incorrect Calculation of Buffer Size A vulnerability exists in the JPEG parser: it\'s based on wrong calculation size for an output buffer in the   function which later causes a heap overflow\nduring file content conversion inside libjpeg   function. Because the file necessary to trigger this vulnerability is quite small we can present its entire content here: We can notice that there are a couple JPEG markers but we will focus on the one directly related with vulnerability. That marker is 0xFFCA which starts at offset : 0x47 and has a size of 0x23 bytes.\nBelow are important values read from this section (marker): To observe how the vulnerability manifests itself, we will use the   test application and our malicious JPEG as input file. Executed under   control we see the following output: So, generally there is a buffer allocated inside   and later overflowed in  .\nLet\'s take a closer look at where this allocation takes place: The important variable here is  . Its value is equal to   so as a result of the comparison, second argument passed to   will be a   boolean\nflag. Going inside this function we see: We see that the   variable which is used in the calculation of the   value at  .\nThe size of the allocated buffer in our case equals 0x90. Now going straight to the function where the heap overflow appears we see these lines: Based on the   value, a different loop is used to copy data from the input buffer to the output one. We land of course in   branch starting at   because our\n  equals 0x9. Then we see the following: Line 403: the   loop condition is based on   which equals 0x1\nLine 404: the   is controlled by   which equals 0x9 and finally\nLine 407: tihs for loop is controlled by   which equals 0x2f. It is clear now why the overflow occurs. The Gdk-pixbuf developers assume only two scenarios of  : 3 or 4 and based on those two potential values, allocated the buffer.\nHere we land in scenario where   equals 0x9 that will cause an out of buffer write at   in will result in heap corruption. 2017-07-11 - Vendor Disclosure \n2017-08-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0366');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (295, 'National Instruments LabVIEW RSRC Arbitrary Null Write Code Execution Vulnerability', 'None', '2017-8-29', 'An exploitable memory corruption vulnerability exists in the RSRC segment parsing functionality of LabVIEW. A specially crafted VI file can cause an attacker controlled looping condition resulting in an arbitrary null write. An attacker controlled VI file can be used to trigger this vulnerability and can potentially result in code execution. LabVIEW 2016 version 16.0 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787: Out-of-bounds Write LabVIEW provides engineers a simple environment to build measurement or control systems. LabVIEW is used to abstract many of the low-level details of various hardware and signal-processing libraries into a single platform. It uses a graphical programming approach to achieve this goal. Modules utilized in this vulnerability: While opening a VI file, an RSRC segment can be parsed. An example of the beginning of this segment is shown below: After parsing the RSRC segment into an internal RSRC struct, LabVIEW tries to clean up data handles created in this process. To begin this process, the loop counter is first extracted from the RSRC segment. Extracted first is the offset to the loop counter [0]. This value is then added to the beginning of the RSRC segment [1]. This new address is accessed to extract the loop counter used for termination of the main loop for clearing data handles. The loop responsible for clearing the data handles is below: The loop extracts the value under the current pointer [4] and adds it to the beginning of the segment [5]. This address is then cleared [6] and the pointer moves to the next section [7]. An attacker can control the loop counter as well as the offsets read from the RSRC struct used to calculate which address to clear, causing a write null anywhere situation. This null overwrite could potentially be leveraged into code execution. 2017-01-25 - Vendor Disclosure \n2017-08-29 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0273');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (296, 'Lexmark LibISYSpdf Image Rendering DCTStream::getBlock() Code Execution Vulnerability', 'None', '2017-8-28', 'An exploitable code execution vulnerability exists in the image rendering functionality of Lexmark Perceptive Document Filters 11.3.0.2400. A specifically crafted PDF can cause a function call on a corrupted DCTStream to occur, resulting in user controlled data being written to the stack. A maliciously crafted PDF file can be used to trigger this vulnerability. Lexmark Perceptive Document Filters 11.3.0.2400 7.5  CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-121 - Stack-Based Buffer Overflow Lexmark Perceptive Document Filters is an SDK used for inspection, conversion, and viewing for a multitude of different file formats. Developers can utilize either the built binaries or shared libraries of this product in order to manipulate common file types including PDFs.  It should be noted that Marklogic uses this product for rendering purposes. Lexmark Perceptive Document Filters statically links various code with a modified version of the open source Poppler library for parsing and rendering PDF files, resulting in a shared library called libISYSpdf6.so. For rendering certain types of images within the PDF, libISYSpdf6 uses a modified version of the DCTStream class, called IGRStream. An interesting thing to note about the DCTStream class, and by extension the IGRStream class, is that there are two buffers within the class that are used for storing image data, however upon initialization, only one of these buffers is allocated and overwritten, depending on the type of the image (interleaved || progressive). A mini-bug in the class occurs in that one can switch the image type after the allocation has occurred, forcing the DCTStream to interact with the un-allocated buffer. Due to the above issue and the fact that the IGRStream doesn\'t clear a few variables correctly, ([IGRStream+0xda8], [IGRStream+0xdb0] respectively designated blockBuf and blockBufEnd), if the heap is manipulated correctly, on initialization of the IGRStream object, the blockBuf and blockBufEnd pointers can be controlled by the user.  It should be noted that the image type needs to be set to progressive at first, and then swapped to interleaved after the memory allocation occurs, such that the blockBuf and blockBufEnd pointers do not get overwritten with malloc pointers. This issue will become relevant soon, but in summary, IGRStream+0xda8 and IGRStream+0xdb0 can both be user controlled. Below is the source code from the poppler-0.53.0 library. It is not 100% accurate with regards to the  Lexmark ISYSpdf6.so code, but it serves as a good base. Our corrupted IGR stream is returned from a lookup, and two functions are called upon it: [0] fontDict->lookup is returning our corrupted IGRStream, which passes isStream() check\n[1]  Something different in the ISYSpdf6.so binary. Inside of GfxFont.cc: Although the above poppler source is not 100% what occurs within the Lexmark code, it\'s a good approximation. The actual assembly is listed below, in which our unintended object has two methods called upon it, that result in the functions DCTStream::reset [0] and DCTStream::getBlock [1] being called, the latter of which is a Lexmark-only function. The DCTStream::getBlock function seems to be a Lexmark replacement for the implementation of reading non-progressive and interleaved JPEG images. It reads the current stream in chunks <= 0x1000 bytes for the image data and copies it onto the stack, with a call to memcpy. The arguments to memcpy end up being as such: Since DCTStream+0xdb0 and DCTStream+0xda8 are user controlled (remember IGRStream::blockBuf and IGRStream::blockBufEnd?), the end result is a call to memcpy with a user-controlled source, count, and a destination on the stack. The only thing protecting from an easy mode return address overwrite is a   instruction as shown below: It should be noted that an integer underflow can occur when calculating the distance between IGRStream::blockBuf and IGRStream::blockBufEnd, which bypasses the   check with 0x1000, forcing the size of the memcopy to be larger than the static buffer of 0x1000 bytes, resulting\nin a stack-based overflow. 2017-04-24 - Vendor Disclosure \n2017-08-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0323');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (297, 'Lexmark Perceptive Document Filters PDF GfxFont Code Execution Vulnerability', 'None', '2017-8-28', 'Lexmark Perceptive Document Filters PDF GfxFont Code Execution Vulnerability An exploitable use-after-free exists in the PDF parsing functionality of the Lexmark Perspective Document Filters 11.3.0.2400 and 11.4.0.2452.\nA crafted PDF document can lead to a use-after-free resulting in direct code execution. Lexmark Perceptive Document Filters 11.3.0.2400 - x86\nLexmark Perceptive Document Filters 11.4.0.2452 - x86 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free This vulnerability is present in the Lexmark Document filter parsing which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services.  This product is mainly used by MarkLogic for document conversions as part of their web-based document search and rendering. It can convert common formats such as Microsoft\'s document formats into more useable and easily viewed formats. There is a vulnerability in the parsing and conversion of a PDF document. A specially crafted PDF file can lead to a use-after-free and ultimately code execution. Let\'s investigate this vulnerability. After attempt of convert a malicious PDF by the Lexmark library we see the following state: As we can see code flow has been redirected to the heap somehow. Using rr and re-running application we gonna try to stop at moment when code execution is redirected to the above heap address. Seeing the above assembly listing, we can notice a virtual function call based on corrupted vftable.\nTo understand better what exactly happened we can look at some source code. Lexmark developers use a modified version of the Xpdf / Poppler library in libISYSpdf6.so.\nFurther analysis reveals that a call to malformed vftable appears in   constructor and is directly related with   object:  object is read from   and later in   call to virtual function   is made.\nAfter a bit of analysis of the Xpdf code in context of places where   object can change, depending on how particular   are executed, this part of the code was monitored. Beside that, the life cycle of the object that is most interesting is   (see the second listing above: ESI == this ). All these observation should reveal places where   object was corrupted or eventually released which later leads to the call of the malformed vtftable. Having all these printed out information during code execution, we can clearly see now that at     object is released. In two places we can observe that address under its\' vftable.\n   is overwritten first by the free in the code executed at    and later by the malloc in the code at  .\nThis all happens inside the   handler. Next when executing the   tag handler, we can see that current font object assigned to   has been change to this released one  .\nAt   the released   object calls its virtual function. An attacker having control of the heap layout using proper PostScript tag combinations can leverage this use-after-free vulnerability to achieve arbitrary code execution. Explanation: The target tried to access data at an address that matches the program counter. This is likely due to the execution of a branch instruction (ex: \'call\') with a bad argument, but it could also be due to execution continuing past the end of a memory region or another cause. Regardless this likely indicates that the program counter contents are tainted and can be controlled by an attacker. Explanation:The target tried to access data at an address that matches the program counter. This is likely due to the execution of a branch instruction (ex: \'call\') with a bad argument, but it could also be due to execution continuing past the end of a memory region or another cause. Regardless this likely indicates that the program counter contents are tainted and can be controlled by an attacker. Explanation: The target tried to access data at an address that matches the program counter. This is likely due to the execution of a branch instruction (ex: \'call\') with a bad argument, but it could also be due to execution continuing past the end of a memory region or another cause. Regardless this likely indicates that the program counter contents are tainted and can be controlled by an attacker. 2017-04-24 - Vendor Disclosure \n2017-08-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0322');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (298, 'GNOME libsoup HTTP Chunked Encoding Remote Code Execution Vulnerability', 'None', '2017-8-10', 'An exploitable stack based buffer overflow vulnerability exists in the GNOME libsoup 2.58. A specially crafted HTTP request can cause a stack overflow resulting in remote code execution. An attacker can send a special HTTP request to the vulnerable server to trigger this vulnerability. GNOME libsoup 2.58 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow GNOME libsoup is a library implementing client and server side code for dealing with HTTP requests and responses. It is used to implement custom web servers or clients. Usually it is used embedded in other applications such as media streaming servers for basic web server functionality. It can also be used standalone and embedded in hardware devices. When processing an HTTP request which contains chunk encoded data, an improper bounds checking can lead to large memory copy operation which can overflow a statically sized buffer on the stack. Buffer that is being overflown is located in function   in file libsoup/soup-body-input-stream.c: The buffer is allocated on the stack at [1]. While further processing the body of a chunk-encoded HTTP request, function   is called: In the above code, we can see   and it’s length being passed to the   function which is just a wrapper around   being called with new line as delimiter: Function   does the actual reading from the input stream into the buffer. In the above code, at [2] a pointer to the end of the stream data is calculated, at [3] it is used as an end condition in a for loop which is looking for a set delimiter (variable  , a newline character in this case) at [4]. Pointer   is being incremented in the loop until newline is found. Finally, at [5], function   is called with input stream as source, buffer as destination and offset to newline character as length. No check to make sure the buffer is big enough is performed anywhere. In the function   a   call can thus lead to a buffer overflow: To trigger this vulnerability, a simple HTTP request like the following is enough: When parsing this request, the first chunk will be of size 1, and then the parser proceeds to scan the overly long series of   characters for a new line. A string longer than 128 characters will overflow the buffer. This can be abused in order to crash the server or achieve remote code execution in the context of the server.\nWhen parsing this request, the first chunk will be of size 1, and then the parser proceeds to scan the overly long series of   characters for a new line. A string longer than 128 characters will overflow the buffer. This can be abused in order to crash the server or achieve remote code execution in the context of the server. Address Sanitizer output: 2017-08-02 - Vendor Disclosure \n2017-08-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0392');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (299, 'Adobe Acrobat Reader DC AcroForm PDFDocEncoding Remote Code Execution Vulnerability', 'None', '2017-8-8', 'An exploitable case of parser confusion can lead to invalid pointer arithmetic in part of code responsible for parsing AcroForm forms in the Adobe Acrobat Reader DC 2017.009.20044. A specially crafted PDF file can abuse this unchecked pointer arithmetic to access and overwrite arbitrary memory in the process ultimately leading to arbitrary code execution.  In order to trigger this vulnerability, a victim would need to open the malicious file or access a malicious web page. Adobe Acrobat Reader DC 2017.009.20044 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-823: Use of Out-of-range Pointer Offset Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. AcroForm elements of the PDF are used to define interactive forms that the user can use to input additional data. As part of AcroForm resource dictionary, various objects can be specified to be used by the form, such as fonts, encodings and so on. One of the encodings can be   which is used for specifically encoded strings. Usually, PDFDocEncoding object will consist of an array of   which define differences of this specific encoding from the defined or implicit base encoding. In Adobe Reader, if   object has it’s base encoding defined as   (which shouldn’t ever be the case in regular files), a parser can be tricked into using a direct differences offset value as an offset to a pointer creating an out of bounds memory access condition. For example: In the above excerpt from our PoC for this issue, object 5 is of   type and its resource dictionary refers to object 6 as   object. Object 6 in turn defines base encoding and malformed differences. The value -247381695 (or 0xf1414141 hex) will end up being used as a pointer offset in a memory write instruction. This can be simply observed in the following crash information:   (1998.211c): Access violation - code c0000005 (first chance)\n  First chance exceptions are reported before any exception handling.\n  This exception may be expected and handled.\n    ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\Adobe\\Acrobat Reader DC\\Reader\\plug_ins\\AcroForm.api -\n  eax=21100061 ebx=00000000 ecx=21105cc0 edx=0a2d4ff8 esi=00000001 edi=f1414141\n  eip=20a77eeb esp=0012e614 ebp=0012e654 iopl=0         nv up ei pl nz na pe nc\n  cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n  AcroForm!DllUnregisterServer+0x316be:\n  20a77eeb 66890479        mov     word ptr [ecx+edi*2],ax  ds:0023:0392df42=???? Note that at the time of the crash,   points to valid memory, but   contains the specified value. A value being written (in register  ) is also under our control and is 0x0061 in this case (ASCII for  ). Finally, by adding more differences entries in the   array, the out of bound write can be repeated arbitrary many times. By abusing this, effectively arbitrary, write anywhere primitive, process can be manipulated into achieving arbitrary code execution. 2017-06-09 - Vendor Disclosure \n2017-08-08 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0361');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (300, 'Kakadu SDK JPEG 2000 Contiguous Codestream Code Execution Vulnerability', 'None', '2017-8-4', 'A code execution vulnerability exists in the kdu expand function  of the Kakadu SDK 7.9. A specially crafted JPEG 2000 file can be read by the program and can lead to an out of bounds write causing an exploitable condition to arise. Kakadu SDK 7.9 - OSX & Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-131: Incorrect Calculation of Buffer Size Kakadu SDK is a commercial solution for the parsing and handling of JPEG 2000 images. This software is used by many high profile companies in the handling of JPEG 2000 images, including Apple. This vulnerability could have a large impact due to the number of users using this SDK to handle their images. The JPEG 2000 format begins with a header describing the data that will be presented in the rest of the file. The header is parsed by scanning through, finding a marker, and parsing the data based off of the type of marker. The size of the current markers data is presented immediately following the marker itself. The vulnerability arises when the parser gets to the contiguous codestream section of the Jpeg2000 image. The codestream size is not checked and is overly large leading to excessive parsing of data erroneously. An outline of the vulnerable image is shown below. As can be seen the size parameters are overly large for a file of only 100 bytes. The program then goes into a loop using these sizes and allocates working buffers based off of the data these sizes point to. The vulnerability arises in the fact that after multiple iterations of the loop the   being read at [1], is zero thus the size calculation is zero at [2], and the buffer being allocated is of size 31 rather than the necessary size. When this buffer is used again for calculations it access beyond the bounds of the buffer and into memory in various places including potential calls and writes leading to a highly exploitable condition. Using a safe malloc implementation the crash is shown below. 2017-04-18 - Vendor Disclosure \n2017-08-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0309');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (301, 'Kakadu SDK JPEG 2000 Unknown Marker Code Execution Vulnerability', 'None', '2017-8-4', 'A code execution vulnerability exists in the Kakadu SDK 7.9\'s parsing of compressed JPEG 2000 images. A specially crafted JPEG 2000 file can be read by the program, and can lead to an out of bounds write causing an exploitable condition to arise. Kakadu SDK 7.9 - OSX & Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-131: Incorrect Calculation of Buffer Size Kakadu SDK is a commercial solution for the parsing and handling of JPEG 2000 images. This software is used by many high profile companies in the handling of JPEG 2000 images, including Apple. This vulnerability could have a large impact due to the number of users using this SDK to handle their images. The JPEG 2000 format begins with a header describing the data that will be presented in the rest of the file. The header is parsed by scanning through, finding a marker, and parsing the data based off of the type of marker. The size of the current markers data is presented immediately following the marker itself. The vulnerability arises in the handling of an unknown marker. The hex dump of the trigger file is shown below. The first two bytes represent a signature then the next two begin the marker parsing. Marker ids begin with 0xFF and the byte following determines the type of marker. Following the marker type the next two bytes represent the size of the field. If we take the size of the first marker id it brings us to the next id of FF52 with a size of 0xC. Then finally we get to the unknown marker id of 0xFF79. Due to this being an unknown marker, the size field is calculated and taken from the fourth byte and is read in as 0x0000001A00000001. The code for creating the working buffer is shown below. And inside enlarge_work_buffers: So from this we can derive that the size of the created buffer is 212 or (0x1a*2+1) * 4. At,1, we can see the newly allocated buffer being put into the structure for use later. Oddly, the buffer is advanced by 104 bytes before being assigned. Later on in the program when this buffer is used again, the same calculations are performed and an attempt to zero out the buffer for a size of 212 is made. As can be seen above this will cause a buffer overflow and lead to an exploitable out-of-bounds write condition. 2017-04-18 - Vendor Disclosure \n2017-08-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0308');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (302, 'EZB Systems UltraISO ISO Parsing Code Execution Vulnerability', 'None', '2017-8-1', 'An buffer overflow vulnerability exists in the ISO parsing functionality of EZB Systems UltraISO 9.6.6.3300. A specially crafted .ISO file can cause a vulnerability resulting in potential code execution. An attacker can provide a specific .ISO file to trigger this vulnerability. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This vulnerability can be triggered by providing specially crafted .ISO file and opening it with UltraISO\nsoftware. After the \"NM\" entry is located in the .ISO file UltraISO executes _strncpy function\nwith maxlen argument calculated directly from the ISO header\'s byte field NM_hdr.len -\nthe length of the alternate name. UltraISO assumes this field is always larger than 5 bytes however if attacker forces it to be\nless than that value the maxlen parameter for the _strncpy function will be extremely big\n(NM_hdr.len - 5, result is unsigned). Later the memset function (inside the _strncpy function) is executed where the extremely big size\nparameter is used which leads to memory corruption. 2017-05-24 - Vendor Disclosure \n2017-08-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0342');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (303, 'FreeRDP Rdp Client License Recv Code Execution Vulnerability', 'None', '2017-7-24', 'An exploitable code execution vulnerability exists in the authentication functionality of FreeRDP 2.0.0-beta1+android11. A specially crafted server response can cause an out-of-bounds write resulting in an exploitable condition. An attacker can compromise the server or use a man in the middle attack to trigger this vulnerability. FreeRDP 2.0.0-beta1+android11 - Windows, OSX, Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:H CWE-129: Improper Validation of Array Index FreeRDP is a remote desktop protocol implementation available for all of the major operating systems. Many of the commercial remote desktop protocol applications actually use this library as their core. The vulnerability arises in using untrusted data in handling the license authentication with the server. At [1], the RDP header is read in and a local variable, length, is assigned a value directly from the attacker controlled packet. The value of length is then subtracted from four, [2], and passed into a decryption function. If the attacker supplies a value less than four a negative value will be passed into decrypt. The attacker controlled length value goes through multiple functions and ends up passed in directly to the OpenSSL RC4 function call. This causes the program to write attacker influence data out of bounds causing a potentially exploitable condition to arise. A hexdump of the attacker controlled packet is below with the bytes pertaining to the length marked. Run included Python server and connect FreeRDP Client to it. 2017-05-24 - Vendor Disclosure \n2017-07-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0336');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (304, 'FreeRDP Rdp Client Read Server Proprietary Certificate Denial of Service Vulnerability', 'None', '2017-7-24', 'An exploitable denial of service vulnerability exists within the reading of proprietary server certificates in FreeRDP 2.0.0-beta1+android11. A specially crafted challenge packet can cause the program termination leading to a denial of service condition. An attacker can compromise the server or use man in the middle to trigger this vulnerability. FreeRDP 2.0.0-beta1+android11 - Windows, OSX, Linux 6.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H CWE-190: Integer Overflow or Wraparound FreeRDP is a remote desktop protocol implementation available for all of the major operating systems. Many of the commercial remote desktop protocol applications actually use this library as their core. The vulnerability arises in the parsing of proprietary certificates. In processing a servers proprietary certificate, the function calls out to read the public key. It takes the key length directly from the packet and decrements eight from it, [1]. It then does a check on the length by adding the eight back and comparing it to the stream length. The vulnerability arises here when a value less than eight is passed in. It passes the check but wraps around and causes a large allocation to be made, [3]. The denial of service arises at, [4] when the stream is now read into the oversized buffer and an out-of-bounds read occurs. Run included Python server and connect FreeRDP Client to it. 2017-05-24 - Vendor Disclosure \n2017-07-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0338');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (305, 'FreeRDP Rdp Client License Read Challenge Packet Denial of Service Vulnerability', 'None', '2017-7-24', 'An exploitable denial of service vulnerability exists within the handling of challenge packets in FreeRDP 2.0.0-beta1+android11. A specially crafted challenge packet can cause the program termination leading to a denial of service condition. An attacker can compromise the server or use man in the middle to trigger this vulnerability. FreeRDP 2.0.0-beta1+android11 - Windows, OSX, Linux 6.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H CWE-252: Unchecked Return Value FreeRDP is a remote desktop protocol implementation available for all of the major operating systems. Many of the commercial remote desktop protocol applications actually use this library as their core. The vulnerability arises due to failure to check the return value result. The license structure is populated at, [1],and a return value check is omitted. This newly populated license is then passed into a decryption function directly. Below is the code for license_read_binary_blob, [1]. In the read_blob function we can see the length is read in directly from the packet and then checked against the stream length, [3]. This will exit the function if the check fails and return false. Recall that the previous function does not check the return value so the type blob->data,[4], will not be initialized. The license_decrypt_platform_challenge function is shown below: The license object is passed in and the EncryptedPlatformChallenge is used without validation, [5]. Recall the EncryptedPlatformChallenge data field is not set due to incorrect length so when the RC4 function attempts to use it a null pointer access happens and a denial of service condition arises. Run included Python server and connect FreeRDP Client to it. 2017-05-24 - Vendor Disclosure \n2017-07-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0341');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (306, 'FreeRDP Rdp Client Recv RDP Code Execution Vulnerability', 'None', '2017-7-24', 'An exploitable code execution vulnerability exists in the RDP receive functionality of FreeRDP 2.0.0-beta1+android11. A specially crafted server response can cause an out-of-bounds write resulting in an exploitable condition. An attacker can compromise the server or use a man in the middle to trigger this vulnerability. FreeRDP 2.0.0-beta1+android11 - Windows, OSX, Linux 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:H CWE-129: Improper Validation of Array Index FreeRDP is a remote desktop protocol implementation available for all of the major operating systems. Many of the commercial remote desktop protocol applications actually use this library as their core. The vulnerability arises in using untrusted data in handling the reception of a RDP packet with the server. At [1], the RDP header is read in and a local variable, length, is assigned a value directly from the attacker controlled packet. Another value, [2], is read in from the packet to determine if encryption is set on this packet. This check is simply anding a value in the packet with a constant and is easily passed. The value of length is then subtracted from four, [3], and passed into a decryption function. If the attacker supplies a value less than four a negative value will be passed into decrypt. The attacker controlled length value goes through multiple functions and ends up passed in directly to the OpenSSL RC4 function call. This causes the program to write attacker influence data out of bounds causing a potentially exploitable condition to arise. A hexdump of the attacker controlled packet is below with the bytes pertaining to the length marked. Run included Python server and connect FreeRDP Client to it. 2017-05-24 - Vendor Disclosure \n2017-07-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0337');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (307, 'FreeRDP Rdp Client License Read Product Info Denial of Service Vulnerability', 'None', '2017-7-24', 'An exploitable denial of service vulnerability exists within the handling of challenge packets in FreeRDP 2.0.0-beta1+android11. A specially crafted challenge packet can cause the program termination leading to a denial of service condition. An attacker can compromise the server or use man in the middle to trigger this vulnerability. FreeRDP 2.0.0-beta1+android11 - Windows, OSX, Linux 6.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H CWE-190: Integer Overflow or Wraparound FreeRDP is a remote desktop protocol implementation available for all of the major operating systems. Many of the commercial remote desktop protocol applications actually use this library as their core. The vulnerability arises in the license_read_product_info functionality. The license_read_product_info function reads in an unsigned integer from the attacker controlled packet. The function then adds four to this value for a check against the remaining length, [1]. There are no checks to detect and overflow here so an overly large value is able to be passed in. The malloc at, [2], succeeds on a 64 bit system causing an out of bounds read and denial of service condition to arise at, [3]. Run included Python server and connect FreeRDP Client to it. 2017-05-24 - Vendor Disclosure \n2017-07-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0340');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (308, 'FreeRDP Rdp Client GCC Read Server Security Data Denial of Service Vulnerability', 'None', '2017-7-24', 'An exploitable denial of service vulnerability exists within the handling of security data in FreeRDP 2.0.0-beta1+android11. A specially crafted challenge packet can cause the program termination leading to a denial of service condition. An attacker can compromise the server or use man in the middle to trigger this vulnerability. FreeRDP 2.0.0-beta1+android11 - Windows, OSX, Linux 6.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H CWE-190: Integer Overflow or Wraparound FreeRDP is a remote desktop protocol implementation available for all of the major operating systems. Many of the commercial remote desktop protocol applications actually use this library as their core. The vulnerability arises in the gcc_read_server_security_data function. The read_server_security_data function reads in two length values from the packet, [1]. It then does an obscure check to ensure that it is not going over the value of the remaining length. With both of these values being taken from the packet it is simple to overflow this check and continue on with a larger length than what is available. When the overly large length data is attempted to be read from the buffer an out-of-bounds read occurs and an exploitable denail of service condition arises. Run included Python server and connect FreeRDP Client to it. 2017-05-24 - Vendor Disclosure \n2017-07-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0339');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (309, 'Corel PHOTO-PAINT X8 GIF Filter Code Execution Vulnerability', 'None', '2017-7-20', 'An of bound write / memory corruption vulnerability exists in the GIF parsing functionality of Core PHOTO-PAINT X8 18.1.0.661. A specially crafted GIF file can cause a vulnerability resulting in potential memory corruption resulting in code execution. An attacker can send the victim a specific GIF file to trigger this vulnerability. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H A memory corruption vulnerability exists in the GIF parsing functionality of Corel PHOTO-PAINT. A specially crafted GIF file can cause a vulnerability resulting in potential memory corruption. The vulnerable code is located in the IEGIF.flt library: The total number of loop executions (r8d value) is calculated below: An attacker can create a malicious GIF file which can force the total number of loop cycles to be extremely big\n(lile r8d=0x8000000000, 0x100000, ...). This causes the loop to overwrite arbitrary memory data. In order to trigger this vulnerability the GlobalColorTableFlag from the LOGICALSCREENDESCRIPTOR_PACKEDFIELDS\nneeds to be 1 and the SizeOfGlobalColorTable needs to be set to 7. Additionally, the value returned by sub_18000A780 (later used for shif-logical-left operation - CL register (count))\nis taken directly from the poc file (offset 0x3f2). 2016-12-01 - Vendor Disclosure \n2017-07-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0244');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (310, 'Corel PHOTO-PAINT X8 TIFF Filter Code Execution Vulnerability', 'None', '2017-7-20', 'A remote out of bound write vulnerability exists in the TIFF parsing functionality of Core PHOTO-PAINT X8 18.1.0.661. A specially crafted TIFF file can cause a vulnerability resulting in potential memory corruption. An attacker can send the victim a specific TIFF file to trigger this vulnerability. Corel PHOTO-PAINT X8 (Corel TIFF Import/Export Filter (64-Bit) - 18.1.0.661) - x64 & x86 version 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787 - Out-of-bounds Write An remote memory corruption vulnerability exists in the TIFF parsing functionality of Corel PHOTO-PAINT. A specially crafted TIFF file can cause a vulnerability resulting in potential memory corruption. Module used in this vulnerability is described below: While parsing a TIFF file, a tag of type   can be given. In this tag, there is a   attribute used to dictate further information to read from the file. If there is no more data to read from the file,   will return   for the number of bytes read from the file. This value is saved at offset   for later use. The function presented below is typically executed 3 times (assuming our POC is being parsed): Using the saved   value from   in a subtraction (0x0001CD70), a   value   is generated and passed as the   to a   operation.    0:000> !analyze -v 2017-03-28 - Vendor Disclosure \n2017—07-20 -  Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0298');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (311, 'Corel PHOTO-PAINT X8 64-bit TIFF Filter Code Execution Vulnerability', 'None', '2017-7-20', 'A remote out of bound write vulnerability exists in the TIFF parsing functionality of Core PHOTO-PAINT X8 version 18.1.0.661. A specially crafted TIFF file can cause a vulnerability resulting in potential memory corruption. An attacker can send the victim a specific TIFF file to trigger this vulnerability. This vulnerability only exists in the 64-bit version. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787 - Out-of-bounds Write An remote memory corruption vulnerability exists in the TIFF parsing functionality of Corel PHOTO-PAINT. A specially crafted TIFF file can cause a vulnerability resulting in potential memory corruption. Module used in this advisory: While parsing the TIFF IFD entries, a crafted TIFF file can cause an underflow resulting in a large value being passed as the   to a  . One value [0] comes from a table of numbers from within the binary itself, whose offset is directly affected by file data. The other [1] comes from a calculation based on the file data itself. Because the attacker can force [1] to be less than [0], the underflow can be triggered, causing a large size to be passed to memset [3]. 2017-03-28 - Vendor Disclosure \n2017-07-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0297');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (312, 'Corel CorelDRAW X8 EMF Parser Code Execution Vulnerability', 'None', '2017-7-20', 'An out of bound write vulnerability exists in the EMF parsing functionality of CorelDRAW X8 (CdrGfx - Corel Graphics Engine (64-Bit) - 18.1.0.661). A specially crafted EMF file can cause a vulnerability resulting in potential code execution. An attacker can send the victim a specific EMF file to trigger this vulnerability. Corel CorelDRAW X8 (CdrGfx - Corel Graphics Engine (64-Bit) - 18.1.0.661) - x64 version 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H A remote memory corruption vulnerability exists in the EMF parsing functionality of CorelDRAW. A specially crafted EMF file can cause a vulnerability resulting in potential memory corruption. Vulnerable code is located in the CdrGfx.dll library: Presented code gets executed when EMR_CREATEBRUSHINDIRECT (39) record from the EMF file is parsed.\nSuch record is typically composed as follows [1]: Attacker can control the RAX register value (see instructions at 0x176B1F and 0x176B22) by simply\nchanging the ihBrush value in the EMF file (EMR_CREATEBRUSHINDIRECT record). This leads to memory\ncorruption of where the destination address is controlled by attacker. Additionally this vulnerability can be triggered using other EMF records. Below is a list of records that can be used to trigger this problem.\n38  -   EMR CREATEBRUSHINDIRECT\n40  -   EMR EXTCREATEFONTINDIRECTW\n93  -   EMR CREATEDIBPATTERNBRUSHPT\n95  -   EMR_EXTCREATEPEN [1] - https://msdn.microsoft.com/en-us/library/cc230604.aspx 2016-12-23 - Vendor Disclosure \n2017-07-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0261');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (313, 'ProcessMaker Enterprise Core Code Execution Vulnerability', 'None', '2017-7-19', 'A code execution vulnerability exists in ProcessMarker Enterprise Core 3.0.1.7-community. A specially crafted web request can cause unsafe deserialization potentially resulting in PHP code being executed. An attacker can send a crafted web parameter to trigger this vulnerability. ProcessMaker Enterprise Core 3.0.1.7-community 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-502 - Deserialization of Untrusted Data It was discovered that the application deserialized untrusted data without properly limiting or validating the incoming data type. The following Proof Of Concept request demonstrate the issue: The following code was found to be responsible for unsafe deserialization: Restrict access to known, trusted users and hosts. 2016-04-28 - Vendor Disclosure \n2017-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0314');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (314, 'ProcessMaker Enterprise Core Multiple SQL Injection Vulnerabilities', 'None', '2017-7-19', 'Multiple exploitable SQL Injection vulnerabilities exists in ProcessMarker Enterprise Core 3.0.1.7-community. Specially crafted web requests can cause SQL injections. An attacker can send a web request with parameters containing SQL injection attacks to trigger this vulnerability, potentially allowing exfiltration of the database, user credentials and in certain setups access the underlying operating system. ProcessMaker Enterprise Core 3.0.1.7-community 7.4 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L CWE-89 - Improper Neutralization of Special Elements used in an SQL Command (\'SQL Injection\') SQL injection has been found and confirmed within ProcessMarker Enterprise Core. A successful attack could allow an attacker to access information such as usernames and password hashes that are stored in the database. The following URLs and parameters have been confirmed to suffer from SQL injections and could be exploited by autenticated attackers: Unauthenticated SQL injection: Note: For this SQL injection to work a \'cnn\' parameter needs to be know as that is the parameter used to establish the connection with the database. The following code which can be directly invoked from the server presents this issue: Restrict access to known, trusted users and hosts. 2016-02-15 - Vendor Disclosure \n2017-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0313');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (315, 'Open Fire User Import Export Plugin XML External Entity Injection', 'None', '2017-7-19', 'An exploitable XML entity injection vulnerability exists in OpenFire User Import Export Plugin 2.6.0. A specially crafted web request can cause the retrieval of arbitrary files or denial of service. An authenticated attacker can send a crafted web request to trigger this vulnerability. OpenFire User Import Export Plugin 2.6.0 8.1 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H CWE-611: Improper Restriction of XML External Entity Reference (\'XXE\') The User Import Export Plugin is vulnerable to an XML External Entity injection attack. The application can be exploited via either Cross Site Request Forgery or if account with given credentials is compromised. This vulnerability may allow the retrieval of arbitrary files or the causing of a Denial of Service condition (by making the server read from a file such as `/dev/random\') External entities can also reference URLs, potentially allowing port scanning from the XML parser\'s host, or the retrieval of sensitive web content that would otherwise be inaccessible due to network topology and defenses. Restrict access to known, trusted users and hosts. 2017-03-06 - Vendor Disclosure \n2017-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0316');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (316, 'Information Builders WebFOCUS Business Intelligence Portal Command Execution Vulnerability', 'None', '2017-7-19', 'An exploitable command execution vulnerability exists in Information Builders WebFOCUS Business Intelligence Portal 8.1 . A specially crafted web parameter can cause a command injection. An authenticated attacker can send a crafted web request to trigger this vulnerability. Information Builders WebFOCUS Business Intelligence Portal 8.1 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-77 - Improper Neutralization of Special Elements used in a Command (\'Command Injection\') WebFOCUS Business Intelligence Portal 8.1 was found to be vulnerable to an authenticated WebFOCUS code injection attack that resulted in arbitrary command execution on the underlying OS of the host system with the same privileges as those of the web server running the BI portal. To exploit this vulnerability, successful login with a valid user account is required, which has the necessary privileges to access the WebFOCUS Business Intelligence Portal dashboard.\nCode injection is achieved on the following URL:  /ibi_apps/WFServlet The injection happens on one of the dynamic URL parameters used on this specific URL, a parameter that is directly used within a WebFOCUS language query, which is used by the application to generate dynamic reports. By successfully injecting WebFOCUS code on this URL parameter while properly completing the expected syntax, an attacker can leverage the \"! \" statement of WebFOCUS which allows for system commands to be executed via the reporting module code. Successfully exploiting this vulnerability results in arbitrary command execution on the underlying Operating System, which in turn can result in full system compromise depending on the level of access the web server is running with. Restrict access to known, trusted users and hosts. 2016-10-31 - Vendor Disclosure \n2016-12-20 - Final attempt to contact vendor after no response  \n2017-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0315');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (317, 'Iceni Infix PDF parsing SetSize Code Execution Vulnerability', 'None', '2017-7-11', 'An out-of-bounds write vulnerability exists in the PDF parsing functionality of Infix 7.1.5. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. An attacker can send the victim a specific PDF file to trigger this vulnerability. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-787 - Out-of-bounds Write An remote memory corruption vulnerability exists in the PDF parsing functionality of Infix. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. The vulnerable code is located in the Infix.exe file: The function SetSize? sets up the dword value located at EDI+23Ch. When a malformed file is being parsed\nthis value is set to 0xFFFFFFFF which normally should indicate an error. However, due to further lack of error\nchecking conditions this value (0xFFFFFFFF) is later used as an argument to memset function (size parameter)\nwhich causes the memory corruption to occur. 2017-06-20 - Vendor Disclosure \n2017-07-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0367');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (318, 'Poppler PDF Image Display DCTStream::readProgressiveSOF() Code Execution Vulnerability', 'None', '2017-7-7', 'An exploitable heap overflow vulnerability exists in the image rendering functionality of Poppler-0.53.0. A specifically crafted PDF can cause an overly large number of color components during image rendering, resulting in heap corruption. An attacker controlled PDF file can be used to trigger this vulnerability. Poppler-0.53.0 7.5 -  CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Poppler is a shared library for displaying PDF files, used as middleware within different enterprise and opensource solutions alike (e.g. Gimp). It is forked off of XPDF, and is a complete implementation of the PDF ISO standard. The Poppler library, by default, uses a private implementation of reading and rendering images. There is a compilation option for  libjpeg support, but the flag is not enabled by default. This private implementation contains assumptions about the JPEG file headers that can lead to heap corruption when broken. This vulnerability was formerly found (CVE-2005-3627) with a fix applied to DCTStream::readBaselineSOF, however the bug was not also fixed in the readProgressiveSOF function. A look at the two functions highlights the vulnerability:\nThere should be a check for:     at [0] As there is no check on the numComps variable, the subsequent loop in   can then write past the intended bounds of compInfo[3], and into heap metadata 2017-05-17 - Vendor Disclosure \n2017-07-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0319');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (319, 'Poppler PDF library JPEG 2000 levels Code Execution Vulnerability', 'None', '2017-7-7', 'An exploitable integer overflow vulnerability exists in the JPEG 2000 image parsing functionality of freedesktop.org Poppler 0.53.0. A specially crafted PDF file can lead to an integer overflow causing out of bounds memory overwrite on the heap resulting in potential arbitrary code execution. To trigger this vulnerability, a victim must open the malicious PDF in an application using this library. Poppler 0.53 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound Poppler is a popular open source PDF parser library. It is used by default in many open source PDF viewers. The library itself implements a decoder for JPEG 2000 encoded images instead of relying on a more complete implementation (such as OpenJPEG), although it does warn about this at compile time and strongly suggests OpenJPEG be used. By default, this internal implementation will be used by applications. That is the case with libpoppler binary shipped by latest Ubuntu version which is used by the default PDF viewer, Evince. When processing a PDF file with an embedded JPEG 2000 image (specified with a   stream) inside, the   source file will be used to render the image. Eventually, the method   will be invoked and it will process the image tile parts according to data in the SOT , SIZ and COD elements. When multiple levels are specified inside a COD element, the code will loop that many times starting at line 1961: In the above excerpt, it can be observed that zeroth level will be processed in one way, where the rest is processed in a different way involving more arithmetic. The first integer overflow can happen at [1] (and other lines, but we’ll use this one for example). Specifically, if the value   is less than 2 to the power of current level being processed, the   can result in a large value, due to integer overflow. Then, when   macro is executed, in almost all cases, this will result in 0, but a single value of K lets the overflow persist after   call, resulting in a large positive result of the division, instead of 0. This later leads to out of bounds heap access. In the above code, when   is equal to 0, the overflown value from the previous calculation will end up in   at [2] and will figure into the calculation at [3], effectively setting    to a non-zero value. This further leads to a loop being entered when it shouldn’t, leading to further corruption: Because   is positive, a loop at [4] will be entered, ultimately leading to an out of bounds write at [5].\nMost of the indices and offsets that figure in the above code come directly from the JPEG 2000 file giving control over the out of bounds write and leaving space for further memory manipulation. This vulnerability can be triggered with poppler PDF utilities if the library is built to use the internal JPX decoder. As previously mentioned, the official binaries shipped with latest Ubuntu distribution use this decoder, so the vulnerability can be triggered through the   application. This means that in order to trigger the vulnerability, it is enough for the victim to view the directory where the malicious file is located. Mitigation for this vulnerability can involve making sure that the library is compiled to use OpenJPEG library instead of its internal parser. 2017-05-16 - Vendor Disclosure \n2017-07-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0321');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (320, 'Poppler PDF Image Display DCTStream::readScan() Code Execution Vulnerability', 'None', '2017-7-7', 'An exploitable heap overflow vulnerability exists in the image rendering functionality of Poppler-0.53.0. A specifically crafted pdf can cause an image resizing after allocation has already occurred, resulting in heap corruption which can lead to code execution. An attacker controlled PDF file can be used to trigger this vulnerability. Poppler-0.53.0 7.5 -  CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Poppler is a shared library for displaying PDF files, used as middleware within different enterprise and opensource solutions alike (e.g. Gimp). It is forked off of XPDF, and is a complete implementation of the PDF ISO standard. The Poppler library, by default, uses a private implementation of reading and rendering images. There is an compilation option for  libjpeg support, but the flag is not enabled by default. This private implementation contains assumptions about the JPEG file headers that can lead to heap corruption when broken. Whenever the PDF Lexer discovers an image, the DCTStream::reset() method eventually gets called to process the image headers found in the PDF. Due to how JPEGs are stored and compressed (Discrete Cosine Transforms), an appropriate amount of space has to be allocated for the DCT decompression to occur (still in DCTStream::reset()) [0] After the space has been allocated, further headers and data are read in to prepare for the DCT algorithm as such (still in DCTStream::reset()). The   function [0] transforms 8x8 pixel blocks.\nWhile   [2] will read headers continuously till error or until the   method returns gTrue. The main issue lies in that the   and   variables that determine the size of the allocated buffer are class variables read from a specific header inside of the   function, more specifically, either   (\\xff\\xc2) or   (\\xff\\xc1). Thus, if a specially crafted PDF file can allocate a JPEG buffer and then resize the height and width after the allocation, it will cause poppler to perform DCT data transforms on internal heap memory when it tries to read the image data. (inside of DCTStream::readScan()). The code below shows the issue: The code at [3] will cause   to point past the end of the allocated buffer, it will subsequently be written to at [5]. 2017-05-16 - Vendor Disclosure \n2017-07-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0311');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (321, 'Nitro Pro 11 PDF Handling Code Execution Vulnerability', 'None', '2017-7-6', 'An out of bound write vulnerability exists in the PDF parsing functionality of Nitro Pro 11.0.4.159. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. An attacker can send the victim a specific PDF file to trigger this vulnerability. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H A remote memory corruption vulnerability exists in the PDF parsing functionality of Nitro Pro. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. The vulnerable code is located in the npdf.dll library: Memory access referred by selected instruction is presented below: The last memory access (instruction at 0x268C7D) is causing the exception to trigger.\nThe instruction at 0x268C7D is using the RAX register value to calculate the final memory address.\nRAX value is calculated by reading 32-bit memory from [r9+0x800] (with sign extension).\nValue at [r9+0x800] in this case is 0xABABABAB which is Microsoft\'s HeapAlloc() mark of \"no man\'s land\"\nguard bytes after the allocated heap memory. In other words this memory should be never referenced in the\nfirst place. This value is later increased by the r10 value (address 0x268C77) and multiplied by 2 (address 0x268C7A). 2017-02-22 - Vendor Disclosure \n2017-07-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0289');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (322, 'Invincea-X SboxDrv.sys Version Number Query Local Privilege Escalation Vulnerability', 'None', '2017-6-30', 'An exploitable double fetch vulnerability exists in the SboxDrv.sys driver functionality of Invincea-X 6.1.3-24058. A specially crafted input buffer and race condition can result in kernel memory corruption, which could result in privilege escalation. An attacker needs to execute a special application locally to trigger this vulnerability. Invincea-X 6.1.3-24058 (Dell Protected Workspace) 8.1 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H This vulnerability is present in the SboxDrv.sys driver which is a part of Invincea-X (Dell Protected Workspace).This product provides sandbox functionality for Windows environments. Because of weak permissions set on the driver any malicious application\ncan communicate with driver. The application can also provide pointer value that is double fetched in the kernel, allowing an attacker to cause a race condition resulting in memory corruption which can lead to local privilege escalation.\nDiving into the details we need to start with permission sets on device created by vulnerable driver. Vectors of attacks are definitely increased due to the weak permissions set on the \'\\Device\\SandboxDriverApi\' device created by the SboxDrv.sys driver which gives group   full access to this device. The driver handles a few IOCTLs codes but one of them (0x222007) is especially rich and uses the first DWORD in the input buffer to decide what particular function is executed. Let\'s investigate the vulnerable function which is launched when first DWORD in input buffer is set to 0x12340001: At address   we see that inputBuffer pointer gets put into the   register and its later also used from this register. Next at   a pointer specified by user\nat offset +8 in inputBuffer is moved to  . The intended purpose of this pointer is to hold the version of the sandbox driver. We see at address  \na very important check is done on the   value using ProbeForWrite before a copy operation is made to this buffer. However, a double fetch vulnerability appears at   where the buffer pointer value to which driver version should be copied is again read from   instead of using the checked pointer value kept in  . This vulnerability opens the possibility for race condition where a malicious application\nchanges the pointer value between ProbeForWrite and its usage in memcpy. Finally that situation will lead to an arbitrary write in kernel address space. Pseudo-code presenting vulnerable code: 2016-12-12 - Vendor Disclosure \n2017-06-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0256');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (323, 'Invincea Dell Protected Workspace Protection Bypass', 'None', '2017-6-30', 'Multiple security flaws exists in InvProtectDrv.sys which is a part of Invincea Dell Protected Workspace 5.1.1-22303. Weak restrictions on the driver communication channel and additonal insufficient checks allow any application to turn off some of the protection mechanisms provided by the Invincea product. Invincea Dell Protected Workspace build 5.1.1-22303   \n 7.8 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H This vulnerability is present in the InvProtectDrv.sys driver which is a part of the Invincea Dell Protected Workspace. This product provides sandbox functionality for Windows environments. Due to weak permissions on the driver communication channel and ineffective additional checks, any malicious application\ncan communicate with driver and turn off some of the security functionality provided by this product. Let\'s investigate these flaws. The   driver creates a communication port via the FltCommunicationPort with weak security descriptions allowing any user to communicate with this port.\nThe vulnerable code looks as follows: The amount of applications to can connect with this port is limited to one but because the connection is occupied by a user mode application which is not protected, malicious application can kill the   process and connect to the port. The Routine responsible for handling messages sent to the driver is at    . One of the functionalities of this communication channel is to apply new policies to the sandbox. Part of   looks as follows: As we can see, before the new policy is applied, the location of the application which sent it is checked. There are a couple of absolute application paths defined and only applications from this paths are able to satifisy this constraint.\nLet\'s take a look at the   function: In the while loop at  , we see a comparison of the array  \'s elements with  . If the sender\'s application path is equal to one of paths, the   flag is set to one. The content of   is as follow: Because the standard installation directory of the executable files listed in this array is  , an unprivileged user can\'t put a malicious executable in that location.\nTo bypass that check attacker can use the   technique on one of the executables listed in the   array. That way, the executable path check will be satisfied.\nAfter bypassing this check, the attacker needs to provided a properly formatted buffer to trigger specific actions. Examining the process reveals that the structure of the   contains a new   that looks as follows: Inside the   function we find call to a routine which exposes what type of policy and functionality we can trigger. We can see that sending a properly formatted   we can turn functionality on or off that is related to: An example of an input buffer that contains a policy that will disable both the options above looks like this: After running the PoC code below with the   defined above, we see the following messages in DebugView: 2016-12-01 - Vendor Disclosure \n2017-06-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0246');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (324, 'Dell Precision Optimizer Local Privilege Escalation Vulnerability', 'None', '2017-6-30', 'An exploitable dll hijacking vulnerability exists in the poaService.exe service component of the Dell Precision Optimizer software version 3.5.5.0.\nA specifically named malicious dll file located in one of directories pointed to by the PATH environment variable will lead to privilege escalation.  An attacker with local access to vulnerable system can exploit this vulnerability. Dell Precision Tower 5810 with nvidia graphic cards.\nPPO Policy Processing Engine      - FileVersion : 3.5.5.0\nati.dll ( PPO Monitoring Plugin ) - FileVersion : 3.5.5.0 7.1 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N This vulnerability is present in the Dell Precision Optimizer application service which is pre-installed on, e.g., a Dell Precision Tower 5810 with Windows.\nPart of official application description : The absence of the  , forces the system to search for this DLL in directories pointed to by the PATH environment variable, which gives attackers the possibility to put a malicious DLL in one of the directories to which they have write permissions. The digital signature of the DLL is not checked before it is loaded.\nAs a result, malicious code is loaded into the   service, which leads to local privilege escalation. 2016-12-01 - Vendor Disclosure \n2017-06-30 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0247');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (325, 'InsideSecure MatrixSSL x509 certificate SubjectDomainPolicy Remote Code Execution Vulnerability', 'None', '2017-6-22', 'An exploitable heap buffer overflow vulnerability exists in the X509 certificate parsing functionality of InsideSecure MatrixSSL 3.8.7b. A specially crafted x509 certificate can cause a buffer overflow on the heap resulting in remote code execution. To trigger this vulnerability, a specially crafted x509 certificate must be presented to the vulnerable client or server application when initiating secure connection. InsideSecure MatrixSSL 3.8.7b 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow MatrixSSL is a secure socket layer cryptographic library aimed at embedded and IoT systems due to it’s low code footprint and RAM utilization. It is supported on many embedded platforms, fully compatible with other SSL implementations and FIPS140-2 compliant. While parsing an x509 certificate in DER form there exist an issue in with ASN1 encoded sequences. Specifically, while parsing x509 SubjectDomainPolicy PolicyMappings extension, an array of one size is allocated on the heap, but due to specially encoded OIDs, one more element can be copied into it. Specifically in the following code in   in fucntion  : At [1]   is called to determine the length of the following ASN1 OID field, the value is stored in   variable. At [2],   is used as a parameter to   function. At [3], an array for OIDs is allocated using   for number of elements. In a for loop at [4], OIDs are coppied into the allocated array. If   is bigger than  , an overflow can happen. If we take a look at   we can observe the following key points: In the above code, an important thing to note is that at [1], a single byte from the buffer initializes two oid entries. Then, at [2], is the soft form is used, both   counter and   buffer pointer are incremented by one. And finaly, in a do-while loop around [3], a long form OIDs are parsed, which can consume more than one byte per OID entry. Therefore, if a specially crafted x509 certificate can have a PolicyMapping with an ASN1 buffer of length N bytes (as returned by  ), but actually contain N+1 OIDs (two from first byte, and all other bytes being short form). As an example, the attached PoC x509 certificate has the following OID sequence: This decodes to length 10. An array   will be allocated for 10 entries only, but 11 will be copied into it (since none are in long form), causing a buffer overflow. A simple fix for this issue would be to use   instead of   when allocating mentioned arrays. 2017-02-07 - Vendor Disclosure \n2017-06-22 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0276');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (326, 'InsideSecure MatrixSSL x509 certificate General Names Information Disclosure Vulnerability', 'None', '2017-6-22', 'An integer overflow vulnerability exists in the X509 certificate parsing functionality of InsideSecure MatrixSSL 3.8.7b. A specially crafted x509 certificate can cause a length counter to overflow,  leading to a controlled out of bounds copy operation. To trigger this vulnerability, a specially crafted x509 certificate must be presented to the vulnerable client or server application when initiating secure connection. Depending on the use of the underlying library, this issue could be abused to leak sensitive memory. It could also be used to cause a crash, resulting in a denial of service. InsideSecure MatrixSSL 3.8.7b 6.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:H CWE-191: Integer Underflow (Wrap or Wraparound) MatrixSSL is a secure socket layer cryptographic library aimed at embedded and IoT systems due to its low code footprint and RAM utilization. It is supported on many embedded platforms, fully compatible with other SSL implementations and FIPS140-2 compliant. While parsing an x509 certificate in DER form, there exists an issue in a way general names extensions are parsed. Specifically, a certificate with subject alternative name ASN1 strings of certain caracteristics can lead to an integer underflow, ultimately leading to an out of bounds   call with full control over size parameter. The vulnerability is present in function  . The key points are highlighted in the following code: At [1],   is an unsigned 16 integer argument. At [2],   is checked to be greater than 0 in each loop iteration. At [3],   is decremented unconditionally. At [4] there’s another chance for   to be further decremented. At [5], a data buffer is allocated appropriately and is  used as a destination for in a memcpy call at [6].\nFrom the above quoted source code, it can be observed that in case initial value of   is small (1 for example), an underflow can happen, making it very big, which would allow the loop to execute more times than needed, causing further trouble. While parsing the ASN1 buffer that is specified, pointer   is constantly incremented, and is kept in bounds by being checked with   pointer. But, due to   underflow, and carefully chosen ASN1 structure lengths,   can be incremented beyound   causing another integer overflow. This allows us to further manipulate the parser, ultimately enabling us to control the   value. If this value is set to be very big, the   call at [6] will create an out of bounds read from the   pointer, copying adjacent heap memory beyond the end of the initial buffer. If this memory buffer and it’s length is later used and returned to the user in some way, it would represent sensitive information leak. The attached minimal x509 certificate that triggers this vulnerability has a few things changed from the benign one. First, the length of the global names field is changed to 1, instead of real length, which causes   to be 1 initially. This achieves the first integer overflow. Second, size of the first subject alternative name is set to a large value. In this case, the buffer passed to   is at most 100 bytes, so maximum size for first malformed alternative name entry is 0x63. This will cause the   pointer to be incremented beyond it’s end after the first iteration of the while loop. And finally, the rest of the certificate is adjusted so that malformed size points to an element with ID other than zero which can now have arbitrary size because the   check is overflown. The issue can be triggered with the   sample application supplied with the library. Address sanitizer output:   Address 0x7ffefe71b800 is located in stack of thread T0 at offset 20064 in frame   HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext   SUMMARY: AddressSanitizer: stack-buffer-overflow (/ramdisk/triage/matrixssl/matrixssl/test/certValidate+0x4a276c)\n  Shadow bytes around the buggy address:    Shadow byte legend (one shadow byte represents 8 application bytes): 2017-02-07 - Vendor Disclosure \n2017-06-22 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0278');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (327, 'InsideSecure MatrixSSL x509 certificate IssuerDomainPolicy Remote Code Execution Vulnerability', 'None', '2017-6-22', 'An exploitable heap buffer overflow vulnerability exists in the X509 certificate parsing functionality of InsideSecure MatrixSSL 3.8.7b. A specially crafted x509 certificate can cause a buffer overflow on the heap resulting in remote code execution. To trigger this vulnerability, a specially crafted x509 certificate must be presented to the vulnerable client or server application when initiating secure connection. InsideSecure MatrixSSL 3.8.7b 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow MatrixSSL is a secure socket layer cryptographic library aimed at embedded and IoT systems due to it’s low code footprint and RAM utilization. It is supported on many embedded platforms, fully compatible with other SSL implementations and FIPS140-2 compliant. While parsing an x509 certificate in DER form there exist an issue in with ASN1 encoded sequences. Specifically, while parsing x509 IssuerPolicy PolicyMappings extension, an array of one size is allocated on the heap, but due to specially encoded OIDs, one more element can be copied into it. Specifically in the following code in   in function  : At [1]   is called to determine the length of the following ASN1 OID field, the value is stored in   variable. At [2],   is used as a parameter to   function. At [3], an array for OIDs is allocated using   for number of elements. In a for loop at [4], OIDs are coppied into the allocated array. If   is bigger than  , an overflow can happen. If we take a look at   we can observe the following key points: In the above code, an important thing to note is that at [1], a single byte from the buffer initializes two oid entries. Then, at [2], is the soft form is used, both   counter and   buffer pointer are incremented by one. And finaly, in a do-while loop around [3], a long form OIDs are parsed, which can consume more than one byte per OID entry. Therefore, if a specially crafted x509 certificate can have a PolicyMapping with an ASN1 buffer of length N bytes (as returned by  ), but actually contain N+1 OIDs (two from first byte, and all other bytes being short form). As an example, the attached PoC x509 certificate has the following OID sequence: This decodes to length 10. An array   will be allocated for 10 entries only, but 11 will be copied into it (since none are in long form), causing a buffer overflow. A simple fix for this issue would be to use   instead of   when allocating mentioned arrays. Proposed patch: 2017-02-07 - Vendor Disclosure \n2017-06-22 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0277');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (328, 'Foscam  IP Video Camera CGIProxy.fcgi Query Append Buffer Overflow Vulnerability', 'None', '2017-6-19', 'An exploitable buffer overflow vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can cause a buffer overflow resulting in overwriting arbitrary data. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 9.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. When the \"CGIProxy.fcgi\" service is started, the service will first enter the   function. After initializing the FastCGI service and then register a couple of message callbacks, the service will initialize the request. This request will be used in a loop in order to read requests that are submitted by the http daemon that is hosting this FastCGI server. After registering the message handlers and initializing the request, the service will enter the following loop to handle each request that was forwarded by the http daemon. This loop will receive each request, decode it, and then determine how each request should be handled. Once calling  , the function at [1] will be called. This function will determine what type of http request is being made. This can be a GET request, a POST request, or an unknown. If a GET request is made, this function will return 0 and then proceed to call the function at [2]. The function at [2] will also pass a global variable [3] which contains a number of buffers that can each be overflown. Inside the function, the service will use   [4] to fetch the query string as provided by the FastCGI protocol. If the query string exists, then it will calculate the   at [5], and then pass it through a URL decoder [6] to process any encoded characters. Immediately afterwards, the function call at [7] will check to see that the query string is no larger than 0x400 bytes. Afterwards, the service will copy the decoded string into the global buffer at [8]. The structure of the global sets aside only 0x400 bytes of space for the query. Later, this buffer will be appended to, causing a buffer overflow. After the buffer has been written into the global, the following code will be executed. This code will first grab the \"REMOTE_ADDR\" parameter [9] and then append the \"remoteIp=\" string to the buffer [10]. Due to the buffer being only 0x400 bytes, this will write the string outside the bounds of the global buffer. Afterwards, the service will search for the \"remoteP2P=\" string in the query [11]. If this value is found, it will also be appended to the global at [12]. If not, the shorter address from the REMOTE_ADDR request will be appended. Either one of these values will write after the 0x400 bytes leading to a buffer overflow. Immediately following this code, another string will be appended to the already overflow buffer. This code will grab the current process id [13], convert it to a string [14], and then write it into a temporary buffer on the stack. After this is done, the service will then append the \"&pid=\" string to the global buffer [15], followed by the process id that was earlier converted to a string [16]. To trigger this request, this can be done with the combination of command line http client and Perl for generating the buffer. The buffer\'s size is 0x400 bytes. However, due to a string concatenation it can be made to overwrite data after the buffer. The usage of the \"remoteP2P\" parameter will cause up to 0x400 more bytes to be overwritten. The following command should trigger the vulnerability. 2017-05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0332');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (329, 'Foscam IP Video Camera CGIProxy.fcgi Wifi Settings Code Execution Vulnerability', 'None', '2017-6-19', 'An exploitable stack-based buffer overflow vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can cause a buffer overflow resulting in overwriting arbitrary data, potentially resulting in code execution. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 7.5 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-120: Buffer Copy without Checking Size of Input (\'Classic Buffer Overflow\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"setWifiSetting\", the function   will be called. This function is responsible for configuring the Wifi interface. At the beginning several parameters are extracted: \"callbackJson\", \"isEnable\", \"isUseWifi\", \"ssid\", \"netType\", \"encryptType\", \"psk\" [10], \"isNewFormat\" [11].\nIf \"isNewFormat\" is not null,   will be called [12] passing the \"psk\" value and a destination buffer as parameters. The \"psk\" parameter contains the wifi password as comma-separated ascii-values (e.g. \"112,119,100\" for \"pwd\"). The purpose of   is to split \"psk\" on commas and save each numeric value as a character, and then put the resulting password in a buffer (passed as second parameter to the function).\nThe local variable \"src\" [13] has a size of 0x100 and is filled with nulls [14]. Another smaller local variable \"var_58\" is filled with nulls as well [15]. Before starting the tokenization, the \"psk\" value is copied in the \"src\" buffer [16] without any constraint of size, leading to a buffer overflow. This vulnerability is reachable by the \"setWifiSetting\" command and requires a valid user account with privilege level 2. The following commands trigger the vulnerability overwrites the saved register  . 2017-05-30 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0353');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (330, 'Foscam C1 Webcam FTP Hard Coded Password Vulnerability', 'None', '2017-6-19', 'Hard-coded FTP credentials (r:r) are included in the Foscam C1 running firmware 1.9.1.12. Knowledge of these credentials would allow remote access to any cameras found on the internet that do not have port 50021 blocked by an intermediate device. Foscam C1 Firmware Version 1.9.1.12 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-259: Use of Hard-coded Password The file found at \'/mtd/app/bin/ftpd/pureftpd.passwd\' contains the following hash: This hash resolves to a simple user/pass combo of \'r:r\'. The user/pass of r:r permits anyone to log into a Foscam camera and have full read/write to the mounted Micro-SD card, which contains .avi videos and .jpg snapshots. If the camera has a microphone, the .avi videos will have audio recording as well. An attacker armed with this knowledge can connect remotely to the target camera and dump potentially sensitive data. Exploitation relies on the availability of port 50021 (the default FTP port that this camera uses). Preventing access to this port or disabling FTP completely will help mitigate this vulnerability. 2016-11-29 -  Vendor disclosure \n2017-06-19 - Public release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0245');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (331, 'Foscam IP Video Camera CGIProxy.fcgi Account Creation Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during account creation resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an HTTP request that\'s forwarded from the HTTP daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query off to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   followed by the function call at [9] which will execute the function pointer. The handler for the \"addAccount\" command has an access level of 2 and points to the function  . This command reads the following parameters from a user\'s query: At [10], is the \"usrName\" parameter. The user\'s password is at [11] as \"usrPwd\". Their \"privilege\" level is at [12], and finally the \"callbackJson\" parameter at [13]. After validating that these parameters have been included, the \"privilege\" parameter will be converted to an integer [14] and then all 3 parameters will be passed as arguments to [15]. Once inside the   function, the service will do a few checks to verify that the user name doesn\'t already exist, that adding a user will not exceed the maximum user count, and that the privilege level is 2. If these checks are satisfied, the service will build a format string using \"sh /usr/bin/ftpd/configFTP.sh 1 %s %s\" and the user name and password pair [16]. Once this is done, the password will be checked to ensure that there are no \';\' characters used [17] and then the format string will be passed to a call to   at [18]. Due to the service not enforcing any other restrictions on the character set, this can allow an attacker to inject arbitrary characters that may be interpreted by the Bourne shell which can allow for one to execute arbitrary shell commands. This vulnerability is reachable by the \"addAccount\" command and requires privileges to create a new account. Both the \"usrName\" and \"usrPwd\" parameters can be injected into although only the \"newPwd\" parameter is filtered for \';\' characters. 2017-05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0328');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (332, 'Foscam IP Video Camera CGIProxy.fcgi SMTP Test Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during the SMTP configuration tests resulting in command execution. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"smtpTest\", the function   will be called. This function is responsible for testing the parameters to be used for sending e-mails. The function extracts the parameters for \"smtpServer\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\", \"sender\" and forwards them via IPC by calling  , using the code 0x6069 at [10]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x6069 is in the \"devMng\" binary and is done by the function   at address 0x159e4. This function extracts the product model of the camera and replies to the message with this information. The reply is handled back in the \"webService\" binary by the function   at address 0x16474. This function parses the numeric function arguments ([11] \"port\", \"isNeedAuth\", etc.) and calls  . The function   receives 9 parameters: \"C1\" (the product model), \"smtpServer\", \"sender\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\" and a pointer to a 128 bytes stack variable. First the function checks if the parameters are non-null, then parses the SMTP server [12], creates the subject of the mail using   [13] and calls   [14]. This function takes care of checking again that the parameters are valid by comparing them with null. Then it proceeds to copying the SMTP username and password in local variables [15] [16], and extracting at most 4 recipients from the comma-separated list provided from the user using the \"sender\" parameter [17]. Note that   also allows \";\" and \" \" as separators. Parameters are then collected and passed to the function   [18].  takes care of creating \"msmtprc\" configuration file and populates it with the user-supplied parameters. The execution continues with encoding the mail subject [19], preparing a \"/tmp/.mail\" file containing the mail contents [20], concatenating the previously extracted recipients and removing any old \"/tmp/.msmtp.log\" log file [21]. A command string is then built using   [23], resulting in \"cat /tmp/.mail | msmtp mailaddr &\" where \"mailaddr\" is the user-supplied \"sender\" parameter [22], which was not previously sanitized. The resulting string is then passed as an argument to   at [24]. This vulnerability is reachable by the \"smtpTest\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-25 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0347');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (333, 'Foscam IP Video Camera CGIProxy.fcgi FTP Startup Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP  request can allow for a user to inject arbitrary shell characters resulting in command injection during the boot process. To trigger this vulnerability, an attacker needs to send an HTTP request and reboot the device. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. The \"webService\" binary is launched on device boot and takes care of starting several other executables, e.g. the HTTP daemon, and it takes care of configuring the FTP server. Before calling  , the dynamic linker calls all the functions defined in the  , one after the other. \"webService\" contains 35 different initialization functions: this advisory describes a vulnerable path in the function   [1].  takes care of initializing several objects that will be used in the future and starts several threads to handle the communication with other applications running on the device. It also loads the user accounts [2] and configures the FTP server [3].  calls two functions: one for reading the configuration file (which only contains the FTP port number) [4], and one which configures the FTP database with existing user accounts [5]. This last one is the vulnerable function.  first calls [6] for loading user accounts from \"/mnt/mtd/app/config/UserAccountConfig.bin\". It then loops [7] over each account and checks for the privilege level. If the privilege is 2 [8], the service will build a format string using \"sh /usr/bin/ftpd/configFTP.sh 1 %s %s\" [9] and the username [10] and password [11] pair, without sanitizing the parameters. Once this is done, the string will be passed to the   call at [12]. Due to the service not enforcing any restrictions on the character set, this can allow an attacker to inject arbitrary characters that may be interpreted by the Bourne shell which can allow for one to execute arbitrary commands. This vulnerability is reachable during the boot process. To trigger it, a command injection must be placed either in the username or in password field of the account. This can be done by the \"changePassword\" command, which requires a valid user account to change the password for: The device should then be rebooted using other means, and the command will be executed upon boot.\nNote that any command that alters username and password can be used, for example the \"addAccount\" command. 2017-05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0334');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (334, 'Foscam IP Video Camera CGIProxy.fcgi SMTP Test Sender Parameter Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary data in the \"msmtprc\" configuration file resulting in command execution. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-77 - Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"smtpTest\", the function   will be called. This function is responsible for testing the parameters to be used for sending e-mails. The function extracts the parameters for \"smtpServer\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\", \"sender\" and forwards them via IPC by calling  , using the code 0x6069 at [10]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x6069 is in the \"devMng\" binary and is done by the function   at address 0x159e4. This function extracts the product model of the camera and replies to the message with this information. The reply is handled back in the \"webService\" binary by the function   at address 0x16474. This function parses the numeric function arguments ([11] \"port\", \"isNeedAuth\", etc.) and calls  . The function   receives 9 parameters: \"C1\" (the product model), \"smtpServer\", \"sender\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\" and a pointer to a 128 bytes stack variable. First the function checks if the parameters are non-null, then parses the SMTP server [12], creates the subject of the mail using   [13] and calls   [14]. This function takes care of checking again that the parameters are valid by comparing them with null. Then it proceeds to copying the SMTP username and password in local variables [15] [16], and extracting at most 4 recipients from the comma-separated list provided from the user using the \"sender\" parameter [17]. Note that   also allows \";\" and \" \" as separators. Parameters are then collected and passed to the function   [18].  simply opens a file in \"/usr/local/etc/msmtprc\" and populates it with the \"msmtp\" configuration, by adding user-supplied strings like \"host\", \"port\", \"from\", \"user\", \"password\" [19]. The \"sender\" parameter is written without any sanitization on the \"from \" line of the file. Back into the parent function, the execution continues with encoding the mail subject [20], preparing a \"/tmp/.mail\" file containing the mail contents [21], concatenating the previously extracted recipients, removing any old \"/tmp/.msmtp.log\" log file [22] and calling \"msmtp\" using   at [23]. Once \"msmtp\" loads, it reads the configuration file and sends the mail accordingly. In the \"msmtprc\" file exists an option that allows for executing a command for decrypting the password before sending a mail. From  : An attacker able to arbitrarily inject new lines in \"msmtprc\" can leverage this functionality to execute arbitrary commands. This vulnerability is reachable by the \"smtpTest\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-25 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0346');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (335, 'Foscam IP Video Camera CGIProxy.fcgi Account Deletion Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during a password change resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"delAccount\", the function   will be called. This function is responsible for deleting a user account both from the users database and from FTP database if the account to be deleted has privilege 2. At the beginning of the function, the parameters for \"usrName\" [10] and \"callbackJson\" [11] are extracted from the query. Afterwards, the \"usrName\" parameter will be passed as an argument to the function call at [12]. The function   is responsible for doing a few comparisons and then making a call to system which deletes the FTP account. First, it verifies that the account name that was provided as an argument already exists and that the privilege for that account is 2 [13]. If so, the service will build a format string using \"sh /usr/bin/ftpd/configFTP.sh 2 %s\" and the username [14]. The resulting string will be executed by the system call at [15]. Due to the service not enforcing any restrictions on the character set, this can allow an attacker to inject arbitrary characters that may be interpreted by the Bourne shell which can allow for one to execute arbitrary commands. This vulnerability is reachable by the \"delAccount\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to use \"addAccount\" to add a user with the command injection payload in the username field, and afterwards trigger the vulnerability deleting the same account: 2017-05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0335');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (336, 'Foscam IP Video Camera CGIProxy.fcgi Message 0x3001 Directory Traversal Vulnerability', 'None', '2017-6-19', 'An exploitable directory traversal vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can cause the application to read a file from disk but a failulre to adequately filter characters results in allowing an attacker to specify a file outside of a directory. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 7.7 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N CWE-22: Improper Limitation of a Pathname to a Restricted Directory (\'Path Traversal\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that was forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query off to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will then be passed to the function call at [7] in order to determine the correct command function which is to be stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"usrBeatHeart\" command, the function pointer for the function at 0x40ac0 will be called. This will extract the \"usrName\", \"remoteIp\", \"groupId\", and \"callbackJson\" parameters from the user\'s query and then log a heartbeat command. After this is done, the service will dispatch to the handler for message code 0x3001 at [10]. There are other ways to reach the path required for the vulnerability, but this specific path was discovered by the author to be the most straightforward. The handler for message code 0x3001 is located back within the \"CGIProxy.fcgi\" service within a function called  . This function does a number of things after first determining what the request type was [11]. If the request was a GET request, then the branch at [12] will be skipped and execution will continue. At [13], the function will then search the request for the string \"magic1234567890ABCDfileName>\". This search is intended to find the content of an element named \"\" in order to extract the filename. After determining the beginning of the element, the function will then execute the following code which will first find the terminating element at [14], and then extract its contents at [15]. Once this is performed, the function will then use   at [16] to build a path to a file relative to \"/tmp/www/snapPic/\". This code does not do anything to strip out characters that may be used to traverse outside of the specified directory. After building the path, the service will open up the file at [17], and then make a call to   in order to determine the size of the file [18]. Once this is done, the function will then allocate space on the heap [19] in order to read the contents of the file into. At [20], the application will then read the contents of the file into the allocated heap buffer. After reading the file into the heap buffer in  , the function will then proceed to build the http response headers in order to return the file back to the user. First the function will build the \"Content-Type:\" header at [21]. Afterwards, it will use the file size that was read earlier at [22] to build the \"Content-Length:\" header. Once that is all complete, the function will finally output the contents of the heap buffer which contains the contents of the specified file back to the user at [23]. It was discovered that this vulnerability is reachable through the \"usrBeatHeart\" command due to the service passing the query parameters to the dispatcher for the message code 0x3001. The following request retrieves an arbitrary file from the device: 2016-05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0330');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (337, 'Foscam IP Video Camera CGIProxy.fcgi Account Password Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during a password change resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"changePassword\", the function   will be called. This function is responsible for allowing a user to change their password and is accessible by users with an access level of 2. At the beginning of the function, the parameters for \"usrName\" [10], \"oldPwd\" [11], \"newPwd\" [12], \"usr\" [13], and \"callbackJson\" [14] are extracted from the query. At [15], the \"usr\" parameter will then be checked to ensure that the account already exists. Afterwards, the \"usrName\" parameter will be passed as an argument along with the old password and the new password to the function call at [16]. The function   is responsible for doing a few comparisons and then making a call to system which changes the password. After verifying that the account name that was provided as an argument already exists, the function will then check to see that the old password matches the original one for the account at [17]. If so, the function will then build the string that is to be passed to the command [18] using a format string built with  . The format string that\'s used is \"sh /usr/bin/ftpd/configFTP.sh 3 %s %s\". Once the format string is successfully built, then the function will check to see if there\'s a \";\" character within the provided password [19]. If there are no invalid characters within the password, then the format string will be executed by the system call at [20]. Due to the service failing to check for other characters interpreted by the Bourne shell, an attacker may inject arbitrary characters that will allow one to specify arbitrary commands that may be interpreted by the shell. This vulnerability is reachable by the \"changePassword\" command and requires a valid user account to change the password for. This can be done with the following curl request: 2017–05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0329');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (338, 'Foscam IP Video Camera CGIProxy.fcgi Gateway Address Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during manual network configuration resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an HTTP request that\'s forwarded from the HTTP daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"setIpInfo\", the function   will be called. This function is responsible for setting up the interface either via dhcp or by manually setting an IP address, netmask, gateway and dns. At the beginning of the function, the parameters [10] for \"callbackJson\", \"isDHCP\", \"ip\", \"gate\", \"mask\", \"dns1\", \"dns2\" are extracted from the query.\nAfterwards, the \"isDHCP\" value [11] is checked against 0 and if it is, the the \"ip\" and \"mask\" parameter values are passed to the function   [12] to be parsed using  : 0 is returned if parameters are correctly parsed, -1 otherwise. The return value is passed via IPC via code 0x3001 [13], which is handled by the binary \"CGIProxy.fcgi\" and takes care of returning the error code as result of the operation.\nRegardless the \"ip\" and \"mask\" parameters were parsed correctly or not, the execution will continue and another message is sent with code 0x601d via IPC [14]. Code 0x601d is handled in the \"devMng\" binary by the function  . The function extracts \"isDHCP\", ip\", \"mask\", \"gate\", \"dns1\" and \"dns2\" parameters from the IPC call and passes them to the function   [15].\nThis function checks a global variable for the state of the operation. In this first call, the branch is not taken and the function will only call   [17], which saves all the parameters in \"/mnt/mtd/app/config/NetworkConfig.bin\". Parameters are also saved in a global structure, to allow access from concurring threads.\nIf no errors are returned,   will call   [19] by passing the pointer to a global structure [18]. Purpose of this function is to flag the completion of the interfaces configuration by putting \"1\" into the structure, at 0x8822c [20]. The application creates 13 threads in total at startup. One of them is continuously polling for network changes:  . Two functions are called in a loop: one for softAP configuration [21] and one for wifi and ethernet connections [22]. We will explore the latter.  is the function that actually checks for the value of the global variable at 0x8822c [23]. As soon as its value is not 0, the function   is called. At this point the execution will continue with many different calls, from a higher level perspective the following is the path that will be taken, stripped to only interesting the stubs (capital names are user-controlled strings): Function   fetches the parameters from a global structure and passes them to  .\nFunction   was already called before, but this time the global state is different. The function thus takes a different branch and the actual interface configuration takes place. User-supplied parameters are taken unmodified from a global structure.\nIn this function the gateway parameter [24] is never sanitized and used in a   [25] call to build the final command that will be passed to   [26]. This vulnerability is reachable by the \"setIpInfo\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-30 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0348');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (339, 'Foscam IP Video Camera CGIProxy.fcgi DNS2 Address Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during manual network configuration resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an HTTP request that\'s forwarded from the HTTP daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"setIpInfo\", the function   will be called. This function is responsible for setting up the interface either via dhcp or by manually setting an IP address, netmask, gateway and dns. At the beginning of the function, the parameters [10] for \"callbackJson\", \"isDHCP\", \"ip\", \"gate\", \"mask\", \"dns1\", \"dns2\" are extracted from the query.\nAfterwards, the \"isDHCP\" value [11] is checked against 0 and if it is, the the \"ip\" and \"mask\" parameter values are passed to the function   [12] to be parsed using  : 0 is returned if parameters are correctly parsed, -1 otherwise. The return value is passed via IPC via code 0x3001 [13], which is handled by the binary \"CGIProxy.fcgi\" and takes care of returning the error code as result of the operation.\nRegardless the \"ip\" and \"mask\" parameters were parsed correctly or not, the execution will continue and another message is sent with code 0x601d via IPC [14]. Code 0x601d is handled in the \"devMng\" binary by the function  . The function extracts \"isDHCP\", ip\", \"mask\", \"gate\", \"dns1\" and \"dns2\" parameters from the IPC call and passes them to the function   [15].\nThis function checks a global variable for the state of the operation. In this first call, the branch is not taken and the function will only call   [17], which saves all the parameters in \"/mnt/mtd/app/config/NetworkConfig.bin\". Parameters are also saved in a global structure, to allow access from concurring threads.\nIf no errors are returned,   will call   [19] by passing the pointer to a global structure [18]. The purpose of this function is to flag the completion of the interfaces configuration by putting \"1\" into the structure, at 0x8822c [20]. The application creates 13 threads in total at startup. One of them is continuously polling for network changes:  . Two functions are called in a loop: one for softAP configuration [21] and one for wifi and ethernet connections [22]. We will explore the latter.  is the function that actually checks for the value of the global variable at 0x8822c [23]. As soon as its value is not 0, the function   is called. At this point the execution will continue with many different calls, from a higher level perspective the following is the path that will be taken, stripped to only interesting the stubs (capital names are user-controlled strings): Function   fetches the parameters from a global structure and passes them to  .\nFunction   was already called before, but this time the global state is different. The function thus takes a different branch and the actual interface configuration takes place. User-supplied parameters are taken unmodified from a global structure.\nIn this function the dns2 parameter [24] is never sanitized and used in a   [25] call to build the final command that will be passed to   [26]. This vulnerability is reachable by the \"setIpInfo\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-30 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0350');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (340, 'Foscam IP Video Camera CGIProxy.fcgi NTP Server Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during NTP server configuration resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"setSystemTime\", the function   will be called. This function is responsible for configuring an NTP server, timezone and time of the system. The function accepts many arguments, but the only two we are interested in are \"timeSource\" [10] and \"ntpServer\" [11]. These parameters are stored unaltered on the stack, while the remaining parameters (hours, minutes, seconds, etc.) and converted using   before being stored on the stack. The function will then pass the parameters by sending a pointer to the stack [12] via  , using code 0x6034 [13]. Code 0x6034 is handled in the binary \"devMng\" by the function  .\nThis function first uses   to send a message with code 0x1009 [13], which will call   in the   binary. This is used for resetting the watchdog before changing the system time.\nTime parameters, previously converted to numbers using  , are passed to   [14], which uses   and a call to \"rtctool\" via   to set the system time.\nFinally   is called by passing   [15] as first parameter: this is the pointer to a global structure shared between threads. Second and third parameters are respectively \"timeSource\" [16] and \"ntpServer\" [17]. At the beginning of  , the value of \"timeSource\" is stored in  +4 [18] and the value of \"ntpServer\" is stored in  +8 [19].\nThe execution then continues by calling  , which saves the parameters in a configuration file with name \"/mnt/mtd/app/config/SystemTimeConfig.xml\". The application creates 13 threads in total at startup. One of them runs the function   which is continuously looping and calling   [20], until a termination is requested using a global flag in the structure   [21]. This structure is defined earlier on thread creation and it\'s pointed by  . Function   is in charge of actually setting up the NTP server address and only receives the pointer to the structure   as parameter [22].\nAt the beginning   [23] is checked, and if it\'s 0,   [24] is checked whether it\'s null or not. If not,   is compared against the string \"Auto\" [25]. If the string doesn\'t match it means that a custom NTP server was supplied and the   value is then used in a   call [26] to build the command that will be executed via   [27]. Until this point the user-supplied   parameter has never been sanitized. This vulnerability is reachable by the \"setSystemTime\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-30 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0351');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (341, 'Foscam IP Video Camera WebService CGI Parameter Code Execution Vulnerability', 'None', '2017-6-19', 'An exploitable stack-based buffer overflow vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera. A specially crafted http request can cause a stack-based buffer overflow resulting in overwriting arbitrary data on the stack frame. An attacker can simply send an http request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query off to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for the code 0x4001 is located within the \"webService\" process. This is performed by the function at offset 0x1e488,  . Inside this function, the service will call a function that\'s responsible for authenticating the command specified by the user [6]. Once called, the service will initialize a number of variables on the stack. Each variable will be initialized as a 64 byte buffer. The   variable will be initialized at [7],   at [8], and finally   at [9]. Following the initialization of these variables, the service will then search through the user\'s query for their respective parameters. This is done by the following code. Each of the functions at [10] will forward to a stub which will call a function [11] to extract the specified value from the query and write it into the buffer. At [11], the service will use the same function to extract the value from the \"remoteIp=\" parameter and write it into a buffer on the stack. Inside the function  , the service will search through the query passed in   for the key specified in  . Once found, the function will write the value into the target buffer specified in  . First the function will check to see that these query and key parameters are valid by comparing them against NULL at [12]. If this is the case, then the service will search for the key that was specified in  . This will return an index which will be used in the loop at [13]. This loop will copy each byte from the query at [14] until an \'&\' byte is found or the end of the query string is reached. Due to this loop explicitly trusting the length of the query during a copy and the function not being informed of the maximum length of the destination buffer as defined by the caller, this loop can be made to write outside the bounds of the buffer passed as an argument. The stack frame of the caller allocates 0x40 bytes for each parameter that is to be fetched. If the   parameter is overflowed, this would require 0x64 bytes to overwrite the saved link-register that is stored on the stack. To trigger this request, this can be done with the combination of command line HTTP client and Perl for generating each buffer. Each variable is being allocated with 0x40 bytes, so any value larger than this will overflow each buffer. The following command should trigger the vulnerability by overflowing the \"usr=\" parameter with 0x40 \'A\' bytes followed by 0x4 \'B\' bytes for the \"funcptr\" variable, 0x1C \'C\' bytes for the frame, and then a 32-bit word for the link register. The address specified here should cleanly reboot the device. 2017-03-28 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0299');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (342, 'Foscam IP Video Camera CGIProxy.fcgi Message 0x3001 Multi-part Form Boundary Code Execution Vulnerability', 'None', '2017-6-19', 'An exploitable buffer overflow vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can cause a buffer overflow resulting in overwriting arbitrary data. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.1 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H CWE-121: Stack-based Buffer Overflow Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the arm architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query off to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is within the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will then be passed to the function call at [7] in order to determine the correct command function which will be stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"usrBeatHeart\" command, the function pointer for the function at 0x40ac0 will be called. This will extract the \"usrName\", \"remoteIp\", \"groupId\", and \"callbackJson\" parameters from the user\'s query and then log a heartbeat command. After this is done, the service will dispatch to the handler for message code 0x3001 at [10]. There are other ways to reach the overflow described in this advisory. However, this was discovered by the author to be the shortest path. The handler for message code 0x3001 is located back within the \"CGIProxy.fcgi\" service within a function called  . This function does a number of things after first determining what the request type was [11]. If the request was anything other than a GET request, then the branch at [12] will be taken. The next branch will then check if the request was a POST at [13] and continue execution if so. After determining the request type, the request\'s content will be searched for the string \"\" and then execute the following code. The function call at [14] will then proceed to process the content that was included with the request. At the beginning of the function  , the content-length will be checked to see if it is valid by checking that it\'s less than 0x80000 bytes, 0xe00000 bytes, and then 0x1000000 bytes. Finally the content-type from the request will be fetched at [15]. Once comparing that the content type is of \"multipart/form-data\" [16], the function will proceed to extract the multipart boundary at [17]. After locating the string from the request that contains the boundary, this string will be copied into a buffer on the stack at [18]. This buffer is 0x100 bytes in size, and only 0x122 bytes from the saved link-register on the stack. If the value of the boundary string is larger than 0x100, then the buffer is being overflown. To trigger this request, this can be done with the combination of command line http client and Perl for generating the buffer. The following commands should trigger the vulnerability. Although the buffer size that is being overflown is 0x100 bytes, this proof-of-concept overflows 0x122 bytes in order to overwrite the saved link-register at the top of the frame. A valid username ( ) and password ( ) must be chosen. 2017-05-08 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0331');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (343, 'Foscam IP Video Camera CGIProxy.fcgi Change Username pureftpd.passwd Injection Vulnerability', 'None', '2017-6-19', 'An exploitable injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary characters in the pureftpd.passwd file during a username change, which in turn allows for bypassing chroot restrictions in the FTP server. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component (\'Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"changeUserName\", the function   will be called. This function is responsible for changing the username of an existing user account. At the beginning of the function, the parameters [10] for \"usrName\", \"newUsrName\", \"usr\", and \"callbackJson\" are extracted from the query.\nThe function then checks that the user (given by the \"usr\" parameter) either has privilege 2 [11] (i.e. administrator) or that the account that he\'s changing the username for is his [12]. This last check is useless since this command is only allowed for users with privilege 2.\nFinally it checks that the \"usrName\" [13] and \"newUsrName\" [14] parameters are not null and passes them to the   function [15].  first checks that \"newUsrName\" doesn\'t already exists [16] and that \"usrName\" exists [17], using a loop over the user-account object that was passed via  . Then the new username is saved in the file \"/mnt/mtd/app/config/UserAccountConfig.bin\" [18]. The last operation needed to successfully update the username is an update of the FTP database. To do this, the function first ensures that the user\'s privilege is 2, then it opens the \"pureftpd.passwd\" [20] and reads its whole content in a local variable [21].\nThen the username line of interest is searched with   [22] using \"\\n%s\", where \"%s\" is the old username that has to be changed. The pointer to the old username is saved in   [23], and the \"passwd\" contents are split before   [24] by copying the preceding contents in a buffer [25]. The function then searches for \":\" [26] (i.e. the pointer to the rest of the file after the old user name). The new \"passwd\" file is then rebuilt using   [27] and concatenating the buffer [25], the new username and the contents after the old username [26].\nFinally the \"pure-pw mkdb\" [28] command is ran to apply the database modifications without restarting the FTP daemon.\nUp until this point no checks are performed on the contents of the \"newUsrName\" parameter, which allows for arbitrarily injecting any characters in the \"pureftpd.passwd\" file. By injecting the character \":\" it\'s possible to add new fields to a line in the \"passwd\" file. This allows for modifying the uid, gid and directory used for chroot.\nNevertheless, when using the \"puredb\" authentication method, \"pure-ftpd\" doesn\'t allow to log-in using uid 0, so the uid with highest privilege that can be used in this injection is 1000.\nBy default the uid set for ftp users is 1001, which only has permission to write inside \"/mnt/sd\". Whereas users with uid 1000 have permission to write almost anywhere in the filesystem. This can be leveraged by an attacker to escalate privileges to root. This vulnerability is reachable by the \"changeUserName\" command and requires a valid user account with privilege level 2. For clarity, the following proof-of-concept adds a new account with privilege level 2 before exploiting the vulnerability. By exploiting the fact that in this device many processes running as \"root\" use the   function, it\'s possible to escalate privileges by overwriting \"/bin/sh\" with a simple wrapper: 2017-05-30 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0352');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (344, 'Foscam IP Video Camera CGIProxy.fcgi DNS1 Address Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary shell characters during manual network configuration resulting in command injection. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-78: Improper Neutralization of Special Elements used in an OS Command (\'OS Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an HTTP request that\'s forwarded from the HTTP daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"setIpInfo\", the function   will be called. This function is responsible for setting up the interface either via dhcp or by manually setting an IP address, netmask, gateway and dns. At the beginning of the function, the parameters [10] for \"callbackJson\", \"isDHCP\", \"ip\", \"gate\", \"mask\", \"dns1\", \"dns2\" are extracted from the query.\nAfterwards, the \"isDHCP\" value [11] is checked against 0 and if it is, the the \"ip\" and \"mask\" parameter values are passed to the function   [12] to be parsed using  : 0 is returned if parameters are correctly parsed, -1 otherwise. The return value is passed via IPC via code 0x3001 [13], which is handled by the binary \"CGIProxy.fcgi\" and takes care of returning the error code as result of the operation.\nRegardless the \"ip\" and \"mask\" parameters were parsed correctly or not, the execution will continue and another message is sent with code 0x601d via IPC [14]. Code 0x601d is handled in the \"devMng\" binary by the function  . The function extracts \"isDHCP\", ip\", \"mask\", \"gate\", \"dns1\" and \"dns2\" parameters from the IPC call and passes them to the function   [15].\nThis function checks a global variable for the state of the operation. In this first call, the branch is not taken and the function will only call   [17], which saves all the parameters in \"/mnt/mtd/app/config/NetworkConfig.bin\". Parameters are also saved in a global structure, to allow access from concurring threads.\nIf no errors are returned,   will call   [19] by passing the pointer to a global structure [18]. The purpose of this function is to flag the completion of the interfaces configuration by putting \"1\" into the structure, at 0x8822c [20]. The application creates 13 threads in total at startup. One of them is continuously polling for network changes:  . Two functions are called in a loop: one for softAP configuration [21] and one for wifi and ethernet connections [22]. We will explore the latter.  is the function that actually checks for the value of the global variable at 0x8822c [23]. As soon as its value is not 0, the function   is called. At this point the execution will continue with many different calls, from a higher level perspective the following is the path that will be taken, stripped to only interesting the stubs (capital names are user-controlled strings): Function   fetches the parameters from a global structure and passes them to  .\nFunction   was already called before, but this time the global state is different. The function thus takes a different branch and the actual interface configuration takes place. User-supplied parameters are taken unmodified from a global structure.\nIn this function the dns1 parameter [24] is never sanitized and used in a   [25] call to build the final command that will be passed to   [26]. This vulnerability is reachable by the \"setIpInfo\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-30 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0349');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (345, 'Foscam IP Video Camera CGIProxy.fcgi SMTP Test Host Parameter Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary data in the \"msmtprc\" configuration file resulting in command execution. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-77 - Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an HTTP request that\'s forwarded from the HTTP daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"smtpTest\", the function   will be called. This function is responsible for testing the parameters to be used for sending e-mails. The function extracts the parameters for \"smtpServer\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\", \"sender\" and forwards them via IPC by calling  , using the code 0x6069 at [10]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x6069 is in the \"devMng\" binary and is done by the function   at address 0x159e4. This function extracts the product model of the camera and replies to the message with this information. The reply is handled back in the \"webService\" binary by the function   at address 0x16474. This function parses the numeric function arguments ([11] \"port\", \"isNeedAuth\", etc.) and calls  . The function   receives 9 parameters: \"C1\" (the product model), \"smtpServer\", \"sender\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\" and a pointer to a 128 bytes stack variable. First the function checks if the parameters are non-null, then parses the SMTP server [12], creates the subject of the mail using   [13] and calls   [14]. This function takes care of checking again that the parameters are valid by comparing them with null. Then it proceeds to copying the SMTP username and password in local variables [15] [16], and extracting at most 4 recipients from the comma-separated list provided from the user using the \"sender\" parameter [17]. Note that   also allows \";\" and \" \" as separators. Parameters are then collected and passed to the function   [18].  simply opens a file in \"/usr/local/etc/msmtprc\" and populates it with the \"msmtp\" configuration, by adding user-supplied strings like \"host\", \"port\", \"from\", \"user\", \"password\" [19]. The \"smtpServer\" parameter is written without any sanitization on the \"host \" line of the file. Back into the parent function, the execution continues with encoding the mail subject [20], preparing a \"/tmp/.mail\" file containing the mail contents [21], concatenating the previously extracted recipients, removing any old \"/tmp/.msmtp.log\" log file [22] and calling \"msmtp\" using   at [23]. Once \"msmtp\" loads, it reads the configuration file and sends the mail accordingly. In the \"msmtprc\" file exists an option that allows for executing a command for decrypting the password before sending a mail. From  : An attacker able to arbitrarily inject new lines in \"msmtprc\" can leverage this functionality to execute arbitrary commands. This vulnerability is reachable by the \"smtpTest\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-25 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0343');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (346, 'Foscam IP Video Camera CGIProxy.fcgi SMTP Test User Parameter Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary data in the \"msmtprc\" configuration file resulting in command execution. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-77 - Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"smtpTest\", the function   will be called. This function is responsible for testing the parameters to be used for sending e-mails. The function extracts the parameters for \"smtpServer\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\", \"sender\" and forwards them via IPC by calling  , using the code 0x6069 at [10]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x6069 is in the \"devMng\" binary and is done by the function   at address 0x159e4. This function extracts the product model of the camera and replies to the message with this information. The reply is handled back in the \"webService\" binary by the function   at address 0x16474. This function parses the numeric function arguments ([11] \"port\", \"isNeedAuth\", etc.) and calls  . The function   receives 9 parameters: \"C1\" (the product model), \"smtpServer\", \"sender\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\" and a pointer to a 128 bytes stack variable. First the function checks if the parameters are non-null, then parses the SMTP server [12], creates the subject of the mail using   [13] and calls   [14]. This function takes care of checking again that the parameters are valid by comparing them with null. Then it proceeds to copying the SMTP username and password in local variables [15] [16], and extracting at most 4 recipients from the comma-separated list provided from the user using the \"sender\" parameter [17]. Note that   also allows \";\" and \" \" as separators. Parameters are then collected and passed to the function   [18].  simply opens a file in \"/usr/local/etc/msmtprc\" and populates it with the \"msmtp\" configuration, by adding user-supplied strings like \"host\", \"port\", \"from\", \"user\", \"password\" [19]. The \"user\" parameter is written without any sanitization on the \"user \" line of the file. Back into the parent function, the execution continues with encoding the mail subject [20], preparing a \"/tmp/.mail\" file containing the mail contents [21], concatenating the previously extracted recipients, removing any old \"/tmp/.msmtp.log\" log file [22] and calling \"msmtp\" using   at [23]. Once \"msmtp\" loads, it reads the configuration file and sends the mail accordingly. In the \"msmtprc\" file exists an option that allows for executing a command for decrypting the password before sending a mail. From  : An attacker able to arbitrarily inject new lines in \"msmtprc\" can leverage this functionality to execute arbitrary commands. This vulnerability is reachable by the \"smtpTest\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-25 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0344');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (347, 'Foscam IP Video Camera CGIProxy.fcgi SMTP Test Password Parameter Configuration Command Injection Vulnerability', 'None', '2017-6-19', 'An exploitable command injection vulnerability exists in the web management interface used by the Foscam C1 Indoor HD Camera running application firmware 2.52.2.37. A specially crafted HTTP request can allow for a user to inject arbitrary data in the \"msmtprc\" configuration file resulting in command execution. An attacker can simply send an HTTP request to the device to trigger this vulnerability. Foscam, Inc. Indoor IP Camera C1 Series 8.8 - CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-77 - Improper Neutralization of Special Elements used in a Command (\'Command Injection\') Foscam produces a series of IP-capable surveillance devices, network video recorders, and baby monitors for the end-user. Foscam produces a range of cameras for both indoor and outdoor use and with wireless capability. One of these models is the C1 series which contains a web-based user interface for management and is based on the ARM architecture. Foscam is considered one of the most common security cameras out on the current market. When various services are started, a service will first register a callback using the   function [1]. This will register a function to be called [2] when another service dispatches a message of the specified code [3]. An example of this registration process is handled inside the   function of the \"CGIProxy.fcgi\" service using the following code: After the \"CGIProxy.fcgi\" service decodes an http request that\'s forwarded from the http daemon, the service will copy the decoded query into a buffer on the stack [4]. Once this is done, the buffer will then be used to pass the decoded query to  . This will dispatch the query to the shared messaging subsystem using the code 0x4001 at [5]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x4001 is in the \"webService\" binary and is done by the function   at address 0x1e5a4. At the beginning of this function, the service will call a function [6] that\'s responsible for extracting the user name, password, and command that was specified within the user\'s query. Once the parameters have been extracted and copied into a local buffer on the stack, the command will be passed to the function call at [7] in order to determine the correct command function which is stored to  . If authentication is not required for the command, then the branch at [8] will execute the function pointer returned by   at [7]. If authentication is required from the command, then the user name and password will be checked via   and then the function call at [9] will execute the function pointer. When handling the \"CGIProxy.fcgi\" command \"smtpTest\", the function   will be called. This function is responsible for testing the parameters to be used for sending e-mails. The function extracts the parameters for \"smtpServer\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\", \"sender\" and forwards them via IPC by calling  , using the code 0x6069 at [10]. At this point, the service that handles the specified code will be woken up to handle the specified request. The handler for code 0x6069 is in the \"devMng\" binary and is done by the function   at address 0x159e4. This function extracts the product model of the camera and replies to the message with this information. The reply is handled back in the \"webService\" binary by the function   at address 0x16474. This function parses the numeric function arguments ([11] \"port\", \"isNeedAuth\", etc.) and calls  . The function   receives 9 parameters: \"C1\" (the product model), \"smtpServer\", \"sender\", \"port\", \"isNeedAuth\", \"tls\", \"user\", \"password\" and a pointer to a 128 bytes stack variable. First the function checks if the parameters are non-null, then parses the SMTP server [12], creates the subject of the mail using   [13] and calls   [14]. This function takes care of checking again that the parameters are valid by comparing them with null. Then it proceeds to copying the SMTP username and password in local variables [15] [16], and extracting at most 4 recipients from the comma-separated list provided from the user using the \"sender\" parameter [17]. Note that   also allows \";\" and \" \" as separators. Parameters are then collected and passed to the function   [18].  simply opens a file in \"/usr/local/etc/msmtprc\" and populates it with the \"msmtp\" configuration, by adding user-supplied strings like \"host\", \"port\", \"from\", \"user\", \"password\" [19]. The \"password\" parameter is written without any sanitization on the \"password \" line of the file. Back into the parent function, the execution continues with encoding the mail subject [20], preparing a \"/tmp/.mail\" file containing the mail contents [21], concatenating the previously extracted recipients, removing any old \"/tmp/.msmtp.log\" log file [22] and calling \"msmtp\" using   at [23]. Once \"msmtp\" loads, it reads the configuration file and sends the mail accordingly. In the \"msmtprc\" file exists an option that allows for executing a command for decrypting the password before sending a mail. From  : An attacker able to arbitrarily inject new lines in \"msmtprc\" can leverage this functionality to execute arbitrary commands. This vulnerability is reachable by the \"smtpTest\" command and requires a valid user account with administrator privileges. The following proof of concept shows how to execute an arbitrary command. 2017-05-25 - Vendor Disclosure \n2017-06-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0345');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (348, 'Tablib Yaml Load Code Execution Vulnerability', 'None', '2017-6-13', 'An exploitable vulnerability exists in the Databook loading functionality of Tablib. A yaml loaded Databook can execute arbitrary python commands resulting in command execution. An attacker can insert python into loaded yaml to trigger this vulnerability. Tablib v0.11.4 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-502 - Deserialization of Untrusted Data Tablib is a Python dataset library used to agnostically generate various tabular formats from data. Tablib is also the main driver behind django-import-export application and library. Tablib is leveraging the unsafe API   [0] for importing the current yaml stream into to Databook.. This yaml can contain a python directive to execute arbitrary commands. A test leveraging the Tablib API shows the commands being executed: Replace   with  2017-04-18 - Vendor Disclosure \n2017-06-13 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0307');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (349, 'Artifex MuPDf JBIG2 Parser Code Execution Vulnerability', 'None', '2017-5-15', 'An exploitable memory corruption vulnerability exists in the JBIG2 parser of Artifex MuPDF 1.9. A specially crafted PDF can cause a negative number to be passed to a memset resulting in memory corruption and potential code execution. An attacker can specially craft a PDF and send to the victim to trigger this vulnerability. MuPDF 1.9\nMuPDF 1.10 RC2 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow MuPDF is a lightweight PDF, XPS, and E-Book viewer that has packages available for Windows as well as Android, iPad, and iPhone. During the parsing of a JBIG2 image embedded in a PDF, each image segment is handled based on the flags for that particular segment. Segments with flags 38 or 39 are handled by calling   on the current segment [0]. Each segment is lifted into a   object by reading the segment header information. Two key values are extracted during   [1]: width and height [2]. After extracting the width and height from the segment,   is called [3]. A   value is calculated from the width and subsequently checked to ensure a multiplication overflow won\'t occur [4]. Assuming this check is passed, the resulting stride value is stored in an image object and returned. If the   flag is set in the image segment flags, then the resulting image is passed to  . During this decoding, the   value is used directly as the   value in a   [6]. Using the calculation of  , a negative value for   can be achieved. Passing this negative value to   results in a buffer overflow condition that could possibly be leveraged to gain code execution. Dr. Memory output Valgrind output 2016-11-29 - Vendor Disclosure \n2017-05-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0243');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (350, 'MuPDF Fitz library font glyph scaling Code Execution Vulnerability', 'None', '2017-5-15', 'An exploitable heap out of bounds write vulnerability exists in the Fitz graphical library part of the MuPDF renderer. A specially crafted PDF file can cause a out of bounds write resulting in heap metadata and sensitive process memory corruption leading to potential code execution. Victim needs to open the specially crafted file in a vulnerable reader in order to trigger this vulnerability. MuPDF 1.10-rc1 8.6 – CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H MuPDF is a lightweight PDF parsing and rendering library featuring high fidelity graphics, high speed and compact code size which makes it a fairly popular PDF library for embedding in different projects, especially mobile and web applications. Fitz is an underlying graphics library which MuPDF uses to render PDFs and images. There exists an exploitable vulnerability in the glyph scaling code of MuPDF. Specifically, when a font glyph is specified and used in a way where it must be scaled down an invalid pointer arithmetic can result in invalid memory access which can be abused to overwrite sensitive memory. The vulnerability is located in function   in file  : In the above code, at [1] and [2] variables   and   are initialized, at [3] the destination pointer   is increased in relation to   and  . Inside a for loop at [4]   pointer is written to and incremented and finally at [5] it is decremented. The vulnerability can be triggered due to the fact that   in increased   times inside for loop, but decreased by   just outside the for loop. If the outer loop (at [3]) loops more than once,   can start pointing behind it’s original value which leads to adjacent memory overwrite.  With precise control over values of   and  , the pointer can be shifted as desired giving control over which memory gets overwritten. In the following debugging session, we can see the concrete values for   and   from a PoC testcase that results in triggering this vulnerability: Breakpoint 2 is hit, at the beginning of function   and we can see that values of   structure are: Also important is that   is set to 1. In this case,   will be equal to 4, at first   will be increased by  , that is 6, then the loop will loop 4 times, increasing   by 4 for a total of 10. Outside the loop,   will be decreased by   or 8, totaling 2. Next time the inner for loop is hit,   will be increased by 4 times (for 6 total) but will be decreased by 8, therefore accessing the data previous to the original pointer address. This can be observed in the above gdb input by setting a read/write access breakpoint on memory location just before the original pointer. This overwrite results in heap metadata corruption leading to process termination. The data that is being written to an out of bounds location is under indirect control of the attacker. Valgrind output showing the vulnerability being triggered against a sample PDF viewer application  : 2016-11-29 - Vendor Disclosure \n2017-05-15 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0242');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (351, 'Hancom Thinkfree NEO Hangul Word Processor HWPTAG_TAB_DEF Tab Count Code Execution Vulnerability', 'None', '2017-5-12', 'An exploitable heap-based buffer overflow exists in the Hangul Word Processor component (version 9.6.1.4350) of Hancom Thinkfree Office NEO 9.6.1.4902. A specially crafted document stream can cause an integer underflow resulting in a buffer overflow which can lead to code execution under the context of the application. An attacker can entice a user to open up a document in order to trigger this vulnerability. Thinkfree Office NEO Trial Word 9.6.1.4902 \n 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow Thinkfree Office NEO is published by Hancom, Inc. and is considered one of the more popular office suites used within South Korea. Hancom\'s Word Processor utilizes a document format known as the Hangul Word Processing Document (.hwp) which is based on Microsoft\'s Structured Storage document format for encapsulating the different streams used by the document format. When processing an HWPTAG DEF record within the   stream, a signedness vulnerability leading to a heap overflow can be made to occur. The vulnerability occurs when calculating the number of tab definitions to grow an array in order to read data from the file into. If the number of tabs is signed, the application will fail to resize a buffer used to store each tab. Later when the application tries to read data from the file into said buffer, a buffer overflow will occur which will lead to code execution under the context of the application. Hangul Word Processor utilizes the Structured Storage COM format to store the different components needed to describe a document in the Hangul Word Processing format. One of these streams is the   stream which contains a bit mask describing how the document is actually stored. One of these flags specifies that some of the streams are encoded using the LZW algorithm and thus need to be decompressed before processing. After determining whether the document is compressed or not, the application will proceed to process the   stream in order to store the general attributes that exist within the document. Although it is not necessary for this vulnerability, the   stream will contain the actual contents of the document. When processing the   stream, the application will begin by reading a few tags that are typically located near the beginning of the stream. The first tag is named HWPTAG PROPERTIES(16), which has its header read at [1]. Immediately following this, the application will parse the HWPTAG MAPPINGS(17) record at [2] and use a loop to read a list of UINT32s out of the file [3] which are used for mapping identifiers. After parsing the list of ID-mappings, there is one more record which is read known as the HWPTAG DATA(18) record. Before the function call at [5], this record containing binary data is parsed at [4]. Finally at [5] the application calls a function which is used to process the font and tab information for the document. After calling the function at 6b247af0, the application will eventually execute the following function calls. The function call at [1] will be used to enumerate fonts that are on the system according to the list of font names that are specified within the document. These font names are identified by the HWPTAG NAME(19) records. Two more record types are parsed before the record type containing the vulnerability is parsed. These are the HWPTAG FILL(20) record at [2], followed by the HWPTAG SHAPE(21) record at [3]. After the HWPTAG FILL(20) is allocated for and then HWPTAG SHAPE(21) record\'s object is constructed, the function call at [4] will be used to parse the HWPTAG DEF(22) records defined within the document. After parsing HWPTAB DEF(22) records, the HWPTAG_NUMBERING(23) records will also be parsed at [5]. Inside the function 6b248ce0, the application will first calculate the terminator for the loop of HWPTAG DEF(22) records at [1] and then begin to enter the loop [2] in order to process each record. For each record the array that stores it will be grown via the function at [3]. This function will simply re-allocate the array that\'s stored at  . At [4], the application will read the header and contents of each HWPTAG DEF(22) record. For each HWPTAG DEF(22) record in the file, the following function will be executed. When reading each record, its header is first processed at [1]. Each HWPTAG DEF(22) record begins with a UINT32 integer which describes properties of the tab. This is then followed by an integer which is used to contain the number of tabs defined within the record [2]. These tabs are aggregated in a single array which contains all of the tabs within each HWPTAG DEF(22) record within the file. The allocation which grows the array is done by the function call at [3]. Afterwards, the count for the single HWPTAG DEF(22) is multiplied by 8 and then passed to the function call at [4] to actually read each tab defined within the record. When allocating space for the number of tabs, the function call at 6b049893 is made which will check the current size of the tabs array and resize it if necessary. First at [1], the function will check to see if the number of tabs is 0. Next at [2], the application will check to see if the current buffer is unallocated. If so, then an allocation will be made. However, due to an HWPTAG DEF(22) already existing the application will continue executing so that it may layer resize the buffer. At [3], the application will check to see if the number of tabs is larger than the current count. Due to this comparison being signed, the number of tabs will be treated as less than the current count which will cause the application to not resize the buffer at [4]. The function then returns due to the application believing that there is no need to resize the buffer containing each tab. Returning back to the address after 6b049893, the application will then multiply the number of tags that were read by 8 and then pass it as an argument along with the buffer that was not resized to the method call at 6b0498ba in order to read tab data from the file into. Inside the method at 6b398340, the application will pass the destination buffer and its size at [1] to call a function at [2] which uses   to decompress file data into a buffer. To perform this action, the application will enter a loop which will decompress each block from the stream into a buffer and then use   to write data into the undersized buffer described previously [3]. Due to the application failing to resize the buffer due to a signed-ness issue, this   will write outside the bounds of the heap buffer which will lead to a heap-based buffer overflow. The Hangul Word Processor comonent utilizes the Compound Document format that is available via Microsoft\'s API. This file format is documented by Microsoft as part of their Document Interoperability Initiative. The format is similar to the FAT file format and contains a table describing where each file stream is stored within the file. Within each HWP file is a list of streams that are used to describe the document. This vulnerability is based around 2 streams, the   stream and the   stream. Within the   stream is the following 512-byte structure. These fields describe the global format of the document. At the beginning of the stream is a 32-byte signature that contains the string \"HWP Document File\". Immediately following this is the version, which is 0x00000005. At offset 0x24 within the provided proof-of-concept is a 32-bit little-endian field that allows for one to describe whether streams are compressed using the LZW algorithm. If the last bit is set, then this specifies that the streams within the file are compressed with LZW excluding the header and CRC. The other streams within the compound document format contain information about the text within the document. The   stream contains a list of tags which describe the type, length, and value of each record to be applied to the document. Within the provided proof-of-concept, the   stream is LZW compressed and will need to be decompressed in order to view the HWPTAG DEF(22) data structure that is responsible for this vulnerability. The HWPTAG DEF(22) structure that triggers the vulnerability is located at offset 0x5b2 within the decompressed stream. At the beginning of each record is a 32-bit binary structure that describes the size and type of the record.. The first 12 bits describe the size, followed by 10-bits for the level (which is irrelevant to this vulnerability), and then 10 bits for the Identifier. If the size has all 12 of its bits set, a UINT32 that immediately follows will be used as the length. Within the proof-of-concept, the record has a size of 0x18 and an identifier of 0x16. At offset 0x4b2 of the proof-of-concept is the data component of the first record. The HWPTAG DEF(22) describes information about the tab definitions within the document. The 2nd field (an INT32) is used as a count for the number of elements that follow and is multiplied by 8 before being used to allocate space for the tab data. At offset 0x5b6 is the data for the next tab definition which triggers the bug. If this value has its high bit set, then the heap buffer allocated in the previous tab definition will be reused without the array being resized to accommodate the space. In the proof-of-concept, the INT32 for the tab count is set to 0x90000002. The contents that are copied into the heap buffer then begin at offset 0x5be. Do not open HWP documents from untrusted sources. 2017–04-13 - Vendor Disclosure \n2017-05-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0320');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (352, 'PowerIso Parsing Code Execution Vulnerability', 'None', '2017-5-5', 'An stack buffer overflow vulnerability exists in the ISO parsing functionality of Power Software Ltd PowerISO. A specially crafted ISO file can cause a vulnerability resulting in potential code execution. An attacker can send a specific ISO file to trigger this vulnerability. Power Software PowerISO 6.8 (6, 8, 0, 0) 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This vulnerability can be triggered by providing specially crafted ISO file and opening it with the PowerISO software. The vulnerable code is presented below: The   function is used to validate whether the currently processed entry is in fact an \"NM\" entry. After this condition\nis met the   function is executed (0x000258B3) with the dest parameter located on the stack space. The source parameter is taken straight from the malformed .ISO file and the count parameter is calculated from a byte stored in the malformed ISO file.\nBy forcing the byte at [esi+2] (0x000258A3) to be less than 5, an attacker can cause the count value to become negative leading to buffer overflow like presented below: 2017-04-14 - Vendor Disclosure \n2017-05-05 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0318');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (353, 'PowerISO ISO Parsing Use After Free', 'None', '2017-5-5', 'A use-after-free vulnerability exists in the .ISO parsing functionality of PowerISO 6.8. A specially crafted .ISO file can cause a vulnerability resulting in potential code execution. An attacker can send a specific .ISO file to trigger this vulnerability. http://poweriso.com 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This vulnerability can be triggered by providing a specially crafted .ISO file and opening it with PowerISO\nsoftware. The Instruction at 0x0001BD5A loads a pointer to EAX register from a memory region that was already freed\nat this point. This pointer after multiplication at 0x0001BD75 is later used as an operand of\ncall instruction at 0x001BD7A. The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system\'s reuse of the freed memory. 2017-04-26 - Vendor Disclosure \n2017-05-05 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0324');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (354, 'WolfSSL library X509 Certificate Text Parsing Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable off-by-one write vulnerability exists in the x509 certificate parsing functionality of wolfSSL library versions up to 3.10.2. A specially crafted x509 certificate can cause a single out of bounds byte overwrite resulting in potential certificate validation vulnerabilities, denial of service and possible remote code execution. In order to trigger this vulnerability, the attacker needs to supply a malicious x509 certificate to either server or client application using this library. WolfSSL 3.10.2 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-193: Off-by-one Error WolfSSL, previously CyaSSL, is a lightweight SSL/TLS library targeted for embedded and RTOS environments, primarily because of its small size, speed, portability, and feature set. According to the vendor it is used in wide range of products including industrial control systems, IoT devices, VoIP hardware, routers and more. The vulnerability exists in x509 code that deals with string fields in DER certificates. Specifically, when parsing  ,  ,  ,  ,   or   fields, the function   is used. Its prototype is: Its task is to copy the appropriate string from   context into supplied   of length  . The issue happens when the string is longer or equal to length of the allocated buffer. Following code highlights the issue for the case of   field: At [1] and [2],   and   are initialized. At [3] the lesser of the two values   and   is chosen. This value ends up as the size parameter to a   call at [4]. Then, the same value is used as an index to NULL terminate the string at [5]. If the string length is bigger than size of the allocated buffer, NULL termination at index   will cause an off-by-one NULL byte write into adjacent memory variable on the stack or heap, depending on where the buffer was allocated. Depending on the way the library is used, this could lead to further issues when doing certificate validation or potentially result in remote code execution. The vulnerability can be triggered by supplying the attached PoC x509 certificate to the   example app from wolfssl-examples. Address sanitizer output: A certificate that triggers this vulnerability can be generated using the following   command: 2017-03-14 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0293');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (355, 'AntennaHouse DMC HTMLFilter UnCompressUnicode Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the UnCompressUnicode functionality of AntennaHouse DMC HTMLFilter used by MarkLogic 8.0-6. A specially crafted xls file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide malicious XLS file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used, among others, to convert XLS files to (X)HTML form. \nThis product is mainly used by MarkLogic for xls document conversions as part of their web based document search and rendering engine.\nA specially crafted XLS file can lead to heap corruption and ultimately to remote code execution. Let\'s investigate this vulnerability. After execution of the XLS to HTML converter with a malformed XLS file as an input we can easily observe the following when using Valgrind: The out of bounds write occrus in the   function but the buffer which is overflowed is allocated in   and has a size of 65538 bytes.\nLet we investigate   function: As we can see there are a couple allocations made with the aformentioned mentioned size.\nLooking at the call stack where the overflow appears, we see that operations made are related to a string object. Everything becomes clearer when we look at the following code from the   function: This code is responsible for calling the proper object constructor based on the XLS record type.\nSo our buggy code fragment parses an XLS Sring (documented in section 2.4.268 of the Excel Binary Format: https://msdn.microsoft.com/en-us/library/dd923608(v=office.12).aspx). Further investigation reveals that the malformed string\nrecord is located at offset 0x11ED: According to the documentation: The   included in the record is described by section   (https://msdn.microsoft.com/en-us/library/dd922754(v=office.12).aspx). The most important information from there: We see check for the   at line 15. In our case it\'s equal to 0x00. In this case the assumption is that   indicates the number of characters, so it should not exceed 32767 . Where in our case this value is equal to: So nearly two times above the limit. There are no extra checks in the   function: As we can see, due to Unicode conversion, we can write double the size of the buffer into the memory allocated by the InitMem function causing heap corruption which can lead to arbitrary code execution. 2017-02-09 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0285');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (356, 'AntennaHouse DMC HTMLFilter GetIndexArray Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the GetIndexArray functionality of AntennaHouse DMC HTMLFilter as used by MarkLogioc 8.0-6. A specially crafted XLS file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide a malicious XLS file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shiped with MarkLogic 8.0-6\nfb1a22fa08c986ec3614284f4e912b0a  /opt/MarkLogic/Converters/cvtofc/libdhf comm.so\n1eabb31236c675f9856a7d001b339334  /opt/MarkLogic/Converters/cvtofc/libdhf comm.so\n4ae366fbd4540dd4c750e6679eb63dd4  /opt/MarkLogic/Converters/cvtofc/libdmc htmlif.so\nd716dd77c8e9ee88df435e74fad687e6  /opt/MarkLogic/Converters/cvtofc/libdhf_whtml.so\ne01d37392e2b2cea757a52ddb7873515  /opt/MarkLogic/Converters/cvtofc/convert 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This product is mainly used by MarkLogic for office document conversions as part of their web based document search and rendering engine.\nA specially crafted XLS file can lead to heap corruption and can ultimately result in remote code execution. The out-of-bounds write occurs in the   function. Let\'s check the pseudocode of the   function and try to spot the vulnerable code: There are plenty of places where integer overflows can occur, however, looking for write operations, we see the   has the potential to result in an out-of-bounds write.\nThe space for   is allocated at  , based on the mulitplication of   and  . The BlankRec in MS-XLS is: And its location in our PoC is 0x13D1: Where the   structure is : and the location of this structure in the PoC is 0x13BE: In our case the result of the multiplication of   (0x08) and   (0x0E) and adding   (0xFF) to it (0x1006fF) is much bigger than allocated space of   which \nleads to an arbitrary out-of-bounds write. 2017-02-28 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0291');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (357, 'AntennaHouse DMC HTMLFilter Txo Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the Txo functionality of AntennaHouse DMC HTMLFilter as used by MarkLogic 8.0-6. A specially crafted xls file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide malicious XLS file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H This product is mainly used by MarkLogic for office document conversions as part of their web based document search and rendering engine.\nA specially crafted XLS file can lead to an heap corruption and ultimately to remote code execution. The dynamically allocated buffer in the   function is overflowed during a   operation.\nLet\'s check the pseudocode of the   function and try to spot the vulnerable code: We see that allocation for   is made at   based on  . The   where the overflow appears as is at  .\nFrom the Valgrind output we know that the allocation is made for 40 bytes, let\'s figure out what value has the     argument has: Here we can see the value is equal to 0xEC. Is easy to observe that values used for allocation and for memcpy operation are different, plus neither of them are checked. Both values are read directly from the file via  .\nLet\'s see what fields the values are coming from: The raw value of   0x11 (value before multiplication) is coming from offset 0xFB5. The value of the   argument in the memcpy operation is located at offset: 0xFBF . 2017-02-21 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0288');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (358, 'AntennaHouse DMC HTMLFilter PPT DHFSummary Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable stack-based buffer overflow vulnerability exists in the DHFSummary functionality of AntennaHouse DMC HTMLFilter as used by MarkLogic 8.0-6.  A specially crafted PPT file can cause a stack corruption resulting in arbitrary code execution. An attacker can send/provide malicious PPT file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used, among others, to convert PPT files to (X)HTML form. \nThis product is mainly used by MarkLogic for office document conversions as part of their web based document search and rendering engine.\nA specially crafted PPT file can lead to an stack corruption and ultimately to remote code execution. Let\'s investigate this vulnerability. After executing the PPT to HTML converter with the malformed PPT file as an input we can easily observe a problem using Valgrind: we see that   called in   function caused a stack based buffer overflow which resulted in stack corruption. Let\'s investigate the moment when   is called: The   parameter is huge and equals  . We can easily observe in the pseudo-code where the value is coming from: We see that   variable is read directly from the file by the   function  , so an attacker has nearly full control of this value. Nearly, because\n  is checked to see if its value exceeds 1026 at  . The problem is that   is a signed value and values greater than 0x7fffffff will cause a negative value to be compared, which bypasses this check causing stack corruption. File structure analysis reveal that the value   (0xec000008 in the file, it\'s decreased by one before the memcpy at  ) is located in   data structure. Offset      0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F 00001A00   FE FF 00 00 05 01 02 00  00 00 00 00 00 00 00 00   ˛ˇ..............\n00001A10   00 00 00 00 00 00 00 00  01 00 00 00 E0 85 9F F2   ............‡ÖüÚ\n00001A20   F9 4F 68 10 AB 91 08 00  2B 27 B3 D9 30 00 00 00   ˘Oh.´ë..+\'≥Ÿ0...\n00001A30   A4 05 00 00 0B 00 00 00  01 00 00 00 60 00 00 00   §........... áŸ9≈.....\n00001B20   18 00 00 00 47 00 00 00  A8 04 00 00 FF FF FF FF   ....G...®...ˇˇˇˇ  starts at offset 00001A00 in the file, and the field used in the memcpy operation is located at offset: 0x1AAC. 2017-02-21 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0286');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (359, 'AntennaHouse DMC HTMLFilter iBldDirInfo Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the iBldDirInfo functionality of AntennaHouse DMC HTMLFilter used by MarkLogic 8.0-6. A specially crafted xls file can cause a heap corruption resulting in arbitrary code execution. An attacker can provide a malicious xls file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used, among others, to convert xls files to (x)html form. \nThis product is mainly used by MarkLogic for xls document conversions as part of their web based document search and rendering engine.\nA specially crafted XLS file can lead to heap corruption and ultimately to remote code execution. Let\'s investigate this vulnerability. After execution of the XLS to html converter with a malformed xls file as an input we can easily observe the following when using Valgrind: We see that a heap-based buffer overflow occurs in the function  . The overflowed buffer is also allocated in this function.\nRunning our target with an instrumented heap we stop in the following place : To figure out something more about the place where the out-of-bound write appears, we can review the pseudo code of the   function: The out of bound write occurs at  . This code parses a  , doing name conversion from Unicode to SJIS (Shift Japanese Industrial Standards) and fills\n dynamically allocated structure   with the converted name. According to the documentation   should not be bigger than 64 bytes.\nWe see a check for that in the while loop at  . The problem appears because instead of only increasing the counter   by 2 each time in the  , the developers also increase   by 2 when a\ncorrect conversion took place from Unicode to SJIS.   being incremented at lines   and  .   as a   string index should not exceed 64 and should definitely not exceed\n96 as is expected at  . As we can imagine,   can easly reach a value like 126 which occurs when: But the most dangerous scenario appears when the parsed   is the last one, writing outside of the   buffer will cause a heap based buffer overflow,\ncausing heap corruption which can lead to arbitrary code execution. 2017-02-09 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0284');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (360, 'AntennaHouse DMC HTMLFilter FillRowFormat Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the FillRowFormat functionality of AntennaHouse DMC HTMLFilter that is shipped with MarkLogic 8.0-6. A specially crafted xls file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide malicious xls file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used, among others, to convert xls files to (x)html form. \nThis product is mainly used by MarkLogic for xls document conversions as part of their web based document search and rendering engine.\nA specially crafted XLS file can lead to an heap corruption and ultimately to remote code execution. Let\'s investigate this vulnerability: after executing the XLS to html converter with malformed xls file as an input we can easily observe the following problem using Valgrind: We see that an out-of-bound write appears in the function   and spaced is allocated for the overflowed buffer in  .\nLet\'s first investigate the place of allocation: Allocation of buffer overflowed in   takes place exactly at  . Calculating allocation size value : 256 * 728 = 186368 we see its equal to the\nvalue presented by valgrind. Of course an important fact to note is that this value is fixed.\nSwitching to the place where overflow appears, we see the following situation: and information from the debugger: At line 8, we see the   parameter of memset is the result of the multiplication of constant value 728 with the result of the subtraction of two WORD fields.\nIn this case, its size is equal to 0x5b2d8 which is much higher than allocated space for this buffer ( 186368 == 0x2d800). Looking for initialization of these fields we land here: The value that we\'re interested in above is the register  , which equals : 0x200. Looking at the pseudo code of the   function, we see the following: Manipulations on 0x200 value are made at lines marked by an   comment. As we can notice at   that value is read directly from the file via the   function and later stored at  .\nDuring this entire procedure the value is checked once, at   whether its bigger than some field. There is NO CHECK for an upper limit. We know now, seeing the code above that the value used for memset as a size argument\nis read almost directly from the file. Looking for this value in our PoC file we can find it at offset : 0x3155. The entire record looks as follows: which is :\ntype : 0x27E\nLen  : 0xA\nData : 0x1B ... According to the documentation  , a record with type 0x27E is  an  .\nThe 0x200 value is a  . In the description for this we read: We saw in the previous analysis that there was a check to see whether   is bigger than  , but that there was no check to ensure that   does not exceed   or 0x00FF, which led to the overflow. 2017-02-09 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0279');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (361, 'AntennaHouse DMC HTMLFilter DHFSummary Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the DHFSummary functionality of AntennaHouse DMC HTMLFilter. A specially crafted doc file can cause a heap corruption resulting in arbitrary code execution. An attacker can provide a malicious doc file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-5.5 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used among others to convert doc files to (x)html form. \nThis product is mainly used by MarkLogic for doc document conversions as part of their web based document search and rendering engine.\nA specially crafted DOC file can lead to heap corruption and ultimately to remote code execution. Let’s investigate this vulnerability. After executing the DOC to html converter with a malformed doc file as an input we can easily observe a couple of flaws using Valgrind: We see in the first couple lines of the Valgrind output that in the   function the argument passed to malloc is equal 2: The argument value is quite small and it can be the result of a malformed field coming directly from the document. Let’s take a glance at the pseudo code of this function and investigate\norigin of malloc argument. The pseudo code looks in the following way: Line 1 signed int  int16)(someSize - 4));\nLine 18   (...) At   the DWORD value   is read directly from the file and is later use as a malloc argument. In our case\n  equals 0 which corresponds to the Valgrind output (since   + 2 = 2). From which region of the file is this value coming from and with what structure is it related? The name of the function suggests that the value comes from the  : The value of   is read from offset 0x3cb0.  is the place where the integer underflow appears and causes further issues.\nAt  ,   bytes are read from the file into the buffer  .\nBecause   equals 0, the result of the substraction is:\n , but since it gets cast to   so we end up with the value  . The size of the   buffer is  , while in the function   ,   bytes are being read into that buffer, causing a heap-based buffer overflow\nresulting in heap corruption. 2016-10-10 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0209');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (362, 'AntennaHouse DMC HTMLFilter PPT ParseEnvironment Code Execution Vulnerability', 'None', '2017-5-4', 'A specially crafted PPT file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide malicious PPT file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6  \nfb1a22fa08c986ec3614284f4e912b0a  /opt/MarkLogic/Converters/cvtofc/libdhf comm.so  \n1eabb31236c675f9856a7d001b339334  /opt/MarkLogic/Converters/cvtofc/libdhf comm.so  \n4ae366fbd4540dd4c750e6679eb63dd4  /opt/MarkLogic/Converters/cvtofc/libdmc htmlif.so  \nd716dd77c8e9ee88df435e74fad687e6  /opt/MarkLogic/Converters/cvtofc/libdhf_whtml.so  \ne01d37392e2b2cea757a52ddb7873515  /opt/MarkLogic/Converters/cvtofc/convert 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This product is mainly used by MarkLogic for office document conversions as part of their web based document search and rendering engine.\nA specially crafted PPT file can lead to heap corruption and ultimately to remote code execution. We see that a heap-based buffer overflow appears in the   function during the   operation. The buffer which is overflowed is also allocated in this function and its size is equal to 76 bytes.\nTo stop the application execution when the overflow takes place we will use duma : Reviewing the   function in pseudo-code form we see the following: The vulnerability occurs at line  . At   the allocation for   is made based on   while at     is used as a   argument for  .\nLooking for the   record in a file we can find it at offset 0x112C: Offset      0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F 00001120                                        00 00 B7 0F               ..∑.\n00001130   44 2F 00 00                                        D/.. So   has a value of 0x2f44. We can also observe it under a debugger : Where   is located at offset 0x1129 Since   is 0x4C in this case, while   this results in a heap-based buffer overflow that can lead to remote code execution. 2017-02-28 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0290');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (363, 'AntennaHouse DMC HTMLFilter AddSst Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the AddSst functionality of AntennaHouse DMC HTMLFilter as used by MarkLogioc 8.0-6. A specially crafted XLS file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide a malicious XLS file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-6  \nfb1a22fa08c986ec3614284f4e912b0a  /opt/MarkLogic/Converters/cvtofc/libdhf comm.so  \n1eabb31236c675f9856a7d001b339334  /opt/MarkLogic/Converters/cvtofc/libdhf comm.so  \n4ae366fbd4540dd4c750e6679eb63dd4  /opt/MarkLogic/Converters/cvtofc/libdmc htmlif.so  \nd716dd77c8e9ee88df435e74fad687e6  /opt/MarkLogic/Converters/cvtofc/libdhf_whtml.so  \ne01d37392e2b2cea757a52ddb7873515  /opt/MarkLogic/Converters/cvtofc/convert 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This product is mainly used by MarkLogic for office document conversions as part of their web based document search and rendering engine.\nA specially crafted XLS file can lead to heap corruption and ultimately to remote code execution. The heap overflow occurs in the   function triggered by the  , where the buffer related with this overflow is allocated in the same function.\nThe pseudo-code of the most important part of this function looks as follows: At   the value for v4 is read directly from the file and later used for the allocation at  . The   which causes the overflow is located at  . The problem occurs because\nthe loop condition for the while loop at   is wrong: This leads to a situation where bigger   is subtracted from a smaller   value at  . This results in an integer underflow and the resulting value is then stored in   and is used as a   argument in the  \nat  . As a result the   is attempting to copy a huge amount of data: The values come from the following locations in the file:\n  - is the Length of an SST record located at 0x948.\n  is coming from wrongly interpreted BoundSheet record located at 0x92E. Exactly one byte from the SheetName field which is \"Sheet1\" and its first letter \"e\" is interpreted as a flag.\n  is also coming from the aforrmentioned BoundSheet record. Its WORD size value also comes from SheetName string and is equal : 0x6853 (\'Sh\'). 2017-02-28 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0292');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (364, 'AntennaHouse DMC HTMLFilter Doc_GetFontTable Code Execution Vulnerability', 'None', '2017-5-4', 'An exploitable heap corruption vulnerability exists in the Doc_GetFontTable functionality of AntennaHouse DMC HTMLFilter. A specially crafted doc file can cause a heap corruption resulting in arbitrary code execution. An attacker can send/provide malicious doc file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-5.5 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used among others to convert doc files to (x)html form.  This product is mainly used by MarkLogic for doc document conversions as part of their web based document search and rendering engine. A specially crafted DOC file can lead to an heap corruption and ultimately to remote code execution. Let’s investigate this vulnerability. After execution the doc to html converter with malformed doc file as an input we can easily observe a couple of flaws using Valgrind: We see in the first couple lines of the Valgrind output thatthe   function argument passed to malloc is equal to 0: That’s the root cause of these OOB writes that we could observe above. Ok, we know where the problem is, let’s take a glance at the pseudo code of this function and investigate the origin of the malloc argument. The pseudo code of this function looks like this: We see that in   some data is read from file and assign to   pointer.\nFirst 128 bytes of that buffer: At  , the first DWORD from this buffer is read and assigned to the   field. Next at  , the value of that field is used as an argument to malloc. From the buffer dump we can see that the first DWORD is equal 0. That explains everything: the value from the file is passed directly as an argument to malloc. In our case it’s equal 0 which causes the result of the multiplication to also be 0. This is not the only bad scenario: this could also lead to an  ,\nleading to the same results which is heap corruption. Let’s see how many bytes are available in a buffer malloced with the argument 0. So that means we have 0x14 bytes available for use.\nFrom   to   we see a while loop with a lot of   into  .\nThe range of these write operations is much bigger than the allocated buffer capacity which leads to heap corruption. 2016-10-10 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0208');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (365, 'AntennaHouse DMC HTMLFilter Doc_SetSummary Code Execution Vulnerability', 'None', '2017-5-4', 'AntennaHouse DMC HTMLFilter Doc_SetSummary Code Execution Vulnerability An exploitable heap corruption vulnerability exists in the Doc_SetSummary functionality of AntennaHouse DMC HTMLFilter.\nA specially crafted doc file can cause a heap corruption resulting in arbitrary code execution. An attacker can send a malicious doc file to trigger this vulnerability. AntennaHouse DMC HTMLFilter shipped with MarkLogic 8.0-5.5 8.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This vulnerability is present in the AntennaHouse DMC HTMLFilter which is used among other things to convert doc files to (x)html form. \nThis product is mainly used by MarkLogic for doc document conversions as part of their web based document search and rendering engine.\nA specially crafted DOC file can lead to a heap corruption and ultimately to remote code execution. Let’s investigate this vulnerability. After execution the DOC to HTML converter with a malformed doc file as an input we can easily observe a couple of flaws using Valgrind: Let’s focus on the out bounds write that appears inside the   function.\nPseudo code of this function looks like this: Let’s investigate the memcpy parameters in line 17 (that\'s the place where the OOB write appears) under a debugger: We see that the third   parameter is fully controllable by attacker and equal to  .  Where   buffer has the following amount of space: (gdb) heap /b $ecx space = (0x80947f0 + 16180) - (0x80947f0+9517)\nso the space equals 6663 bytes. The 3rd parameter to   is much bigger which in consequences lead to heap corruption. Using rr debugger we can easily find place where memcpy   parameter is set: pseudo code We see that lower WORD   is set to a structure field which is later used as a part of   parameter. Its value is read directly from the buffer at   which content has been read from the file at  .\nInteresting is also name of the function we land in:  .\nAccording   documentation   is a name of a structure that contains Document Properties. So our memcpy param is a field in a   structure.\nCalculating the difference between the beginning of the buffer and the place where value of this field appears we get info about offset for that field in the Dop structure. Let’s go back to the place where the heap corruption appears and perform one step to confirm this theory: 2016-10-10 - Vendor Disclosure \n2017-05-04 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0207');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (366, 'Randombit Botan Library X509 Certificate Validation Bypass Vulnerability', 'None', '2017-4-28', 'A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. Randombit Botan 2.0.1 6.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:L CWE-125: Out-of-bounds Read Botan is a C++ cryptographic library that implements the basis for practical systems that require TLS, PKIX certificate handling, password hashing or other cryptographic primitives. There exists a programming error in code related to x509 distinguished name parsing. Namely, an x509 DN comparison function can lead to out of bounds memory access leading to unexpected results, information disclosure or potential denial of service. The vulnerability is located in the overloaded equality comparison function  : First, at [1], initiall whitespaces are skipped. Then, strings are compared byte by byte in a loop while checking for whitespace at [2]. If a space occurs in the first string [2] and the second too [3], those are again skipped at [4] and [5]. Then, at [6], if both have reached an end,   is returned. If not, another comparison is made at [7] and if it passes, the pointers are increased at [8]. The vulnerability lies in the way whitespaces are handeled. If we are comparing two strings which are initially the same up to a space character, we would enter while loops at [4] and [5]. Now, if one string contains a NULL byte after that space, and the other has spaces until its end, the check at [6] won’t be true, because only the second string would point to its end. However, both are actually pointing at a NULL byte, which means the check at [7] will still hold true, and pointers are once again increased at [8]. Then when the loop rolls around, one of the pointers can point outside its allocated buffer, leading to unexpected behaviour. A specially crafted x509 certificate with specific x509 DN strings for subject and issuer fields can be created. Example strings that satisfy the above conditions are: Notice that both are the same length, begin with same characters up until space after which the first is terminated and the second has spaces till the end. Because of the way these pieces of certificate are copied from the x509 file to their memory buffers, the first string’s length won’t be 3, that is, it won’t be terminated at the first NULL. With careful control over X509 distinguished names contents and depending on memory layout in the target application, it could be possible to craft a certificate where equality checks could pass or fail. Also, a discrepancy between a way these malformed strings are handled in Botan and other x509 libraries could lead to other types of abuse, possibly not unlike the famed CVE-2009-2408. The vulnerability can be triggered with the supplied example x509 certificate. Address sanitizer output: Adding another check which tests if either string is at the end while the other is not, which would make them different, is enough to resolve this vulnerability: 2017-03-16 - Vendor Disclosure \n2017-04-28 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0294');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (367, 'Zabbix Proxy Server SQL Database Write Vulnerability', 'None', '2017-4-27', 'An exploitable database write vulnerability exists in the trapper functionality of Zabbix Server 2.4.X . Specifically crafted trapper packets can pass database logic checks, resulting in database writes. An attacker set up a Man-in-the-Middle server to alter trapper requests made between an active Zabbix proxy and Server to trigger this vulnerability. Zabbix Server 2.4.8.r1 7.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:L CWE-300: Channel Accessible by Non-Endpoint (\'Man-in-the-Middle\') One of the Trapper requests made by the Zabbix proxy is the ìproxy configî request, which allows a proxy to request its own proxy configuration from the Zabbix Server (or any other Zabbix Proxyís configuration if they know the hostname of that machine). When this occurs, the Zabbix Server pulls varying configuration for the given Zabbix Proxy from its database. While the Zabbix server has hardcoded tables that it looks at when searching for the desired configuration data to send to the proxy, there is no such restriction on what the Zabbix Proxy will apply to it is database. Thus, if an attacker is able to man in the middle the traffic of a Zabbix Proxy and Zabbix Server, an attacker can insert arbitrary JSON into the configuration response of the Server, and the Zabbix Proxy will apply the configuration without hesitation. This is doubly concerning since the proxy configuration data flows unencrypted over the local network, allowing anyone with network connectivity to the Zabbix Server to utilize this attack. Since the ìproxy configî request happens at regular intervals from the Proxy to the Server, an attacker can use a proxy server to intercept the traffic and insert arbitrary data into the database, as long as the destination table is a valid table in the Zabbix proxy database. 2017-03-22 - Vendor Disclosure \n2017-04-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0326');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (368, 'Zabbix Server Active Proxy Trapper Remote Code Execution Vulnerability', 'None', '2017-4-27', 'An exploitable code execution vulnerability exists in the trapper command functionality of Zabbix Server 2.4.X . A specially crafted set of packets can cause a command injection resulting in remote code execution. An attacker can make requests from an active Zabbix Proxy to trigger this vulnerability. Zabbix Server 2.4.8.r1 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-88: Argument Injection or Modification The vulnerability lies within the ìTrapperî section of the Zabbix Code, this is the network service that allows the Proxies and the Server to communicate (TCP Port 10051) There are a set of API calls that the Zabbix Server exposes to the Zabbix proxy, the two that will be discussed are the ìdiscovery dataî and ìcommandî requests.  Example data of these requests are shown below: It should be noted that the ìrequestî command invokes a script located in the  Zabbix database without any authentication occurring (which might be considered a bug in itself). Another pivotal aspect of the vulnerability is that by default, Zabbix 2.4.X populates the MySQL database with 3 scripts inside of the scripts table: The problem lies in the fact that the {HOST.CONN} field actually gets replaced by the hostís IP address during the invocation of the script. The value that replaces {HOST.CONN} is located in the Zabbix ìinterfaceî table, and is stored as the ìIPî field as a VARCHAR(64). Thus, if an attacker can create an interface with a command injection as the IP address, and script with {HOST.CONN} is run via the ìcommandî request, the command injection will occur and a reverse shell can be gained. The difficulty lies in actually getting a valid entry into the Zabbix ìhostî table. By default, an unauthenticated attacker cannot do this, it requires a minor configuration on the part of the system administrators, specifically in regards to Zabbixís Auto-discovery feature. Zabbixís Auto-discovery and Auto-registration features allow for configuration of the Zabbix Server to occur based on the data presented Zabbix Server by the Zabbix Proxy. More specifically, if a hosts presents certain characteristics to the Zabbix Proxy, based on the configuration of the server, certain actions could be potentially taken, one of which causes the newly discovered host to get added to certain Zabbix database tables.  When this occurs, a host is inserted into the ìhostsî table and also an entry into the Zabbix ìinterfaceî table will be created, with the IP address presented by the host being inserted into the IP column, without any validation of that IP address occurring. Thus, by sending a ìdiscovery dataî request to the server with a suitable host, a command injection can be inserted into the database: Due to the size limitation of the ëipí field of the Zabbix ìInterfaceî table, a second host was inserted into the table with another IP address. After these two hosts were added, there was still the issue of not knowing the hostidís for the ìcommandî request, but this was easily solved by brute forcing backwards into the database since the command request would return a different response if the host actually existed or not, and once the hostidís of the injected hosts were known, they could be invoked directly, and a reverse shell could be gained. By removing the three default script entries inside of the Zabbix Serverís ìZabbixî database, an attacker would be unable to actually execute code, even if they can insert hosts with spoofed addresses into the database. This should not affect an organizations current operations, unless teh scripts are actually used. This proposed fix can either be done directly from the database (use zabbix; delete * from scripts;) or from the GUI interface (Administration -> Scripts -> Checkmarks -> ìDelete Selectedî/îGoî). 2017-03-22 - Vendor Disclosure \n2017-04-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0325');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (369, 'IrfanView JPEG 2000 Reference Tile Width Arbitrary Code Execution Vulnerability', 'None', '2017-4-26', 'IrfanView JPEG 2000 Reference Tile Width Arbitrary Code Execution Vulnerability An exploitable integer overflow vulnerability exists in the JPEG 2000 parser functionality of IrfanView 4.44. A specially crafted jpeg2000 image can cause an integer overflow leading to wrong memory allocation resulting in arbitrary code execution. Vulnerability can be triggered by viewing the image in via the application or by using thumbnailing feature of IrfanView. IrfanView 4.44 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound IrfanView is a popular image viewer application for Windows due to its support for large number of file formats through its plugins and numerous image manipulation options. While parsing a JPEG 2000 file, IrfanView will use the reference tile width value in a buffer size calculation. Due to insufficient checks for integer wraparound, these calculations can result in a small buffer being allocated for a seemingly large tile which later results in a controlled out-of-bounds write vulnerability which can be further abused to achieve arbitrary code execution in the context of the application. Erroneous allocation happens in function sub_10027E40 (image base of unpacked JPEG2000.dll is at 0x10001000) and the condition for the integer overflow can be observed at the following breakpoint: Second argument to the above call is 0x50 which ends up being a size argument to   call, and is actually derived from   value in the   marker of the sample file which in this case is 0x0CCCCCCF, the smallest value that will trigger the integer overflow. Notice that the   register holds the same value, before buffer size calculations are done. Buffer size calculations basically boil down to multiplying the value by 20 plus a small value. Therefore, instead of allocating a large enough buffer, a small memory region will be reserved after the call: Later, when actual values are to be written in this buffer, a controlled out-of-bounds write will happen potentially overwriting sensitive memory. Note that due to different memory layouts, an out-of-bounds write can happen on actually accessible memory and in general won’t result in a crash. By modifying the   value slightly (to 0x0dcccccf), to force a crash, we can observe the following: In the above debugging output, we can again see   having the original   value from the file, and an overflowed value pushed as a second argument on the stack (0x14000050, overflown by multiplying edx by 20). After this call we can see our buffer being allocated: So, a buffer of size 0x14000058 has been successfully allocated. Continuing the execution results in the following crash: The crash occurs in a function at offset 0x10028200, specifically while writing values in a loop controlled based on number of components. Upper bound for   in the above out-of-bounds write loop is the   value specified in the file which can be easily controlled to achieve multiple out of bounds writes. Also, backing up a bit in the crashing function reveals that   pointer is derived from the   value which causes the initial integer overflow: An original   value twice dereferenced at [1] and [2] ends up in  , multiplied by 1 at [3] and used as offset in pointer calculation at [4], with   as a base being a start of our previously allocated buffer. This pointer is stored as   at [5] and because the offset is multiplied by 4, and the original buffer is smaller than that, this ends up causing the out-of-bounds write. This can be observed in the following debugging session: Above, we see that the value at (esi+8)+0x14 is equal to original   value. Stepping through this block shows how the value in edx is calculated as well as value in   being retrieved. Last instruction above uses   as base pointer and   as an offset into it. Before the   instruction, we can see that   points to our allocated buffer which is smaller than  . This causes   to point out-of-bounds: Continuing the process again leads to the crash when a value is written into memory pointed to by   plus an offset based on other   fields. The value that is being written out-of-bounds is based on  . By carefully controlling the   value, and manipulating final arithmetics via other values in the   marker, an attacker can overwrite a chosen memory location with its controlled value which can lead to arbitrary code execution. 2017-04-18 - Vendor Disclosure \n2017-04-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0310');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (370, 'Moxa AWK-3131A Hard-coded Administrator Credentials Vulnerability', 'None', '2017-4-21', 'An exploitable Use of Hard-coded Credentials vulnerability exists in the Moxa AWK-3131A Wireless Access Point running firmware 1.1.  The device operating system contains an undocumented, privileged (root) account with hard-coded credentials, giving attackers full control of affected devices. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H An exploitable Use of Hard-coded Credentials vulnerability exists in the Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client.  The device operating system contains an undocumented, privileged (root) account with hard-coded credentials, giving attackers full control of affected devices. The device lacks the functionality for legitimate administrators to modify or remove the backdoor account. Disable all remotely-accessible services, such as SSH and Telnet. 2016-11-14 - Vendor Disclosure \n2017-04-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0231');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (371, 'ARM Mbedtls x509 ECDSA invalid public key Remote Code Execution Vulnerability', 'None', '2017-4-19', 'An exploitable free of a stack pointer vulnerability exists in the x509 certificate parsing code of ARM mbedTLS 2.4.0. A specially crafted x509 certificate, when parsed by mbedTLS library, can cause an invalid free of a stack pointer leading to a potential remote code execution. In order to exploit this vulnerability, an attacker can act as either a client or a server on a network to deliver malicious x509 certificates to vulnerable applications. ARM mbedTLS 2.4.0. 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A CWE-590: Free of Memory not on the Heap mbedTLS, previously known as PolarSSL is an SSL and TLS implementation aimed at embedded devices and as such has few dependencies and small footprint. It is especially popular as a way of providing transport layer security to embedded web servers such as GoAhead, for example. The vulnerability exists in the part of the code responsible for handling elliptic curve cryptographic keys. It can be triggered by supplying a specially crafted x509 certificate to the target which performs a series of checks on the certificate and supplied public key. In the provided proof-of-concept x509 certificate a curve of type   is specified: Notice that   tool fails to parse the public key properly. While parsing the certificate, and public key specifically, mbedTLS library will identify the curve in question as   while validating the public key and will invoke a numer of elliptic curve arithmetic in order to verify the key, as can be seen from the context of the crashing application: In the above output, the application is crashing due to invalid call to free inside   function: At [1] a wrapper to libc   is called with   as parameter. Going backwards through the callstack and code, it can be concluded that final values of   and   are actually initialized in   function: At [1], we can observe variable   being allocated on the stack. It’s assigned to   at [2] and at [3], a call to   is made, which eventually leads to invalid free. This can also be confirmed in the debugger: Mitigating factor of this vulnerability is the fact that the area of memory pointed to by pointer being freed is zeroed-out just before the free, which does complicate exploitation, but since the library is designed and intended for embedded platforms which might not have modern heap exploitation mitigations in place, we believe it can result in remote code execution in certain environments. The vulnerability can be triggered with the supplied PoC file by opening it in   sample application provided with the library. Valgrind output: 2017-01-25 - Vendor Disclosure \n2017-04-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0274');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (372, 'Moxa AWK-3131A Web Application Ping Command Injection Vulnerability', 'None', '2017-4-18', 'An exploitable OS Command Injection vulnerability exists in the web application \'ping\' functionality of Moxa AWK-3131A Wireless Access Points running firmware 1.1. Specially crafted web form input can cause an OS Command Injection resulting in complete compromise of the vulnerable device. An attacker can exploit this vulnerability remotely. Moxa AWK-3131A WAP Version 1.1 Build 15122211 9.1 - CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H The ping feature of the Moxa AWK-3131A WAP web application is vulnerable to OS command injection.  No obfuscation or encoding is needed - it appears there is no filtering of user input.  Entering an OS command that is preceded with a ; results in the command being executed by the OS with root permissions. An authenticated user may obtain a remote shell with root privilages by entering the following in the ping input box: then telnet to port 9999.  The attacker will be connected to a /bin/sh shell as the root user, without needing to enter any credentials. Exploitation of the vulnerable parameter requires authentication to the web application.  However, commands are executed by the operating system as the root user, negating any user-level privilege enforcement by the web application. 2016-11-14 - Vendor Disclosure\n2017-04-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0235');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (373, 'Lexmark Perceptive Document Filters XLS ShapeHLink Information Disclosure Vulnerability', 'None', '2017-4-18', 'An exploitable arbitrary read exists in the XLS parsing of the Lexmark Perspective Document Filters conversion functionality. A crafted XLS document can lead to a arbitrary read resulting in memory disclosure. The vulnerability was confirmed on versions 11.3.0.2228 and 11.3.0.2400 Lexmark Perceptive Document Filters 11.3.0.2228\nLexmark Perceptive Document Filters 11.3.0.2400 4.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N CWE-125 - Out-of-bounds Read This vulnerability is present in the Lexmark Document filter parsing which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services.  This product is mainly used by MarkLogic for document conversions as part of their web based document search and rendering. It can convert common formats such as Microsoft\'s document formats into more useable and easily viewed formats. There is a vulnerability in the parsing and conversion of XLS documents. A specially crafted XLS file can lead to an arbitrary read and ultimately memory disclosure. Let\'s investigate this vulnerability. After the Lexmark library attempts to read metadata from the malicious file, we see the following state: As we can see in the function   an access violation occurred during a read from a very specific address  . The address from where these 4 bytes are extracted are fully\ncontrolled by attacker. Let\'s look at where this value comes from. We return to the place where   was set: looking in the file for value the   we can find it at offset 0x6D82. It points to data inside the   field of the   record type (described in  .aspx) of the Office Drawing Binary File Format. Looking at the constructor name we can easily guess that the object which the currently library was parsing is related with a  . Indeed, it is wrongly parsing the   structure (defined in  .aspx) of the Office Common Data Types and Objects Structures:\nThe   object has, among others, 2 string fields,   and  . Both fields have variable lengths. The Perceptive Filter library reads the read string length from the file without extra checks and adds it to   pointer to find the location of  .  This lack of value sanitization leads to an arbitrary memory read and can result in memory disclosure. 2017-04-05 - Vendor Disclosure \n2017-04-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0302');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (374, 'Moxa AWK-3131A Web Application Cleartext Transmission of Password Vulnerability', 'None', '2017-4-10', 'An exploitable Cleartext Transmission of Password vulnerability exists in the Web Application functionality of Moxa AWK-3131A Wireless Access Point running firmware 1.1. The Change Password functionality of the Web Application transmits the password in cleartext. An attacker capable of intercepting this traffic is able to obtain valid credentials. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 7.5 - CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H An exploitable Cleartext Transmission of Password vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. The Change Password functionality of the Web Application transmits the password in cleartext as HTTP POST parameters. An attacker capable of intercepting this traffic is able to obtain valid credentials. To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-14 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0230');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (375, 'Moxa AWK-3131A HTTP GET Denial of Service Vulnerability', 'None', '2017-4-10', 'An exploitable null pointer dereference exists in the Web Application functionality of Moxa AWK-3131A Wireless Access Point running firmware 1.1. Any HTTP GET request not preceded by an \'/\' will cause a segmentation fault in the web server.  An attacker can send any of a multitude of potentially unexpected HTTP get requests to trigger this vulnerability. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H An exploitable null pointer dereference exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. Any HTTP GET request not preceded by an \'/\' will cause a segmentation fault in the web server.  An attacker can send any of a multitude of potentially unexpected HTTP GET requests to trigger this vulnerability. There is no way to restart the web application using legitimate functionality outside of rebooting the device. The following is one of many HTTP GET requests which will result in a web server segmentation fault: To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-18 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0237');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (376, 'Moxa AWK-3131A serviceAgent Information Disclosure Vulnerability', 'None', '2017-4-10', 'An exploitable information disclosure vulnerability exists in the serviceAgent functionality of Moxa AWK-3131A Wireless Access Point running firmware 1.1. A specially crafted TCP query will allow an attacker to retrieve potentially sensitive information. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N An exploitable information disclosure vulnerability exists in the serviceAgent functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. A specially crafted TCP query will allow an attacker to retrieve potentially sensitive information, such as firmware version. The functionality exposed by serviceAgent is accessible by using a freely-available Windows application (Moxa Windows Search Utility) or with custom scripts.  In addition, the service does not use authentication and the protocol communicates in cleartext. The below Python script, using a payload pulled from traffic generated by the Moxa Windows Search Utility application, will retrieve information from a target device that may be of value to an attacker . It does not appear possible to disable serviceAgent using legitimately accessible functionality.  In addition, the service does not require authentication and transmits information in cleartext.  Blocking this service from communicating across network boundaries will mitigate some of the risk associated with this vulnerability. 2016-11-18 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0238');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (377, 'Moxa AWK-3131A Web Application systemlog.log Information Disclosure Vulnerability', 'None', '2017-4-10', 'An exploitable information disclosure vulnerability exists in the Web Application functionality of the Moxa AWK-3131A wireless access point running firmware 1.1. Retrieving a specific URL without authentication can reveal sensitive information to an attacker. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N An exploitable information disclosure vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. Retrieving a specific URL without authentication can reveal sensitive information to an attacker. To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-18 - Vendor Disclosure\n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0239');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (378, 'Moxa AWK-3131A Web Application bkpath HTTP Header Injection Vulnerability', 'None', '2017-4-10', 'An exploitable HTTP Header Injection vulnerability exists in the Web Application functionality of the Moxa AWK-3131A Wireless Access Point running firmware 1.1. A specially crafted HTTP request can inject a payload in the bkpath parameter which will be copied in to Location header of the HTTP response. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 3.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N An exploitable HTTP Header Injection vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. A specially crafted HTTP request can inject a payload in the bkpath parameter which will be copied in to Location header of the HTTP response.  This vulnerability can be exploited in order to execute a variety of other attacks. Request Response To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-14 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0234');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (379, 'Moxa AWK-3131A Web Application asqc.asp Information Disclosure Vulnerability', 'None', '2017-4-10', 'Moxa AWK-3131A Web Application asqc.asp Information Disclosure Vulnerability An exploitable Information Disclosure vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. Retrieving a specific URL without authentication can reveal sensitive information to an attacker. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N An exploitable Information Disclosure vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. Retrieving a specific URL, /asqc.asp, without authentication can reveal sensitive information to an attacker. To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-18 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0236');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (380, 'Moxa AWK-3131A Web Application onekey Information Disclosure Vulnerability', 'None', '2017-4-10', 'An exploitable information disclosure vulnerability exists in the Web Application functionality of Moxa AWK-3131A Wireless Access Point. Retrieving a series of URLs without authentication can reveal sensitive configuration and system information to an attacker. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N An exploitable information disclosure vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. Retrieving a series of URLs without authentication can reveal sensitive configuration and system information to an attacker. Specifically, an unauthenticated attacker can visit http:///makeonekey.gz and then http:///getonekey.gz to obtain compressed file which contains systemlog.log, config.ini, and the system_status folder.  These files contain sensitive information, including encoded credentials for system services and wireless interfaces. First Then To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-18 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0241');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (381, 'Moxa AWK-3131A web_runScript Header Manipulation Denial of Service Vulnerability', 'None', '2017-4-10', 'An exploitable null pointer dereference vulnerability exists in the Web Application /forms/web filename functionality of Moxa AWK-3131A Wireless Access Point running firmware 1.1. An HTTP POST request with a blank line in the header will cause a segmentation fault in the web server. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H An exploitable null pointer dereference vulnerability exists in the Web Application /forms/web filename functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. An HTTP POST request with a blank line in the header will cause a segmentation fault in the web server. \nThere is no way to restart the web application using legitimate functionality outside of rebooting the device. POST /forms/web_runScript HTTP/1.1\nHost: 192.168.127.253\nUser-Agent: Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9, ;q=0.8\nAccept-Language: en-US,en;q=0.5\nContent-Length: 871 Accept-Encoding: gzip, deflate\nReferer: http://192.168.127.253/Troubleshooting.asp\nCookie: Password508=\nConnection: close\nContent-Type: multipart/form-data; boundary=---------------------------99926971127282895659616238\nContent-Length: 591 To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-18 - Vendor Disclosure\n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0240');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (382, 'Moxa AWK-3131A Web Application Cross-Site Request Forgery Vulnerability', 'None', '2017-4-10', 'An exploitable Cross-Site Request Forgery vulnerability exists in the Web Application functionality of Moxa AWK-3131A Wireless Access Point running firmware 1.1. A specially crafted form can trick a client into making an unintentional request to the web server which will be treated as an authentic request. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H An exploitable Cross-Site Request Forgery (CSRF) vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. A specially crafted form can trick a client into making an unintentional request to the web server which will be treated as an authentic request. Successful exploitation of this vulnerability can enable an attacker to trick a legitimate user in to performing any action permitted by the device, including exploitation of unrelated vulnerabilities.  For example, an attacker may use a CSRF attack to modify device settings or even take advantage of OS Command Injection vulnerabilities to execute operating system commands with root privileges. The below will change the user\'s password to a value determined by the attacker Alternatively, leveraging an OS Command Injection vulnerability in conjunction with CSRF, a client which attempts to render the below page will cause a root-level shell to be opened on the vulnerable device: To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-14 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0232');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (383, 'Moxa AWK-3131A Web Application Nonce Reuse Vulnerability', 'None', '2017-4-10', 'An exploitable nonce reuse vulnerability exists in the Web Application functionality of Moxa AWK-3131A Wireless AP running firmware 1.1. The device uses one nonce for all session authentication requests and only changes the nonce if the web application has been idle for 300 seconds. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 5.9 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N An exploitable Nonce Resume vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. The device uses one nonce for all session authentication requests and only changes the nonce if the web application has been idle for 300 seconds.\nThe value of a sessions token is the result of MD5(password+webNonce).  With a fixed nonce, attacks against the session token to determine valid credentials are greatly simplified as the attacker now only needs to crack MD5(password). The nonce reuse is also the basis for the way sessions are implemented: because the nonce keeps getting reused as long as the web application hasn\'t been idle, the session remains valid. This introduces another problem: when logging out, the cookie containing the session token is cleared, but the session does not become invalid until the timeout has occured. This allows attackers who have been able to gain access to a session token to use it to log in even if the user has explicitly logged out. They can also keep this session token valid permanently by ensuring that the web application never goes idle, which prevents the nonce from changing. The below script will grab a nonce once every 250 seconds, just under the 300 second time-out period.  This will prevent the nonce from changing. To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-14 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0225');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (384, 'Moxa AWK-3131A Web Application Multiple Reflected Cross-Site Scripting Vulnerabilities', 'None', '2017-4-10', 'An exploitable reflected Cross-Site Scripting vulnerability exists in the Web Application functionality of Moxa AWK-3131A Wireless Access Point running firmware 1.1. Specially crafted input, in multiple parameters, can cause a malicious scripts to be executed by a victim. Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client 1.1 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H An exploitable Reflected Cross-Site Scripting (XSS) vulnerability exists in the Web Application functionality of Moxa AWK-3131A Series Industrial IEEE 802.11a/b/g/n wireless AP/bridge/client. Specially crafted input, in multiple parameters, can cause a malicious scripts to be executed by a victim. The following parameters have been validated as being vulnerable to XSS exploitation:\n - devIndex parameter in client ssid cert.asp\n - vapIndex parameter in wireless_security.asp In testing, it was possible to inject JavaScript which allowed an attacker to steal legitimate session tokens, allowing the attacker to impersonate an authenticated user. Basic PoC\nIn multiple set.asp, devIndex parameter, JavaScript preceded by   and closed with  Stealing Session Tokens\nThe URL below will send an authenticated user\'s valid session token to the attacker: To significantly mitigate risk of exploitation, disable the web application before the device is deployed. 2016-11-14 - Vendor Disclosure \n2017-04-10 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0233');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (385, 'Network Time Protocol Origin Timestamp Check Denial of Service Vulnerability', 'None', '2017-3-29', 'An exploitable denial of service vulnerability exists in the origin timestamp check functionality of ntpd 4.2.8p9.  A specially crafted unauthenticated network packet can be used to reset the expected origin timestamp for target peers.  Legitimate replies from targeted peers will fail the origin timestamp check (TEST2) causing the reply to be dropped and creating a denial of service condition. NTP 4.2.8p9 http://www.ntp.org CVSSv2: 4.3 - (AV:N/AC:M/Au:N/C:N/I:N/A:P)\nCVSSv3: 3.7 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L In most modes, NTP prevents spoofing by off-path attackers by verifying that the origin timestamp of an incoming NTP packet\nmatches the transmit timestamp on the daemon\'s last outgoing packet --- using the transmit and origin timestamps as a per-request nonce. This test described in RFC 5905 and dubbed   in ntpd\'s source code.  To prevent an NTP daemon from accepting responses to duplicated request packets, RFC 5095 also specifies that the expected origin timestamp should be set to zero after successfully validating the origin timestamp of an incoming packet. Unfortunately, ntpd releases before 4.2.8p9 did not correctly reject incoming packets bearing a zero origin timestamp.  This allowed a trivial bypass of TEST2, the origin timestamp check, by setting the origin timestamp on spoofed packets equal to zero (CVE-2015-8138,CVE-2016-7431). ntp-4.2.8p9 fixes CVE-2015-8138 by rejecting packets with zero origin timestamps in all modes where that is not expected legitimate behavior.  However, for reasons unknown, before rejecting a packet bearing a zero origin timestamp, ntp-4.2.8p9 clears the expected origin timestamp (peer->aorg) as can be seen in the following abstracted code: This leads to a trivial denial of service.  An unauthenticated network attacker who knows the address of one of the peers of a\nvictim ntpd process can send the victim ntpd spoofed packets with the source address of the peer and a zero origin timestamp in order to reset peer->aorg for that peer.  This will cause the next packet sent from the peer to fail the origin timestamp check (TEST2) and be dropped.  The attacker can repeat this each poll period for all known peers in order to prevent their packets from being accepted by the victim ntpd. This attack is very effective against symmetric associations where the duration between an outgoing packet from the victim ntpd and its \"response\" will be on the order of seconds to minutes.  The attack is more difficult for client-server associations where the request-response window is likely to be on the order of milliseconds.  However, if the attacker can observe the victim\nntpd\'s request packet, it can attempt to race the remote peer\'s legitimate response. An attacker can learn the currently selected peer of a victim ntpd process by sending the victim a client mode request and reading the peer\'s address from the refid field of the victim\'s response.  This allows the attacker to target the currently selected peer one at a time until it has learned and targeted all peers of the victim ntpd process.  If the victim allows NTP control queries or the attacker can observe the victim\'s NTP traffic, the attacker can easily learn all the victim\'s peers. The call to L CLR(&peer->aorg): The only ntpd-based mitigations for this vulnerability are to try to\nmake it harder for an attacker to guess the peers of ntpd instances\nand to monitor ntpd logs for messages such as the following: All ntpd instances should be configured to block control queries from untrusted servers.  This is best practice. All ntpd clients should block all incoming traffic that does not originate from a known peer address.  This can be accomplished with a stateful firewall. Because peer->aorg is cleared before authentication is enforced, enabling NTP authentication does not prevent exploitation of this vulnerability. 2017-01-04 - Vendor Disclosure \n2017-03-29 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0260');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (386, 'National Instruments LabVIEW LvVarientUnflatten Code Execution Vulnerability', 'None', '2017-3-22', 'An exploitable memory corruption vulnerability exists in the LvVarientUnflatten functionality of LabVIEW 2016 version 16.0.0.49152. A specially crafted VI file can cause a user controlled value to be used as a loop terminator resulting in internal heap corruption. An attacker controlled VI file can be used to trigger this vulnerability, exploitation could lead to remote code execution. LabVIEW 2016 Evaluation (version 16.0.0.49152) 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-122: Heap-based Buffer Overflow LabVIEW provides engineers a simple environment to build measurement or control systems. LabVIEW is used to abstract many of the low-level details of various hardware and signal-processing libraries into a single platform. It uses a graphical programming approach to achieve this goal. Modules utilized in this vulnerability: During the unflattening of a LvVarient object, a call to   occurs [0]: During this  , various pieces of the input file is read using   from a   [1]. This object provides an interface to an open file handle to read input in various formats. In this case, an unsigned 32 bit integer is being read from the file. While parsing the   segment of the input file, four bytes are read which are used as a loop condition in which   is called over chunks of the heap structure internal to LabVIEW. In each iteration of the loop, the current internal heap address is cleared in 8 byte chunks and incremented to the next heap address. By supplying an invalid loop termiator, an attacker can clear internal heap chunks which could potentially lead to remote code execution. 2017-01-13 - Vendor Disclosure  \n2017-03-22 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0269');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (387, 'R PDF LoadEncoding Code Execution Vulnerability', 'None', '2017-3-9', 'An exploitable buffer overflow vulnerability exists in the LoadEncoding functionality of the R programming language version 3.3.0. A specially crafted R script can cause a buffer overflow resulting in a memory corruption. An attacker can send a malicious R script to trigger this vulnerability. R 3.3.0 \nR 3.3.2 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H The R programming language is commonly used in statistical computing and supported by the R Foundation for Statistical Computing. R is praised for having a large variety of statistical and graphical features. During the creation of a PDF document, the file containing the encoding array can be specified by the user. The following command can specify the encoding file for a pdf. While loading this file, each of the specific elements in the file is copied into the   element for each item in the   array [0]. The   array is a part of a   structure. The   array is of structure type   with a   attribute that is a buffer of length 40 [1]. By providing an element in the encoding file of longer than length 40, the   buffer is overflown. This could be leveraged to potentially gain remote code execution later in the program. 2016-11-17 - Vendor Disclosure \n2017-03-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0227');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (388, 'Apple OS X and iOS x509 certificate parsing Name Constraints Remote Code Execution Vulnerability', 'None', '2017-3-9', 'An exploitable use-after-free vulnerability exists in the x509 certificate validation functionality in Apple macOS Sierra (10.12.3 release and 10.12.4 public beta versions) and iOS 10.2.1. A specially crafted x509 certificate can trigger a use-after-free vulnerability potentially resulting in remote code execution. In order to trigger this vulnerability the victim needs to visit a HTTPS website or other server which serves a malicios certificate or click on a file. Apple macOS 10.12.3\nApple macOS 10.12.4 beta\nApple iOS 10.2.1 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-416: Use After Free When a client establishes a secure connection to a server, the server presents an x509 certificate which the client must validate.On Apple macOS, most client applications will use macOS\'s certificate validation agent, at which point the malicious certificate will be parsed by the vulnerable code. This vulnerability can be triggered by, for example, visiting a HTTPS website with either Safari or Chrome, by connecting to a malicious mail server via Mail.app, or by simply importing the certificate by double clicking on it in finder. The vulnerability exists in code responsible for parsing   x509v3 certificate extension fields. In x509 certificate,   are stored as general subtrees (RFC 5280) and while parsing them, the function   in library   gets called: At [1], DER sequence decoding is started, and a new memory buffer is allocated at [2] and saved in register  . At [3], actual decoding is performed which, if failed, ends up at   and then at [4], a pointer to allocated memory is saved in   which points  inside a structure allocated for this certificate. Because the call at [3] has failed, the check at [4] won\'t succseed and the memory buffer gets freed at once at [5]. This is a first free and a stale pointer is left at  .  Since this pointer is not NULL, it can later be reused, leading to process crash and further undefined behaviour. With the supplied PoC certificate, the process will again attempt to free the already freed memory area while freeing all certificate parsing related structures when calling  SecCertificateDestroy`. This can be observed in the following debugging session: Above, we set a breakpoint at function   and at a call to   in it so we can see where our memory gets allocated. We can see that heap chunk of size 48 was allocated at  , then we continue untill   call returns: We can observe the return value of  . This will jump out of the loop and end up at the code that saves the pointer to   and then frees it: Memory is now free, but a stale pointer is left. Continuing the process leads to the following crash: The crash is due to use of   which marks freed memory as unreadable and unwritable: If we consult open source code from Apple regarding DER parsing functions, we can see that   will return   on decoding error (DR_DecodeError enum to be precise), so in order to trigger this vulnerability, a specially crafted x509 certificate with invalid   is needed. Further manipulation of the certificate layout in memory can lead to other structures being allocated at the freed chunk, leading to further undefined behaviour and eventual remote code execution. When a simple PoC crashing certificate file is double clicked in Finder, it gets added to keychain which crashes when trying to parse it. This will keep crashing com.apple.trustd agent in a loop, effectively rendering the system unusable and unable to connect to any SSL/TLS server. A certificate that triggers this vulnerability can be created by modifying a sample certificate generated via   with added extensions to configuration file: And then executing the following command: And modifying nameConstraints sequence decoding to fail, for example : To: The crash can be demonstrated via   : Or by creating a fake web server and visiting via browser: Which when visited by a browser results in: 2017-03-09 - Vendor Disclosure \n2017-03-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0296');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (389, 'Pharos PopUp Printer Client DecodeString Code Execution Vulnerability', 'None', '2017-3-7', 'An exploitable buffer overflow exists in the psnotifyd application of the Pharos PopUp printer client version 9.0. A specially crafted packet can be sent to the victim\'s computer and can lead to a heap based buffer overflow resulting in remote code execution. This client is always listening, has root privileges, and requires no user interaction to exploit. Pharos PopUp Printer Client 9.0 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-122 - Heap-based Buffer Overflow Pharos PopUp Printer client is printing software that is widely used in universities all over the United States. This client is a way to manage multiple connections to a single printing point and is constantly listening in the background for a packet from the printer. It is also running with root privilege for easy access to any privileged drivers. These all make this an excellent target where a vulnerability could have a high impact. The vulnerability is located inside of the DecodeString function. The packet strings are sent to the program encoded in an encoding format. This function parses the packet and decodes the string. First off the function locates the end of the string, reads in some data from the packet and finally passes it into a decode function. This code is shown below. Starting at [1], we see the string location being loaded from a struct and moved into RSI. A few checks are made on the data which is controlled by the attacker and can be easily bypassed. Then at [2], we see some data being moved directly from the attacker controlled packet and into EDX. Further down, [3], we see a call to xor_decode which is of interest because the third argument to that function is EDX. The relevant function code for xor decode is shown below.  At the beginning, EDX is being checked against zero, [1], then we subsequently fall into a loop. Some data is then grabbed from the packet structure and used at location [2]. This is XOR\'d against user data in an attempt to deobfuscate the packet received. Continuing down a touch further we see an increment to RSI, CL and a decrement to EDX. EDX is then tested against zero and it is clear the loop will continue until EDX reaches zero. This means that the loop will be executed however many times the attacker passed in from the previous function, directly taken from the packet. The code will continue incrementing the packet pointer in RSI, causing a buffer overflow of attacker controlled data and ultimately leading to remote code execution. 2017-02-07 - Vendor Disclosure \n2017-03-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0280');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (390, 'Pharos PopUp Printer Client memcpy Code Execution Vulnerability', 'None', '2017-3-7', 'A buffer overflows exists in the psnotifyd application of the Pharos PopUp printer client version 9.0. A specially crafted packet can be sent to the victim\'s computer and can lead to a heap based buffer overflow resulting in potential remote code execution. This client is always listening, has root privileges, and requires no user interaction to exploit. Pharos PopUp Printer Client 9.0 9.0 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-122 - Heap-based Buffer Overflow Pharos PopUp Printer client is printing software that is widely used in Universities all over the United States. This client is a way to manage multiple connections to a single printing point and is constantly listening in the background for a packet from the printer. It is also running with root privilege for easy access to any privileged drivers. These all make this an excellent target where a vulnerability could have a high impact. The vulnerability is located inside of the BlobData function. Blob data is encoded data returned to the client upon making the connection. It is partially controlled by the data passed in from the attacker to start. The packet is continually parsed and used by this blob data function until the packet\'s end is reached. This code is shown below. The length of the packet is calculated, [1] and we see RBX is incremented by one. RBX in this instance points to the data in the structure that was sent via the packet. From here we see EAX, [2], is decremented and is not checked for validity. Finally at [3], EAX is passed into BlobData as the length. Inside of the BlobData function a new Blob structure is created and the length passed in is EAX, one decremented from the length of the previous packet. Then subsequently at [4], the new Blob data pointer is swapped from R15 into R14, the register used for all of our checks. To recap what we know so far, the blob structure\'s length is calculated and a new blob structure is created with a length decremented by one. This new blob structure is then used to replace the original blob structure. The vulnerability arises at [5], because the check is incorrect and should be jump if zero not JNZ. This makes the program fall into an infinite loop where the length is ever decrementing. Looking one time into the doBlobData function we can see the crashing point. The size shown at [1] is the passed in EAX from the previous function. Without a way to stop this number gets decremented down until it passes a negative value into the memcpy causing an out of bounds write. Due to the fact that multiple concurrent connections can be made there may be a way to use threads to stop the memcpy and cause an exploitable condition to arise. 2017-02-07 - Vendor Disclosure \n2017-03-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0282');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (391, 'Pharos PopUp Printer Client DecodeBinary Code Execution Vulnerability', 'None', '2017-3-7', 'An exploitable buffer overflow exists in the psnotifyd application of the Pharos PopUp printer client version 9.0. A specially crafted packet can be sent to the victim\'s computer and can lead to a heap based buffer overflow resulting in remote code execution. This client is always listening, has root privileges, and requires no user interaction to exploit. Pharos PopUp Printer Client 9.0 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H CWE-122 - Heap-based Buffer Overflow Pharos PopUp Printer client is printing software that is widely used in Universities all over the United States. This client is a way to manage multiple connections to a single printing point and is constantly listening in the background for a packet from the printer. It is also running with root privilege for easy access to any privileged drivers. These all make this an excellent target where a vulnerability could have a high impact. The vulnerability is located inside of the DecodeBinary function. The packet encodes binary data and adds the length of the data to the beginning. By passing in an overly large length the application can be caused to overflow the buffer with controlled data and an exploitable condition arises. The relevant code is shown below. Starting at [1], we see the data location being loaded from a struct and moved into RSI. A few checks are made on the data which is controlled by the attacker and can be easily bypassed. Then at [2], we see some data being moved directly from the attacker controlled packet and into EDX. Further down, [3], we see a call to xor_decode which is of interest because the third argument to that function is EDX. The relevant function code for xor decode is shown below.  At the beginning, EDX is being checked against zero, [1], then we subsequently fall into a loop. Some data is then grabbed from the packet structure and used at location [2]. This is XOR\'d against user data in an attempt to deobfuscate the packet received. Continuing down a touch further we see an increment to RSI, CL and a decrement to EDX. EDX is then tested against zero and it is clear the loop will continue until EDX reaches zero. This means that the loop will be executed however many times the attacker passed in from the previous function, directly taken from the packet. The code will continue incrementing the packet pointer in RSI, causing a buffer overflow of attacker controlled data and ultimately leading to remote code execution. Talos would also like to thank NYU Osiris Lab for helping out with some of the reversing. 2017-02-07 - Vendor Disclosure \n2017-03-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0283');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (392, 'Pharos PopUp Printer Client DecodeString Code Execution Vulnerability', 'None', '2017-3-7', 'A denial of service vulnerability exists in the psnotifyd application of the Pharos PopUp printer client version 9.0. A specially crafted packet can be sent to the victim\'s computer and can lead to an out of bounds read causing a crash and a denial of service. Pharos PopUp Printer Client 9.0 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L CWE-125 - Out-of-bounds Read Pharos PopUp Printer client is printing software that is widely used in Universities all over the United States. This client is a way to manage multiple connections to a single printing point and is constantly listening in the background for a packet from the printer. It is also running with root privilege for easy access to any privileged drivers. These all make this an excellent target where a vulnerability could have a high impact. The vulnerability begins inside of the DecodeString function. The packet strings are sent to the program encoded in an encoding format. This function parses the string from the packet and increments the packet pointer to the next data. It does this by reading in the length of the string from the packet just before the string to be parsed. It then adds this value to its current location to position itself at the next data to be parsed. This code is shown below. Starting at [1], we see the string location being loaded from a struct and moved into RSI. A few checks are made on the data which is controlled by the attacker and can be easily bypassed. Then at [2], we see some data being moved directly from the attacker controlled packet and into EDX. Further down, [3], we see this attacker controlled length directly added to the pointer. Later in the code a call to CheckPacketEnd is made and the pointer is used again. The code is below. At location [1],  the pointer for the end of the string is moved into RBX. It is then immediately dereferenced and compared against zero, [2]. This pointer is never validated and indeed points out of bounds after being manipulated in the previous function. This leads to an out of bounds access and a denial of service condition. 2017-02-07 - Vendor Disclosure \n2017-03-07 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0281');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (393, 'Iceni Argus icnChainAlloc Signed Comparison Code Execution Vulnerability', 'None', '2017-2-27', 'An exploitable heap corruption vulnerability exists in the loadTrailer functionality of Iceni Argus version 6.6.05.\nA specially crafted PDF file can cause a heap corruption resulting in arbitrary code execution.\nAn attacker can send/provide a malicious PDF file to trigger this vulnerability. Iceni  Argus  Version 6.6.05  (Sep 22 2016) NK Linux x64 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This product is mainly used by MarkLogic for PDF document conversions as part of their web based document search and rendering.\nA specially crafted PDF file can lead to an heap corruption and ultimately to remote code execution. we see that memset in   function causes an overflow in tje buffer allocated in  . We will now analyze the   function and try to figure out\nwhere the memset   parameter is coming from and in which conditions it will cause overflows.\nA pseudo code fragment of   looks like this: In the above listing we see that the memset   parameter strongly depends on the   field value at Line 9,\nwhich comes directly from a file. This value takes a part in couple arithmetic operations: at lines 21 and 29\nand the result of that is used as a parameter to memset.\nAt line 26 we see potential (re)allocation for the same value   as used later for memset but that doesn\'t seem to happen and the code ends up overflowing a buffer allocated in  . Let\'s take a look at  : At line 17, we see that a new allocation can occur for specified value   but before this line is reached a couple of checks need to be passed.\nInside the while loop starting at line 6 we see a check (line 8) where   is compared with the available chunks size (the application uses a custom allocator for objects), but the comparison is made\nfor a signed value (see the definition of the   var at line 3).\nIf the value of   is bigger than INT_MAX (generally, a negative value), the check at line 8 will be true and the allocation for new space will not happen. The existing chunk of allocated memory will be returned and used later in the memset. An example of a PDF which leads to overflow situation looks like this : The value of the   field is set to -1 what cause that we land in   with the following parameters. Of course   passes all mentioned constraints leading to situation where proper space is not allocated.\nBecause the value passed to   just needs to be a negative value and we have direct influence on the   field,\nwe can easily calculate entire range of values which will cause that situation. (0x80000000 / 2 ) / 24 = 0x2aaaaaa\n0x2aaaaaa + 1 = 0x2aaaaab ( 44739243 ) So all values from 0x2aaaaab to 0xffffffff used as a value in   field will lead to an overflow. 2016-10-10 - Vendor Disclosure  \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0228');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (394, 'Ichitaro Office Excel File Code Execution Vulnerability', 'None', '2017-2-27', 'A vulnerability was discovered within the Ichitaro word processor. Ichitaro is published by JustSystems and is considered one of the more popular word processors used within Japan. Ichitaro handles Microsoft Excel\'s .xls file format. When processing a record type of 0x3c from a Workbook stream from an .xls, the application trusts that the size is greater than zero, subtracts one from the length, and uses this result as the size for a memcpy. This results in a heap-based buffer overflow and can lead to code-execution under the context of the application. JustSystems Ichitaro http://www.ichitaro.com/ 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This vulnerability revolves around an unchecked integer underflow of the size of a Record of type 0x3c within a Workbook stream in an .xls file handled by Ichitaro. The modules involved in the vulnerability are below (as described by   in windbg): While reading a record of type 0x3c, the application calculates the number of bytes it needs to copy into memory. This calculation involves subtracting one from a value read from the file itself (offset 0x1afef in the provided sample) causing an integer underflow. Later in the same function, this underflowed value is passed to the function handling the copying of file data. The main copy function does have a check to ensure that the size is greater than zero. The underflow value flys under the radar though and passes all checks. Below is the copy function commented with relevant variable names. Note, due to the same register being pushed in the above assembly, both   and   in the below C code are equal. The   address is an allocation with size also from the file of the surrounding element with type   (offset 0x1afe5 in the provided sample). This size is multiplied by 2 before being passed to a  . Now that an attacker can control both the size of the allocation, trusted from the file, and the size of a memcpy, by leveraging an integer underflow, a heap-based buffer overflow can occur, which can lead to arbitary code execution. 2016-08-29 - Vendor Disclosure  \n2017-02-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0197');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (395, 'Iceni Argus TrueType Font File Cmap Table Code Execution Vulnerability', 'None', '2017-2-27', 'An exploitable heap-based buffer overflow exists in Iceni Argus. When it attempts to convert a PDF containing a malformed font to XML, the tool will attempt to use a size out of the font to search through a linked list of buffers to return. Due to a signedness issue, a buffer smaller than the requested size will be returned. Later when the tool tries to populate this buffer, the overflow will occur which can lead to code execution under the context of the user running the tool. Iceni Argus Version 6.6.04  (Sep  7 2012) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This is a heap-based buffer overflow that occurs in a conversion tool that comes with Iceni Argus. This tool is used primarily by MarkLogic to convert PDF files to (X)HTML form. When parsing a font file embedded within a PDF, the tool will call the   function which will call   to get the different tables located within a font file. Inside the   function, the tool will eventually allocate space for the subtable offsets for each entry in the \"cmap\" table. If the font is corrupted the following code will get executed and the size will be clamped to 0x64 * 4 (0x190). After allocating the space, the tool will read data from the offset table into this buffer. In the following code, the table will be searched for specific values. When the loop terminates, the resulting index will be left in -0x548(%ebp) and the font object in %esi. After finding the index, the tool will then use this index to grab a size out of the \"cmap offset\" table. Once this size is fetched, this will be added to the base size property from the object that was discovered above and stored in %esi. Immediately afterwards, this size is passed to the icnBufferAlloc function which actually contains a signedness issue. If a signed value is used to allocate with this function, then an undersized buffer will be returned as the algorithm for   searches through a linked list for a buffer size that is larger than the argument passed to it. The   function, which is responsible for allocating memory out of a linked list, will take two arguments, one of which is the \"icn\" object and the other of which is a size. This function contains a signedness issue with regards to the size that\'s passed to it. After adding 1 to the size, the function will loop through a linked list pointed to by the first argument while checking to see if the size defined in the list is larger than the size provided as the second argument. If the allocated size is less than 0, then any buffer within the linked list will be returned. After allocating with  , the convert tool will return back to   and then execute the following code. This code passes the potentially undersized buffer along with the size to   which will read data from the file directly into the buffer. Due to the buffer that was allocated potentially being smaller than the space that\'s being read as a result of the signedness issue, a buffer overflow can be made to occur. 2016-10-10 - Vendor Disclosure \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0211');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (396, 'Iceni Argus ipStringCreate Code Execution Vulnerability', 'None', '2017-2-27', 'An exploitable heap overflow vulnerability exists in the ipStringCreate function of Iceni Argus Version 6.6.05. A specially crafted pdf file can cause an integer overflow resulting in heap overflow. An attacker can send file to trigger this vulnerability. Iceni Argus 6.6.05 (Sep 22 2016) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H \nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 CWE-190: Integer Overflow or Wraparound This product is mainly used by MarkLogic for pdf document conversions as part of their web based document search and rendering.\nA specially crafted PDF file can lead to an heap corruption and ultimately to remote code execution. Let\'s take a look at body of this function: In   where the buffer for the string object is allocated, an integer overflow can appear in the second argument. For  , an argument value bigger than 0xfffffff4 will trigger this occurence. Next in  \nwe see that the   argument content is copied to the allocated buffer. As we can see the   argument will have bigger value than  +11 which will lead to heap corruption. There is a missing check for a potential error code returned from   which is requal -1 (0xffffffff). We see in   that returned value is directly assigned to   variable\nand next this variable is passed as 3th argument to  . As mentioned before, for values bigger than 0xfffffff4 integer overflow will occure in   leading to heap overflow. 2017-01-11 - Vendor Disclosure \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0271');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (397, 'Iceni Argus PDF Inflate+LZW Decompression Heap-Based Buffer Overflow Vulnerability', 'None', '2017-2-27', 'An exploitable heap-based buffer overflow exists in Iceni Argus. When it attempts to convert a malformed PDF with an object encoded w/ multiple encoding types terminating with an LZW encoded type, an overflow may occur due to a lack of bounds checking by the LZW decoder. This can lead to code execution under the context of the account of the user running it. Iceni Argus Version 6.6.04  (Sep  7 2012) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This is a heap-based buffer overflow that occurs in Iceni Argus. This tool is used primarily by MarkLogic Server to convert PDF files to (X)HTML form. While decoding an encoded object that is encoded within a PDF with more than one encoding type where one of them is LZW, the tool will call the   function to initialize the decoder for an object that is LZW encoded. The object is created by first allocated a 0x545c byte buffer which will set aside 0x1000 bytes of space at the end of it for decoding. This is assigned as a pointer which is written into an object at line 0x80cb2b8. Within the same function,  , the constructor will initialize space for an array containing the decoding-table/code-dictionary. Each entry is initialized with 0x101 (end-of-data) for the value along with an index. This is done all the way up to index 0x100. Inside the following loop, the application will look through the code-dictionary and grab each index along with its respective value. This loop will only terminate if the specified index points to an end-of-data entry. If during decoding the end-of-data entry is not found combined with the loop iterating more than 0x1000 times, a buffer overflow can be made to occur due to a missing boundary check for terminating of the loop. 2016-10-10 - Vendor Disclosure  \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0212');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (398, 'Iceni Argus PDF Uninitialized WordStyle Color Length Code Execution Vulnerability', 'None', '2017-2-27', 'An exploitable uninitialized variable vulnerability which leads to a stack-based buffer overflow exists in Iceni Argus. When it attempts to convert a malformed PDF to XML a stack variable will be left uninitialized which will later be used to fetch a length that is used in a copy operation. In most cases this will allow an aggressor to write outside the bounds of a stack buffer which is used to contain colors. This can lead to code execution under the context of the account running the tool. Iceni Argus Version 6.6.04  (Sep  7 2012) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This is an uninitialized variable that leads to a stack-based buffer overflow that occurs in Iceni Argus. This tool is used primarily by MarkLogic to convert PDF files to (X)HTML form.\nWhen aggregating styles for the different words defined within a page\'s content, the convert app will first try to grab a style that has already been created by calling  . Inside the   function, the app will call   to get the object representing the actual color, and then pass the result to the   function.    will simply seek into an object and return a pointer inside one of its properties. Due to some malformed colors defined by the \'rg\' opcode, this returned pointer will be left initialized as 0 and contain no color information. Inside the function  , the tool will read a byte from the buffer initialized by 00. At address 824b1c2, this causes an integer underflow which means the branch at 824b1c7 will be taken. This function is supposed to copy data from the 3rd argument into the pointer at the 2nd argument, but due to the integer underflow causes the function to return without writing any data to the buffer pointed to by the 2nd argument. After returning back to   with the buffer left uninitialized, the application will try and read a byte from the buffer and use it as a terminator to a loop that follows. This loop will actually copy the color data from a source to the destination using the variable at -0x99 as the sentinel for the loop. The size of the target buffer appears to be a maximum of 4 DWORDs, and it takes around 10 DWORDs to get to the stack frame pointer. If the uninitialized value on the stack is larger than 4, then the stack buffer is being overflown. The size of the stack frame for   adds -0xac bytes to the frame pointer and the sentinel is at offset -0x99 relative to the frame. The difference between these is 0x13 bytes which means that in order to control the sentinel, something controlled must be written to 0x10(%ebp) or 0xc(%esp) in the caller. It turns out that there\'s only two places in the   function that immediately write to the byte in this DWORD. At address 0x8161013, the pointer for   (0x815fea0) is written to 0xc(%esp). This sets the sentinel value for the loop to 0xfe which is larger than 4. In order to set this sentinel value to this specific value, the loop in   must be hit at least once. 2016-10-10 - Vendor Disclosure \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0210');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (399, 'Iceni Argus PDF TextToPolys Rasterization Code Execution Vulnerability', 'None', '2017-2-27', 'An exploitable integer-overflow vulnerability exists within Iceni Argus. When it attempts to convert a malformed PDF to XML, it will attempt to convert each character from a font into a polygon and then attempt to rasterize these shapes. When rasterizing these shapes, the tool will perform a multiplication to determine the bounds at which the shape can be filled as well as use it to perform an allocation. Due to a lack of bounds checking, this multiplication can result in an integer larger than 32-bits which is an integer overflow. As the application attempts to iterate through the rows and initializing the polygon shape in the buffer, it will write outside of the bounds of said buffer. This can lead to code execution under the context of the account running it. Iceni Argus Version 6.6.04  (Sep  7 2012) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This is an integer overflow that occurs in Iceni Argus. This tool is used primarily by MarkLogic Server to convert PDF files to (X)HTML form. Due to the integer overflow, two different lengths will be used for an allocation and for a copy. The object that contains the objects with the sizes which are used in the overflow is created in the   function. Inside this function an object of size 0xadf8 is allocated. For every single text item inside the document that uses the showTextOld opcode, the   function is called. Inside this function the   function will copy a pointer from the +4 field (+0xaa0c:4) into the +8 field (+0xaa0c:8) of the 0xadf8 sized object. For each character, the tool will processor a character, convert it into a TextPath and then convert it into a polygon. After a polygon is completed, the tool will call   to fill each of the polygons. While calling   the application will execute the following code in  . This code will take the product of the dword at 0x108(%esi) and the one at 0x10c(%esi) and store it in %edi at 0x821432d. Later this register will be passed as an argument to   at 0x821434d which will allocate space that will later be written to. Due to a missing check that the product of these two values are not larger than 31-bits, the resulting product may wrap which will cause the allocation size to be smaller than expected. The buffer that\'s allocated will then be written to +0x108 (+0xaa0c:8:108) of the 0xadf8 object. These lengths will later be used as boundaries for rasterizing a polygon. Later while filling a polygon, the tool will load these values into the floating point co-processor to perform some math. Afterwards, the instructions will store the results as integers into variables on the stack at -0x98(%ebp) and -0xa0(%ebp). The first Y index will also be stored in integer form at -0x14(%ebp) and within the %esi register. Aftewards, the code will enter a loop that will iterate through using these values. Due to the only the product of these integers overflowing, the call to   will be called for every pixel inside the under-allocated buffer as defined by the integers stored in -0x38(%ebp) and -0xa4(%ebp). The   function will essentially wrap   which actually performs the write.. Within   the application will check to see if the current values are within the correct bounds, and then later use these values to write a null byte relative to the buffer at +0xaa0c:8:108. Due to the buffer being undersized while the tool attempts to fill the rasterized polygon, a buffer overflow may occur. 2016-10-10 - Vendor Disclosure  \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0214');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (400, 'Iceni Argus PDF Font-Encoding GlyphMap Adjustment Code Execution Vulnerability', 'None', '2017-2-27', 'An exploitable arbitrary heap-overwrite vulnerability exists within Iceni Argus. When it attempts to convert a malformed PDF to XML, it will explicitly trust an index within the specific font object and use it to write the font\'s name to a single object within an array of objects. Due to it explicitly trusting this index, one can specify an out-of-bounds index which will cause a pointer to a string to be written outside the bounds of the specified array. This can lead to code execution under the context of the account running it. Iceni Argus Version 6.6.04  (Sep  7 2012) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This is a heap-based arbitrary write vulnerability that occurs in Iceni Argus. This tool is used primarily by MarkLogic Server to convert PDF files to (X)HTML form. While attempting to adjust the glyphmap for a particular font embedded within a .PDF file, the tool will explicitly trust an index and use it to write a pointer to the font\'s name outside the bounds of an array. Within the   function, the tool will allocate 0x17f4 bytes of space using  , and write it to -0xdc(%ebp). Later the pointer returned will be passed to  . Inside the  , the tool will take the pointer passed to it and add 0x10. Afterwards this resulting pointer will then be stored in -0x30(%ebp). Within the same function the tool will search through a dictionary for a value with the key of \"Differences\". This returns the pointer to an object that contains the array from the file containing the bad index. This object is stored in -0x20(%ebp). Afterwards the object containing the index that is trusted is passed to  . This function will iterate through the array that is within the object that was grabbed from the \"Differences\" dictionary. Once inside the   function, the following loop will iterate through every glyph inside the object grabbed from the dictionary. Once inside this loop, the tool will compare an index that is grabbed to ensure it\'s less than a maximum value. Due to a signedness issue, this check will pass. With the provided sample the bad index that is read out of the object is 0xedffffff. This index will get stored into the %edi register. To determine the glyph\'s name which will get written, the following code gets executed. This first calls  , followed by a call to  . The resulting pointer is written to -0x24(%ebp). After grabbing the name, the index that is stored is then checked if it\'s larger or smaller. There is a signed-ness check here for both bounds, however the index is not modified and instead used at 0x80bb076 to write the glyph name too. Due to none of the checks modifying the %edi register, this value is explicitly multiplied by 4 and trusted to index into the destination array passed as the second argument. This can allow for an aggressor to write a pointer to a string at an arbitrary place in memory which can lead to memory corruption. Under the correct circumstances this can lead to code execution. 2016-10-10 - Vendor Disclosure \n2017-02-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0213');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (401, 'Ichitaro Office JTD Figure handling Code Execution Vulnerability', 'None', '2017-2-24', 'A vulnerability was discovered within the Ichitaro word processor. Ichitaro is published by JustSystems and is considered one of the more popular word processors used within Japan. Ichitaro\'s proprietary file format is a Compound Document similar to .doc for Microsoft Word called .jtd. When processing a Figure stream from a .jtd, the application will allocate space when parsing a Figure. When copying filedata into this buffer, the application will calculate two values to determine how much data to copy from the document. If both of these values are larger than the size of the buffer, the application will choose the smaller of the two and trust it to copy data from the file. This value is larger than the buffer size, which leads to a heap-based buffer overflow. This overflow corrupts an offset in the heap used in pointer arithmetic for writing data and can lead to code-execution under the context of the application. JustSystems Ichitaro http://www.ichitaro.com/ 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H Ichitaro uses the Structured Storage documentation format to read and process a .jtd file. Although there are many streams within a .jtd, the two streams that affect this bug are Figure and FigureData. Figure is the metadata for Figures and FigureData is contents representing the Figure. The modules involved in the vulnerability are below (as described by   in windbg): In the following code, the application isolates a   byte chunk out of a previously allocated   chunk ( ). This chunk is used to store FigureData which is processed later. The reason this occurs is to write the size of this chunk after the isolation. This leaves the chunk with the size at the end of the object and a pointer to the end of the object. Pseudocode:\nbase ptr = base ptr - 2) = 0x3006 Later in the code, the application will reset the writing pointer to point back to the beginning of the chunk using the aforementioned saved size. This   is then saved for later use by Ichitaro. The application can now read the size of a given Figure from the Figure header. This value is multiplied by 6 since each of the elements that will be read later in the program are 6 bytes in length. From this code, one suspect value is saved and will be returned to later ( ). There is also a second value calculated based on the FigureData itself. The application reads the subelement lengths from the FigureData header by reading the second byte of each element representing a number of subelements. To calculate the possible figure length from this header, an accumulation value starts at 0. The application starts by adding   to the accumulation value and   for each subsequent element, as shown below: After saving the possible length using elements, the application also must take into account subelements. Thus,   is added to the accumulation value for each of the subelements. This final value will be refered to as  . Before copying the FigureData into the allocated region, a   occurs to determine the size to copy. The application will choose the smaller of the two values, regardless if it is actually greater than the original   chunk size. Using this value, the application will overwrite the saved chunk size (offset   from the above arithmetic). During the manual unallocation of the   chunk from the larger   chunk, the corrupted size value results in a pointer that is read out of bounds of the   initial chunk and is saved for later use. Because this pointer is trusted by the application and reused later, an attacker can potentially gain arbitrary write conditions leading to arbitrary code execution. 2016-08-29 - Vendor Disclosure \n2017-02-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0196');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (402, 'Ichitaro Word Processor PersistDirectory Code Execution Vulnerability', 'None', '2017-2-24', 'Ichitaro Office contains a vulnerability that exists when trying to open a specially crafted PowerPoint file. Due to the application incorrectly handling the error case for a function\'s result, the application will use this result in a pointer calculation for reading file data into. Due to this, the application will read data from the file into an invalid address thus corrupting memory. Under the right conditions this can lead to code execution under the context of the application. JustSystems Ichitaro 2016 Trial \n 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H Ichitaro\'s word-processor includes the ability to parse data from various Microsoft Office document formats. Each of these document formats are stored using Microsoft\'s Structured Storage format. When using these formats, the document contents are organized in the form of a list of streams. Within each stream is a list of records that are used to describe the attributes and contents of various parts of the document. When processing a Powerpoint Document (.ppt), the application will first have to identify the \"PowerPoint Document\" stream. Once the correct stream has been identified, the application will proceed to read records within the file in order to render its contents to the user. Each of these records are referred to as an Atom which is prefixed with a type and length and followed by its contents. In order to determine the records of the document that were last edited, the application will first look up the \"Current User\" stream. This stream is typically a single-record that describes where the PersistDirectory records are at within the \"PowerPoint Document\" stream. The application begins to do this at address 0x6bd64a1. Once identifying the correct streams and storing them at +0x28 and +0x2c of an object, the application will read 0x14 bytes for the structure \"CurrentUserAtom\" from the \"Current User\" stream. This is portrayed in the following code. After the CurrentUser record\'s structure has been filled, the application will use one of its fields, OffsetToCurrentEdit, to determine where the actual UserEditAtom is located within the PowerPoint Document stream. the application does this by seeking into the stream at address 0x6bd65b7. Afterwards, the application will read 0x1c bytes for the UserEditAtom header, and then call into the function at 0x6bd6601. The function at 0x6bd7372 will construct an object for the PersistDirectory within the Powerpoint file and read the number of directory entries as described in the file format specification. Inside the function at 0x6bd7372, the application will allocate space for a 0x4c object and initialize it with a record-type of 0x1772. This record-type corresponds with the PersistDirectory record described within the Powerpoint specification. The constructor for this 0x4c object is also responsible for initializing the index that is overflown at offset 0x40 of the structure. This index is used to calculate the total number of offsets that are maintained within the PersistDirectory records for the document and is used to determine how much space to allocate for them. After constructing the 0x4c byte object, the application will return back to the function 0x6bd7372 at the address 0x6bd73d0. This function contains numerous loops in order to properly parse the UserEditAtom and all the PersistDirectory entries within a document. The outer-most loop will read the UserEditAtom, seek to the dword specified in the offsetPersistDirectory field, and then will simply consume all the offsets of the record within the PersistDirectoryAtoms. For each iteration of this loop, the application will read a dword that determines the PersistId as well as the number of offsets that are stored as cPersist. Using cPersist as the number of offsets to read, the next loop will then read each offset and update the fields in the object at %ebp-10. This object is responsible for containing the PersistId as well as each offset for every single persist directory entry within the document. The field at 0x40 of this object will be incremented for each offset that is read out of all the records within the document. Immediately following this loop, the application will process the rest of the PersistDirectory records linked by the first record. It does this by checking to see if CurrentAtom.offsetLastEdit is 0. If this is true, the loop will terminate. Otherwise, the loop will seek to the specified offset of the document and continue to read offsets out of the record similarly to the first loop described earlier. Inside this loop, the application will seek to the file offset specified in the current record\'s OffsetLastEdit field. The root of this vulnerability is due to an aggressor being allowed to specify an OffsetLastEdit field that points to any number of chained records. This allows for an attacker to be able to control when this loop terminates and can set the number of offsets to any value they deem useful. This loop has a similar functionality of reading offsets based on the value of the cPersist and PersistId fields that was described prior. This can be used to corrupt arbitrary memory which will be described later. Before entering the inner-most loop for reading offsets, however, the application will determine the PersistId and the number of offsets that follow by reading a dword and extracting a number from it\'s bits. These will be used to read the number of offsets from the document and store them for retrieval later. The function call at 0x6bd763a will be used to store the offset and PersistId for each iteration of the loop. At the function 0x6be0c2e, the application will allocate 8 bytes of space to store the PersistId and the offset. Also within this function, the aplication will update the current index of offsets. This is done to offset 0x40 of the PersistDirectory object that was allocated with the enumeration 0x1772 earlier. This counter represents the number of offsets that have been read and will be increased without any constraints on it\'s bounds. Due to a potential attacker being able to control when the linked list of Persist Records terminates as well as the number of offsets that are within a record allows one to set this field to any value that they choose. The function at 0x6bd87a0 is simply a wrapper that calls 0x6be5ba0. Inside the function at 0x6be5ba0, the application will check to see if there\'s enough space for the current number of offsets. If this is not the case then the application will increase the current size by a power of two and then resize it using realloc. It is at address 0x6be5bf6 that the application immediately stores this to *this+8 without checking to see if realloc has returned a failure result (NULL). Due to this oversight, the function call can fail under memory pressure which causes some pointer arithmetic that follows to point outside the bounds of the original allocation. Immediately after resizing the buffer to the next power of two, the application will proceed to write the user-controlled offset to NULL + Index*4. This actually happens at address 0x6be5c38. Normally a near-NULL write is not exploitable on modern systems due to NULL page constraints, but due to an attacker nearly being able to control the index that\'s being added to this pointer, one can specify an index that\'s larger than a page. In this situation, utilizing a technique such as a heapspray to force a useful data structure being mapped at an address that\'s a power of two, an aggressor could potentially corrupt memory that might allow them to manipulate more of the state of the application. Ichitaro Word Processor is able to open various file formats that have been created by the Microsoft Office Suite of applications. These file formats are encoded in a filesystem of sorts known as the Structured Storage file-format. The Structured Storage file-format has the ability to encode multiple files/streams within the document. It is within these streams that the contents of the document can be located. Each of these streams contain a list of records that are each prefixed with the following header. Within this structure, a record contains a 4-bit version followed by a 12-bit Instance. Following it is a 16-bit type, a 32-bit length, followed by the record\'s contents. Despite the contents of a Powerpoint document being primarily contained within the \"PowerPoint Document\" stream, the application starts by reading the contents of the \"Current User\" stream. The Current User stream consists entirely of just a single record named the CurrentUserAtom. At offset 0 of the stream will be the following structure. Within this structure at offset 0x10 is a dword that represents the offset into the \"PowerPoint Document\" stream. This offset points to another structure named the UserEditAtom which contains information about the previous edits that were made to the document. The offset in the following structure is based it\'s location within the provided sample. At offset 0x86b7e of the \"PowerPoint Document\" stream is the UserEditAtom record. This record has a type of 0xff5 and is where the vulnerability begins. This atom is the record that the application uses in order to locate the PersistDirectory records and where a linked list based on the offsetLastEdit field is located. At offset 0x10 of this record type is a pointer to the next UserEditAtom. If this is set to non-zero, the application will continue onto the next UserEditRecord that is described by this offset. For each of the UserEditAtom records, the application will dereference the field at 0x14 to identify the PersistDirectoryAtom containing the list of offsets. The offsets for all of these UserEditAtom records are then aggregated into the buffer that is inreased by powers of two. When loading the contents of this record type, the application descends into the offsetPersistDirectory record in order to load the different offsets of the edits that have been made to the document. This record contains an array of elements with the following format. This format is a dword where the ficount and id are encoded. The first 12 bits represent the number of offsets that follow, whereas the other 20 bits representing an unique identifier. Immediately following this dword is the array of offsets. This array of offsets is what the vulnerability writes out-of-bounds. Each of these elements then repeat until they meet the size of the record described in it\'s header. As an example within the provided proof-of-concept, the following 2-element array begins at offset 0x86b66 of the stream. The vulnerability actually occurs due to the application not restricting the number of offsets that it will read out of a list of UserEditAtom records. If an aggressor specifies a list of UserEditAtoms (using the value of offsetLastEdit) that either does not terminate due to it being self-referencing or aggregates a number of offsets (up to a power of 2) in which the target is unable to allocate space for then this will allow an aggressor to corrupt memory at the same power of two relative to the null page. This can be done by using a combination of either multiple PersistDirectory entries with a high count for the number of offsets or multiple UserEdit atoms. 2016-08-28 - Vendor Disclosure \n2017-02-24 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0199');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (403, 'Aerospike Database Server Client Batch Request Code Execution Vulnerability', 'None', '2017-2-21', 'An exploitable out-of-bounds write vulnerability exists in the batch transaction field parsing functionality of Aerospike Database Server 3.10.0.3. A specially crafted packet can cause an out-of-bounds write resulting in memory corruption which can lead to remote code execution. An attacker can simply connect to the port to trigger this vulnerability. Aerospike Database Server 3.10.0.3 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-823 - Use of Out-of-range Pointer Offset Aerospike Database Server is both a distributed and scalable NoSQL database that is used as a back-end for scalable web applications that need a key-value store. With a focus on performance, it is multi-threaded and retains its indexes entirely in ram with the ability to persist data to a solid-state drive or traditional rotational media. For handling packets received by a client, the server spawns multiple threads which each execute the   function. When a socket is ready to be read, the server will receive data from the socket and determine the packet\'s message type. If it\'s protocol type specifies that the packet is compressed (PROTO AS COMPRESSED), the server will decompress the contents of the packet with zlib [1] and then continue to process the packet as a type of PROTO AS TYPE MSG, the server will check some flags within the header and use it to determine what type of request is being made. If one of these flags specifies the AS INFO1_BATCH option, the server will pass the packet to the   function [2]. Inside the   function, the server will first parse the header [1] and then proceed to iterate through all the fields defined in the packet looking for fields with the type AS FIELD BATCH or AS FIELD BATCH SET. If a field with this type is discovered, the function will save it to the   variable [2]. Later, the server will then process the specific field by reading a uint32_t [3] which is used as the number of records to read from the packet followed by a byte [4] that determines whether the transaction described in the packet is processed in-line or not. The server will then enter a loop to read each record out of the packet. Inside the loop, the server will check to see if the   boolean is set. If it\'s not, the server will proceed to create a   structure in order to satisfy the batch request made by the client [1]. If the   boolean is set, the previous message is reused in order to complete the transaction [2]. It is prudent to note that if the first transaction is set to repeat, an uninitialized transaction will be queued to the server which can cause a denial-of-service condition. After determining that a transaction should be read from the packet, the server will read two uint16_t values to determine the number of fields ( ) and number of operations ( ) [3] that need to be read. After reading the number of fields and the number of operations, the server will iterate through the packet calling   [1] for each field, and set a flag if a field is of the type AS FIELD SET [1]. To seek to the next field within the packet, the server will call   [2]. This function will simply read a uint32_t out of the packet as a size and add it to the pointer that is provided as the argument. Due to a missing bounds check within the loop, the call to this function can seek the   variable outside the bounds of the packet at which point the next iteration of the   call can flip the byte-order for the size. This can cause memory corruption which can lead to code execution under the context of the server. Immediately after processing off the transaction operations within the packet, the server correctly checks to see if any seeking causes the   variable to be seeked out-of-bounds [3]. This is done for both the   structure itself and when using the size defined within to seek to the next operation. To execute the provided proof-of-concept, simply extract and run it as follows: A client packet for Aerospike server has the following structure. The first 2 bytes describe the protocol   and the protocol  . The   must be 0x02, where the protocol   can be one of two values. If AS MSG(0x04) is specified, then the contents of   are zlib-encoded. Otherwise, the AS_MSG(0x03) value is used. The size of this data is defined by the   field which is a 48-bit unsigned integer. The contents of the   field has the following structure. In order to submit a batch message, a flag needs to be specified in the   field. When the fourth bit is set (0x08) the packet is representing a batched transaction that intended to be queued. After this flag is set, the number of protocol fields is specified in  . The provided proof-of-concept sends a packet with two fields encoded within. Each field will begin with a 32-bit size. This size includes the number of bytes that represent the type as well as the contents of the   field. The two field types that are required are the NAMESPACE(0x0) type and the BATCH(0x29) type. The NAMESPACE(0x0) type simply contains an ascii-encoded string describing the namespace to query within the   field. The BATCH(0x29) field has the following structure. The   variable describes the number of transactions that are within. The provided proof-of-concept includes two transactions of which only one is required. The   byte that follows describes whether the transaction should be executed in-line or queued for later and does not affect the triggering of this vulnerability. Each transaction begins with a 25-byte header. The last byte of this header represents which type of transaction record is described. If it is set to 0x01, then a repeat record is used otherwise an actual \'as s\' structure within the packet. The vulnerability described in this advisory revolves around the fields described within an embedded \'as s\' packet and so, as a result, the 25th byte of the header must be defined as 0x00. The first batch transaction and it\'s header is as follows. Due to the   byte in the header being 0x00, the structure at offset 0x2d of the packet contains an   type. When processing this type encoded within a BATCH(0x29) field, the transaction   is encoded as a truncated   type and has the following format. The contents of   and   are mostly ignored by Aerospike Server. At offset 0x46 of the packet produced by the proof-of-concept is the truncated   of the as s structure. This structure begins with the   byte and is followed by two fields,   and  , which describe the number of fields that follow. Due to an assumption made by the server, there must be at least two fields within this structure to reach this vulnerability. Despite the two fields in the   field being of the type SET(0x1), the   field does not affect the vulnerability. The vulnerability exists due to the application not checking if the   of each field in   will seek the pointer outside the bounds of the packet data. If the aggregate sum of all of the   uint32 t,  , at offset 2 of the packet), then this vulnerability is being triggered. The provided proof-of-concept sets both of these lengths to the largest possible uint32_t. 2016-12-23 - Vendor Disclosure \n2017-02-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0265');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (404, 'Aerospike Database Server Fabric-Worker Socket-Loop Denial-of-Service Vulnerability', 'None', '2017-2-21', 'An exploitable denial-of-service vulnerability exists in the fabric-worker component of Aerospike Database Server 3.10.0.3. A specially crafted packet can cause the server process to dereference a null pointer. An attacker can simply connect to a TCP port in order to trigger this vulnerability. Aerospike Database Server 3.10.0.3 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-476 - NULL Pointer Dereference The Aerospike Database Server is both a distributed and scalable NoSQL database that is used as a back-end for scalable web applications that need a key-value store. With a focus on performance, it is multi-threaded and retains its indexes entirely in ram with the ability to persist data to a solid-state drive or traditional rotational media. When receiving a packet on the fabric port (3001/TCP) the server will read data from a socket [1]. Upon receiving a packet, the data returned will be passed as an argument to the   function at [2]. Inside this function, the server will extract the size and type of the packet and write them to the variables   and  . Inside the   function, the server will ensure that the buffer is >= 6 bytes. Afterwards, the buffer will be casted to a   structure which contains a size and a type [1]. After flipping the byte-order to the architecture\'s native format [2], the size and type will be written to the pointers passed in the function\'s arguments. Upon returning to the  , the server will check to see if the resulting size is larger than 0x100000 [1], and then use this size in a following allocation. Due to a missing check of on the result of the call to   [2], an attacker can cause the allocation to fail which when encountering the   that follows will result in a write to a NULL pointer before reading the rest of the packet [3]. To execute the provided proof-of-concept, simply extract and run it as follows: The proof-of-concept sends a packet encoded in big-endian form with the following structure. To trigger this vulnerability, an aggressor simply needs to specify a 32-bit size that is larger than 0x100000 and will cause the target server\'s allocator to fail. The server will add the value of   with the size of a   (6) and then used it in an allocation. Is it recommended to use technology such as a firewall to deny illegitimate users access to the ports required by the server for clustering. 2016-12-23 - Vendor Disclosure \n2017-02-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0263');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (405, 'Aerospike Database Server RW Fabric Message Particle Type Code Execution Vulnerability', 'None', '2017-2-21', 'An exploitable out-of-bounds indexing vulnerability exists within the RW fabric message particle type of Aerospike Database Server 3.10.0.3. A specially crafted packet can cause the server to fetch a function table outside the bounds of an array resulting in remote code execution. An attacker can simply connect to the port to trigger this vulnerability. Aerospike Database Server 3.10.0.3 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-129 - Improper Validation of Array Index Aerospike Database Server is both a distributed and scalable NoSQL database that is used as a back-end for scalable web applications that need a key-value store. With a focus on performance, it is multi-threaded and retains its indexes entirely in ram with the ability to persist data to a solid-state drive or traditional rotational media. When processing a packet from the fabric port, the server will handle it by calling the   function. Inside this function, the server will read data from a socket and then hand the data off to the   function [1]. Once inside  , the server will parse the message in order to determine its type and size [2]. This is done first for an AS FABRIC(0) message type is received from the wire, an attacker can then proceed to send another message type. Once the next message is received, this type will be used as an index into a list of callbacks [4]. This will then hand-off the packet to the correct handler for the specified message type. This particular vulnerability using the M RW(7) message type. Once the message is finally sent to the fabric port,the server will call the   function. Inside this function, the server will extract the operation type from the RW OP(0) field [1]. This enumeration will then be used to choose a case from a switch statement. Although the provided proof-of-concept uses the RW WRITE(1) message type [2], the RW MULTI(5) can also be used to trigger this vulnerability [2]. In order to handle the operation, the server will extract a buffer from the RW RECORD(9) field [1]. This buffer contains a specific format that will then be handed off to the   function for decoding [2]. Also within this structure is an array that contains the index that is key to this vulnerability. Inside the   function is the code that is responsible for parsing the RW RECORD(9) buffer. This buffer starts out with a uint16_t that represents the number of bins which are used to allocate an array [1], and then used to read data from the packet into [2]. After the bins are loaded, the   function will then make a call to   to allocate a buffer on the stack [3]. The call   will re-parse the pickled buffer that was read prior in order to determine the number of bins. Once the number of bins is returned, then a loop will iterate over each \"bin\" within the packet. For each bin, the   function will be called. This function will read an uint8 t  , an aggressor can specify an index that is outside the bounds of the   array [4]. Each element of this array contains a list of function pointers. Once the correct element is determined according to the   index, the   function will be called with the   and   pulled directly from the packet. To execute the provided proof-of-concept, simply extract and run it as follows: Each fabric packet for Aerospike server has the following structure. It begins with a 32-bit  , followed by an 16-bit message  . The   is then used to determine the number of fields that follow. Each field is prefixed with a 16-bit field  , and then a 16-bit storage  . After the storage   is a 32-bit size and then the data that represents the contents of the field. In order to send message types to Aerospike Server, at least two message types must be sent. The first one must be of an AS NODE(0x0) for one of its fields. The FIELD_NODE(0x0) field uses a UINT64(0x4) for its type and can simply be an arbitrary number. Once the AS RW(0x7). This second message sent by the proof-of-concept has the following format. An AS_RW(0x7) packet has a number of fields that can be used to make that particular request. One of the fields is the OP(0x0) which specifies what kind of operation to make. This vulnerability depends on the WRITE(0x1) operation and so the field for OP(0x0) must be defined as a UINT32(0x2) with a value of WRITE(0x1).  In order to reach the vulnerable code described in this advisory, a number of other fields must also be defined. Each of these fields will be described individually. Most fabric packet types include a string representing the NAMESPACE(0x2) that the query is actually referring to. At offset 0x11 of the second packet send by the proof-of-concept is a string representing the namespace as so chosen by the user. This must be a BUF(0x6) type and can contain any kind of arbitrary content. The next field sent by the proof-of-concept, is another string representing the DIGEST(0x5). This must also be a BUF(0x6) type and can contain arbitrary content. The next required field is of the type INFO(0xc). This field is an enumeration and isn\'t required at all to trigger this vulnerability. It is simply set to 0x00000000 although it can be of any value. The two required fields at the end of the packet are of type GENERATION(0x4) and VOID_TIME(0xb). These fields are simply UINT32(0x2) types and are not significant except in that the contents of GENERATION(0x4) must not be equal to 0. The 5th field of the AS_RW(0x7) message type contains an identifier of RECORD(0x9) and storage type of BUF(0x6). This message type contains an embedded structure which is key to triggering this vulnerability. At the beginning of the content of the RECORD(0x9) field is a uint16_t that describes the number of elements that follow. Within the provided proof-of-concept, this is simply set to 0x0001 as there\'s only one element that was required to trigger this vulnerability. Each element has the following structure. This structure is parsed in order to extract the index that is misused by the server. The   field is used to determine the length of the string   defined within the structure. If the   field in any of these elements is larger than 24, then the specified   will index out of the bounds of the array of function tables within the server. Is it recommended to use technology such as a firewall to deny illegitimate users access to the ports required by the server for clustering. 2016-12-23 - Vendor Disclosure \n2017-02-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0267');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (406, 'Apple GarageBand Out of Bounds Write Code Execution Vulnerability', 'None', '2017-2-14', 'An exploitable out of bounds write vulnerability exists in the parsing of saved files in Apple\'s GarageBand version 10.1.5. A specially crafted project file can cause an out of bounds write resulting in an exploitable condition. An attacker can deliver a project file via other means. This vulnerability is the result of an incomplete fix of bug id TALOS-2016-0262 / CVE-2017-2372. Apple GarageBand 10.1.5 8.8 -- CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-123: Write-what-where Condition Garageband is a music creation tool used to create new and original music easily from your computer. GarageBand comes installed for free with all new Mac purchases, meaning there is a large market of people who have this software installed on there computer. The file format used by GarageBand is a proprietary .band file. There exists a vulnerability in the parsing of this format. The format is broken into various segments each with its own properties. This length is controllable by the user and no validation checks are done to ensure this length is in bounds thus leading to an exploitable condition. This vulnerability is due to an incomplete fix of TALOS-2016-0262 / CVE-2017-2372. The code that contains the vulnerability is used for serialization of a string and arises in multiple areas when parsing the format. The initial crash is shown below: Shown above we can see a null byte being written out of bounds due to an invalid calculation of R14 and RCX. Looking through the current function we can see where these values come from. Starting with R14 it can be seen that this is a buffer on the heap. We run malloc history on it and the output is shown below: This is a buffer created for holding the data from our opened document. This means that RCX must be an index into this buffer. Looking where RCX comes from we are led a few lines above: At, [2], we can see var_12 being loaded into ECX only a few lines above our vulnerability. looking further we see this same variable, [0], passed in as the second argument to a dynamic function call. Tracing our input further, we follow it into the dynamic call below: As can be seen,[0], our buffer is moved into R14. It is then zeroed out, moved into the 4th argument, [1], for CFDataGetBytes,[2]. This function gets data from a buffer for a range, designated by RSI and EDX, and stores it into RCX. In this case the range it is extracting is 2 bytes. This extracted data is then used in our original calculation above to index into the original data buffer. The problem arises in the fact that the buffer that data being is extracted from, [2], is user controlled and no input validation is done on the bytes read in. This means that RCX is user controlled and can be any arbitrary 2 byte value. This leads to an exploitable null byte write anywhere. It was originally believed that only this particular structure led to this code path. Upon receiving Apple\'s update it is now apparent that there are multiple different structures utilizing the same parsing code. The code the crash is in is responsible for serializing a string and is used relatively frequently allowing this vulnerability to arise again. 2017-01-24 - Vendor Disclosure \n2017-02-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0275');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (407, 'Apple GarageBand Out of Bounds Write Code Execution Vulnerability', 'None', '2017-2-14', 'An exploitable out of bounds write vulnerability exists in the parsing of saved files in Apple\'s GarageBand version 10.1.4. A specially crafted project file can cause an out of bounds write resulting in an exploitable condition. An attacker can deliver a project file via other means to trigger this vulnerability. Apple GarageBand 10.1.4 8.8 -- CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-123: Write-what-where Condition Garageband is a music creation tool used to create new and original music easily from your computer. GarageBand comes installed for free with all new Mac purchases, meaning there is a large market of people who have this software installed on there computer. The file format used by GarageBand is a proprietary .band file. There exists a vulnerability in the parsing of this format. The format is broken into chunks each with a length field at the beginning of the chunk. This length is controllable by the user and no validation checks are done to ensure this length is in bounds thus leading to an exploitable condition. The initial crash is shown below: Shown above we can see a null byte being written out of bounds due to an invalid calculation of R14 and RCX. Looking through the current function we can see where these values come from. Starting with R14 it can be seen that this is a buffer on the heap. We run malloc history on it and the output is shown below: This is a buffer created for holding the data from our opened document. This means that RCX must be an index into this buffer. Looking where RCX comes from we are led a few lines above: At, [2], we can see var_12 being loaded into ECX only a few lines above our vulnerability. looking further we see this same variable, [0], passed in as the second argument to a dynamic function call. Tracing our input further, we follow it into the dynamic call below: As can be seen,[0], our buffer is moved into R14. It is then zeroed out, moved into the 4th argument, [1], for CFDataGetBytes,[2]. This function gets data from a buffer for a range, designated by RSI and EDX, and stores it into RCX. In this case the range it is extracting is 2 bytes. This extracted data is then used in our original calculation above to index into the original data buffer. The problem arises in the fact that the buffer that data being is extracted from, [2], is user controlled and no input validation is done on the bytes read in. This means that RCX is user controlled and can be any arbitrary 2 byte value. This leads to an exploitable null byte write anywhere. 2016-12-15 - Vendor Disclosure \n2017-02-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0262');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (408, 'Nitro Pro PDF Handling Code Execution Vulnerability', 'None', '2017-2-3', 'A remote out of bound write / memory corruption vulnerability exists in the PDF parsing functionality of Nitro Pro 10. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. An attacker can send the victim a specific PDF file to trigger this vulnerability. http://gonitro.com 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H An remote memory corruption vulnerability exists in the PDF parsing functionality of Nitro Pro. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. Vulnerable code is located in the npdf.dll library: The r8 value at 0x000000000011B40F can be partially controlled by the data in the malformed PDF file. 2016-09-30 - Initial Discovery \n2016-10-13 - Vendor Notification \n2017-02-03 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0218');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (409, 'Nitro Pro 10 PDF Handling Code Execution Vulnerability', 'None', '2017-2-3', 'A remote out of bound write / memory corruption vulnerability exists in the PDF parsing functionality of Nitro Pro 10.5.9.9. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. An attacker can send the victim a specific PDF file to trigger this vulnerability. 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H A memory corruption vulnerability exists in the PDF parsing functionality of Nitro Pro. A specially crafted PDF file can cause a vulnerability resulting in potential memory corruption. Vulnerable code is located in the npdf.dll library: Memory access refered by selected instruction is presented below: Last memory access (instruction at 0x268C7D) is causing the exception to trigger.\nInstruction at 0x268C7D is using RAX register value to calculate the final memory address.\nRAX value is calculated by reading 32-bit memory from [r9+0x800] (with sign extension).\nValue at [r9+0x800] in this case is 0xABABABAB which is Microsoft\'s HeapAlloc() mark of \"no man\'s land\"\nguard bytes after allocated heap memory. In other words this memory should be never referenced in the\nfirst place. This value is later increased by r10 value (address 0x268C77) and multiplied by 2 (address 0x268C7A). 2016-10-26 - Initial Discovery \n2016-11-04 - Vendor Notification \n2017-02-03 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0226');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (410, 'Nitro Pro 10 PDF Handling Code Execution Vulnerability', 'None', '2017-2-3', 'A potential remote code execution vulnerability exists in the PDF parsing functionality of Nitro Pro 10. A specially crafted PDF file can cause a vulnerability resulting in potential code execution. An attacker can send the victim a specific PDF file to trigger this vulnerability. http://gonitro.com 9.3 - AV:N/AC:M/Au:N/C:C/I:C/A:C An potential remote code execution vulnerability exists in the PDF parsing functionality of Nitro Pro. A specially crafted PDF file can cause a vulnerability resulting in potential code execution. Vulnerable code is located in the npdf.dll library: Instruction at 7fe`d6f611bd references malformed/unintialized memory region. This memory area can be later used by call instruction which calls subroutine located at the pointer provided by malformed memory. 2016-10-13 - Initial Discovery \n2016-10-24 - Vendor Notification \n2017-02-03 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0224');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (411, 'McAfee ePolicy Orchestrator DataChannel Blind SQL Injection Vulnerability', 'None', '2017-2-1', 'An exploitable blind sql injection vulnerability exists within McAfee\'s ePolicy Orchestrator 5.3.0 that is accessible without authentication. A specially crafted HTTP post can allow an aggressor to alter a sql query which can result in disclosure of information within the database or impersonation of an agent. An attacker can use any HTTP client to trigger this vulnerability. McAfee\'s ePolicy Orchestrator 5.3.0 http://www.mcafee.com/us/products/epolicy-orchestrator.aspx(http://www.mcafee.com/us/products/epolicy-orchestrator.aspx) 8.2 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:L McAfee\'s ePolicy Orchestrator is a centralized security management suite that is used to manage antivirus and policies within the enterprise. These types of software are also known as an HBSS or Host-based Security System. It is used to manage a number of agents which are deployed in the enterprise and can be used to enforce defenses and software policies in a scalable manner. McAfee\'s ePolicy Orchestrator is composed of a number of components. This consists of a load-balancer which is driven by Apache and extended via custom modules. The Console itself which is based on Tomcat, and is used by staff to manage the entirety of the software. The last component are the agents themselves which are deployed on each client machine. The agents communicate over a proprietary protocol known as SPIPE to Apache which is then forwarded to the Console. This specific vulnerability is located within the application server and is reachable over SPIPE or via the Console directly. Within the Tomcat server component, which may be reachable on port 8443 in most configurations, are a number of servlets which serve as the management component of the application. The DataChannel servlet is actually mapped to a POST request received against \"https://<server:port>/receiveDataChannelMsg.dcp\" and is implement by the class \"com.mcafee.epo.dataChannel.servlet.EPODataChannelServlet\". This resource is normally not reachable without authentication, however there is another servlet that is responsible for forwarding requests to this servlet for an agent. This servlet is the \"com.mcafee.epo.dataChannel.servlet.redirect.EPODataChannelRedirectServlet\" class and is mapped to \"https://<server:port>/dcRedirect/dataChannelMsg.dc\". This resource will receive a POST request without authentication and then forward it to the \"/receiveDataChannelMsg.dcp\" for processing without needing authentication. Once the POST request is received by the EPODataChannelServlet class, the following code will be executed. When calling the ProcessIncomingMessage function, this will eventually call the EPOBaseDataChannelData.unpackLittleEndian_DataPacket method. This method will decode a structure from the POST\'s content which contains the message type, it\'s origin, and most importantly the Agent\'s GUID as well as some other fields. Afterwards this object will then get passed to the EPODataChannelMessagingService.receiveAgentMessage method. The EPODataChannelMessagingService.receiveAgentMesage method will then forward the object containing the unpacked data to the DataChannelMessagingServiceInternal.receiveAgentMessage method. This method will check to see that the Agent GUID in the packet is defined, and then call the EPOComputerService.getByAgentGUIDNoUserCheck method using the AgentGUID as its only argument. In the EPOComputerService class, the getByAgentGUIDNoUserCheck method is contains the sql injection vulnerability. This method will simply take the provided Agent GUID and use it to build a query using the EPOComputerDataMapper class which will then be executed over the jdbc connection. This results in the EPOComputerDatabaseMapper class building a query that looks like the following. In some configurations, the console may not be directly reachable by an agent. The method by which an agent communicates to the console, however, is through the Apache based load balancer using a proprietary protocol known as SPIPE. This can be reached via the uri \"https:///spipe\". This request is implemented by an Apache extension module named mod_epo.dll which can perform a number of operations. To perform these operations, the module initially registers a couple handlers, one of which is responsible for forwarding the request to the library responsible for implementing the SPIPE protocol. When a request is made to the \"/spipe\" resource, the following code will be executed. Afterwards, the VERB will be checked if it\'s an HTTP POST which will then cause the module to initialize the EPO Handler if it hasn\'t been initialized already and then call a function responsible for handling the POST request. This function is simply responsible for checking that the Content-Length of the POST request is larger than 0xea bytes and will then proceed to call into the NAIMSERV.DLL library which contains the majority of the SPIPE implementation. This size represents the header of the SPIPE protocol. NAIMSERV.DLL registers a couple of callbacks, one of which is responsible for processing the POST request. Eventually after some checks, the module will encounter the following code which will xor all the bytes in the POST\'s content with the byte 0xAA. Immediately after decoding, the application will process the header and store it into an object which is used to determine the version of the SPIPE package as well as store extra data that\'s interpreted as a list of key/value pairs. The version of the SPIPE package can be one of the following values: 0x40000001, 0x50000001, or 0x60000001. If a version 4 packet is used, then the application will use the DES3 algorithm to decrypt the extra data. Version 6, however relies on using SSL. Within this same function, the library will extract the SupportedSPIPEVersion string which could be \"4.0\", \"5.0\", or \"6.0\". Afterwards, the module will then use these values to locate the Agent\'s public key. This public key will be used to verify that the SPIPE package has not been tampered with. Once this is done, then the application will check the Server\'s key against the value of the \"ServerKeyHash\" field provided in the packet. A few more checks later and the module will finally encounter the function responsible for actually handling the Agent\'s request. Inside the AgentRequestHandler function, the application will then check the PackageType field from the packet in order to determine how to handle an Agent\'s request. When encountering the following function, the library will populate the object at @ebp-0x17d8 with values from the packet. One of these is the Agent\'s GUID. After extracting the GUID from the package, the library will then execute the following code which ensures that the GUID isn\'t contained in a blacklist. After this is done, the library will check the sequence number and then enter a series of loops that will check which \"PackageType\" is being requested. If the package type specified by the agent is \"MsgUpload\", then the application will call a function, server_OnMsgUpload, which will forward the data to the application server. This function will tokenize data provided by the agent, and then enter the following loop which forwards the data directly to the application server using the ForwardDataChannelMessageToJava function. The ForwardDataChannelMessageToJava function will simply take the input that was extracted from the Agent\'s request, and then forward it to the \"/dcRedirect/dataChannelMsg.dc\" resource that\'s located directly on the application server component. The POST request that is made to the application server is made to the DataChannel servlet. The servlet implement\'s the Data Channel which has the following format. A StringPacket structure is a byte which defines the number of bytes that define a string. A Data structure is similar to a StringPacket except it uses a uint32_t to define the length of the data. In the proof-of-concept, the following packet is POSTed. The only requirements of this packet are that the version is set to 1, the m data field contains at least one byte of data. If all of these fields are valid, then the m_agentGUIDBytes can contain up to 256 characters used for the sql injection. To ensure that an attacker does not have direct access to the vulnerability and instead has to use just SPIPE as an agent, verify that port 8443 that the McAfee ePolicy Orchestrator Console is bound to is inaccessible by ePolicy Orchestrator\'s agents and can only by accessed by Administrators. 2016-11-04 - Vendor Disclosure \n2017-02-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0229');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (412, 'Libbpg BGP image decoding Code Execution Vulnerability', 'None', '2017-1-23', 'An exploitable heap write out of bounds vulnerability exists in the decoding of BPG images in libbpg library. A crafted BPG image decoded by libbpg can cause an integer underflow vulnerability causing an out of bounds heap write leading to remote code execution. This vulnerability can be triggered via attempting to decode a crafted BPG image using libbpg. Libbpg - 0.9.4 and 0.9.7 http://bellard.org/bpg/bpg_spec.txt 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H BPG (Better Portable Graphics) is an image format created in 2014 based on the HECV video compression standard. BPG has been praised for its ability to produce the same quality image as JPEG or JPEG XR, but in a much smaller file size. It is currently in line to be incorporated in the multimedia player VLC. During the decoding of a BPG, in the   function, an attacker controlled integer underflow can occur [1] during the calculation of offsets for the   and   operands of a  . Because of the underflows, the resulting addresses passed to the   [2] are outside the bounds of the original heap structures, resulting in an out of bounds write condition. In the above valgrind output, an out of bounds write is recorded. The following patch will fix the vulnerability, but it is untested as to whether it breaks any legitimate images. 2016-10-20 - Vendor Disclosure \n2017-01-23 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0223');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (413, 'Adobe Acrobat Reader DC jpeg decoder Remote Code Execution Vulnerability', 'None', '2017-1-20', 'A use of uninitialized memory vulnerability exists in JPEG image file format decoding code of Adobe Acrobat Reader which ultimately leads to a heap-based buffer overflow which can be abused to achieve remote code execution. A specially crafted PDF file with an embedded JPEG can trigger this vulnerability when opened on a victim computer. Adobe Acrobat Reader DC 2015.020.20039 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H CWE-457 - Use of Uninitialized Variable Adobe Acrobat Reader is the most popular and most feature-rich PDF reader. It has a big user base, is usually a default PDF reader on systems and integrates into web browsers as a plugin for rendering PDFs. As such, tricking a user into visiting a malicious web page or sending a specially crafted email attachment can be enough to trigger this vulnerability. There exists a vulnerability in the JPEG decoder and parser which can result in the use of two 4 byte integer values which are previously uninitialized. The use of these two uninitialized variables leads to further process corruptions as can be seen in the following crash context: The above crash occurs with Page Heap enabled. The crash is due to and out of bounds write in a   call. This particular   call is made inside a function starting at 600D25A3. The following  disassembly shows the relevant parts: At [1] we enter a loop. At [2] a   call occurs, size being 0x1fff in case of our testcase. At [3] destination pointer is increased and at [4]  , which serves as a boundary condition for this loop, is decreased. At [5] it is tested for 0 and the code jumps back if that’s not the case. If we examine the starting value of   we can see that it is unusually big: Since in each round of the loop,   gets decreased by only 0x1fff, the destination buffer for the memcpy call will get increased outside of its allocated space causing a heap-based buffer overflow. Tracing back the origin of the particular value is   through the call stack gets us to the following code in the function starting at 605AC8C2 :  At [1], a pointer is read into  , at [2] an address is copied into   and contents from it get pushed to the stack at [3]. This can be observed in the following debugging output: The value from   is a result of previous arithmetic operations on an uninitialized memory and after further arithmetic gets its final value as   at the time of the crashing   call. If we examine the allocation from which the uninitialized variable use stems from we can see that it was allocated with a call to  : A possible solution for this issue could be to change the call to   instead. When Page Heap is disabled, we can observe that the same memory area contains zeros which leads to different results of arithmetic operations (all being zeros) which wouldn’t cause a crash. As has been seen with previous Reader exploits, the heap can be groomed in a specific way so that the uninitialized memory falls under attackers control which could then end up controlling the heap buffer overflow size directly. With further heap layout control this can lead to successful exploitation and  remote code execution. 2016-12-14 - Vendor Disclosure \n2017-01-20 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0259');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (414, 'Oracle Outside In Technology RTF Parsing Code Execution Vulnerability', 'None', '2017-1-17', 'An exploitable Use After Free vulnerability exists in the RTF parser functionality of Oracle Outside In Technology SDK. A specially crafted RTF document can cause a reuse of a reference to the previously freed memory which can be manipulated into achieving arbitrary code execution. Oracle Outside In Technology 8.5.3. 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:C/A:C) Oracle Outside In Technology SDK is a widely used file format access and filtering framework. It’s used in many enterprise software distributions for accessing, parsing, filtering and converting numerous file formats. While parsing a specially crafted RTF document, a reference to a freed object is reused. If during the window of time after the object is freed and before its reference is reused, the same memory area is properly manipulated, it may result in arbitrary reading or writing of memory that could ultimately result in arbitrary code execution. The minimized testcase that triggers this vulnerability is as follows: In the above example testcase,   directive causes allocation of memory for an object which is subsequently freed. When document rendering reaches the second   directive the same memory area is reused without new allocation. This results in accessing the freed memory. With proper memory manipulation, the attacker can cause the same area of memory to be allocated for a different object. With control of the allocated memory. The memory allocation and object initialization is done in the function at 0xb6031310 in   shared library (with image base 0xb6022000): In the above output, we can see that allocated buffer is at 0xad496ac0. The buffer is later freed at 0xb602de67 in the same library by calling   which is a wrapper around  : The first Use After Free condition occurs at 0xb6036062. During normal execution, the process will not crash because the memory still contains the same valid data, even though it is freed. If a debugging allocator is used (such as libduma), the freed page will be kept busy, but will be marked unreadable in order to catch this kind of issue. In that case, resuming the execution results in the following crash: In the above output, it should be observed that the pointer being dereferenced in the   instruction is the same as previously freed, and the process has crashed because the page permissions deny read access. By further manipulating the document by placing an object of precise size between the point of free and point of reuse, further memory corruption can be achieved potentially resulting in arbitrary code execution. The vulnerability can be triggered by running the   binary, included in the SDK, with the above mentioned testcase. Although the supplied testcase doesn’t cause a crash, the use after free can be caught with Valgrind for example. Example output from Valgrind: 2016-10-10 - Vendor Disclosure \n2017-01-17 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0215');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (415, 'Oracle Outside In Technology PDF parser confusion Code Execution Vulnerability', 'None', '2017-1-17', 'An exploitable arbitrary write vulnerability exists in the PDF parser functionality of Oracle Outside In Technology SDK. A specially crafted PDF document can cause a parser confusion resulting in an arbitrary write vulnerability ultimately leading to code execution. Oracle Outside In Technology 8.5.3. 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N) Oracle Outside In Technology SDK is a widely used file format access and filtering framework. It’s used in many enterprise software distributions for accessing, parsing, filtering and converting numerous file formats. While parsing a specially crafted PDF file, a parser confusion can result in a string pointer being interpreted as an integer value, resulting in an out of bounds memory access which with careful manipulation of the memory and PDF layout can result in an arbitrary memory overwrite leading to code execution. The vulnerability can be triggered by a malformed /Index entry. Index usually contains an array of numbers, but if a string is found in the array, the vulnerability is triggered. A sample PDF file to trigger the vulnerability is: A misplaced   character in the above PDF sample causes the third array element to be interpreted as a string, placing a pointer to that string where an integer is expected. This pointer is then wrongfully used in offset calculation in the following code: In the above disassembly, at [1] a string pointer instead of a small integer is moved into  . At [2] it is added to   which is a pointer to a structure. Since   is a pointer, adding them together will result in an integer overflow. It just so happens that /Size parameter is parsed before and influences memory layout. By carefully choosing the value of /Size, we can control the integer overflow and end up with an arbitrary pointer. In the above PDF example, the /Size value is chosen so we end up with a pointer to a heap chunk, lending itself to further heap metadata corruption. From the above GDB session, we can see that we end up with   pointing to a heap chunk. The same address gets reused a bit later in the same faulty function as a destination of a write operation (with an added offset of 20) which can be seen in the following disassembly: In the above disassembly, an integer from the decompressed stream is read into an address pointed to by   which is under our control which can be seen in the following gdb log: Note that in the above gdb log,   contains 0x4141 which is an arbitrary value from the compressed stream (under direct control) and that   points to our the heap pointer we chose previously by integer overflow (with offset +20). A write operation in this case will corrupt the size data of the heap chunk resulting in a following crash: It should be noted that the size of the conversion in   function is controlled by /W parameter giving us further control over the overwirte. The same vulnerability can be triggered multiple times, resulting in multiple arbitrary memory overwrites and ultimately code execution. It is obvious that /Index array should not contain any strings, which signifies a malformed file. The vulnerability can be triggered by the   application supplied with the SDK. Depending on the memory layout in the target environment, the supplied testcase might not result in a crash, nevertheless, memory corruption does occur. 2016-08-29 - Vendor Disclosure  \n2017-01-17 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0198');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (416, 'Aerospike Database Server Set Name Code Execution Vulnerability', 'None', '2017-1-9', 'An exploitable stack-based buffer overflow vulnerability exists in the querying functionality of Aerospike Database Server 3.10.0.3. A specially crafted packet can cause a stack-based buffer overflow in the function   resulting in remote code execution. An attacker can simply connect to the port to trigger this vulnerability. Aerospike Database Server 3.10.0.3 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-121 - Stack-based Buffer Overflow Aerospike Database Server is both a distributed and scalable NoSQL database that is used as a back-end for scalable web applications that need a key-value store. With a focus on performance, it is multi-threaded and retains its indexes entirely in ram with the ability to persist data to a solid-state drive or traditional rotational media. When processing a packet from the client, the server will execute the   function. After accepting a connection on the socket, the server will read the header from the packet and check it\'s protocol type. If its protocol type specifies that the packet is compressed (PROTO AS COMPRESSED), it will decompress it with zlib and then continue to process the packet [1]. Later, when the protocol type is PROTO AS_MSG the server will pass the packet to the   function [2]. The   function will first read the namespace from the packet then and check to see the data is configured to be stored in memory by calling the   function [1]. If the namespace is undefined or configured to not be stored in memory, the function will continue by calling into   [2]. In order to trigger this particular vulnerability, this is the path that must be taken. Inside the   function, the server will use the string defined by the AS FIELD NAMESPACE field to determine the namespace. Once the namespace is discovered, the server will determine what type of transaction request is being made. This is done by checking which fields are defined. After determining the transaction is a multi-record type by checking that the AS FIELD KEY and AS FIELD DIGEST MSG BIT RIPE MSG BIT RANGE field being set and if so will pass execution to the   function at [4]. At the beginning of the   function, the application will hand-off the transaction to the   function [1]. Inside this function, the server will ensure that the requested namespace has a secondary index associated with it by calling the   [2]. After this is determined, the metadata for the index will be fetched from the packet at [3]. After all is said and done, the server will read a string out of the AS FIELD SET field. This will get saved to the   variable and then passed as an argument to [4]. Inside the   function, the string from the packet will be passed through the   function which is a wrapper around  . Later in that function, the string will be handed off to  . This is the function that contains our specific vulnerability. Finally the string will be passed into   [1] and then used as an argument to sprintf [2]. If the length of the string plus the id for the bin is larger than AS PROP SIZE (84), then this vulnerability is being triggered. To execute the provided proof-of-concept, simply extract and run it as follows: A client packet for Aerospike server has the following structure. The first 2 bytes describe the protocol   and the protocol  . The   must be 0x02, where the protocol   can be one of two values. If AS MSG(0x04) is specified, then the contents of   are zlib-encoded. Otherwise, the AS_MSG(0x03) value is used. The size of this data is defined by the   field which is a 48-bit unsigned integer. The contents of the   field has the following structure. In order to submit a message that passes the checks at   and  , There simply needs to be a field with the NAMESPACE(0x0) id, one with an INDEX KEY(2) or BIT RIPE(4) identifiers. The field that is being used to overflow with is using the INDEX t field   must be set to 0x0003 or more. Af offset 0x1e of the packet is the definition of  . This is an array of fields that provide options for the type of request that is being made. The field identified by NAMESPACE(0x0) contains a namespace that supports the configuration defined above. One of the requirements is that an INDEX_RANGE(0x16) field must be defined. This begins at offset 0x2b of the packet generated by the proof-of-concept. Another requirement is that an INDEX_TYPE(0x1a) field must be defined. The last field that is used to overflow the 84 byte buffer has the identifier of SET(0x1). As long as the length defined in   is larger than 84 (exclusive) and the contents of   contains the same number of bytes, this vulnerability is being triggered. 2016-12-23 - Vendor Disclosure \n2017-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0268');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (417, 'Aerospike Database Server Client Message Memory Disclosure Vulnerability', 'None', '2017-1-9', 'An exploitable out-of-bounds read vulnerability exists in the client message-parsing functionality of Aerospike Database Server 3.10.0.3. A specially crafted packet can cause an out-of-bounds read resulting in disclosure of memory within the process, the same vulnerability can also be used to trigger a denial of service. An attacker can simply connect to the port and send the packet to trigger this vulnerability. Aerospike Database Server 3.10.0.3 8.2 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H CWE-129 - Improper Validation of Array Index Aerospike Database Server is both a distributed and scalable NoSQL database that is used as a back-end for scalable web applications that need a key-value store. With a focus on performance, it is multi-threaded and retains its indexes entirely in ram with the ability to persist data to a solid-state drive or traditional rotational media. In order to receive a packet from the client, the server spawns threads which execute the   function. At the beginning of this function, the server will receive data from the socket and then validate the protocol type. If the protocol type specifies that the packet is compressed (PROTO AS COMPRESSED), it will decompress it with zlib and then continue to process the packet [1]. Later, when the protocol type is PROTO AS_MSG the server will pass the packet to the   function [2]. Inside the   function, the server will call the   function [1]. This function will extract the specified namespace as defined within the packet and check to see if the   field [2] is set. The value of this field is defined within the configuration for the service. If the value of this field for the namespace is clear, then the   function will be called [3]. The   function will then check to see if the   setting is specified within the configuration [1]. If this is the case, the server must peek into the packet to decide which device the transaction is to be written to [2]. Inside the   function, the server will read the   field out of the packet and store a pointer to the data in   [3]. Due to this function not checking the minimum size of the field, an assumption made by the caller can be made to access data outside its bounds. This is done by the code at [4]. To execute the provided proof-of-concept, simply extract and run it as follows: A client packet for Aerospike server is encoded in big-endian form and has the following structure. The first two bytes describe the protocol   and the protocol  . The   must be 0x02, where the protocol   can be one of two values. If AS MSG(0x04) is specified, then the contents of   are zlib-encoded. Otherwise, the AS_MSG(0x03) value is used. The size of this data is defined by the   field which is a 48-bit unsigned integer. The contents of the   field has the following structure. Within this structure, the only fields that are important are   and   which are the values returned by   defined in the vulnerability description. In order to reach the described vulnerability, there must be two field types defined within  . These types are NAMESPACE(0x0) and DIGEST RIPE field type is greater than 0 and less than 8, then this vulnerability is being triggered. 2016-12-23 - Vendor Disclosure \n2017-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0264');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (418, 'Aerospike Database Server Index Name Code Execution Vulnerability', 'None', '2017-1-9', 'An exploitable stack-based buffer overflow vulnerability exists in the querying functionality of Aerospike Database Server 3.10.0.3. A specially crafted packet can cause a stack-based buffer overflow in the function   resulting in remote code execution. An attacker can simply connect to the port to trigger this vulnerability. Aerospike Database Server 3.10.0.3 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H CWE-121 - Stack-based Buffer Overflow Aerospike Database Server is both a distributed and scalable NoSQL database that is used as a back-end for scalable web applications that need a key-value store. With a focus on performance, it is multi-threaded and retains its indexes entirely in ram with the ability to persist data to a solid-state drive or traditional rotational media. When processing a packet from the client, the server will execute the   function. After accepting a connection on the socket, the server will read the header from the packet and check it\'s protocol type. If its protocol type specifies that the packet is compressed (PROTO AS COMPRESSED), it will decompress it with zlib and then continue to process the packet [1]. Later, when the protocol type is PROTO AS_MSG the server will pass the packet to the   function [2]. The   function will first read the namespace from the packet then and check to see the data is configured to be stored in memory by calling the   function [1]. If the namespace is undefined or configured to not be stored in memory, the function will continue by calling into   [2]. In order to trigger this particular vulnerability, this is the path that must be taken. Inside the   function, the server will use the string defined by the AS FIELD NAMESPACE field to determine the namespace. Once the namespace is discovered, the server will determine what type of transaction request is being made. This is done by checking which fields are defined. After determining the transaction is a multi-record type by checking that the AS FIELD KEY and AS FIELD DIGEST MSG BIT RIPE MSG BIT RANGE field being set and if so will pass execution to the   function at [4]. At the beginning of the   function, the application will hand-off the transaction to the   function [1]. Inside this function, the server will ensure that the requested namespace has a secondary index associated with it by calling the   [2]. After this is determined, the namespace and the packet itself will be passed to the   function [3]. Upon receiving the namespace and the packet, the server will extract the fields identified by the enumerations AS FIELD INDEX MSG TYPE MSG TYPE NAME field is then passed to the   function [3]. Both the   representing the namespace and the   variable containing the secondary index name extracted from the packet will then be passed to the  . This server will continue to hand-off these arguments through the function call at [2] and then at [3]. Finally the   function will be called with the namespace and secondary index name from the packet. This function will write the index name to the   buffer which has a maximum size of 0x100 bytes [1]. The index name is then written into the buffer using   and a buffer length based on the   of the string within the packet [2]. Due to the server using the length of the string from the packet as the bounds for the buffer instead of the size of the buffer itself, a stack-based buffer overflow can be made to occur. To execute the provided proof-of-concept, simply extract and run it as follows: A client packet for Aerospike server has the following structure. The first 2 bytes describe the protocol   and the protocol  . The   must be 0x02, where the protocol   can be one of two values. If AS MSG(0x04) is specified, then the contents of   are zlib-encoded. Otherwise, the AS_MSG(0x03) value is used. The size of this data is defined by the   field which is a 48-bit unsigned integer. The contents of the   field has the following structure. In order to submit a message that passes the checks at   and  , There simply needs to be a field with the NAMESPACE(0x0) id, one with an INDEX KEY(2) or BIT RIPE(4) identifiers. The field that is being used to overflow with is using the INDEX t field   must be set to 0x0003 or more. Af offset 0x1e of the packet is the definition of  . This is an array of fields that provide options for the type of request that is being made. The field identified by NAMESPACE(0x0) contains a namespace that supports the configuration defined above. One of the requirements is that an INDEX_RANGE(0x16) field must be defined. This begins at offset 0x2b of the packet generated by the proof-of-concept. The last field that is used to overflow the 0x100 byte buffer has the identifier of INDEX_NAME(0x15). As long as the length defined in   is larger than 0x200 (exclusive) and the contents of   contains the same number of bytes, this vulnerability is being triggered. 2016-12-23 - Vendor Disclosure \n2017-01-09 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0266');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (419, 'Tarantool Msgpuck mp_check Denial Of Service Vulnerability', 'None', '2016-12-16', 'An exploitable incorrect return value vulnerability exists in the mp check function to incorrectly return success when trying to check if decoding\na map16 packet will read outside the bounds of a buffer, resulting in a denial of service vulnerability. Msgpuck 1.0.3 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-125: Out-of-bounds Read The Msgpuck library is used to encode and decode data that is serialized with the MsgPack (http://msgpack.org) format.\nThis library was originally implemented to be the default library used for serialization and deserialization for the\nTarantool Application Server, but is also distributed as an independent library to provide support for the MsgPack\nformat to other C or C++ applications. When deserializing data that is encoded with the MsgPack format, the Msgpuck library provides a function named mp_check\nthat\'s used to validate the Msgpack data before it is decoded. This function takes two arguments, one to the beginning\nof the MsgPack data and another to the end of the data which is used to determine if decoding the packet will read\noutside the bounds of the data. An example of how this is intended to be used is as follows: For optimization purposes, each of the Msgpuck functions are inlined. When calling mp t seeks past the end pointer. Due to a typo, however,\nthe library will incorrectly return false which is a result that\'s different from the function\'s failure result.\nOne can see that the result of a map32 returns a constant   when that particular failure occurs. This means that\nif the 2 bytes determining the map16\'s length cause the sum to seek past the end pointer, the function will succeed.\nLater when the library tries to decode this data, the library will read outside the bounds of the source data buffer. In order to demonstrate the out-of-bounds read, a server that reads a MsgPack decoded map type is provided. This\nserver allocates space for the source buffer followed by a guard-page to show the exact instruction that reads outside\nthe allocated buffer. To compile this, simply copy the   file to the root of the Tarantool directory and\ntype in the following. This will create a binary named   which will run the MsgPack server. The arguments\nto this binary control which interface and port the server will bind to. Once the server is running, the proof-of-concept can be executed against the server using python. This is done using\na similar syntax. The proof-of-concept will send 5 packets. The first 3 packets that are sent will exercise the fixmap,\nmap16, and map32 encoded types. The 4th packet will send a malformed map16 type. The 5th and last packet will trigger\nthe vulnerability causing the out-of-bounds read. 2016-12-14 - Vendor Disclosure \n2016-12-16 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0254');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (420, 'Tarantool Key-type Denial Of Service Vulnerability', 'None', '2016-12-16', 'An exploitable out-of-bounds array access vulnerability exists in the   function of Tarantool\n1.7.2.0-g8e92715. A specially crafted packet can cause the function to access an element outside the bounds of a\nglobal array that is used to determine the type of the specified key\'s value. This can lead to an out of bounds\nread within the context of the server. An attacker who exploits this vulnerability can cause a denial of service\nvulnerability on the server. Tarantool 1.7.2-0-g8e92715 7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-125: Out-of-bounds Read Tarantool is an open-source lua-based application server. While primarily functioning as an application server, it\nis also capable of providing database-like features and providing an in-memory database which can be queried using\na protocol based around the MsgPack serialization format. Tarantool is used by various service providers such as\nMail.RU, or Badoo. Tarantool\'s protocol is based around the MsgPack serialization format. This protocol is used to encode specific\nrequest types which are then made against the server. Inside the header of this protocol is data encoded as a map\ntype in which each key is represented by integers. Each of these integers are used to index into an array which is\nused to determine the type of the key that was specified. In the following code, the server will first read the length out of the MsgPack encoded packet. After reading the\nlength, the server will create a new instance of a message using the   function. Afterwards, this\nobject will be passed onto the   function. At the very beginning of the   function, the server will call a wrapper named  .\nThis wrapper will simply chain into the   function. When inside the   function, the server will first check to see if the MsgPack encoded data is not\nmalformed in anyway. Once this is performed, the next part of the packet will be checked to see if it is of the MP_MAP\ntype. Afterwards, the server will enter a loop which will iterate over the number of values that are stored within the\nmap type. For each entry within the map type, the server will decode a key from the map and then use it as an index to\na global array named  . This array contains 0x31 elements. If one of the keys that are encoded are an\ninteger that is larger than this array, then the server will access an element outside the bounds of said array. When first running the Tarantool application server, start a server by typing the following at the Tarantool prompt.\nThis will start a server bound to TCP port 57005. To run the provided proof-of-concept, simply run it with python as; When connecting to port 57005 on the server, Tarantool will first send a 128 byte greeting that has the following format: After receiving this packet, one can then send the MsgPack encoded message that triggers the vulnerability. The MsgPack\nformat has the capacity of encoding various atomic types such as integers, booleans, and strings as well as different\ncontainer types such as arrays or map (key/value) types. When encoding a type, the first byte will dictate the type+size\nfollowed by the data representing the value. The first byte is a binary structure that determines the size of the type.\nFor integral types, this structure may be one of the following. If the type is positive-fixint, then the bottom 7-bits\nrepresent the integer value. If the type is negative-fixint, then the bottom 5-bits represent the integer value. If the integer type is larger than 7 bits, then the following enumerations will occupy the bottom 5 bits. Depending on\nthe enumeration type, the next number of bytes will contain the integer encoded in big-endian form. If a container type such as a mapping-type is being specified, then it will have one of the following formats. If it\'s\nof a mapfix-type, then the bottom 4 bits represent the number of key/value pairs that follow. If a map16 or map32 is\nspecified, then the first 3 bits will represent the type enumeration (110), and then the next 5 bits will represent\none of the following enumerations. Immediately following the map16 or map32 byte will then be either a uint16 ot\nuint32 (respectively) that is encoded in big-endian form. Each of these container types will then be followed with\na number of MsgPack encoded values. This number specifies the number of pairs (key/value) that compose the mapping type. Tarantool\'s protocol first begins with a MsgPack encoded integer which dictates the number of bytes that compose the\nheader and body that follow. This integer can be encoded within any of the previous defined integral types. Within the\nprovided proof-of-concept, the size has the following format: Immediately following the size, are two MsgPack encoded mapping types. Within Tarantool\'s protocol, the mapping\ntype will contain pairs of key/values where the keys are are MsgPack encoded integer types and can be any one of\nthe previously defined types (mapfix, map16, map32). Within the provided proof-of-concept, the header will look\nlike the following map: The data of this type contains a list of pairs. If the key of any one of these pairs is larger than the length of\nthe iproto type global variable (0x31), then this vulnerability is being triggered. In the provided proof-of-concept, this key is set to a positive-fixint of 0x32. It is prudent to note, that the type\ncan be any one of the aforementioned integer types (positive-fixint, negative-fixint, uint8, uint16, uint32, uint64,\nsint8, sint16, sint32, sint64). 2016-12-14 - Vendor Disclosure \n2016-12-16 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0255');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (421, 'Joyent SmartOS Hyprlofs FS IOCTL Add Entries Native File System Denial of Service Vulnerability', 'None', '2016-12-16', 'An exploitable denial of service exists in the the Joylent SmartOS OS 20161110T013148Z Hyprlofs file system. The vulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES. An attacker can cause a buffer to be allocated and never freed. When repeatedly exploit this will result in memory exhaustion,  resulting in a full system denial of service. Joyent SmartOS  20161110T013148Z 6.2 - CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-400: Uncontrolled Resource Consumption (\'Resource Exhaustion\') Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. The code at [1] shows the allocation of a buffer with a partially controlled size. At the code marked [2], we see that this function can return without freeing the allocated buffer. If this IOCTL is repeatedly called this will lead to a denial of service. Attached is a C file that works as a POC. Simply compile this on SmartOS and mount a hyprlofs file system and it will trigger the vulnerability. 2016-12-12 - Vendor Disclosure  \n2016-12-16 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0257');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (422, 'Nvidia Windows Kernel Mode Driver Denial Of Service', 'None', '2016-12-14', 'An local denial of service vulnerability exists in the communication functionality of Nvidia Windows Kernel Mode Driver. A specially crafted message can cause a vulnerability resulting in a machine crash (BSOD). An attacker can send a specific message to trigger this vulnerability. (Requires physical machine) \n- Nvidia Windows Kernel Mode Driver, 372.70 (21.21.13.7270)  \n- Nvidia Windows Kernel Mode Driver, 372.90 (21.21.13.7290) http://nvidia.com 5.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H An local denial of service vulnerability exists in the communication functionality of Nvidia Windows Kernel Mode Driver. A specially crafted D3DKMTEscape message can cause a vulnerability resulting in a machine crash (BSOD). An attacker can send a specific message to trigger this vulnerability. This bug happens because the ZwSetValueKey API is executed by the Nvidia driver with an invalid argument. 2016-09-30 - Initial Discovery \n2016-10-17 - Vendor Notification \n2016-12-14 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0217');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (423, 'Joyent SmartOS Hyprlofs FS IOCTL Native File System Integer Overflow Privilege Escalation Vulnerability', 'None', '2016-12-12', 'An exploitable integer overflow exists in the Joyent SmartOS OS 20161110T013148Z Hyprlofs file system. The\nvulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when dealing with native\nfile systems. An attacker can craft an input that can cause a kernel panic and potentially be leveraged into a full\nprivilege escalation vulnerability. This vulnerability is distinct from CVE-2016-9031. Joyent SmartOS  20161110T013148Z 7.8 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. : At [1] we see that these variables are labeled as integers. Continuing on we see that [2] is verifying which command we have chosen and if it is HYPRLOFS ENTRIES it copies in the data directly from the user. The vulnerability is present at  [3], when the user supplied length, which is an unsigned integer, becomes cast to a signed integer. This allows us to bypass the check at [4] by supplying an integer that is large enough to wrap around to a negative value when cast to an int. This then passes in a large value to malloc causing failure and a NULL to be returned. Since there is no check before use at [6], the kernel will subsequently write to the NULL page, leading to a potential privilege escalation from an exploit that has mapped the NULL page in userspace. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0248');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (424, 'Joyent SmartOS Hyprlofs FS IOCTL 32-bit File System name Buffer Overflow Privilege Escalation Vulnerability', 'None', '2016-12-12', 'An exploitable buffer overflow exists in the the Joyent SmartOS OS 20161110T013148Z Hyprlofs file system. The vulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when dealing with 32-bit file systems. An attacker can craft an input that can cause a buffer overflow in the   variable leading to an out of bounds memory access and could result in potential privilege escalation. This vulnerability is distinct from CVE-2016-9032. Joyent SmartOS  20161110T013148Z 7.0 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make there product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. The code at [1] shows the declaration of the vulnerable stack buffer of size MAXPATHLEN, 1024. We see at [2] that if our command is HYPRLOFS ENTRIES we continue into the vulnerable code path. Our data is first copied in at [3], and is then used for some set up. Later we see the user supplied name length is validated to ensure it is not too large for the buffer at [4]. The vulnerability is present because the check says greater than MAXPATHLEN instead of greater than or equal, resulting in a length that is one too large to be allowed. This results in a null byte out of bounds write at [5]. This vulnerability may be leveraged by an attacker to potentially increase privileges or as a denial of service. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0252');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (425, 'Joyent SmartOS Hyprlofs FS IOCTL 32-bit File System path Buffer Overflow Privilege Escalation Vulnerability', 'None', '2016-12-12', 'An exploitable buffer overflow exists in the the Joyent SmartOS OS 20161110T013148Z Hyprlofs file system. The\nvulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when dealing with native\nfile systems. An attacker can craft an input that can cause a buffer overflow in the   variable leading to\nan out of bounds memory access and could result in potential privilege escalation. This vulnerability is distinct\nfrom CVE-2016-9033. Joyent SmartOS  20161110T013148Z 7.0 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. The code at [1] shows the declaration of the vulnerable stack buffer of size MAXPATHLEN, 1024. We see at [2] that if our command is HYPRLOFS ENTRIES we continue into the vulnerable code path. Our data is first copied in at [3], and is then used for some set up. Later we see the user supplied name length is validated to ensure it is not too large for the buffer at [4]. The vulnerability is present because the check says greater than MAXPATHLEN instead of greater than or equal, resulting in a length that is one too large to be allowed. This results in a null byte out of bounds write at [5]. This vulnerability may be leveraged by an attacker to potentially increase privileges or as a denial of service. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0253');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (426, 'Joyent SmartOS Hyprlofs FS IOCTL Add Entries 32-bit File System Denial of Service Vulnerability', 'None', '2016-12-12', 'An exploitable denial of service exists in the the Joylent SmartOS OS 20161110T013148Z Hyprlofs file system. The vulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when used with a 32 bit model. An attacker can cause a buffer to be allocated and never freed. When repeatedly exploit this will result in memory exhaustion,  resulting in a full system denial of service. Joyent SmartOS  20161110T013148Z 6.2 - CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H CWE-400: Uncontrolled Resource Consumption (\'Resource Exhaustion\') Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. The code at [1] shows the allocation of a buffer with a partially controlled size. At the code marked [2], we see that this function can return without freeing the allocated buffer. If this IOCTL is repeatedly called this will lead to a denial of service. Attached is a C file that works as a POC. Simply compile this on SmartOS and mount a hyprlofs file system and it will trigger the vulnerability. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0258');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (427, 'Joyent SmartOS Hyprlofs FS IOCTL Native File System name Buffer Overflow Privilege Escalation Vulnerability', 'None', '2016-12-12', 'An exploitable buffer overflow exists in the the Joyent SmartOS OS 20161110T013148Z Hyprlofs file system. The\nvulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when dealing with native\nfile systems. An attacker can craft an input that can cause a buffer overflow in the   variable leading to an\nout of bounds memory access and could result in potential privilege escalation. This vulnerability is distinct\nfrom CVE-2016-9034. Joyent SmartOS  20161110T013148Z 7.0 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. The code at [1] shows the declaration of the vulnerable stack buffer of size MAXPATHLEN, 1024. We see at [2] that if our command is HYPRLOFS ENTRIES we continue into the vulnerable code path. Our data is first copied in at [3], and is then used for some set up. Later we see the user supplied name length is validated to ensure it is not too large for the buffer at [4]. The vulnerability is present because the check says greater than MAXPATHLEN instead of greater than or equal, resulting in a length that is one too large to be allowed. This results in a null byte out of bounds write at [5]. This vulnerability may be leveraged by an attacker to potentially increase privileges or as a denial of service. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0250');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (428, 'Joyent SmartOS Hyprlofs FS IOCTL Native File System path Buffer Overflow Privilege Escalation Vulnerability', 'None', '2016-12-12', 'An exploitable buffer overflow exists in the the Joyent SmartOS OS 20161110T013148Z Hyprlofs file system. The\nvulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when dealing with native\nfile systems. An attacker can craft an input that can cause a buffer overflow in the   variable leading to\nan out of bounds memory access and could result in potential privilege escalation. This vulnerability is distinct\nfrom CVE-2016-9035. Joyent SmartOS  20161110T013148Z 7.0 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H CWE-121: Stack-based Buffer Overflow Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. The code at [1] shows the declaration of the vulnerable stack buffer of size MAXPATHLEN, 1024. We see at [2] that if our command is HYPRLOFS ENTRIES we continue into the vulnerable code path. Our data is first copied in at [3], and is then used for some set up. Later we see the user supplied name length is validated to ensure it is not too large for the buffer at [4]. The vulnerability is present because the check says greater than MAXPATHLEN instead of greater than or equal, resulting in a length that is one too large to be allowed. This results in a null byte out of bounds write at [5]. This vulnerability may be leveraged by an attacker to potentially increase privileges or as a denial of service. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0251');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (429, 'Joyent SmartOS Hyprlofs FS IOCTL 32-bit File System Integer Overflow Privilege Escalation Vulnerability', 'None', '2016-12-12', 'An exploitable integer overflow exists in the Joyent SmartOS OS 20161110T013148Z Hyprlofs file system. The\nvulnerability is present in the Ioctl system call with the command HYPRLOFS ENTRIES when dealing with\n32-bit file systems. An attacker can craft an input that can cause a kernel panic and potentially be leveraged\ninto a full privilege escalation vulnerability. This vulnerability is distinct from CVE-2016-8733. Joyent SmartOS  20161110T013148Z 7.8 - CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H CWE-190: Integer Overflow or Wraparound Joyent SmartOS is an operating system deployed by Joyent to be used as a hypervisor like solution meaning virtual machines will run on top of the system itself. SmartOS is unique in the fact that it is based on a fork of Opensolaris. This leaves many vulnerabilities in the kernel due to the fact that it is not as actively developed as other operating systems. Hyprlofs is a file system specifically designed for SmartOS which allows the creation of new virtual file systems quickly and easily. This was developed and designed to help make their product, Manta, possible. Most of the controls for Hyprlofs go through the Ioctl calls. An Ioctl is a control function that operates on various streams in this case a file descriptor to the file system. Looking further into that code we can spot the vulnerability. The beginning of the function is shown below. At [1] we see that these variables are labeled as integers. Continuing on we see that [2] is verifying which command we have chosen and if it is HYPRLOFS ENTRIES it copies in the data directly from the user. This code path is taken if an alternative data model (for 32-bit file systems) is used. The vulnerability is present at  [3], when the user supplied length, which is an unsigned integer, becomes cast to a signed integer. This allows us to bypass the check at [4] by supplying an integer that is large enough to wrap around to a negative value when cast to an int. This then passes in a large value to malloc causing failure and a NULL to be returned. Since there is no check before use at [6], the kernel will subsequently write to the NULL page, leading to a potential privilege escalation from an exploit that has mapped the NULL page in userspace. 2016-12-01 - Vendor Disclosure \n2016-12-12 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0249');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (430, 'ImageMagick Convert Tiff Adobe Deflate Code Execution Vulnerability', 'None', '2016-12-3', 'An exploitable out of bounds write exists in the handling of compressed TIFF images in ImageMagicks\'s convert utility. A crafted TIFF document can lead to an out of bounds write which in particular circumstances could be leveraged into remote code execution.. The vulnerability can be triggered through any user controlled TIFF that is handled by this functionality. ImageMagick 7.0.3-1 http://www.imagemagick.org 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H This vulnerability is present in the convert utility bundled with ImageMagick. Thus utility is used by many web applications to parse and convert images and other formats inter changeably. It is a very popular piece of software for this use. The vulnerability arises when attempting to deflate an Adobe Deflate compressed Tiff image. The vulnerability arises in the way that ImageMagick handles compressed data inside of an image. The size necessary to hold the decompressed data is calculated and then passed in to LibTiff but it is not large enough to hold the decompressed stream. The buffer is calculated here: and then passed in here as op: Finally this buffer is used as the next available buffer in a stream which has more data than is available and the out of bounds write occurs. This is a controlled out of bounds write that under proper circumstances could be exploited into full remote code execution. 2016-10-10 - Vendor Disclosure \n2016-12-03 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0216');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (431, 'Network Time Protocol Control Mode Unauthenticated Trap Information Disclosure and DDoS Amplification Vulnerability', 'None', '2016-11-21', 'An exploitable configuration modification vulnerability exists in\nthe control mode (mode 6) functionality of ntpd. A specially crafted\ncontrol mode packet can set ntpd traps, providing information\ndisclosure and DDoS amplification, and unset ntpd traps, preventing\nlegitimate monitoring.  A remote, unauthenticated, network attacker\ncan trigger this vulnerability. NTP 4.2.8p3 \nNTP 4.2.8p8 \nNTPsec 0.9.1 \nNTPsec 0.9.3 http://www.ntp.org \nhttp://www.ntpsec.org/ CVSSv2: 6.4 - (AV:N/AC:L/Au:N/C:P/I:P/A:N) \nCVSSv3: 6.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N ntpd provides a   functionality that sends asynchronous\nnotifications to a number of   whenever an event of\ninterest occurs.  Example events of interest include: association\nmobilization and demobilization, authentication failures,\nreachability changes, etc. Since at least ntp-4.0.94 (July 21, 1999), ntpd has allowed traps to\nbe configured via control (mode 6) and private (mode 7) NTP modes.\nThough private mode requires messages modifying trap settings to be\nbe authenticated, control mode allows unauthenticated packets to\nmodify trap settings using the   and   control\nmessages. This vulnerability can be used to achieve several goals: Authentication should be required in order to modify trap\nconfiguration. Several mitigations can lessen the impact of this vulnerability. Traps specified in ntp.conf cannot be modified using this\nvulnerability. [1] http://www.talosintelligence.com/reports/TALOS-2016-0077/ 2016-09-20 - Vendor Disclosure \n2016-11-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0203');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (432, 'Network Time Protocol Broadcast Mode Poll Interval Enforcement Denial of Service Vulnerability', 'None', '2016-11-21', 'An exploitable denial of service vulnerability exists in the\nbroadcast mode poll interval enforcement functionality of ntpd. To\nlimit abuse, ntpd restricts the rate at which each broadcast\nassociation will process incoming packets.  ntpd will reject\nbroadcast mode packets that arrive before the poll interval\nspecified in the preceding broadcast packet expires. A\nvulnerability exists which allows remote unauthenticated attackers\nto send specially crafted broadcast mode NTP packets which will\ncause ntpd to reject all broadcast mode packets from legitimate NTP\nbroadcast servers. NTP 4.2.8p6 http://www.ntp.org/ CVSSv2: 5.0 - (AV:N/AC:L/Au:N/C:N/I:N/A:P) \nCVSSv3: 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L In response to the NTP Deja Vu vulnerability (CVE-2015-7973),\nntp-4.2.8p6 introduced several new integrity checks on incoming\nbroadcast mode packets.  Upon receipt of a broadcast mode packet,\nbefore authentication is enforced, ntpd will reject the packet if\nany of the following conditions hold: The following logic is used to ensure constraint 2, which ensures\nthat broadcast associations will process only one incoming packet\nper poll interval: If the time elapsed since the last broadcast packet was received\nfrom this peer is less than the poll interval declared by the sender\n( ), the\npacket will be discarded.  (A previous check ensures that\n  is within acceptable bounds.) Unfortunately, line 1341 compares the current time against the last\ntime any broadcast mode packet was received with a source IP address\nof the peer ( ).  In contrast to\n , which is updated only when a  \n(correctly authenticated and passing integrity checks) packet is\nreceived,   is updated by all incoming broadcast\npackets including spoofed and replayed packets. This leads to a trivial denial of service attack.  The attacker: To prevent this vulnerability, ntpd should only discard packets\nbroadcast packets when less than one poll interval has elapsed since\nthe last legitimate packet has been received ( ). There is no workaround for this issue.  Because the vulnerable logic\nis executed before authentication is enforced, authentication and\nthe   ntpd.conf directive have no effect.  An\nattacker can bypass   restrictions by sending incorrectly\nauthenticated packets. In order to succeed in an attack, the attacker must send at least\none spoofed packet per poll period.  Therefore observing more than\none NTP broadcast packet from the same sender address per poll\nperiod indicates a possible attack. The following patch can be used to fix this vulnerability: 2016-09-12 - Vendor Disclosure \n2016-11-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0130');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (433, 'Network Time Protocol Trap Crash Denial of Service Vulnerability', 'None', '2016-11-21', 'An exploitable denial of service vulnerability exists in the trap\nfunctionality of ntpd.  If an ntpd instance is configured to send\ntraps, a specially crafted network packet can be used to cause a\nnull pointer dereference resulting in a denial of service.  This\nvulnerability can be triggered by a remote unauthenticated attacker. NTP 4.2.8p8 \nNTPsec 0.9.3 http://www.ntp.org \nhttp://www.ntpsec.org/ CVSSv2: 7.1 - (AV:N/AC:M/Au:N/C:N/I:N/A:C) \nCVSSv3: 5.9 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H When reporting traps, the ntpd report event() can be called with NULL peer parameter, ntpd will\nabort() causing a DoS condition. ntp-4.2.8p7 introduced a variety of validity checks on crypto-NAK\npackets to address the nak-dos vulnerability (CVE-2016-1547).  When\nany of these validity checks fail, ntpd reports an event to any trap\nreceivers with: report AUTH, peer, \"Invalid_NAK\"). If the source address and mode of the incoming crypto-NAK packet do\nnot correspond to an existing peer, the peer argument will be NULL\ncausing the INSIST(peer != NULL) assertion to fail when\nreport_event() attempts to report the event to its trap recipients. It may also be possible to trigger reporting of a peer event without a\nvalid peer on other code paths.  For example, check timer.c calls: If ntpd\'s sys leapsec() to be called without a valid sys_peer leading\nto the assertion failure above. This crash can be reliably triggered on ntp-4.2.8p8.  We are\nreporting this defect against NTPsec 0.9.3 as well because it\ncontains the same incorrect logic in report event() with a NULL peer is not as\nstraightforward as with ntp-4.2.8p8. The fix for CRYPTO_NAK crash (CVE-2016-4957) introduced in\nntp-4.2.8p8 does not address this vulnerability. Though traps are not configured in most common NTP environments,\nattackers can employ \"Network Time Protocol Control Mode\nUnauthenticated Trap Information Disclosure and DDoS Amplification Vulnerability\"\n(TALOS-2016-0203) in order to configure a trap in order to exploit this\nvulnerability. Successful exploitation of this vulnerability requires ntpd to be\nconfigured with trap recipients.  Systems can be protected by\nremoving all \"trap\" commands from ntp.conf and adopting the\nmitigations for \"Network Time Protocol Control Mode Unauthenticated\nTrap Information Disclosure and DDoS Amplification Vulnerability\" (TALOS-2016-0203). 2016-09-20 - Vendor Disclosure \n2016-11-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0204');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (434, 'Network Time Protocol Broadcast Mode Replay Prevention Denial of Service Vulnerability', 'None', '2016-11-21', 'An exploitable denial of service vulnerability exists in the\nbroadcast mode replay prevention functionality of ntpd.  To prevent\nreplay of broadcast mode packets, ntpd rejects broadcast mode\npackets with non-monotonically increasing transmit timestamps.  Remote\nunauthenticated attackers can send specially crafted broadcast mode\nNTP packets to cause ntpd to reject all broadcast mode packets from\nlegitimate NTP broadcast servers. NTP 4.2.8p6 http://www.ntp.org/ CVSSv2: 5.0 - (AV:N/AC:L/Au:N/C:N/I:N/A:P) \nCVSSv3: 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L In response to the NTP Deja Vu vulnerability (CVE-2015-7973),\nntp-4.2.8p6 introduced several new integrity checks on incoming\nbroadcast mode packets.  Upon receipt of a broadcast mode packet,\nbefore authentication is enforced, ntpd will reject the packet if\nany of the following conditions hold: The following logic is used to ensure that packet transmit\ntimestamps are monotonically increasing: If the packet transmit timestamp is less than the transmit timestamp\non the last received broadcast packet from this association ( ), the packet will be discarded. Unfortunately, line 1362 updates the saved transmit timestamp for\nalleged sender of the packet ( ) before the packet is\ndiscarded.  The update takes place even if the packet is\nunauthenticated and fails the previous integrity checks. This leads to a trivial denial of service attack.  The attacker: To prevent this vulnerability,   should only be updated\nwhen a packet authenticates correctly.  This is the approach taken\nin the patch below. There is no workaround for this issue.  Because the vulnerable logic\nis executed before authentication is enforced, authentication and\nthe   ntpd.conf directive have no effect.  An\nattacker can bypass   restrictions by sending incorrectly\nauthenticated packets. In order to succeed in an attack, the attacker must send at least\none spoofed packet per poll period.  Therefore observing more than\none NTP broadcast packet from the same sender address per poll\nperiod indicates a possible attack. The following patch can be used to fix this vulnerability: 2016-09-12 - Vendor Disclosure \n2016-11-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0131');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (435, 'HDF5 Group libhdf5 H5T_COMPOUND Code Execution Vulnerability', 'None', '2016-11-17', 'HDF5 is a file format that is maintained by a non-profit organization, The HDF Group. HDF5 is designed to be used for storage and organization of large amounts of scientific data and is used to exchange data structures between applications in industries such as the GIS industry via libraries such as GDAL, OGR, or as part of software like ArcGIS. The vulnerability exists due to the library allocating space for the array using a value from the file, and then within the loop for initializing said array allowing a value within the file to modify the loop\'s terminator. Due to this, an aggressor can cause the loop\'s index to point outside the bounds of the array when initializing it. This is a heap-based buffer overflow, and can lead to code execution under the context of the application using the library. hdf5-1.8.16.tar.bz2 \n  tools/h5ls: Version 1.8.16 \n  tools/h5stat: Version 1.8.16 \n  tools/h5dump: Version 1.8.16 http://www.hdfgroup.org/HDF5/ \nhttp://www.hdfgroup.org/HDF5/release/obtainsrc.html \nhttp://www.hdfgroup.org/ftp/HDF5/current/src/hdf5-1.8.16.tar.bz2 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H The HDF file format is intended to be a general file format that is self-describing for various types of data structures used in the scientific community [1]. These data structures are intended to be stored in two types of objects, Datasets and Groups. Paralleling the file-format to a file system, a Dataset can be interpreted as a file, and a Group can be interpreted as a directory that\'s able to contain other Datasets or Groups. Associated with each entry, is metadata containing user-defined named attributes that can be used to describe the dataset. Within the HDF file format, paths can be specified as the \'/\'-separated posix format. When reading a dataset, the library will open the object using H5D DTYPE msg_read. Inside H5O read id argument to determine which message type is being used for a message. This message type is used to determine which callback to use in order to handle the message. This process occurs within the macro H5O NATIVE at H5Omessage.c:545 Inside the H5O NATIVE macro, the application will select a structure containing function pointers out of the msg->type field. This structure contains various functions that are used to decode the message. When decoding a msg of type H5O ID, the library will dispatch into the H5O shared dtype dtype dtype helper which is responsible for decoding the data types. Inside decode helper, the library will read a dword from the file and use the bottom 4 bits to determine the datatype. If the datatype is H5T_COMPOUND(6), the library will enter the case at src/H5Odtype.c:260. At the beginning of this case, the library will use a bitmask from the fields to allocate space for the number of members. Immediately afterwards, the library will enter a loop that is terminated by the number of members in the prior snippet. For each iteration of this loop, the library will read a number of dimensions that will be passed to a function H5T create. Although the library checks that the number of dimensions that are read are bound by 4, the check is done via an assertion. When the library is built in production mode[3], this assertion will be optimized out by the preprocessor. Inside H5T create, the library will use the ndims value as a terminator to a loop. This loop is used to calculate the size of the array. Due to the index being oob of the 4-element array, the loop can assign an arbitrary value to u.array.ndims and u.array.nelem. These values are actually a union within the structure that they\'re written to, and due to this can be used to change the length of the loop after the space has already been allocated. The structure\'s that overlap are located within the H5T t definition in src/H5Tpkg.h:288. In this structure, the \"u\" field is a union of both an H5T t and an H5T T which both are used within the loop that was explained in the prior snippet. In these structures, H5T t.nelem is the same as H5T t.nalloc, and H5T t.ndims is the same as H5T t.nmembs. These are defined below. The field\'s that are used to control the allocation and the loop are marked. Referring back to the loop, these two fields are used to control when the loop terminates. Since u.array.ndims let\'s the librayr modify the value of u.compnd.nmembs, the code at line 391 will write outside the bounds of the allocation. This is a heap-based buffer overflow and can lead to code execution under the context of the application using the library. 2016-05-08 - Discovery  \n2016-05-17 - Vendor Notification  \n2016-11-15 - Public Disclosure  [1] https://en.wikipedia.org/wiki/Hierarchical Format \n[2] http://www.hdfgroup.org/HDF5/', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0179');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (436, 'HDF5 Group libhdf5 Shareable Message Type Code Execution Vulnerability', 'None', '2016-11-17', 'HDF5 is a file format that is maintained by a non-profit organization, The HDF Group. HDF5 is designed to be used for storage and organization of large amounts of scientific data and is used to exchange data structures between applications in industries such as the GIS industry via libraries such as GDAL, OGR, or as part of software like ArcGIS. The vulnerability exists due to the library\'s failure to check if certain message types support a particular flag. When this flag is set, the library will cast the structure to an alternative structure and then assign to fields that aren\'t supported by the message type. Due to the message type not being able to support this flag, the library will write outside the bounds of the heap buffer. This can lead to code execution under the context of the library. hdf5-1.8.16.tar.bz2 http://www.hdfgroup.org/HDF5/ \nhttp://www.hdfgroup.org/HDF5/release/obtainsrc.html \nhttp://www.hdfgroup.org/ftp/HDF5/current/src/hdf5-1.8.16.tar.bz2 8.6 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H The HDF file format is intended to be a general file format that is self-describing for various types of data structures used in the scientific community [1]. These data structures are intended to be stored in two types of objects, Datasets and Groups. Paralleling the file-format to a file system, a Dataset can be interpreted as a file, and a Group can be interpreted as a directory that\'s able to contain other Datasets or Groups. Associated with each entry, is metadata containing user-defined named attributes that can be used to describe the dataset. Within the HDF file format, paths can be specified as the \'/\'-separated posix format. When iterating through the contents of a group, for each object the library will first populate an H5G t structure with information about the object\'s location. Immediately afterwards, the library will fetch the metadata for the object using H5O info. This is done by the following code located within src/H5O.c After reading the header of the object\'s information into the \"oh\" variable, the library will use this information to store the object class. A little bit later, the library will use the version to determine how to process some of the attributes associated with the object. If the object\'s version is H5O 1, the library will then call H5O read MTIME msg oh. Inside H5O read id argument to determine which message type is being used for a message. This message type is used to determine which callback to use in order to handle the message. This process occurs within the macro H5O NATIVE at H5Omessage.c:545 Inside the H5O NATIVE macro, the application will select a structure containing function pointers out of the msg->type field. This structure contains various functions that are used to decode the message. After calling the decode method, the library will check to see if the H5O FLAG UPDATE_SHARED is used to write into the pointer returned by the decode function. Inside the decode function for the H5O ID structure, the application will make an allocation that is the size of a time_t field. This is located within src/H5Omtime.c:174. After allocating space for the time LOAD MSG SHAREABLE bit set. If so, the application will mis-cast the pointer to the time shared UPDATE_SHARED macro. Due to the H5O t being larger than the size of a time UPDATE t structure that was allocated by H5O decode. This will corrupt adjacent metadata in the heap, and can be used to corrupt more of the state of the application which can lead to code execution under the context of the application using the library. This H5O t structure is listed below. This vulnerable pattern also occurs while decoding two other messages. These two messages are the H5O NEW mtime decode, and H5O ID which calls H5O decode. H5O new t structure that is smaller than an H5O t which can be used to trigger a similar style of overwrite. The other message, H5O ID, which uses H5O decode uses the following H5O t structure. Due to the library mis-casting this structure to an H5O t, the library will write outside the bounds of the allocation of the H5O t. Similarly, the library will use H5FL stab_t) to allocate space for the structure that gets overwritten. These message IDs are located within src/H5Oprivate.h. H5O FLAG_SHAREABLE is located 2016-05-08 - Discovery  \n2016-05-17 - Vendor Notification  \n2016-11-15 - Public Disclosure  [1] https://en.wikipedia.org/wiki/Hierarchical Format \n[2] http://www.hdfgroup.org/HDF5/', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0178');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (437, 'HDF5 Group libhdf5 H5T_ARRAY Code Execution Vulnerability', 'None', '2016-11-17', 'HDF5 is a fileformat that is maintained by a non-profit organization, The HDF Group. HDF5 is designed to be used for storage and organization of large amounts of scientific data and is used to exchange data structures between applications in industries such as the GIS industry via libraries such as GDAL, OGR, or as part of software like ArcGIS. The vulnerability exists due to the library\'s failure to check if the number of dimensions for an array read from the file is within the bounds of the space allocated for it. When reading elements from the file into this array, a heap-based buffer overflow will occur, potentially leading to arbitrary code execution. hdf5-1.8.16.tar.bz2 \n  tools/h5ls: Version 1.8.16 \n  tools/h5stat: Version 1.8.16 \n  tools/h5dump: Version 1.8.16 http://www.hdfgroup.org/HDF5/ \nhttp://www.hdfgroup.org/HDF5/release/obtainsrc.html\nhttp://www.hdfgroup.org/ftp/HDF5/current/src/hdf5-1.8.16.tar.bz2 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H The HDF file format is intended to be a general file format that is self-describing for various types of data structures used in the scientific community [1]. These datastructures are intended to be stored in two types of objects, Datasets and Groups. Paralleling the file-format to a filesystem, a Dataset can be interpreted as a file, and a Group can be interpreted as a directory that\'s able to contain other Datasets or Groups. Associated with each entry, is metadata containing user-defined named attributes that can be used to describe the dataset. Within the HDF file format, paths can be specified as the \'/\'-separated posix format. When reading a dataset, the library will open the object using H5D DTYPE msg_read. Inside H5O read id argument to determine which message type is being used for a message. This message type is used to determine which callback to use in order to handle the message. This process occurs within the macro H5O NATIVE at H5Omessage.c:545 Inside the H5O NATIVE macro, the application will select a structure containing function pointers out of the msg->type field. This structure contains various functions that are used to decode the message. When decoding a msg of type H5O ID, the library will dispatch into the H5O shared dtype dtype dtype helper which is responsible for decoding the datatypes. After allocating space for the H5T t, the library will return back to H5O decode which will then execute the function H5O decode ARRAY, the library will read the number of dimensions from the file and then check that it\'s valid via an assertion. Due to an assertion being only enabled when the application is compiled in debug-mode, this check will get optimized out by the preprocessor. Immediately following, the library will enter a loop that reads DWORDs from the file into the H5T t.dim field. If the value of u.array.ndims is larger than 32, then this loop will read data outside the bounds of the H5T t that was allocated earlier. This will lead to heap corruption and can lead to code execution under the context of the application using the library. 2016-05-08 - Discovery 2016-05-17 - Vendor Notification 2016-11-15 - Public Disclosure [1] https://en.wikipedia.org/wiki/Hierarchical Format [2] http://www.hdfgroup.org/HDF5/', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0176');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (438, 'HDF5 Group libhdf5 H5Z_NBIT Code Execution Vulnerability', 'None', '2016-11-17', 'HDF5 is a file format that is maintained by a non-profit organization, The HDF Group. HDF5 is designed to be used for storage and organization of large amounts of scientific data and is used to exchange data structures between applications in industries such as the GIS industry via libraries such as GDAL, OGR, or as part of software like ArcGIS. The vulnerability exists when the library is decoding data out of a dataset encoded with the H5Z_NBIT decoding. When calculating the precision that a BCD number is encoded as, the library will fail to ensure that the precision is within the bounds of the size. Due to this, the library will calculate an index outside the bounds of the space allocated for the BCD number. Whilst decoding this data, the library will then write outside the bounds of the buffer leading to a heap-based buffer overflow. This can lead to code execution under the context of the application using the library. hdf5-1.8.16.tar.bz2   tools/h5ls: Version 1.8.16   tools/h5stat: Version 1.8.16   tools/h5dump: Version 1.8.16 http://www.hdfgroup.org/HDF5/ http://www.hdfgroup.org/HDF5/release/obtainsrc.html http://www.hdfgroup.org/ftp/HDF5/current/src/hdf5-1.8.16.tar.bz2 8.6 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H The HDF file format is intended to be a general file format that is self-describing for various types of data structures used in the scientific community [1]. These data structures are intended to be stored in two types of objects, Datasets and Groups. Paralleling the file-format to a file system, a Dataset can be interpreted as a file, and a Group can be interpreted as a directory that\'s able to contain other Datasets or Groups. Associated with each entry, is metadata containing user-defined named attributes that can be used to describe the dataset. When reading a dataset out of the file, the HDF5 library will call the following function, H5Dread. After allocating space for the buffer, the library will call an internal function H5D chunk_lock. This function is responsible for reading the contents of the dataset into a cache that the application will later be able to access. Once chunk pipeline. Inside H5Z_pipeline, the library will determine what kind of filter to choose and then call the \"filter\" method from a data structure that contains methods or handlers that deal with the specific encoding type. When handling data encoded with the nbit encoding type, the library will call H5Z nbit. This function will take inputs from the file and use it to calculate the amount of space required to decode the encoded data. This is done by taking the number of elements and multiplying it by the size of elements. With the provided proof of concept, the size is 4 and the number of elements is 12. This results in a buffer size of 48 bytes. When entering the H5Z ATOMIC case, the library copy input from the file into a structure that gets passed to H5Z decompress atomic. This loop will iterate for the number of elements that were stored in the dataset. The field that is used later to write outside the buffer allocated in the prior snippet is used to determine the precision of a binary-coded-decimal number. Once inside H5Z decompress atomic, the library will use the value of p.precision to calculate the index into the buffer that was allocated. Due to a lack of bounds-checking, this index will allow for a loop that is executed later to write outside the bounds of the buffer. If precision is larger than datatype_len, then the index can be made to overflow. 2016-05-17 - Vendor Notification  2016-11-15 - Public Disclosure  [1] https://en.wikipedia.org/wiki/Hierarchical Format [2] http://www.hdfgroup.org/HDF5/', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0177');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (439, 'GMER Path Length Code Execution Vulnerability', 'None', '2016-11-3', 'A stack based buffer overflow vulnerability exists in the method receiving data from SysTreeView32 control of the GMER application. A specially created long path can lead to a buffer overflow on the stack resulting in code execution. An attacker needs to create path longer than 99 characters to trigger this vulnerability. GMER 2.1.19357 http://www.gmer.net/ CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H/E:P/RC:C \nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 Gmer can be used to detect and delete hidden files and folders. We can use this functionality by choosing the \"Files\" tab in the GMER application. Folders are presented there in the SysTreeView32 control. A directory name longer than 99 characters causes a stack based buffer overflow in the function resposible for receiving data from this control item. Let\'s take a look at a vulnerable function and its surroundings. As we can see, the previous function prepares 220 bytes for local variables. Here we reach the call to the wrapper function of the TreeView_GetItem macro. We are looking at a buffer of size 200 expressed in characters (third parameter), everything looks correct and the buffer should be able to accommodate 200 ANSI chars. Stepping inside this call we see the code responsible for preparing the TVITEM structure: Everything starts to be clear when we get into sub_40AA80: Another wrapper, this time on SendMessageA. We see here 3 parameters pushed on the stack for the SendMessageA api and the handle to SysTreeView32 is pushed inside the wrapper. Let\'s jump over the wrapper code to the API call and see all the parameters pushed onto the stack: Now the most interesting parameter for our purposes is a Message and its value 113E.\nResolving this hexadecimal value to a more understandable form we get TVM_GETITEMW.\nWhile the author used the SendMessage version for ANSI, the number of signs\npassed to TVITEM cchTextMax value means now that our buffer is able to accommodate 200 UNICODE characters.\nThis incorrect size value allows an attacker to overflow the buffer and gain code execution. The buffer that accommodates data from a SysTreeView32 control should be\ndeclared as wchar t) to be able to receive the entire directory name. 2016-06-01 - Discovery  \n2016-06-10 - Reported    \n2016-11-03 - Released', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0127');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (440, 'Memcached Server SASL Autentication Remote Code Execution Vulnerability', 'None', '2016-10-31', 'An integer overflow in process sasl_auth function which is responsible for authentication commands of Memcached binary protocol can be abused to cause heap overflow and lead to remote code execution. Memcached 1.4.31 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Memcached is a high performance object caching server intended for speeding up dynamic web applications and is used by some of the most popular Internet websites. It has two versions of the protocol for storing and retrieving arbitrary data, an ASCII based one and a binary one. The binary protocol is optimized for size. If enabled during compilation, Memcached can support authentication using SASL. An integer overflow can be triggered by sending a specially crafted authentication command. The affected command is SASL Auth whose opcode is 0x21. The function responsible for parsing an authentication packet is  : In the above code, it should be noted that at [1]   is declared as a signed integer, and at [2] an integer overflow is possible if the value of   is less than   resulting in a small or possibly negative value of   which is then used at [4] in a call to  . At [3] a check limits the values   can take (MAX MECH_LEN is 32). Function   is a wrapper around   which allocates the memory for the item and copies the key: At [1],   corresponds to the specified key length and   to the previously calculated   value. At [2] the total resulting value is used as the size for allocation which ends up being too small to hold the key which leads to a heap buffer overflow at [3]. At the time of the overflow, the contents of   and the contents of memory pointed to by   are under direct control of the attacker. The following packet has all the conditions to trigger the vulnerability: In the above packet, body length is specified to be 1, and key length 32, resulting in an integer overflow which causes too little memory to be allocated, causing a heap buffer overflow during a memcpy call. Simply sending the above packet triggers the heap overflow but doesn’t cause a direct crash. In order to observe the issue, the server can be run under valgrind (with SASL authentication enabled) which then results in the following trace: 2016-10-10 - Vendor Disclosure \n2016-10-12 - Vendor Patched \n2016-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0221');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (441, 'Memcached Server Append/Prepend Remote Code Execution Vulnerability', 'None', '2016-10-31', 'An integer overflow in the process append_prepend function which is responsible for processing multiple commands of Memcached binary protocol can be abused to cause heap overflow and lead to remote code execution. Memcached 1.4.31 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H Memcached is a high performance object caching server intended for speeding up dynamic web applications and is used by some of the most popular Internet websites. It has two versions of the protocol for storing and retrieving arbitrary data, an ASCII based one and a binary one. The binary protocol is optimized for size. An integer overflow can be triggered by issuing a command that appends or prepends data to an existing key-value pair. Affected commands are: Append (opcode 0x0e), Prepend (opcode 0x0f), AppendQ (0x19), PrependQ (opcode 0x1a) which all call into   function. While parsing a binary packet, the process ends up in the following switch case in  : If either the   or   commands (or their quiet equivalents) are executed, no check is  made on the specified value of the body length. After reading the key, the parser ends up in the following code: static void process append_prepend(conn *c) { Notice that at [1]   and   are signed integers. At [2]  , which is unsigned, gets assigned to   (signed). At [3], an integer overflow can occur if   is less than   both of which come directly from the network and are under direct attacker control.  The value of   can end up being small and even negative and is later used in  . Function   is a wrapper around   which allocates the memory for the item and copies the key: At [1],   corresponds to the specified key length and   to the previously calculated   value. At [2] the total resulting value is used as the size for allocation which ends up being too small to hold the key which leads to a heap buffer overflow at [3]. At the time of the overflow, the contents of   and the contents of the memory pointed to by   are under direct control of the attacker. The following packet has all the conditions necessary to trigger the vulnerability: In the above packet, body length is specified to be 0, and key length 0xfa, resulting in an integer overflow which causes too small area of memory to be allocated causing a heap buffer overflow. The vulnerability can be triggered multiple times, and can be abused to modify internal slab metadata. As such, it can also be abused to cause information leaks required for successful exploitation. Simply sending the above packet triggers the heap overflow but doesn’t cause a direct crash. In order to observe the issue, the server can be run under valgrind which then results in the following trace: A complete server crash can be achieved by simply corrupting an existing item and then trying to retrieve it as demonstrated by the attached proof of concept. In that case, the process crashes in the following manner: 2016-10—10 - Vendor Disclosure \n2016-10-12 - Patch Fixed \n2016-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0219');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (442, 'Memcached Server Update Remote Code Execution Vulnerability', 'None', '2016-10-31', 'Multiple integer overflows in process update function which is responsible for processing multiple commands of Memcached binary protocol can be abused to cause heap overflow and lead to remote code execution. Memcached 1.4.31 9.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H Memcached is a high performance object caching server intended for speeding up dynamic web applications and is used by some of the most popular Internet websites. It has two versions of the protocol for storing and retrieving arbitrary data, an ASCII based one and a binary one. The binary protocol is optimized for size. An integer overflow can be triggered by issuing a command that adds or replaces an existing key-value pair. The affected commands are: Set (opcode 0x01), Add (opcode 0x02), Replace (opcode 0x03) , SetQ (opcode 0x11), AddQ (opcode 0x12) and ReplaceQ (opcode 0x13) which all call into   function. While parsing a binary packet, the process ends up in the following switch case in  : If any of the  ,  and   (or their quiet equivalents) is received a check is made before calling  . It should be noted that   and   are of type   and   respectively. In  : This is the first condition that must hold in order to reach the vulnerability.\nAfter reading the key, the process ends up in   function where the integer overflow happens: Notice that at [1] and [2]   and   are of type   and recall that   is an unsigned integer. Because of the difference in signedness between   and   an integer overflow can occur resulting in a negative value of   at [3]. The first required check has passed because integer promotions work in our favor, but in the second case, the final value of the arithmetic expression at [3] (an unsigned value) gets assigned to a signed value. The value in   is then used to allocate and store an item: Function   is a wrapper around   which allocates the memory for the item and copies the key: At [1],   corresponds to the specified key length and   to the previously calculated   value. At [2] the total resulting value is used as the size for allocation which ends up being too small to hold the key which leads to a heap buffer overflow at [3]. At the time of the overflow, the contents of   and the contents of memory pointed to by   are under direct control of the attacker. The following packet has all the conditions necessary to trigger the vulnerability: The value of   must be 0x8 as it is directly checked. The value of   must be greater than   when compared as unsigned integers,   also has to be greater than 0. Other checks in the code constrain the value of   required to trigger the vulnerability to the 0xFFFFFFF0-0xFFFFFFFF range. The vulnerability can be triggered multiple times, and can be abused to modify internal slab metadata. As such, it can also be abused to cause information leaks required for successful exploitation. Simply sending the above packet triggers the heap overflow but doesn’t cause a direct crash. In order to observe the issue, the server can be run under valgrind which then results in the following crash: 2016-10-10 - Vendor Disclosure \n2016-10-12 - Vendor Patched \n2016-10-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0220');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (443, 'Iceni Argus ipfSetColourStroke Code Execution Vulnerability', 'None', '2016-10-26', 'A specially crafted pdf file can cause a buffer overflow resulting in arbitrary code exection.\nAn attacker can provide a malicious pdf file to trigger this vulnerability. Iceni  Argus  Version 6.6.04  (Sep  7 2012) NK 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This product is mainly used by MarkLogic for pdf document conversions as part of their web based document search and rendering.\nA specially crafted PDF file can lead to an stack based buffer overflow and ultimately to remote code execution. that the return address has been overwritten: Using rr debugger we can easily return a couple if instructions back and see where overflow occurred. Now setting a hardware breakpoint on 0xffcf900c where the original ret address was located and executing a reverse-continue should lands in the place where the overwrite occurred. (rr) rc\nContinuing.\nWarning: not running or target is remote\nHardware watchpoint 3: *0xffcf900c Indeed, we see a write operation with eax set to the value which was used to overwrite our return address.\nA quick glance at the decompiled code : We see this write operation in line 18 where the   variable is dereferenced.\nBut, to answer why the overflow occurred we need to go back to the   function. Its code is represented as follow: In line 9 we see that the   function copies elements of the opStack container to a temporary array called  .\nThe amount of copied elements is specified by  . However,   can handle only 9 four byte values, while\n  equals 12. Let we investigate   function: As mentioned before,   elements from   are copied to  .\nThere is no check to ensure that   is smaller than the size of   which causes a buffer overflow. Let\'s see which part of the malformed pdf leads to this issue: The function   where   is defined, is related to Stroke Color Space functionality which is confirmed by the use of the   operator at line 7.\nAt line 8 we see 12 operator parameters that are used, which corresponds to the   value. The return address is overwritten by second to last value  .\nAn attacker who controls this value can cause arbitrary code execution. 2016—09-16 - Vendor Disclosure \n2016-10-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0200');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (444, 'Iceni Argus ipNameAdd Code Execution Vulnerability', 'None', '2016-10-26', 'A specially crafted pdf file can cause a buffer overflow resulting in arbitrary code execution.\nAn attacker can send/provide malicious pdf file to trigger this vulnerability. Iceni  Argus  Version 6.6.04  (Sep  7 2012) NK - Linux x64 \nIceni  Argus  Version 6.6.04  (Nov 14 2014) NK - Windows x64 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H \nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 This product is mainly used by MarkLogic for pdf document conversions as part of their web based document search and rendering.\nA specially crafted PDF file can lead to an stack based buffer overflow and ultimately to remote code execution. that the return address of a function has been overwritten: As we can see above, the stack buffer protection mechanism got triggered which means that the return address indeed has been corrupted.\nChecking call stack : shows that function where overflow occured is  . Using rr debugger we can easily return to this function when overflow took place and investigate important details: We are now at the beginning of the   function before the overflow took place. We can see that call stack is not corrupted:\n(rr) bt Before we step a couple instructions further, let\'s take a glance at the representation of the   function in pseudo-code to understand the bigger picture: From this pseudo-code we can immediately spot the vulnerability: at line 12 just at the beginning of function,\nthe argument   is passed directly to   function without any checks.\nThe string length check for   is done at line 14, AFTER the   call. We can also see at line 8 that the   buffer can hold up to 255 characters, so a\nstring longer than 255 characters will cause a buffer overflow. When we see part of document where the vulnerable string is located it looks like this: In this example the   string is located inside the dictionary as a value for key(Object name)  .\nBut what type of object it is ? String ? Int ? Float ? ...?\nIt turns out none of them and that is what is causing the problem. To observe it we need to take a glance one function above on call stack which is  . As you can see there are checks and conversions to   line 1-16,   line 19-25,   line 27-34 and a check\nwhether   is an integer at line 35. If all these checks fail we end up at line 44 and   is converted into a  . No length checks\nfor   are done in that case. The only scenario where   length is checked before passing it to   is when  \nis in a \"regular\"   representation starting with \"/\", line 1-3.\nIf an attacker creates a   that is not a \"regular\"  , it will cause a stack based buffer overflow which can result in arbitrary code execution. part of code if it\'s   element: or   content : Limitations related with characters of that string are following. It can contain characters in range [0x21-0xff] without 0x80. 2016-09-06 - Vendor Disclosure \n2016-10-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0202');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (445, 'LibTIFF TIFF2PDF TIFFTAG_JPEGTABLES Remote Code Execution Vulnerability', 'None', '2016-10-25', 'An exploitable heap based buffer overflow exists in the handling of TIFF images in LibTIFF\'s TIFF2PDF tool. A crafted TIFF document can lead to a heap based buffer overflow resulting in remote code execution. Vulnerability can be triggered via a saved TIFF file delivered by other means. LibTiff - 4.0.6 https://developer.apple.com/osx/download 6.4 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:L/A:L This vulnerability is present in the Tiff2PDF tool that is bundled with LibTIFF. this tool is installed by default in the standard build process. There exists a vulnerability in the parsing and handling of TIFF images. A specially crafted TIFF image file can lead to an out of bounds write and ultimately to remote code execution. Tiff offers support for multiple compression algorithms inside of the image itself. One such algorithm is the JPEG compression. Looking at an information dump of the attached trigger we can see this is the compression algorithm used. Note also this is a tiled tiff [0], and the crash that happens when running the trigger is shown below. The vulnerability arises in the calculating of the images tile size. The code uses a separate size reading function called t2p tiff tile. The relevant code is shown below: Our files compression is indeed jpeg so this code block is hit. The vulnerability comes when the size variable, k, is decremented by 2. Above we see that the JPEG tables of our image are 114 bytes and by decrementing by 2 it is moving it to 112. Due to malloc rounding on OS X, 112 will not be rounded and a buffer of exact size is used. Relevant code to when the jpeg is read in is below. The vulnerable buffer is allocated based on the data size in the structure which is 112 as shown above [1]. When the call to get field is made for jpeg tables [2], it will return 114 as previously noted thus resulting in a 2 byte buffer overflow. This overwrite happens to be adjacent to another freed object thus corrupting the chunk but could also be used to turn this into full remote code execution. 2016-06-15 - Vendor Disclosure  \n2016-10-25 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0187');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (446, 'LibTIFF PixarLogDecode Remote Code Execution Vulnerability', 'None', '2016-10-25', 'An exploitable heap based buffer overflow exists in the handling of compressed TIFF images in LibTIFF\'s PixarLogDecode api. A crafted TIFF document can lead to a heap based buffer overflow resulting in remote code execution. The vulnerability can be triggered through any user controlled TIFF that is handled by this functionality. LibTiff - 4.0.6 http://libtiff.maptools.org 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H This vulnerability is present in the PixarLogDecode function inside of LibTIFF. This vulnerability is present whenever attempting to decompress a PixarLog compressed TIFF image. To decompress the PixarLog compressed data inside of a TIFF image, LibTIFF uses the Zlib compression library. First the parameters needed to pass to Zlib are set up with a function call to PixarLogSetupDecode. A buffer is allocated with the code shown below: Later this buffer is used when calling the Zlib library function inflate which is responsible for the decompression. Now seeing how these parameters are used in the inflate function: So seeing this we see that this is used by Zlib as a space to write output too. The problem arises with how LibTIFF calculates out these two values. First the buffer is calculated above with this line of code: Which comes out significantly less than the avail_out value calculated below: Passing this undersized buffer into the Zlib inflate function causes a heap overflow that could be potentially leveraged into remote code execution. 2016-09-20 - Vendor Disclosure \n2016-10-25 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0205');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (447, 'LibTIFF Tag Extension Remote Code Execution Vulnerability', 'None', '2016-10-25', '{{ page.status }} An exploitable remote code execution vulnerability exists in the handling of TIFF images in LibTIFF. A crafted TIFF document can lead to a type confusion vulnerability resulting in remote code execution. This vulnerability can be triggered via a TIFF file delivered to the application using LibTIFF\'s tag extension functionality. LibTIFF - 4.0.6 http://www.remotesensing.org/libtiff/ 8.1 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H There exists a vulnerability in the parsing and handling of TIFF images. A specially crafted TIFF image file can lead to an out of bounds write and ultimately to remote code execution. This vulnerability is present in the LibTIFF api and is present in the standard build. TIFF offers support for tag extensions allowing for more tags than the standard TIFF specification. One such tag is number 326, BadFaxLines. When using this tag in LibTIFF it is possible to have a type confusion vulnerability where LibTIFF attempts to read a mistyped argument off of the variable argument list. Running the provided trigger through the Thumbnail utility provided by LibTIFF gives us the following crash. The crash occurs at the following lines of code: Recall that   retrieves the next available argument from the argument list  . Let\'s take a look at where this function was called. We see that we are passing in the variable argument list from TIFFGetField into TIFFVGetField. Effectively this is a wrapper for creating the variable list that will be handled by each individual tag. Let\'s traverse up one more function to see how   is called. Analyzing the crash a bit we can see the tag that we are crashing on is indeed number 326. Looking into the source we can see a double value is expected on the argument list but instead there is nothing there. The vulnerability arises due to the field type being determined to be a double, yet the variable argument list is empty causing an out of bounds write and ultimately leading to an exploitable condition. 2016-07-25 - Vendor Disclosure \n2016-10-25 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0190');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (448, 'Hopper Disassembler ELF Section Header Size Code Execution Vulnerability', 'None', '2016-10-18', 'An exploitable out of bounds write vulnerability exists in the parsing of ELF Section Headers of Hopper App. A specially crafted ELF file can cause attacker controlled pointer arithmetic resulting in a partially controlled out of bounds write. An attacker can craft an ELF file with sepecific section headers to trigger this vulnerability. Hopper Dissassembler 3.11.20 https://www.hopperapp.com/ 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H Hopper is a popular disassembler used for analysis of disassembly of various binary formats. During the parsing of ELF section headers, there is a user controlled size passed in that is not validated to be correct. This is then used later, causing the program to access memory out of bounds and leads to the vulnerable conditon. There are two initial crashes shown below: Here we see the program is crashing on a null check ensuring the supplied value is not 0 and in another scenario it is crashing due to an invalid string being passed into strlen. After some reversing we can detect where the r14 value has come from and can also determine what is causing the out of bounds access in the second crash We can see this value is an int which is read in directly from the program itself and then used without any validation. This 64-bit value is actually read from the binary\'s section header table and is easily controlled by the attacker. Below is an example section header with the relevant pieces changed. Now investigating the second crashing point we can see that our arbitrary value is used to calculate out the pointer to be passed into a string function. If this value is pointing out of bounds the strlen crash occurs. We see that this function is attempting to copy the provided attacker controlled string into another buffer in memory. Knowing this we can see that we can point this string anywhere in the program and copy arbitray contents creating an out of bounds write scenario. This could then be leveraged by an attacker to potentially gain remote code exection later in the program. 2016-10-13 - Vendor Disclosure \n2016-10-14 - Patch Fixed \n2016-10-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0222');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (449, 'Foxit PDF Reader JBIG2 Parser Information Disclosure Vulnerability', 'None', '2016-10-18', 'A large out of bounds read on the heap vulnerability in Foxit PDF Reader can potentially be abused for information disclosure. Combined with another vulnerability, it can be used to leak heap memory layout and in bypassing ASLR. Foxit Software Foxit Reader 8.0.2.805 6.8 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:H A wrongly bounded call to   while parsing JBIG2 segments contained in a PDF file can be triggered in the Foxit PDF Reader that would cause an out of bounds heap memory to be read into a buffer. The destination buffer of the   call is properly sized, but the source is smaller than the size argument, causing the adjacent memory to be copied into a buffer that is further controlled. This will cause heap data including metadata, addresses and pointers to be copied into a buffer which is later reused, disclosing memory layout which can lead to an ASLR bypass. The vulnerability is present in the code responsible for parsing symbol dictionary segments. A sample JBIG2 file which is enough to trigger the vulnerability is as follows: In the above listing, we have broken down two JBIG2 segments. Both are of type  . Important thing to note is that the second segment refers to the first one. Segment data in the first segment  is further broken down as follows: Segment data in the second segment is: Rest of the bytes in both segments can be ignored for now. The vulnerability itself if present in the function at 00979119 (image load base 0x00400000) which is parsing the details of symbol dictionary type segments. The paths in that function while parsing each segment diverge at the following location: At [1] in the above disassembly, a single (8th) bit in segment data is tested. 8th bit signifies if “bitmap coding context” is used. In the case of the first segment it isn’t set. The path continues in the function until it reaches the following interesting block: In the above disassembly, a single byte is tested and it decides which of the following blocks is executed: Above block sets the value of   to 65536. In the second branch , listing above, the value of ebx ends up being 0x400.\nBoth of these are followed by an allocation which is sized by value in   times 8. The byte being tested to decide which path to take (allocating 8 0x400) depends on the bits 12 and 11 of the data segment header which is extracted by the following code: In the above disassembly, at [1] the start of the data segment is copied into edx. At [2] first 10 bits are discarded and at [3], only first two of the remaining 6 are left and then saved at   at [4]. These two bits represent the SDTEMPLATE value. As the SDTEMPLATE value is 0b10 in the first segment, the second branch is taken prior to the allocation, meaning the allocated buffer will be 8*0x400 == 0x2000 bytes long. This can be observed in the following debugging session: In the above windbg session, it can be observed that at [1], two bytes from ebx correspond to begining of segment data from the first segment. At [2], we can see that the saved bits are 0b10, corresponding to the SDTEMPLATE value. At [3] is the point where the paths for the two segments diverge, the segment data header doesn’t have “bitmap coding context used” bit set and then proceeds to the [4] where previously extracted SDTEMPLATE value is being tested. It’s not 0, so we get to [5] where a memory allocation function is called with 8 and 0x400 as parameters. THe returned value at [6] is in   and is   . Next, the process continues to parse the second segment. A different path takes it to a slightly different part of the code. Because in the second segment, the “bitmap coding context used” bit it set, we land at the same test as before, but in a different location: Again, the value of SDTEMPLATE is compared, but this time it will be 0, taking the following branch: Here we see the value in   being set to 0x10000 (the other branch sets it to 0x400 again) and it is subsequently used as a size argument to  : If we observe the execution in the debugger, it can be seen In the above windbg excerpt it can be seen that the memcpy call has the destination pointer at 0x11800000\n, source pointer at 0x13279000 (which is our previously allocated buffer), and size of 0x80000. In the above, we can see that the destination is propperly sized for a 0x80000  . The source, on the other hand, is not, leading to a large out of bounds heap read and eventually a crash: The application crashes due to an out of bounds read attempt at the guard page because Page Heap is enabled. When it’s not, and there other objects allocated on the heap past the source buffer, a memcpy could succeed potentially disclosing sensitive information. In order to trigger the vulnerability, a couple of conditions need to be met. First, there needs to exist a symbol dictionary segment which refers to another symbol dictionary segment. The referred-to segment needs to have SDTEMPLATE value other than 0, and must have “bitmap coding context used” unset, wheres the referee segment, must have SDTEMPLATE as 0, and “bitmap coding context used” set. 2016-09-06 - Vendor Disclosure \n2016-10-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0201');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (450, 'FreeImage Library XMP Image Handling Code Execution Vulnerability', 'None', '2016-10-3', 'An exploitable out-of-bounds write vulnerability exists in the XMP image handling functionality of the FreeImage library. A specially crafted XMP file can cause an arbitrary memory overwrite resulting in code execution. An attacker can provide a malicious image to trigger this vulnerability. FreeImage 3.17.0 8.8 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H The FreeImage library is used by over 100+ programs according to  . Major consumers include the game engine Unity and Spamfighter, a major antispam filter developer. Consumers of this library often identify image files by calling a generic loader function such as FreeImage_GetFileType() to get a file type using a signature, or using the extension with the function FreeImage Load(). Since this often doesn\'t require a particular file format to be specified by the user of the library, it allows for easy loading and support of multiple file formats. However, this also means that file formats that a particular program doesn\'t intend to support, might be parsed by FreeImage anyway, regardless of extension. The vulnerability occurs in the file Source/FreeImage/PluginXPM.cpp in the function Load(), which is called when an XPM file is being loaded. At lines 177-207 the following code is present: At line 178, the number of chars per pixel is provided and read into a signed integer. This value is then used without further checks at line 200 to find the start of the color keys area. This memory location is then written to by replacing tabs with spaces. One way to mitigate this is to explicitly check wether a file is detected as being an XPM file by checking the return value of FreeImage GetFIFFromFilename(). If the return value of either of these functions is FIF_XPM, then the subsequent loading function should not be called. 2016-07-29 - Vendor Disclosure  \n2016-10-03 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0189');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (451, 'Redis CONFIG SET client-output-buffer-limit command Code Execution Vulnerability', 'None', '2016-9-30', 'An out of bounds write vulnerability exists in the handling of the client-output-buffer-limit option during the CONFIG SET command for the Redis data structure store. A crafted CONFIG SET command can lead to an out of bounds write potentially resulting in code execution. Redis - 3.2.3 http://redis.io/ 6.6 - CVSS:3.0/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H Redis is a simple in-memory data structure store using a key-value model. Redis has been growing in popularity due to its ability to handle problems that other databases can\'t solve or are inherently slow at. An out of bounds write vulnerability exists during the modification of the   option using the   command. The required syntax for setting the   option is shown below. This option sets the limits for disconnecting clients of a certain class. This option is set using the following code: In the parsing of   a call to   is used to retrieve the corresponding class\'s type. In this case,   returns a value in the set of [-1, 3]. Looking at the declaration of the   array, we see that the size of the array is  . Although   is only expecting clients of types  ,  , and  ,   is\nalso a valid client. By providing a client type of  , the   array is overflown and subsequent\nstructure variables are overwritten. A sample command exercising this vulnerability is below: 2016-09-22 - Vendor Disclosure \n2016—09-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0206');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (452, 'OpenJPEG JPEG2000 mcc record Code Execution Vulnerability', 'None', '2016-9-29', 'An exploitable code execution vulnerability exists in the jpeg2000 image file format parser as implemented in the OpenJpeg library. A specially crafted jpeg2000 file can cause an out of bound heap write resulting in heap corruption leading to arbitrary code execution. For a successful attack, the target user needs to open a malicious jpeg2000 file. The jpeg2000 image file format is mostly used for embedding images inside PDF documents and the OpenJpeg library is used by a number of popular PDF renderers making PDF documents a likely attack vector. OpenJpeg openjp2 2.1.1 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H The OpenJpeg library is a reference implementation of JPEG2000 standard and is used by many popular PDF renderers. Most notably Poppler, MuPDF and Pdfium. Due to an error while parsing   records in the jpeg2000 file, out of bounds memory can be accessed resulting in an erroneous read and write of adjacent heap area memory. Careful manipulation of heap layout and can lead to further heap metadata process memory corruption ultimately leading to code execution under attacker control. The vulnerability lies in   function in   file which is responsible for parsing   records. When an   record is being parsed, a   array is being iterated over in search of appropriate index. Next, if the index is not found, the following code is executed: The first if statement is entered if the index was not found, then, if current number of records has reached a maximum of   (which is 10 initially), maximum is increased and memory is reallocated to accommodate more records. At the end of the function, number of records is increased: The vulnerability in the above code lies in the improper increment of the number of records at the end of the function. If a malicious image is created, such that it has a number of   records with the same (zero) index, the counter in the for loop can never reach the value that would satisfy   condition. If there are 10 or more such objects,   will be  increased to more than   without actually reallocating the appropriate amount of memory. If then there is an mcc record with a different index in the image, the if condition inside the for loop won’t ever be true, which will lead to   pointer being increased out of bounds, causing an out of bounds read. Further on, this out of bounds pointer is retained and is used in a write operation when its index is being updated by a controlled value. By varying the number of mcc records, an attacker can target a particular heap memory area and by abusing the same bug multiple times gain enough control over the process memory to get arbitrary code execution. In the above Valgrind output, an invalid out of bounds read and write is recorded. 2016-07-26 - Vendor Disclosure \n2016-09-29 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0193');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (453, 'Microsoft Windows10 AHCACHE.SYS Remote Denial Of Service', 'None', '2016-9-13', 'A denial of service vulnerability exists in the AHCACHE.SYS driver. A specially crafted Portable Executable\nfile can cause a bugcheck in the Windows kernel resulting in remote denial of service. Windows 10, AHCACHE.SYS version 10.0.10586.0\nTested on Windows 10 X86 6.8 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:N/A:H The AHCACHE.SYS driver handles local cache for application compatibility information which is used to fix application behavior on newer versions of Microsoft Windows operating system. The bug happens in the AslpFileQueryVersionString function which is called during cache lookup (among other functions - see attached stack trace in the Crash Information section): AslpFileQueryVersionString is called from the AslpFileMakeStringVersionAttributes function. As you can see on the\ncode provided above the \"crash NOT_FOUND (assuming forged PE file is used). The value of EDI is taken from the PE file (resource section, Var->wValueLength [1] field) through the AslpFileVerQueryValue\nfunction where the wanted sub-block argument is \"\\VarFileInfo\\Translation\" (Var identifiers are often used by applications to\naccess a language-specific StringTable structure in the version-information resource). Just like presented below: Obtained maximum loops cycles value is later divided by 4 and supplied as an argument to the AslpFileQueryVersionString function\nand later used as the loop limit. When attacker forges this value it is possible to cause access violation exception because\nunavailable memory will be accessed (address 0x00020856). This happens because there are no boundary checks testing whether the\nobtained data from the resource section is big enough to cover extra size provided by Var->wValueLength. This causes whole system to\ncrash and can be triggered remotely. [1] - https://msdn.microsoft.com/en-us/library/windows/desktop/ms646994(v=vs.85).aspx 2016-07-11 - Initial Discovery \n2016-07-25 - Vendor Notification \n2016-09-13 - Patch Released \n2016-09-13 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0191');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (454, 'Kaspersky Anti-Virus Unhandled Windows Messages Denial of Service Vulnerability', 'None', '2016-9-5', 'An local denial of service vulnerability exists in window broadcast message handling functionality of Kaspersky Anti-Virus software.\nSending certain unhandled window messages, attacker can cause application termination and in the same way bypass KAV self-protection mechanism. Kaspersky Total Security 16.0.0.614 http://www.kaspersky.com/ Broadcast window messages are used by AVP protocol to certain actions trigger in Kaspersky AntiVirus such as switching current application tab to scan, tools, settings, etc. The below dispatcher code is responsible for calling appropriate handlers. The handlers for the   values listed result in termination of the Kaspersky AVP user application and protection bypass. 2016-03-17 - Discovery  \n2016-04-29 - Reported  \n2016-09-05 - Released', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0175');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (455, 'Kaspersky Internet Security KL1 Driver Signal Handler Denial of Service', 'None', '2016-8-26', 'A denial of service vulnerability exists in the IOCTL handling functionality of Kaspersky Internet Security KL1 driver. A specially crafted IOCTL signal can cause an access violation in KL1 kernel driver resulting in local system denial of service. An attacker can run a program from user mode to trigger this vulnerability. Kaspersky Internet Security 16.0.0, KLIF driver version 10.0.0.1532 5.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H This vulnerability can be triggered by sending a specially crafted IOCTL signal (0x222070) to KLBG device. The faulting code is located in the KL1 hidden driver: The instruction at 0x00018D2E is executed in a loop. The purpose of this loop is to calculate\nthe input string length by scanning for a NULL character. However if the NULL character\nis not found in the supplied input string this loop will continue reading memory\nthat exceeds the bounds of supplied buffer which in most of cases will cause\na access violation and a system crash. 2016-04-29 - Vendor Notification  \n2016-08-26 – Patch Released  \n2016-08-26 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0169');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (456, 'Kaspersky Internet Security KLIF Driver NtAdjustTokenPrivileges_HANDLER Denial of Service', 'None', '2016-8-26', 'A denial of service vulnerability exists in the syscall filtering functionality of Kaspersky Internet Security KLIF driver. A specially crafted native api call can cause a access violation in KLIF kernel driver resulting in local denial of service. An attacker can run program from user mode to trigger this vulnerability. Kaspersky Internet Security 16.0.0, KLIF driver version 10.0.0.1532 5.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H This vulnerability can be triggered by sending specially crafted NtAdjustTokenPrivileges call. Kaspersky\nx86 platforms by default hooks internal Windows kernel functions. This includes functions from\nKiServiceTable and W32pServiceTable. Even though new function hooks point to the KLHK driver\nthe real ones are located in the KLIF driver - KLHK driver acts more like a dispatcher. The faulting code is located in the KLIF driver in a function responsible for filtering the\nNtAdjustTokenPrivileges: At 0x000A218C ECX is initialized by TOKEN PRIVILEGES.PrivilegeCount to be 0x80000000 we can force the ecx after final calculation to be 0x4.\nThis allows the attacker to pass security checks in the AllocAndCopySafe procedure testing whether user supplied\ndata is located in user mode memory etc. The crash happens in the \"sub PRIVILEGES.PrivilegeCount and bases a loop\niteration on this value. So for example attacker can force loop to be executed 0x80000000 times. Since by each\nloop iteration the requested memory address for read operation is increased, sooner or later KLIF driver\nwill access unavailable memory which will lead to system crash. 2016-04-29 - Vendor Notification  \n2016-08-26 – Patch Released  \n2016-08-26 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0167');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (457, 'Kaspersky Internet Security KLIF Driver NtUserCreateWindowEx_HANDLER Denial of Service', 'None', '2016-8-26', 'A denial of service vulnerability exists in the syscall filtering functionality of the Kaspersky Internet Security KLIF driver. A specially crafted\nnative api call request can cause a access violation exception in KLIF kernel driver resulting in local denial of service. An attacker can run program from user mode to trigger this vulnerability. Kaspersky Internet Security 16.0.0, KLIF driver version 10.0.0.1532 5.5 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H This vulnerability can be triggered by sending specially crafted NtUserCreateWindowEx call. Kaspersky\nInternet Security on x86 platforms by default hooks internal Windows kernel functions. This includes functions\nfrom KiServiceTable and W32pServiceTable. Even though new function hooks point to the KLHK driver\nthe real handlers are located in the KLIF driver - KLHK driver acts more like a dispatcher. The faulting code or rather codes are located in the KLIF driver in a function responsible for filtering the\nNtUserCreateWindowEx: Denial of Service location 1: Denial of Service location 2: Variables arg plstrClsVersion and arg plstrWindowName are arguments of the NtUserCreateWindowEx\ncall. They both are defined as pointers to unicode strings. Kaspersky checks in the TestPtrAndCopy function whether the provided pointer resides in the user space and whether\nfirst 4 bytes are readable: However this check is not enough since only 4 bytes are tested and later on Kaspersky\ntries to access the dword located at offset +0x8 which wasn\'t validated. This can lead\nto local denial of serivice attack when the memory located at offset +0x8 is not accessible. This vulnerability can be triggered either by forging the arg plstrClsVersion argument\nor the arg plstrWindowName argument. 2016-04-29 - Vendor Notification  \n2016-08-26 – Patch Released  \n2016-08-26 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0166');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (458, 'Kaspersky Internet Security KLDISK Driver Multiple Kernel Memory Disclosure Vulnerabilities', 'None', '2016-8-26', 'Multiple information leaks exist in various IOCTL handlers of the Kaspersky Internet Security KLDISK driver. Specially crafted IOCTL requests can cause the driver to return out of bounds kernel memory, potentially leaking sensitive information such as privileged tokens or kernel memory addresses that may be useful in bypassing kernel mitigations. An unprivileged user can run a program from user mode to trigger this vulnerability. Kaspersky Total Security 16.0.0.614 http://www.kaspersky.com/ This vulnerability can be triggered by sending IOCTL requests to the KlDiskCtl device. Here we show the default access control on the device allow any user on the system to send IOCTL requests: Multiple privileged memory disclosure vulnerabilities exist specifically in the way certain IOCTL handlers misuse buffered transfers.\nWe can identify IOCTls using buffered transfers by looking for the METHOD_BUFFERED property: These vulnerabilities are strictly related with this specific transfer type and how the output buffer length information is set at the end of\nthe IOCTL handler function. Analysis of an example vulnerable IOCTL handler at 0x8123e048 follows: In Line 7 we see that OutputBufferLength is set to 0x14 but in Line 18 again assigned a value from parameters passed by user.\nLine 20 makes a call to a function to which OutputBufferLength is passed as parameter and set by the underlying function based upon the return buffer size. The vulnerability appears when the condition on line 36 is not met. In this case, the function won\'t assign outBuffLen on line 49.\nSince the value is not replaced in the underlying function, on line 22 to IoStatus.Information field which indicates how many bytes is returned in output buffer to user mode is set based on fully controllable user input resulting in arbitrary amount of memory leaked from kernel to userspace. The vulnerability exists during handling the following IOCTLs: Python code to trigger the memory disclosure: Example output: If possible we recommend a more strict access control on accessing the affected device as well as fixing the code path leading to user control over IoStatus.Information. 2016-04-29 - Vendor Notification  \n2016-08-26 – Patch Released  \n2016-08-26 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0168');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (459, 'AB Rockwell Automation MicroLogix 1400 Code Execution Vulnerability', 'None', '2016-8-11', 'An exploitable Use of Hard-coded Credentials (Undocumented Community String) vulnerability exists in the SNMP functionality of Allen-Bradley Rockwell Automation MicroLogix 1400 Programmable Logic Controller (PLC) Systems. At the most basic level, knowledge of the undocumented community string allows an attacker to read all values accessible via SNMP. In addition to read permissions, the \'wheel\' community has the same write privileges as the \'private\' community and can modify all writable SNMP OIDs.  An attacker can leverage this vulnerability to remotely modify the device firmware, allowing the attacker to run his own malicious code on the device. Allen-Bradley Rockwell Automation MicroLogix 1400 Programmable Logic Controller Systems versions 7 - 15.004 7.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L Allen-Bradley MicroLogix 1400 Programmable Logic Controllers are configured with an undocumented and privileged SNMP community string which enables malicious actors to take complete control of all affected devices.  According the Allen-Bradley, MicroLogix 1400 PLCs are intended for use in: \"General Industrial Machinery (Material Handling, Packaging, Assembly, etc), HVAC / Building Automation, SCADA (Oil and Gas, Water/Wastewater, and Electrical Power), Food and Beverage, Pharmaceutical, Commercial Machinery (Vending, Industrial Washers and Dryers, etc)\". In addition to the default, documented SNMP community strings of \'public\' (read) and \'private\' (read/write), an undocumented community string of \'wheel\' (read/write) exists which enables attackers to make unauthorized changes to the devices, such as modification of settings and even conducting malicious firmware updates. It is possible this community string allows access to other untested OIDs, but that has not been tested at this time. At the most basic level, knowledge of the undocumented community string allows an attacker to read all values accessible via SNMP. The below shows walking Allen Bradley\'s MIB using the public, private, and wheel community strings.  ​Note that the \'public\' string is denied access but the \'​private\' and \'wheel\' community strings both return the same results, indicating that \'wheel\' provided privileged access. In addition to read permissions, the \'wheel\' community has the same write privileges as the \'private\' community. The below demonstrates reading and writing to the SysContact OID. Both the \'private\' and \'wheel\' community strings are authorized to write to this field. To demonstrate the risk associated with this undocumented privileged access, the below walks through the process of using the \'wheel\' community string to upload a malicious firmware file. The entirety of the attack is conducted using the free and open source applications  from the ​Net-SNMP ​project (http://net-snmp.sourceforge.net/wiki/index.php/TUT:snmpwalk). Get\nInitial/default value of IP address of firmware: ​0.0.0.0\nInitial/default value of filename of firmware: \"\" (empty)\nInitial/default value of firmware update flag: ​ Set\nValue of IP address of firmware: ​192.168.42.200 ​(attacker)\nValue of filename of firmware: “​hacked_firmware.bin\" Confirm\nRead value of IP address of firmware: ​192.168.42.200\nRead value of filename of firmware: \"hacked_firmware.bin\" Execute firmware updates\nSetting OID ​1.3.6.1.4.1.95.2.3.1.1.1.1.0 ​to a value of \'2\' triggers the firmware update process. The PLC attempts to initiate a TFTP file transfer and retrieve the file specified at the IP address of the attacker. The unencrypted nature of SNMPv1 and v2c communications presents risk from attackers who are able to sniff traffic and capture community strings in transit. The risk of using the plain text protocol would be substantially mitigated by the necessity for an attacker to be in a position to capture traffic to/from the target device (assuming asset owners have changed the default community string values). However, the presence of an undocumented community string significantly increases the risk of attack since attackers no longer need to sniff a valid community string from network traffic. The ability to change the community string, it is not \'hard-coded\', slightly reduces the risk of its use by a malicious actor. However, the undocumented nature of the string leaves asset owners ignorant of its presence and therefore unlikely to change it from the default value. 2016-06-10 - Vendor Disclosure  \n2016-08-11 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0184');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (460, 'Microsoft Windows PDF API Jpeg2000 csiz Remote Code Execution Vulnerability', 'None', '2016-8-9', 'An exploitable out of bounds write vulnerability exists in the PDF parsing API in the latest versions of Microsoft Windows. A specially crafted PDF file can cause an out of bounds write resulting in arbitrary code execution. Vulnerability can be triggered via malicious web page or a saved PDF file delivered by other means. Microsoft Windows PDF API Windows.Data.Pdf.dll version 10.0.10.586.162 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H The vulnerability is present in the Microsoft native PDF API which is available since Windows 8.1. In Windows 10, Microsoft Edge is the default application for opening PDF files enabling potential vulnerabilities in native PDF API to be exploited over the Web. There exists a vulnerability in the way Microsoft PDF API parses jpeg2000 files embedded in the PDF documents. A specially crafted jpeg2000 file can trigger a out of bounds memory overwrite and lead to remote code execution. Jpeg2000 files consist of a number of containers or boxes. Contiguous Codestream box contains the actual image data in the jp2 file and can have a number of child boxes. Contiguous Codestream box starts with a \"jp2c\" marker. According to the standard, jp2c box can contain SIZ marker segment (image and tile size info), a COD marker segment (coding style default info), a QCD marker segment (quantization default information) and a number of tile part elements which can in turn contain their own COD, CQD and other child elements. Start markers for SIZ is 0xFF51, COD 0xFF52, QCD is 0xFF5C and tile part is 0xFF90. An example of the file layout can be as follows: According to the standard, tile part elements can contain only COD, CQD, COM, and SOT elements where COD, CQD and COM are optional. In the supplied testcase triggering the vulnerability a tile part element has an unexpected SIZ element which gets parsed and leads to a vulnerability. Elements are parsed one by one in a   method where for each marker type, a suitable decoder is called: When parsing a SIZ element,   in the above code calls the   method. In it, various values are initialized. Amongst other things, SIZ marker specifies the number of components (csiz) as an 16 bit integer. This value is used to resize a vectors holding COD and CQD information: In the above disassembly, at [1] csiz value is read from the bytestream, at [2], it\'s used to resize the QCD MARKER vector. The pointers to both are stored at   and   respectively. Next, COD marker decoder is called,  , where the above resized vector is used in it\'s elements initialized in a loop: At [1] a pointer to the vector is retrieved, at [2]   is used as an index into the vector values, and is added to  , at [3] the current vector element is used with its assignment operator, at [4] index is increased,  and at [5] the counter is compared to the previously mentioned csiz value. A similar codepath is executed while parsing the CQD marker. With page heap enabled , the supplied testcase crashes with the following: It\'s crashing in the COD MARKER vector is resized to 3 inside   method: In the above debugging output, it can be seen that the resize argument is 3  and that   is pointing to  . Also, after the call, the location at   is initialized with pointers to vector start and end, so initially the COD_MARKER vector starts at  . Placing a breakpoint at above mentioned COD vector assignment code inside   gives: In the above debugging output, we hit a breakpoint on a call to   and can see that   points to the beginning of the resized vector from the  previous disassembly. It continues to loop 3 times as specified by csiz value. As mentioned before, the supplied testcase has a tile part that contains an extra SIZ marker along with COD marker, so resuming the execution breaks again in   during COD_MARKER vector resize: In the above debugging output, a call to resize is made with the same   as previously. Before the call, the same vector pointers are at  , but after the call, the vector has been reallocated because of resize. In the above code, the value of the  , or the argument to resize, is 4 which is the csize value specified in the second SIZ element in the file. In short, the COD_MARKER vector had to be resized to 4 which ended up reallocating it, meaning that previous saved pointers are invalidated. Continuing execution leads us again to COD element decoder, but this time a different path is taken. Instead of new reference to a resized vector, an old one is used but with a new counter: In the above debugging output, we can see that the max counter value is 4 (as specified by new csiz value) but the vector being used is still the same as before,  . In the fourth iteration of this loop, the index into the vector elements will be increased past the allocated heap chunk resulting in an out of bound memory access: This ultimately leads to a crash due to invalid memory write. With page heap turned off, memory past the end of the heap chunk above will be readable and writable so the process wouldn’t crash there. By carefully controlling the contents of the memory past the adjacent chunk further memory corruption can be achieved possibly leading to arbitrary code execution. Similarly to COD marker, CQD marker parsing is affected with the same out of bounds access/write issue. A stale reference is being reused there too leading to other interesting memory overwrite primitives: Above disassembly is from   method call and in it, the stale CQD vector pointer is used to iterate through its elements with an assignment operator. The same out of bounds issue occurs and leads to a different crash inside   where a call to   is passed an pointer from invalid memory. Finally, without page heap, the following crash occurs: The above crash occurs after the out of bound memory write in COD marker decoder corrupts heap metadata and an invalid pointer gets used during the CQD decoder. In order to successfully exploit this vulnerability, a high control over the heap contents is needed which can possibly be achieved with calculated placement of tile information and other boxes in the jp2 file. It is also possible that the vulnerability can be triggered multiple times while parsing the same file, giving the attacker even greater control over the overwrites. In summary, the vulnerability is due to the fact that SIZ element present inside tile data element (which seems to violate the standard) resizes the COD and CQD vectors, but a stale pointer gets reused leading to out of bounds write. A detection of malicious files of this nature can be based on a fact that a one or more tile parts have a SIZ element that specifies csiz greater than the initial, global SIZ element. Vulnerability analysis is done on a custom simple sample application that utilizes PDF API, but the supplied testcase also crashes in Microsoft Edge browser. With application verifier and page heap enabled, output of \"analyze -v\":', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0170');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (461, 'LexMark Perceptive Document Filters XLS Convert Code Execution Vulnerability', 'None', '2016-8-6', 'An exploitable buffer overflow exists in the XLS parsing of the Perspective Document Filters conversion functionality. A crafted XLS document can lead to a stack based buffer overflow resulting in remote code execution. Lexmark Perceptive Document Filters http://www.lexmark.com/en_us/partners/enterprise-software/technology-partners/oem-technologies/document-filters.html 10.0 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H This vulnerability is present in the Lexmark Document filter parsing which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services.  This product is mainly used by MarkLogic for document conversions in as part of their web based document search and rendering. It can convert common formats such as Microsoft\'s document formats into more useable and easily viewed formats. There is a vulnerability in the parsing and conversion of a XLS document. A specially crafted XLS file can lead to an out of bounds write and ultimately to remote code execution. Escher is part of the Office DLL and is used by PowerPoint, Word, FrontPage, Publisher, and Excel. Escher streams store their data as records with a common header. This header is shown below: Essentially the XLS document is read in as a stream with defining headers to determine where data is and how it should be displayed. In the supplied test case the cbLength field is modified to be larger than the expected block. This value is read in directly from the XLS document and used in a memcpy to a stack based buffer of fixed size. The given POC uses a size of 0x900 and the stack buffer is 112. Struct initialization: The data corresponding to the read: The instance in the header is used to determine the code path taken for the corresponding data. The instance value falls between 0xF000 and 0xFFFF and the meanings of these values can be looked up. In this case the value of 0xF016, corresponding to a msofbtDgg structure,  leads us down the vulnerable code path. And the stream reader assembly: The subsequent crash with user controlled PC: In summary a size integer is read in directly from the user and is used as the size for a memcpy causing a stack based buffer overflow fully controllable by an attacker. Ensure library path is setup correctly and run the convert application with the trigger passed in as the first argument.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0172');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (462, 'Lexmark Perceptive Document Filters CBFF Code Execution Vulnerability', 'None', '2016-8-6', 'An exploitable heap overflow vulnerability exists in the Compound Binary File Format (CBFF) parser functionality of Lexmark Perceptive Document Filters library.\nA specially crafted CBFF file can cause a code execution.\nAn attacker can send a malformed file to trigger this vulnerability. Perceptive Document Filters 11.2.0.1732 http://www.lexmark.com/en_us/partners/enterprise-software/technology-partners/oem-technologies/document-filters.html This vulnerability is present in the Lexmark Document filter parsing which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture services.\nThis product is mainly used by MarkLogic for document conversions as part of their web based document search and rendering. It can convert common formats such as Microsoft\'s document formats into more useable and easily viewed formats.\nThere is a vulnerability in the parsing and conversion of a CBFF file. A specially crafted CBFF file can lead to an integer overflow and ultimately to remote code execution. This is what it looks like when we get the library to parse a malformed CBFF file: |Name                               |   Value     | Start  |Size|\n------------------------------------|-------------|--------|----|\nstruct StructuredStorageHeader stg  |             |     |   200h|\nBYTE  clsid                 |             | 8h  |   10h|\nUSHORT  uDllVersion                 |   3         | 1Ah |   2h|\nUSHORT  uSectorShift                |   241       | 1Eh |   2h|\nUSHORT  usReserved                  |   0         | 22h |   2h|\nULONG  csectDir                   |   0         | 28h |   4h|\nFSINDEX  sectDirStart                  |   16842754  | 30h |   4h|\nDFSIGNATURE  ulMiniSectorCutoff           |   0         | 38h |   4h|\nSECT  csectMiniFat               |   4294967295| 40h |   4h|\nSECT  csectDif                   |   4278714368| 48h |   4h|\nSECT _sectFat[109]                  |             | 4Ch |   1B4h| and raw form of first 80 bytes monitoring for potential memory corruption we obtain the following result: as we can see in lines: had place allocation of heap buffer with size 0 and next at least 8 bytes are copied to this buffer with memcpy causing heap corruption. Having information about the call stack is interesting. Let’s investigate the ISYS Short_Sectors\nmethod in context of what values of our corrupted file have been used to calculate the buffer size and have triggered memcpy. We can observe in line 24 the malloc size argument is a result of multiplication of _csectMiniFat and dword214.\nThere is no check to make sure no integer overflow has occurred before passing this result to malloc.\nLet we see what the values look like just before imul instruction is called ok, let execute imul instruction: like we expected, an integer overflow occurred and malloc is called with argument size equal 0. Before we go further to see where the heap is corrupted and what size value is used in memcpy let’s try to figure out where: is initialized. with 20 additional bytes at the beginning. Checking the location of allocation for this buffer: we see that this buffer has a size of 712 bytes and has been allocated in the ISYS_NS::docfile::StgOpenStorage method. Somewhere around there we should try to find the initialization of the field at offset +0x214. Line 13 presents the allocation of our buffer and next there is call to the CIStorageBase constructor. Reviewing the code of the CIStorageBase constructor we see: so the first header from the file is read (512 bytes) and next we see the WORD at offset +0x32 which is in our file field: is used as a shift operator parameter and the result from this operation is stored in value +0x214.\nWe can presents it as a pseudo code in the following way: Now we know both integers values are used in a multiplication, and the result is later used in malloc. At information\'s presented by valgrind we see that the heap corruption take place in Read Sector method: This method is called just after the call to malloc with the following parameters: Coming just after malloc function let us set bp on ISYS_NS::CBufferedReader::Read and step to the line where memcpy is called. We end up in the following situation: Where does the 3rd argument (size = 0x215) come from?\nIn ISYS_NS::CBufferedReader::Read method there is a check which checks if the value passed as the size of the buffer to copy (which in our case was __sectMiniFatStart)\nis bigger than file size. If so, the file size value is used in a memcpy. You can see this in the following pseudo code: As we can see the heap gets corrupted.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0185');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (463, 'LexMark Perceptive Document Filters Bzip2 Convert Out of Bounds Write Vulnerability', 'None', '2016-8-6', 'An exploitable out of bounds write exists in the Bzip2 parsing of the Perspective Document Filters conversion functionality. A crafted Bzip2 document can lead to a stack based buffer overflow causing an out of bounds write which under the right circumstance could potentially be leveraged by an attacker to gain arbitrary code execution. Lexmark Perceptive Document Filters http://www.lexmark.com/en_us/partners/enterprise-software/technology-partners/oem-technologies/document-filters.html 7.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L This vulnerability is present in the Lexmark Document filter parsing which is used for big data, eDiscovery, DLP, email archival, content management, business intelligence and intelligent capture. This product is mainly used by MarkLogic for document conversions in there rendering. It can convert common formats such as Microsoft\'s document formats into more useable and easily viewed formats. This converter also handles files inside of a compressed format for further use cases. There is a vulnerability in the parsing and conversion of a Bzip2 document. A specially crafted Bzip2 file can lead to an out of bounds write and potentially to remote code execution. The number of bits to be read in from the next sequence of parsing is directly controlled by the user as shown here: Running this with a debugger we can see the value assigned to our counter. Notice the value of ESI, 0x101, being written to RBP (compressed_object) + 0x50 which is the counter variable inside of the object. This becomes important for the next part of the vulnerability. This read in counter value is then used in a loop that is effectively a memset of the compressed objects buffer. This loop writes null bytes into the buffer until the counter is less than 255. The problem arises in that the counter object never changes. The counter relies on multiple fields inside of the compressed object but none of these change the value of the counter causing an infinite loop. As can be seen below the array access to change v3 always returns the current value of v3 causing this to turn into an infinite loop with the array continually being incremented. First loop through notice RDX = 0 which will be written into the stack buffer. Going a few steps further we can see where RDX gets reassigned. Directly after RDX gets assigned the value from the compressed objects array,  we note that RDX still is equal to 0x101. This is going to cause an issue due to the fact that the stack buffer continuously gets incremented and there is no way for the loop to exit. The array continues to get incremented until it runs into unmapped memory which then throws the out of bounds memory access exception. Ensure library path is setup correctly and run the convert application with the trigger passed in as the first argument.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0173');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (464, 'Hancom Hangul Office HShow!NXDeleteLineObj+0x560cb Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul HShow application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul HShow Document (.hpt) and processing a structure within the document, the application will attempt to allocate space for a list of elements using a length from the file. When calculating this length, an integer overflow can be made to occur which will cause the buffer to be undersized when the application tries to copy file data into the object containing this structure. This allows one to overwrite contiguous data in the heap which can lead to code-execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul HShow is prefixed with a header which can describe whether it\'s contents are encoded with the zlib library. After processing the header, the application will take the version and use it to determine which structures need to be decoded within the zlib-encoded data. When reading a particular uint32_t from the file, the application will take this value and multiply it by 0x228. Later, the application will use this result to perform an allocation for a buffer that is used by a loop that reads content from the file. Due to the application not checking for an upper bounds on this value, the integer can be made to overflow causing the heap allocation to be undersized at which point the loop can be made to write outside this buffer. After reading the header and decompressing the zlibbed data section in the file, the application will eventually encounter the following function. This function is responsible for reading a 0x10 byte structure from the file. When the function returns, the function only checks if the dword has it\'s signed-bit set. Inside this function, the application will read a dword into the structure that\'s passed as an argument in the %eax register. After reading the dword, the application will use the dword in the following code. This code multiplies the dword by 0x228 and then passes it to a function to allocate memory followed by initializing the memory using the memset function. Due to the application failing to check the bounds of this multiply, an integer overflow can be made to occur. This will later be used in an allocation. Later, the application will use the dword from the file as a counter to a loop that\'s responsible for reading each structure from the file. This loop will iterate the number of times that\'s specified by the dword and will eventually call a function with the same parameters as fread(...) to decompressed the zlibbed data into the allocated buffer. Due to this loop using a different value than the one used to allocate the space to write to, a heap-based buffer overflow can be made to occur. With the provided proof-of-concept, the particular fread that overflows this buffer is located here. Inside the provided proof of concept, the 0x10 byte structure that\'s read is located at offset 0x7faf within the decompressed zlib data. The first dword is the value multiplied by 0x228 for the allocation. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0144');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (465, 'Hancom Hangul Office HShow!NXDeleteLineObj+0x53692 Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul HShow application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul HShow Document (.hpt) and processing a structure within the document, the application will use a field from the structure in an operation that can cause the integer to overflow. This result is then used to allocate memory to copy file data in. Due to the lack of bounds checking on the integer, the allocated memory buffer can be made to be undersized at which point the reading of file data will write outside the bounds of the buffer. This can lead to code execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul HShow is prefixed with a header which can describe whether it\'s contents are encoded with the zlib library. After processing the header, the application will take the version and use it to determine which structures need to be decoded within the zlib-encoded data. When reading a particular uint32_t from the file, the application will take this value and multiply it by 2 and then add 1. Later, the application will use this result to perform an allocation for a buffer that is used by a loop that reads content from the file. Due to the application not checking for an upper bounds on this value, the integer can be made to overflow causing the heap allocation to be undersized at which point the reading of file data will write outside the bounds of the allocated buffer. At the very beginning of the function at 0x887120, the application will read a structure from the disk. When reading this structure, one of the fields are used in an allocation. Immediately after reading the structure from the file, the application will take the 3rd dword at read from the structure, multiply it by 2 and then add 4, and then use it to allocate memory that is later read into. Due to a lack of bounds checking, this operation can be made to overflow. Afterwards, the buffer is written to %esi+0xc A few instructions after storing the heap pointer, the application will then pass this value to a function that\'s responsible for reading file-data into. Once inside the function, the application will use the length as a terminator for a loop that reads data into the pointer that\'s passed in as an argument. This will overflow the buffer that was under-allocated. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2015-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0146');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (466, 'Hancom Hangul Office HShow!NXDeleteLineObj+0x6960c Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul HShow application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul HShow Document (.hpt) and processing a structure within the document, the application will attempt to allocate space for a block of data within the file. When calculating this length, the application will use a value from the file and add a constant to it without checking whether the addition of the constant will cause the integer to overflow which will cause the buffer to be undersized when the application tries to copy file data into it. This allows one to overwrite contiguous data in the heap which can lead to code-execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul HShow is prefixed with a header which can describe whether it\'s contents are encoded with the zlib library. After processing the header, the application will take the version and use it to determine which structures need to be decoded within the zlib-encoded data. When reading a particular uint32_t from the file, the application will take this value and add 0x16 to it when allocating space for data. Later, the application will try to read file data into the allocated space. Due to the application not checking that the addition will cause the integer to overflow, a heap-based buffer overflow can be made to occur. After reading the header and decompressing the zlibbed data section in the file, the application will eventually call the function at HShow.exe+5fcf30. At the beginning of this function, the application will copy data from an argument onto the stack. The second dword of this data is used in a loop later in the function. Later in the same function, the application will enter the following loop. This loop will use the second dword to terminate itself. The first function call in this loop will lead to our vulnerability. Inside the function that\'s called, the application will set a variable on the stack to point to a linked-list. One of the structures within this linked list contains all the variables required by our vulnerability. At address 0x8b22a, the application will pass the linked-list as the second argument. Once the linked-list is passed to the function call at 0x8bd22c, the application will enter the following loop at 0x8bf95c. This loop increments an index in the %edx register, which is used to fetch the structure that\'s located within the linked list that\'s passed as an argument. Once the structure is fetched at the beginning of the loop, the application will pass the structure as an argument to the following function call. This function call contains a list of 0x24 different cases. In case 0xd, the application will pass an object containing the size as the third argument to the function. Inside the function at 0x911640, in the function the application will pull a uint32_t length out of the third argument and then add the constant 0x16 to it. This constant does is not checked and can be made to overflow. Later, this constant is passed down the call-chain and is eventually used to allocate a buffer. After passing the size as an argument at the function call to 0xaba920, the application will store the size into the %ebp register. Later in the function, this size will be used as an argument for an allocation and then later a memcpy operation occurs. Due to an integer-wrap occurring, this memcpy will overflow the heap buffer which can lead to the overwriting of a contiguous structure on the heap. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0145');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (467, 'Hancom Hangul HCell Workbook Table and Pivot Style Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul Hcell application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul Hcell Document (.cell) and processing a record containing the table and pivot style within the Workbook stream, the application will copy arbitrarily sized data into the primary data structure used for the current Workbook. The vulnerability occurs due to a negligence of the application to check the length of the style names before copying them into a constantly sized buffer. This results in a heap-based buffer overflow which can lead to code execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul Hcell uses the Structured Storage COM API to load and store the Spreadsheet generated by a user. Although there are various streams that can be specified wthin a document, the Hcell application stores the contents of a workbook within the \"Workbook\" stream as an array of Type-Length-Value structures. Each of these structures describe the worksheets and the cells that compose the document. Within a document, a user can create any number of styles that can be used to describe the look-and-feel of a document. During rendering of the workbook to the user, these styles will get applied to the document. When parsing the Workbook stream, the application will perform 3 passes over each record. During the second pass, the application will collect the majority of the records containing formatting information as well as cell contents. If the record type is of the value 0x088e, then the application will execute a method at address 0x6b9c755a. Immediately after, the application will execute the method using the dynamic call at address 0x6b9c766f. This calls the function at address 0x6ba64180 which is responsible for parsing the contents of the 0x088e record. Inside this function call, the application will enter a loop that will iterate through each record of type 0x088e and execute the method at 0x6ba64197 on it\'s contents. This implies that it is common for the application to put a chain of these records next to each other. The method call at 0x6ba64197 executes a function at address 0x6ba2e870. This method at address 0x6ba2e870 is responsible specifically for parsing the contents of the 0x088e record. At the beginning of this function, the application constructs two std::basic string type. After building the two basic_string types for the Table and Pivot style name, the application will finally execute the method at address 0x6ba2ea15 for copying the Table style string into the CBook object. This method is exported as CBookBase::SetDefTableStyle and has a similar logic to the next method that is called at 0x6ba2ea36, CBookBase::SetDefPivotStyle. Both of these methods are responsible for populating the CBook object with the styles listed within the file. The vulnerability exists within both of these methods, however, the provided proof-of-concept triggers it within the Pivot style name first. Inside the HCellBook.dll!CBookBase::SetDefPivotStyle method, the application will first calculate the length of the string that was passed to it as a paremter. If this string length is zero, then the function will terminate early. At this point, the application will then check to see if the string length that was passed as a parameter is zero, if this is not the case then the application will then call the wcscpy s) is then used to copy the string into one of the properties of the CBook object. Due to the application explicitly trusting the length provided from the file when copying this string, a buffer overflow can be made to occur. The logic within the HCellBook.dll!CBookBase::SetDefTableStyle method is the exact same. Inside the copy constructor for the CBookBase object at HCellBook.dll!CBookBase::CBookBase, one can see the destination buffers for the wcscpy_s function are allocated with the size of 0x82 * sizeof(dword). This vulnerability occurs if the lengths specified within the 0x088e record plus one for the null byte are larger than 0x208 inclusive. At offset 0xa14 of the structure is a pointer to an HclDoc object that can be overwritten. The Hangul HCell document format utilizes the Compound Document format that is available via Microsoft\'s API. This file format is documented by Microsoft as part of their Document Interoperability Initiative. The format is similar to the FAT file format and contains a table describing where each file stream is stored within the file. Within each Hcell file is a stream labeled \"Worbook\" which is where the contents of the document is stored at. The overall structure of an Hcell document can be described as a list of arrays of smaller type-length-value structures. Each record within the stream is prefixed by a header described as the following. Each array is terminated by an element of type 0x000a. Within the proof-of-concept that should\'ve been provided, this leaves 6 substreams. The element containing the style names is identified by type 0x088e and is located at offset 0xa11 of the provided proof-of-concept. This can also be located as record 67 of the 1st stream. The 0x088e record can be located at offset 0xa15 within the proof-of-concept and has the following structure. The first few fields don\'t appear to be used for anything. However, at offset 0x10 and 0x12 within the structure are the string lengths that are used by this vulnerability. Both of these are of type uint16_t and are used to determine the lengths of the Table style and Pivot style strings that follow the fields within the file. The amount of space allocated in the data structure where these Style strings (plus a null byte) are copied to is 0x83*4 (524) bytes in length. If either of the length fields in this structure are larger than 522, then this vulnerability is being triggered. Within the provided proof-of-concept, the Table style length is 0x3b00 and the Pivot style length is 0x4a00. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0148');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (468, 'Hancom Hangul HCell OfficeArt Record pConnectionSites and pVertices Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul Hcell application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul Hcell Document (.cell) and processing a property record within the Workbook stream, the application will attempt to allocate space for an element using a length from the file. When copying user-supplied data to this buffer, however, the application will use a different size which leads to a heap-based buffer overflow. This vulnerabiltiy can lead to code-execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul Hcell uses the Structured Storage COM API to load and store the Spreadsheet generated by a user. Although there are various streams that can be specified wthin a document, the Hcell application stores the contents of a workbook within the \"Workbook\" stream as an array of Type-Length-Value structures. Each of these structures describe the worksheets and the cells that compose the document. When parsing the Workbook stream, the application will perform 3 passes over each record. The third pass is assumed by the author to parse record types that depend on cell data that is parsed during the second pass. During the third pass, the application will read the record type of 0x00ec. This record type is the same as OfficeArt\'s (Escher) record and utilizes the exact same format. Once this type is identified, the application will then enter a function that deals with OfficeArt records. Inside this function is a loop that will take the recordheader and use it to determine which case should be used to handle which record type. If the recordtype is 0xf004, which defines the record OfficeArtSpContainer, then the application will execute the following code. This code is responsible for reading information from the file that is used to define a Shape. Inside this function, the application will read the contents of the container into a buffer. After reading the file data into a buffer, the function call at 6979d455 is responsible for initializing an object containing a number of associative arrays that are used to reference file data related to the shape. Each of these arrays are a map-like-object that store the offsets to the various record types that compose a Microsoft Office shape container. When creating the associative array for each property, if the property has it\'s fComplex bit set, then the associative-array\'s value is mapped to the out-of-band data associated with the property. This allows the application to quickly find the IMsoArray data that is used by the pVertices and pSegmentInfo properties when rendering the shape. After populating this object with it\'s lookup tables, the object will then get passed to the function call at 6979d477. Inside the function at 69b41a10, the application will process the different sub-records that are within the OfficeArtSpContainer. After processing record types such as 0xf122 or 0xf00b which contains information such as the coordinate system for the shape, the application will use the flags for the 0xf00a record type. This record type is named OfficeArtFSP and contains a list of flags that describe conditions of the shape. Eventually, the application will execute the code at 69b42009. This function call is specifically responsible for acting on the list of properties that were read from the 0xf00b record. It is within the 0xf00b record that information such as the vertices and the segment-info of our shape are processed. Inside this function, the application will process our vulnerable OfficeArtFOPTE properties specifically. The function call at 0x69b4b316 will return a pointer to the file-data given a property identifier in the %esi register. With the provided proof-of-concept, which does not include a philShape property, the application will execute until it finally hits the function call at 69b4b4ac. This function call checks to see if the shape is to be drawn in Black and White mode (bWMode). Inside the function at 69b4b540, the application will map the value of the bWMode property to an enumeration described as MSOBWMODE. After this is determined, the application will finally grab the value of the pVertices property and then make a call to the function at 69b4fb45 with the file data as it\'s parameter. Once in this function, the application will continue on to the call at 69b55f60 which will actually use the property\'s values in a vulnerable manner. Inside the function call at 69b55f60, the application will process the pVertices and pSegmentInfo properties. Earlier, when the application created an associative array for the properties within this container, an the array was made to store the out-of-band data parts of each property. This out-of-band data will be referred to as the complexData field. For these properties, the complexData field is organized in a structure known as IMsoArray. It as at this point in execution, that the application copies an IMsoArray structure out of the complexData field within the file. At address 0x69b56031, the application processes the pVertices\' IMsoArray. A little bit later, at address 69b5607f, the application will call the vulnerable function using the IMsoArray from the pSegmentInfo property. Although both properties are vulnerable, the provided proof-of-concept triggers the vulnerability using the pSegmentInfo property. Within the function 69b561c0, the application will then perform an allocation by multiplying the constant 8 by the value of the IMsoArray.nElems field. Later, at address 69b56231, the application copies data into this buffer using the value of the IMsoArray.cbElem field for each element. Due to the application using a different size (8) for the cbElem field during allocation than what is used to copy data from the file into the allocated buffer, a heap-based buffer overflow can be made to occur. This can allow for one to corrupt the heap which can lead to code-execution under the context of the application. After corrupting the heap buffer, the application will eventually have to return 5 times to get to the address 0x69b4b5bf. It as at this point the application will use a 0x2c byte object to call a virtual method. The Hangul HCell document format utilizes the Compound Document format that is available via Microsoft\'s API. This file format is documented by Microsoft as part of their Document Interoperability Initiative. The format is similar to the FAT file format and contains a table describing where each file stream is stored within the file. Within each Hcell file is a stream labeled \"Worbook\" which is where the contents of the document is stored at. The overall structure of an Hcell document can be described as a list of arrays of smaller type-length-value structures. Each record within the stream is prefixed by a header described as the following. Each array is terminated by an element of type 0x000a. Within the proof-of-concept, this leaves 5 Worksheets. The Escher record is used by Hangul Hcell to draw Office Art records. This record can be identified by the type 0x00ec and is located at offset 0x129e6 of the provided proof-of-concept. This can also be located as record 72 of the 2nd sheet. The documentation for this format [1] has been released as part of Microsoft\'s Open Specification promise and is named [MS-ODRAW]. Within this record, the application abides by the format described in Microsoft Office\'s Office Art file-format. This format prefixes each record with an 8-byte header. This particular vulnerability is located within an OfficeArtSpContainer identified by the record type of 0xf004. This specific record type is used for describing a shape in the OfficeArt format and actually contains multiple records. This shape record, OfficeArtSpContainer, is used to describe shapes which will be drawn onto the spreadsheet. Within this record is a list of subrecords which begins at offset 0x129f2. Another record, identified by the recType 0xf00b, is named OfficeArtFOPT and specifically holds the property table that contains the fields that are used by this vulnerability.  Within the proof-of-concept, this record begins at offset 0x12a02. The 0xf00b record contains a list of properties for a particular shape. The number of properties in this record is identified by the Instance field within the record\'s header. Within the provided proof-of-concept, this value is 0x11 which states that there\'s 17 properties within the container. Each property is 6-bytes in length and has the following structure. If any of the properties has it\'s fComplex bit set, then immediately following the list of properties is out-of-band data associated with the property. It is prudent to note that n order to determine where the out-of-band data begins, the number of propertes will need to be multiplied by 6 and for each property that has it\'s fComplex bit set, the \'op\' field of that property contains the length within the complexData. In order to trigger this vulnerability any of the properties must have an id of 0x145 (pVertices) or 0x151 (pConnectionSites). Within the provided proof-of-concept a pVertices property is located at 12a22. This property has an op value of 0x90e which states that the size of it\'s data within the complexData field is 0x90e bytes. At offset 0x12a23 the complexData field has 0x30e bytes which is the next number of bytes that contains the complexData. Each piece of data is indexed by whichever properties have it\'s fComplex bit set. Within the proof-of-concept the pConnectionSites property\'s complexData field begins at offset 0x1338a. This is the 3rd property that has it\'s fComplex bit set. The other properties that prefix the complexData are the pVertices propetty at offset 0x12a22 and the pSegmentInfo property at offset 0x12a28. Both the pVertices and pSegmentInfo properties\' complexData field have the following structure. This structure contains the fields that are utilized by the vulnerability. The expected size of the pVertices and pSegmentInfo fields is supposed to be 8. The application uses the value of 8 multiplied by the nElems field to calculate the size of the buffer. However, when copying file-data into this buffer, it explicitly trusts the value in the cbElem field. If any of the pVertices or pSegmentInfo properties\' complexData contains a cbElem value other than 8, then this vulnerability is being triggered. Within the provided proof-of-concept, the IMsoArray structure is at offset 0x1338a and uses the cbElem value of 0x6040. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure  [1] http://download.microsoft.com/download/2/4/8/24862317-78F0-4C4B-B355-C7B2C1D997DB/[MS-ODRAW].pdf', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0149');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (469, 'Hancom Hangul Office HShow!NXDeleteLineObj+0x47269 Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul HShow application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul HShow Document (.hpt) and processing a structure within the document, the application will use a static size to allocate a heap buffer yet explicitly trust a size from the file when modifying data inside of it. Due to this, an aggressor can corrupt memory outside the bounds of this buffer which can lead to code execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul HShow is prefixed with a header which can describe whether it\'s contents are encoded with the zlib library. After processing the header, the application will take the version and use it to determine which structures need to be decoded within the zlib-encoded data. When reading a particular structure from the file, the application will allocate 0xa0 bytes for it and initialize it with data from the file. Later, the application will trust another length when modifying data in this buffer which can allow one to corrupt memory outside the bounds of the 0xa0 byte buffer. First the application will read a structure from the file. This structure has 5 different cases and will read a 16-bit value from the file. This 16-bit value is used to control the number of iterations within a loop that is later used during the oob write. After reading this structure, the application will then encounter the following code. This code will allocate 0xa0 bytes for a buffer. This is done at address 0x18fc9d1. Immediately afterwards, the application will initialize it with memset followed by initializing it with data from the file at address 0x18fc9f5. This statically sized buffer will be the one that can be corrupted later. Afterwards, the application will enter the following loop at 0x18fca10. This loop will iterate the number of times as specified in the structure that was read previously. Due to this value being 15-bits in length, and the 0xa0 being less than 15-bits...this loop will act on data outside the bounds of the heap allocation. Inside the loop, the application will test to see if a 16-bit value has it\'s signed bit set, and if it doesn\'t it will write the current index into that pointer. Due to the sentinel for this loop possibly being larger than 0xa0, this write will corrupt data after the 0xa0 byte buffer. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0147');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (470, 'BlueStacks App Player Privilege Escalation Vulnerability', 'None', '2016-8-4', 'A local privilege escalation vulnerability exists in BlueStacks App Player. The BlueStacks App Player installer\ncreates a registry key with weak permissions that allows users to execute arbitrary programs with SYSTEM privileges. BlueStacks 2.1.3.5650 http://www.bluestacks.com/ During installation BlueStacks App Player creates registry keys with weak permissions. Here we can see the \'Users\' group has full permissions on the InstallDir key: Using process monitor we can observe that BlueStacks service is reading the InstallDir key to obtain installation path and later executes HD-Network.exe and other files from that path.\nA malicious user can set InstallDir to a directory under their control to execute arbitrary code with SYSTEM privileges. Change the permission for key to group other than Administrator on Read/Execute. Discovered by Marcin ëIcewallí Noga of Cisco Talos.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0124');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (471, 'Hancom Hangul HCell CSSValFormat::CheckUnderbar Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul Hcell application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul Hcell Document (.cell) and processing a record that uses the CSSValFormat object, the application will search for an underscore (\"_\") character at the end of the string and write a null terminator after it. If the character is at the very end of the string, the application will mistakenly write the null-byte outside the bounds of it\'s destination. This can result in heap corruption that can lead code execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul Hcell uses the Structured Storage COM API to load and store the Spreadsheet generated by a user. Although there are various streams that can be specified within a document, the Hcell application stores the contents of a workbook within the \"Workbook\" stream as an array of Type-Length-Value structures. Each of these structures describe the worksheets and the cells that compose the document. Within a document, a user can specify the format of any number of cells which will cause the application to convert the result of the cell\'s contents to the format that the user has specified. When parsing the Workbook stream, the application will perform 3 passes over each record. During the second pass, the application will collect the majority of the records containing formatting information as well as cell contents. If the record type is of the value 0x041e, then the application will switch to the case at 0x6ae774de. This block of code will call the method that is used to handle the 0x041e record type. Inside this method call, the application will enter a loop that will iterate through each contiguous record of type 0x041e and execute the method at 0x6af14217 on it\'s contents. This implies that it is common for the application to put a chain of these records next to each other. The method call at 0x6af14217 executes a function at address 0x6aee19f0 which will parse the contents of the 0x041e record type. It is prudent to note by the author that this vulnerability can be reached via any condition where the CSSValFormat::CheckUnderscore method is called and may be reachable through alternative file formats other than the 0x041e record type describe herein. The function at 0x6aee19f0 will first read a uint16 from the file. This uint16 is used to determine the worksheet number that the CSSValFormat structure is to be attached to. After reading the worksheet number, the application will execute the function at 0x6aee1a54. This function will read a value format string from the contents of the record. After reading the value format string from the file, the application will pass this string to the HCellBook.dll!CSSValFormat::CheckUnderbar function at address 0x6aee1af4. This string is allocated with the size based on the contents of the first uint16 before the string contents begins. At the beginning of the CheckUnderbar function, the application will calculate the length of the widechar string. After finding the end of the string using this length, the application will then seek backwards looking for the last underscore. Once that is determined, the application will then rewrite the underscore followed by a null-terminator. If the string ends with an underscore, the application will write the underscore at the end of the string, followed by the null-terminator one byte after the end of the string. This writes outside the bounds of the string and if there\'s an object contiguous to this string, can be used to corrupt the first byte of the structure that follows. If an object with a virtual table follows, this can be used to shift the methods of the virtual table into a state that can be used to cause further corruption. The Hangul HCell document format utilizes the Compound Document format that is available via Microsoft\'s API. This file format is documented by Microsoft as part of their Document Interoperability Initiative. The format is similar to the FAT file format and contains a table describing where each file stream is stored within the file. Within each Hcell file is a stream labeled \"Worbook\" which is where the contents of the document is stored at. The overall structure of an Hcell document can be described as a list of arrays of smaller type-length-value structures. Each record within the stream is prefixed by a header described as the following. Each array is terminated by an element of type 0x000a. Within the proof-of-concept that should\'ve been provided, this leaves a single substream for the worksheet. The element containing the CSSValFormat is identified by type 0x041e and is located at offset 0x6c6 of the provided proof-of-concept. This can also be identified as record 31 of the 1st stream. It is prudent to note that this vulnerability can be reached through a few different formats, records, or through regular document editting, but the record type 0x041e is the only record type known by the author that can be used to reach the code that triggers this vulnerabilty. The 0x041e record\'s contents begins at offset 0x6ca within the provided proof of concept. This record has the following structure. The format size field contains the number of widechars that follow. If the character that\'s positioned at the end of the string according to the provided length is an underscore \'_\', then the application will write the null-terminator outside the bounds of the space that was allocated for the CSSValFormat structure. The contents of the format field is a unicode wide-character string, and so is also represented within the provided proof-of-concept as such. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0151');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (472, 'Hancom Hangul HCell HncChart CFormulaTokenSizeModifier Code Execution Vulnerability', 'None', '2016-8-4', 'This vulnerability was discovered within the Hangul Hcell application which is part of the Hangul Office Suite. Hangul Office is published by Hancom, Inc. and is considered one of the more popular Office suites used within South Korea. When opening a Hangul Hcell Document (.cell) and processing a particular record within the Workbook stream, an index miscalculation leading to a heap overlow can be made to occur. The vulnerability occurs when processing data for a formula used to render a chart via the HncChartPlugin.hplg library. Due to a lack of bounds-checking when incrementing an index that is used for writing into a buffer for formulae, the application can be made to write pointer data outside it\'s bounds which can lead to code execution under the context of the application. Hancom Office 2014 VP Trial http://www.hancom.com\nhttp://www.hancom.com/en/product/product2014vp_01.jsp 8.6 -- CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H Hangul Hcell uses the Structured Storage COM API to load and store the Spreadsheet generated by a user. Although there are various streams that can be specified wthin a document, the Hcell application stores the contents of a workbook within the \"Workbook\" stream as an array of Type-Length-Value structures. Each of these structures describe the worksheets and the cells that compose the document. The Hangul Hcell application includes a directory of plugins that are used to handle external features such as chart rendering or text art. This specific bug is depending on the HncChartPlugin.hplg plugin that is bundled with the Hangul Office Suite but is believed by the author to be reachable via any chart that uses the CFormulaTokenSizeModifier object to adjust formula. When parsing the Workbook stream, the application will perform 3 passes over each record. The third pass is assumed by the author to parse record types that depend on cell data that is parsed during the second pass. Within the following code, the application checks that the record type is of type 0x7ef0. If the type matches this value, then the method call at 0x68858601 will occur with the current worksheet passed as an argument. This method is responsible for parsing the contents of the record. Near the beginning of the method, the application will read 2 bytes from the file. These 2 bytes are used to describe the chart type defined within the file. With the provided proof-of-concept, this type is 0x0067. The Chart Type of 0x0067 is used to describe an MSChartDoc object. This will cause the application to allocate a 0x168 byte structure utilized by the parser to store information related to the chart which will then get passed to the function call at address 0x6891b5f0. This function call is responsible for reading properties of the chart from the file into the chart structure. Later within this function, the application will initialize an object on the stack that is used to store input from the file which is used to create a formula object. This code occurs at address 0x6863184f within the HCellApp.dll library. Later, this structure is passed as an argument (as well as the worksheet) to the function call at 686318c9 with the formulatype of 9. At the beginning of this function, the source formula structure that was initialized earlier is used to construct 2 different objects that inherit from a CFormulaTokenSizeModifier. This object is populated using data read from the file and is used to trigger the vulnerability. Later in the function, a 16-bit length is read from the file which is then used to allocate space for reading file data related to the CFormulaTokenSizeModifier object. The CFormulaTokenSizeModifier object is a 0xc068 byte object containing two pairs of large buffers within them. The first buffer is composed of 4096 words, and the second one (which is overflown by this vulnerability) is composed of 4096 dwords. This implies that there is a maximum of 4096 formulae that can be handled by the CFormulaTokenSizeModifier object. After the file data for the formula is read, this buffer along with the column and row is passed to the CFormulaTokenSizeModifier::ModifyFormula method at address 0x6883d000. This method is located within the HCellBook.dll shared library and contains the root of the vulnerability described herein. Inside the ModifyFormula method is the following loop which processes data that is read from the file. This loop will continue until the end of the record data has been reached. Before the loop, the application will store a 32-bit pointer to the current position at %esi+3c. This pointer later gets incorrectly treated as a 16-bit value when determining the current position. It is prudent to note, that there\'s more than one place that this pointer value will get incorrectly casted as a 16-bit value. At the beginning of this loop, the application will read a byte. This byte will be used to seek into an array labeled CFormulaBase::m_Bases. If the base returned is 0x19, then the application will read a word from the file followed by another byte. Laster, this next word will actually be used as a terminator to a smaller loop that is used to writing. Lastly the parser will check to see if the second bit of the byte is clear. At this point, the application will enter the loop that can be used for writing. This loop will iterate the number of times determined by the first 16-bit word that was read. For each iteration of this loop, the application will increase an index. This index will be used to write outside the bounds of the buffer allocated within the CFormulaTokenSizeModifier. Due to a lack of bounds checking, the loop can allow for the index at %esi+6048 to be increased past the bounds of the CFormulaTokenSizeModifier\'s second 4096 dword buffer. Once that occurs, then the write instruction at 0x6956b3da can then be used to write the value of %edx outside of the object leading to the buffer overflow. The Hangul HCell document format utilizes the Compound Document format that is available via Microsoft\'s API. This file format is documented by Microsoft as part of their Document Interoperability Initiative. The format is similar to the FAT file format and contains a table describing where each file stream is stored within the file. Within each Hcell file is a stream labeled \"Worbook\" which is where the contents of the document is stored at. The overall structure of an Hcell document can be described as a list of arrays of smaller type-length-value structures. Each record within the stream is prefixed by a header described as the following. Each array is terminated by an element of type 0x000a. Within the proof-of-concept, this leaves 2 substreams. The HncChart element is identified by type 0x7ef0 and is located at offset 0x15a3 of the provided proof-of-concept. This can also be located as record 62 of the 2nd stream. Within this record, is the following structure. The first dword appears to be reserved, however the second field ChartType must correspond to the value described in the description at address 6891b44a. In the poc, it should be 0x0067. The chartdata record has the following structure and is terminated by a formula type that is prefixed by a 16-bit length. In order to get to the data pertaining to the vulnerability, this length will need to be used to seek past to the data that was modified. After getting past the first formula that is parsed, the following data will be encountered. The loop that is used to read the next formulae is determined by the dword size at offset 0x15e3 of the stream. At offset 0x693f, is the following structure. This controls the inputs that are used for the loop that can be used to write pointers to the formula outside of the 4096 dword buffer. Within the loop-data, each byte is checked to determine a path that should be taken. None of these values should be larger than 0x3e To get to the write loop, each byte that is part of loopdata is checked. If a byte value of 19 is set in this data, then the next byte will be a flag. If the next flag has it\'s 2nd bit cleared and it\'s 4th bit set, then the write loop will be entered. In the proof-of-concept, this value is 04. Immediately after this flag is a 16-bit loop counter, which controls the number of iterations of the write loop. The rest of the bytes in the stream control a relative offset that is used by a cmp instruction and do not appear to be important to the vulnerability short of triggering an access violation. If the number iterations of each loop accumulate the index near 4096, and then there\'s a formula base of 19 which is used to write outside the bounds of the buffer, then this vulnerability is being triggered. 2016-03-28 - Discovery  \n2016-04-19 - Vendor Notification  \n2016-08-04 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0150');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (473, 'OpenOffice Impress MetaActions Arbitrary Read Write Vulnerability', 'None', '2016-7-21', 'An exploitable out-of-bounds vulnerability exists in OpenOffice when handling MetaActions. A specially crafted Open Office Impress file can cause an out-of-bounds read/write resulting in potential code execution. An attacker can provide the malicious file to trigger this vulnerability. Apache Open Office 4.1.1 http://openoffice.apache.org In the attached sample an out of bounds occurs when replacing a Polygon in the PolyPolygon object when performing a MetaPolyPolygonAction. In this case, the position in the array is 512, while the array containing Polygons (mpPolyAry) is only 2 in size. This will result in a delete of a pointer which is read out of bounds at line 228 of file main\\tools\\source\\generic\\poly2.cxx. This will be followed at line 229 with an out-of-bounds write, writing a new pointer which is gotten by creating a new Polygon at that location. This provides an attacker with multiple ways to exploit this vulnerability: through a free of an invalid pointer, but if that fails, the writing of a new pointer out of bounds could provide a second opportunity for exploitation. Below are line 217-230 of main\\tools\\source\\generic\\poly2.cxx: While there is a check to ensure that npos is smaller than the array size at line 220, it is simple an assert that is only enabled in debug mode. The value is read from the sample file in the function MetaPolyPolygonAction::Read in the file main\\vcl\\source\\gdi\\metaact.cxx at line 1189: Here is the call stack when the problem occurs: 2015-10-08 - Initial Vendor Contact \n2016-10-30 - Second Vendor Contact \n2016-01-13 - Vendor review and communication \n2016-07-21 - Patch released', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0051');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (474, 'Oracle OIT IX SDK libvs_pdf Root xref Denial of Service Vulnerabiity', 'None', '2016-7-19', 'A stack overflow leading to a crash due to unbounded recusive function call is present in the PDF file format parsing code of the IX SDK. Oracle Outside In IX sdk 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a malformed PDF file which contains a reference to the Root element with malformed or missing an xref table a recursive call to a function is made each time with the same parameters eventualy leading to a crash due to process stack exhaustion. Technical information below: During a call to VwStreamOpen function in libvs_pdf.so library, code dealing with Root element is reached (image base is at 0xB74BF000): Function   in turn calls a function   in which the unbounded recursive call can happen: The supplied minimized testcase triggers the recursive call and leads to a crash due to stack exhaustion. The sample program   supplied with the SDK can be used to reproduce the crash. 2016-04-12 - Vendor Notification  \n2016-07-19 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0099');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (475, 'Oracle OIT ContentAccess libvs_mwkd VwStreamSection Code Execution Vulnerability', 'None', '2016-7-19', 'A partially controlled memory corruption vulnerability exists in Mac Works Database file\nformat parsing code of Oracle Outside In Technology Content Access SDK.\nAn unchecked pointer arithmetic leads to an out of bounds memory overwrite\nresulting in arbitrary code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html When parsing a Mac Works Database document memory is being written in a loop using\na counter in destination address calculations.\nNo size checks are performed after the arithmetic operations resulting in an out\nof bounds memory write. Although the file is identified by as a MWKD document, leading to it being\nparsed by libvs_mwkd library, the vulnerability can be triggered by the example\n  application supplied with the SDK. Technical information below: Vulnerability is present in   function  in libvs_mwkd.so library\n(with image base at 0xB7F89000), specifically starting in the following basic block: Values of   and   are used as counter with an upper value read from\na byte at file offset 0x5ee in the supplied testcase. Contents of  \nare then written into the destination address at [1]. No bounds checking is\nperformed, leading to an out of bounds memory overwrite. In a supplied testcase, memory corruption resulting from this vulnerability\noverwrites the value of a function pointer which is later dereferenced\nin a   instruction at 0xb7d87d71 in libsc_ch.so library (with base\naddress of 0xb7d6f000). 2015-10-10 - Discovery  \n2016-04-20 - Initial Vendor Notification  \n2016-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0159');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (476, 'Oracle OIT IX SDK libvs_pdf Xref Offset Denial of Service Vulnerability', 'None', '2016-7-19', 'A vulnerability in PDF parser of the IX SDK exists that results in out\nof bounds heap memory access following an unchecked memory allocation\noperation under specific conditions. Oracle Outside In IX sdk 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html In a PDF file an xref table contains multiple rows each containing three values (\nexcept for the first row which specifies the first object being referenced and the\nnumber of objects). First value represents the 10 digit offset into the file where\nobject is to be found. In a specially crafted PDF file, OID SDK PDF parser\nuses the specified value as a parameter in a call to   which can fail.\nThe return value is checked for errors but is subsequently ignored. The original\nnumerical value is then used as an upper bound in a loop where out of bounds\nread happens during process cleanup. In a function at 0xB74C603A in libvs_pdf.so (base address being 0xB74BF000)\neither a call to   or   is being made indirectly. Final size is calculated\nas follows: Initially, register   holds the value from the file. In this case\nit is multiplied by 0x10 in  . The upper bound for the value in the\nfile is 0x7ffffff, so the maximum size that can be passed to  \nis 0x7ffffff0. In limited memory conditions, of about less than 2 gigabytes of virtual\nmemory available, this reallocation will fail returning zero. Although\nthere are checks for this condition, the same buffer is iterated over\nduring process cleanup. Specifically, in the following code in function\n : At [1],   points to the buffer that was previously subject to failed  .\nRegister   serves as a counter, is increased by 1 each turn at [2] and compared to\nthe initial value from the file at [3]. At [4], pointer in   is increased by 0x10.\nAt this point, the parser expects that the memory reallocation was successful which\nleads to an out of bounds memory access. The supplied minimized testcase triggers the out of bounds access in  \napplication supplied with the SDK. In order to trigger it, a virtual memory\nlimit must be set by executing: 2016-04-12 - Vendor Notification  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0102');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (477, 'Oracle OIT IX SDK TIFF ExtraSamples Code Execution Vulnerabiity', 'None', '2016-7-19', 'While parsing a specially crafted TIFF file, a parser confussion\ncan lead to a heap buffer overflow resulting in out of bounds\nmemory overwrite leading to arbitrary code execution. Oracle Outside In IX sdk 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a specially crafted TIFF file with ExtraSamples tag present, a parser\nconfusion can lead to insuficient heap memory allocation which later results in\na buffer overflow corrupting the heap structures which can be abused to achieve\narbitrary code execution. As per the file format documentation ExtraSamples influences\nhow many actual bits per sample there are in the file. Size of the allocation is based directly on on ImageWidth value (at offset 0x6c in the supplied\ntestcase) and is the allocation happens in the following basic block in   (image base is\n0xB74E1000): At [1], the size of the allocation is read from a structure on the heap\nwhich comes from the file directly. In the supplied testcase (minimal.tiff)\nthis will be 0x20 bytes, resulting in 0x28 byte chunk being allocated. The overflow happens in the following code in  : In the above code, at [1] a byte value is read from the heap and is written to a destination buffer\nat [2]. At [2],   points at the begining of the previously allocated buffer (as discussed above)\nand   serves as offset, incremented by 1 in each iteration of the loop. This block of code is\nexecuted in a bigger loop, the rest of which is ommited for brevity. At [3],  , which is a loop\ncounter (also an index into a buffer at [1]), is incremented by value in   which comes directly\nfrom SamplesPerPixel value in the file (2 in the supplied minimal.tiff). Finally, at [4], the\n  counter is compared to a max value in  . If the maximum value of the counter (  at [4] above) is greater than the allocated\nbuffer a heap overflow can occur. Upper bound of this loop is calcualted in the following basic\nblock: At [1], the initial value is comes from BitsPerSample value from the file\nand is multiplied by a value coming from ImageWidth at [2]. At [3], a\nSamplesPerPixel value is retrieved and is multiplied with previous result at [4].\nAfter 7 is added  at [5], the final value is divided by 8 at [6]. The final value\nis written into heap structure pointed to by   at offset 0x3CC at [7]. In short, the upper bound for the loop in which the overflow happens is: In the supplied testcase, the upper bound for the loop is 0x80, and since increment in\neach iteration is 2 this leads to a buffer overflow of 0x40 bytes where only 0x28 were allocated,\nleading to an application crash. In summary, both the size of the allocation and size of the overwrite are under direct control.\nThe supplied testcase   demonstrates a more controled buffer overwrite where adjecent\nheap chunks are overwriten with ASCII A\'s resulting in the following crash: Breakpoint 4 is placed in the loop where the overwrite happens and here shows the initial values.\nThe pointer to the allocated memory is  . After the crash, by examining\nthe memory around it, we can see that the adjecent heap chunk has been  overwriten. The essential difference between the original TIFF file and the supplied minimal testcase is\nthat the minimal testcase contains the ExtraSamples tag, which influences the calculations,\nas well as the different values for both BitsPerSample and SamplesPerPixel values. This issue can be triggered by running the supplied testcase in the   application\nsupplied with the SDK. 2016-04-12 - Vendor Notification  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0103');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (478, 'Oracle OIT IX SDK libvs_pdf Tj Operator Denial of Service Vulnerability', 'None', '2016-7-19', 'When parsing a specialy crafted PDF document, a NULL pointer dereference leading\nto a process termination. A pointer value from a memory structure initialized\nto zero is reference without check. Oracle Outside In IX SDK 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While executing a   operator on a piece of text contained in a stream, a memory structure\nprobably containing charset mappings is referenced. No NULL pointer check is made and\nsince the sturcture is zero initialized this can result in a crash. The supplied testcase succesfully crashes the sample   application\nsupplied with the SDK. In the supplied testcase, after the parser successfully decodes the /FlateDecode\nencoded stream data, it proceeds to execute the operators contained whitin.\nIn this case the decoded stream data is : The problematic code is triggered while   operator is being executed with it\'s\nargument being string \"Results\". Function    in libvs_pdf.so implements\nthis operator. Eventually the function   is reached (libvs_pdf.so base address being 0xB74BF000)\nand the crash is triggered by the following basic block specifically: At the time of the crash, initial value of   at [1] contains the first character of the   operator argument, in this case \"R\", which ends up\nin   and is subsequently used as an offset into the memory structure at [4]. At [2], value of   is zero extended into ecx limiting our control over it.\nAt [3], final value of   is set from offset 0x1f18 into  .\nValue of   can be NULL but isn\'t checked resulting in a near NULL\npointer dereference. It is worth nothing that when the same memory address is accessed in other parts of the code, the pointer is properly checked beforehand. 2016-04-12 - Discovery  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0098');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (479, 'Oracle OIT IX SDK libvs_pdf Size Integer Overflow Vulnerability', 'None', '2016-7-19', 'An integer overflow leading to two distinct issues can be triggered by\na specially crafted PDF file. Oracle Outside In IX sdk 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a PDF file with specific /Size element, a memory allocation operation\ncan fail, returning a NULL pointer due to integer overflow, which is unchecked and leads to a crash\nduring a   call. A carefuly selected size value can also lead to further memory\ncorruption. The supplied testcase can be abbrevated to the following: A huge   value leads to failed memory allocation in the following basic block: At [1], the value in   comes straight from the 32bit rounded value from the\n  element. At [2], it is multiplied by four therefore invalidating the\ninteger overflow check that was done previously. A   wrapper is called\nat [3] and the returned pointer (NULL in this case) is saved at [4].\nEven though the pointer is checked against NULL at the end, in a subsequent\nbasic block it is still used as a destination for  : The same size derived in the previous basic block is used at [1] as a size\nparameter for  . At [2], saved pointer is retrieved and is NULL in this\ncase. The application crashes at [3] due to invalid pointer. If a size value is choosen carefuly, it can lead to an integer\noverflow at [2] in the first basic block such that a small value\nis passed to SYSNativeAlloc at [3]. In this case, the subsequent\n  call would pass without issue.  The problem arises\nwhen, due to rounding, heap allocator returns a pointer\nto a bigger heap chunk than requested. In this case, the  \ncall will initiallize only the originaly requested size, leaving the\nrest of the buffer uninitialized to zero. Later on in the code,\nthis buffer is treated as a pointer array with checks for NULL pointers,\nbut the uninitialized portion of the buffer may have non-NULL values\nleading to further issues. As an example, if the size value is specified to be 0x10000001 it will\npass the check before allocation in the first basic block above, but when shifted by 4,\nit becomes 0x10, making a small allocation. Depending on an underlying allocator,\nthe actuall size of the allocated chunk would be bigger. In case of Linux, in\nthis case, the returned chunk will be 24 bytes long and subsequent   will\nonyl initialize the first 16 bytes. Afterwards, the code reaches the following loop inside VwStreamClose: At [1], a pointer to the previously allocated buffer is moved into   and used as a starting\nposition of a loop. At [2], a counter is initialized to 0. At [3], a pointer stored in the\nbuffer is copied into   and tested agains being NULL at [4]. If it\'s not NULL, a usercall\nfunction who\'s first argument is   is called at [5]. After the function call, or if the pointer\nwas NULL, a counter in   is advanced by one and then compared to the upper bound which is\nthe original   value as specified in the file (before the overflow) at [7]. Finally, the code\njumps back to [8], where the pointer into the buffer is increased by 16. It is now clear that if only first 16 bytes of the buffer are initialized, when the code executes the loop\nfor the second time, at [3] it will be accessing memory that is uninitialized to zero effectively turning\nthis into a sort of use-after-free vulnerability. Function called at [5] deals with heap structures and,\nif sufficient heap control is achieved, leftover data present in uninitialized part can cause further\nmemory corruption, potentially leading to code execution. 2016-04-12 - Initial Vendor Communication  \n2016-07-19 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0097');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (480, 'Oracle OIT ContentAccess libvs_word Denial of Service Vulnerability', 'None', '2016-7-19', 'A partially controlled memory write vulnerability exists in Mac Word file\nformat of Oracle Outside In Technology Content Access SDK.\nAn unchecked pointer arithmetic creates a bitwise OR on out of bounds\nmemory address, resulting in memory corruption and likely program termination. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html When parsing a Mac Word document a single-byte value from a file is used as a\nmax value for a counter which is used in arithmetic operations for memory access.\nNo size checks are performed after the arithmetic operations resulting in an\nout of bound memory access. Calculated memory address is used as a destination\noperand in   instruction. Although the file is identified by OIT CA SDK as FI word library, the vulnerability can be triggered by the example\n  application supplied with the SDK. The vulnerability is present in function at address sub_B74A83AC, specifically\nstarting in the following basic block: At [1] value in edi is a counter with upper value coming from a file being parsed.\nAt [2] and [3] additional arithmetic is performed with the value of the counter\nas an argument. Final value of eax is calculated at [3] and at [4] is being used\nas a destination operand resulting in a bit being set at the calculated address. No bounds checking is performed and with a high upper value of the counter\nout of bounds memory can be written. While parsing the supplied testcase, out of bounds access results in a\npointer previously initialized to NULL to become non-NULL leading\nto an invalid free() during the cleanup after the file has been parsed. The byte used as an counter upper bound is located at offset 0x334 in\nthe supplied testcase. In a hypothetical situation, more interesting data structures could be\nlocated in the addresses being accessed out of bounds potentially leading to\nabuse. 2016-04-12 - Discovered  \n2016-04-19 - Initial Vendor Contact  \n2016-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0156');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (481, 'Oracle OIT libim_gem2 Gem_Text Code Execution Vulnerability', 'None', '2016-7-19', 'An integer overflow vulnerability exists in file parsing code of\nOracle Outside In Technology libim_gem2 library. A specially crafted\nGem file can trigger an integer overflow leading to multiple heap\nbased buffer overflows which can be abused to achieve remote code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a Gem metafile data an unchecked memory allocation is performed.\nIn function Gem gem library, a 16 bit value read from the file is used in arithmetic\noperations without checks leading to an integer overflow. As an example, the vulnerability is triggered in the   demo application\nsupplied in the SDK. The supplied minimized testcase crashes due to overwritten heap\nstructures resulting from a buffer overflow enabled by unchecked memory allocation. Vulnerability is present in function Gem gem2 library.\nSignificant code excerpt: The 16 bit value read from a file is sign extended into edi at [1].\nAt [2] and [3] a size argument for   is calculated leading\nto the first integer overflow. If the value in bp was 0xffff, sign\nextending if makes edx 0xffffffff, then [2] and [3] overflow this\nvalue which ends up in eax and as a parameter to  .\nNo check is performed for sane values of size parameter. In case of initial\nvalue being 0xffff, the size of allocated memory would be small (3 bytes requested). Second integer overflow can occur at [5] and, again, an unchecked result\nis used as a size parameter to  . If the initial value was 0xffff,\nthe requested memory size would be 0. Pointer to the allocated memory is saved\nat [6] and is subsequently used. Pointer from the second allocation is used as a parameter to the  \nfunction which,in essence, is tasked with translating one codepage to another. Original\nsize value is also supplied to this function and serves as a counter. Function   can be simply explained with the following pseudo-C: If an integer overflow did occur during memory allocation with initial size value of\n0xffff,   will happily write up to 0xffff bytes starting at the\nallocated buffer leading to a heap buffer overflow. By manipulating the heap to place specially crafted values in memory after the\nwrongfully allocated buffer, arbitrary content can be placed on the heap. Later on in the code, the   translated buffer is used as a\nsource string in a   call which leads to another heap buffer overflow\nwhich can be abused to achieve remote code execution.\nSecond heap overflow happens during a   call in   function.\nSince the   function will, in case of integer overflow, always\ngenerate a string of length 0xffff, this buffer overflow can be abused to overwrite\ndifferent control structures that are present on the heap. 2015-10-19 - Discovery \n2016-04-20 - Initial Vendor Communication \n2016-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0162');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (482, 'Oracle OIT IX SDK GIF ImageWidth Code Execution Vulnerabiity', 'None', '2016-7-19', 'While parsing a specially crafted GIF file, an integer overflow vulnerability\nand result in out of bounds heap memory overwrite potentially leading to\narbitrary code execution. Oracle Outside In IX sdk 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a GIF file with a ImageWidth in IMAGEDESCRIPTOR set to 0xFFFF an integer\nloop counter checking on truncated integer size results in an integer overflow\nwhich leading to unbounded memory write in two branches of the same function. The first integer overflow occurs while parsing the supplied testcase and\nfollowing basic block in   is reached\n(image base being 0xB7F81000): ` In the above code, at [1],   points to a buffer on the heap.\nAt [2], each time the code loops,   is incremented by 2. At\n[3] pointer from   is moved to   for further comparison.\nAt [4], value of   contains a saved pointer to the start\nof the heap buffer (the original value of edx when entering the basic\nblock for the first time). Also at [4], lower two bytes of  \nare substracted from   (which effectively contains lower two bytes of current\nbuffer pointer) effectively calculating the offset into the buffer.\nThis offset is then compared at [5] to a value at   which\nis actually the ImageWidth from the file. Since value at   is always 0xFFFF, 16 bit integer arithmetic\nis in place, and   is always incremented by 2, the jump condition\nat the end of the block will always be satisfied. Thus the integer\noverflow resulting from substraction at [4] turns this into an infinite loop. In the supplied testcase (integer_overflow.gif), the overwrite eventually hits either an unmapped\nregion of memory or a read-only page resulting in a crash. The only change to the original file is ImageWidth (at offset 0x32) which is set\nto 0xFFFF. Added garbage at the end of the file is there to align the heap so the\napplication crashes on WriteAV at [6] otherwise it crashes with ReadAV at [1] A similar integer overflow can be triggered if the LocalColorTableFlag is set in the\nIMAGEDESCRIPTOR PackedFields (at offset 0x36 in integer_overflow2.gif). In this case,\nthe other branch in the function at 0xB7F8280C is taken and code ends up in the following\nbasic block: At [1], the same comparison is made as in the previously described integer overflow.\nThe supplied testcase (integer_overflow2.gif) has a few more bytes changed, to accommodate\nfor added LocalColorTableFlag. Both issues can be triggered with the supplied testcase in the   application\nsupplied with the SDK. 2016-04-12 - Vendor Notification  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0105');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (483, 'Oracle OIT IX SDK TIFF file parsing heap buffer overflow', 'None', '2016-7-19', 'While parsing a specially crafted TIFF file, a parser confusion\ncan lead to a heap buffer overflow resulting in out of bounds\nmemory overwrite and possibly leading to arbitrary code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a specially crafted TIFF file with PhotometricInterpretation set to\n5, indicating a CMYK image, the same amount of memory is allocated as when processing\nthe original file (with PhotometricInterpretation set to 3 in this case), but\nthe parser takes a different path, ending in a loop that uses the size\nvalue as a counter. The overflow happens because in each iteration\nof the loop, 3 bytes are written to the destination thus leading to\nheap buffer overflow and overwrite of adjacent heap structures. Technical information below: Size of the allocation is based on ImageWidth value (at offset 0x6c in the supplied\ntestcase) and is calculated in the following basic block in   (image base is\n0xB74E1000): At [1], the final value of the allocation is saved in  . The arithmetic\ncan be translated into the following formula: The allocation in question happens at the following basic block: At [1], previously computed value is set as a parameter to   which is a wrapper to\n . After the successful allocation, the parser eventually ends up in the following basic block\nwhere the overflow happens: At [1],[2] and [3] in the above basic block, 3 bytes are written to the destination buffer\nin   which gets incremented by 3 at [5] in each iteration of the loop. At [4]   is\nalways 1, increasing the counter in   only by 1, resulting in an overflow as the counter\nis compared against the previously calculated allocation size at [6]. The 1 value in  \nat [4] comes from SamplesPerPixel (at offset 0xD8 in the supplied testcase).\nRegular TIFF file with CMYK color map should have SamplesPerPixel value of 4. To summarize, by controlling the size of the allocation, we can control the size\nof the overflow, as the number of bytes written in the loop that causes the\noverflow is SamplesPerPixel*SizeOfAllocation. Control over the data that gets written\npast the end of the buffer is subject to arithmetic transformations in the previous\nbasic block. In the supplied testcase, the values have been malformed in such\na way as to result in a function pointer overwrite. The application crashes\nwhen the overwritten function pointer is dereferenced during a call. This issue can be triggered by running the supplied testcase in the   application\nsupplied with the SDK. 2016-04-12 - Vendor Notification  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0104');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (484, 'Oracle OIT libim_psi2 psiparse Code Execution Vulnerability', 'None', '2016-7-19', 'A memory corruption vulnerability exists in file parsing code of\nOracle Outside In Technology libim_psi2 library. Specifically, a\ninteger overflow leading to an undersized memory allocation and a\nmemory copy operation leading to buffer overflow in   function can\nwrite 8 controlled bytes into adjacent memory, possibly leading to code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a PSI image file, a 2 byte size field is read and sign extended.\nThis value is then used in memory allocation and a subsequent   call.\nRead size value is increased by 8 before an actuall memory area is allocated,\nbut the original size is used in   call. As an example, the vulnerability is triggered in the   demo application\nsupplied in the SDK. PSI file is being parsed by   function. Vulnerability occurs around the following\ncode: At [1] size read from a file is used as size argument to a memory allocation function\ncalled at [2]. At [3] size is used as an argument to a function called at [4].\nIn the vulnerable process path, function called at [4] is located at offset 0xad3dc\ninto libim_pis2 library which, in essence, is a   wrapper. Size argument is parsed in PSCAN_Next function. Specifically, a function at offset\n0x904ab: Depending edx, this function reads either little or big endian 16 bit integer\nand returns its sign extended value. In the supplied testcase, big endian 0xFFF9 is being sign extended into info\n0xFFFFFFF9 which gets overflown by adding 8 during memory allocation function\npassing the checks, but leads to a crash during  . It is worth noting, the buffer that is being copied during   is located\njust after he 2 byte size value in the supplied crashing testcase. 2015-10-19 - Discovery  \n2016-04-20 - Initial Vendor Communication  \n2016-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0161');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (485, 'Oracle OIT IX SDK libvs_pdf arbitrary pointer access', 'None', '2016-7-19', 'When parsing a specially crafted PDF document, a value derived from a file is\nused as a memory pointer leading to a process crash. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html When parsing a PDF file with an object containing a stream, missing object type specification\ncan lead to arbitrary pointer access. In the supplied testcase, a /Type value is missing\n(originaly /XRef) and trailing bytes are interpreted as type. An ASCII integer value is\nconverted into 32bit integer which is subsequently used as a pointer in a comparison\noperation. In case the pointer is invalid, process crash occurs. Technical information below: An ASCII integer value appearing after /Type element in the supplied PDF file is converted into\n32 bit integer (in this case 0x41414141) which ends up being used as a source operand, in  ,\nin the comparison instruction against \'XRef\' value pointed at by   : Although the value in   is fully controlled, it is promptly discarded after the comparison\nmaking this issue unexploitable by itself. 2016-04-12 - Vendor Notification  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0101');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (486, 'Oracle OIT ContentAccess libvs_mwkd VwStreamReadRecord Memory Corruption Vulnerability', 'None', '2016-7-19', 'Partially controlled memory write vulnerability exists in Mac Works Database file\nformat parsing code of Oracle Outside In Technology Content Access SDK.\nAn unchecked pointer arithmetic causes an out of bounds memory write which\ncan lead to denial of service or possibly code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html When parsing a Mac Works Database document memory is being written in a loop using\na counter in destination address calculations.\nNo size checks are performed after the arithmetic operations resulting in a\npartially controlled 2 byte overwrite. Although the file is identified by as a MWKD document, leading to it being\nparsed by libvs_mwkd library, the vulnerability can be triggered by the example\n  application supplied with the SDK. Technical information below: Vulnerability is present in   function  in libvs_mwkd.so library\n(with image base at 0xB7F89000), specifically starting in the following basic block: At [1] and [2] pre-calculated values of   and   are read from the stack\nand zero extended. At [3]   is being used in destination address calculation\nand the value of   is being written there. Initial values of   and  \nare related,   serving as a counter. No bounds checking is in place\nresulting in a possible 2 byte out of bounds overwrite. In the supplied testcase, last seven bytes can be  used to influence the\nwritten value. The supplied testcase crashes the   program upon\na   on an invalid pointer. The overwritten pointer is allocated in\nthe   function and it\'s least significant byte is later overwritten\nas a result of out of bounds memory write. A specially crafted file could be used to shift the to-be-freed pointer to\nan attacker controlled area which can then be used to subvert the  \nand achieve code execution. 2016-04-12 - Discovered  \n2016-04-29 - Initial Vendor Communication  \n2016-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0157');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (487, 'Oracle OIT IX SDK libvs_pdf FlateDecode Colors Denial of Service Vulnerabiity', 'None', '2016-7-19', 'A null pointer dereference leading to process crash can occur while parsing a\nmalformed PDF file. Oracle Outside In IX sdk 8.5.1 http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a PDF file which contains a /FlateDecode encoded stream, with a set /Predictor to a value other than 1, a malformed value for /Colors\ncauses a NULL pointer dereference in libsc_ut.so library while\nde-initializing the decoder. The supplied testcase can be abbreviated to the following: The invalid /Colors value , 0x100000000 in this case, causes a\nNULL pointer to be dereferenced during the memory read instruction. The bug can be triggered by using the   sample application supplied\nwith the SDK. Program state at the time of the crash: 2016-03-27 - Discovery  \n2016-04-12 - Initial Vendor Contact  \n2016-07-19 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0100');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (488, 'Oracle OIT ImageExport libvs_bmp BMP BI_RLE8 Width Code Execution Vulnerability', 'None', '2016-7-19', 'When parsing a specially crafted BMP file, an erroneous memory copy operation\ncan cause a heap buffer overflow leading to arbitrary code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a specially crafted BMP file, an unchecked value specifying bitmap width\nis used to calculate the size for the memory write operation.\nCompression method must be set to 0x01 or BI_RLE8. While reading the file, a piece of memory\non the heap is effectively overwritten by zeros. The size of this overwrite is unchecked and\ncomes straight from the bitmap width. This can lead to heap data structures overwrite with\nNULL bytes. In the supplied testcase, the out of bounds null byte write overwrites a function\npointer which leads to a crash. By carefully tweaking the size of the overwrite, a function\npointer on the heap can be manipulated and arbitrary code execution achieved. The supplied testcase has compression method bit set to 0x1 at offset 0x1E. BMP image\ndata  has the width field set to 0x4141 which gets\nused in the size of the overflow. The overflow happens in the function\nVwStreamRead in libvs_bmp.so (image base being 0xb7f80000), specifically in the\nfollowing basic block: Notice that the basic block loops back to itself as long as   is less than   which contains\nthe bitmap width value. Initial value of   is a heap pointer and memory starting at   gets\noverwritten by zeros without bounds checking, resulting in heap corruption. The vulnerability can be triggered with the supplied testcase in the   application\nsupplied with the SDK. The same vulnerability can be triggered through a specially crafted ICO\nfile that contains the same BMP data. 2015-10-19 - Discovery  \n2016-04-20 - Initial Vendor Communication  \n2016-07-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0163');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (489, 'Oracle OIT ContentAccess libvs_word+63AC Code Execution Vulnerability', 'None', '2016-7-19', 'Partially controlled memory write vulnerability exists in Mac Word file\nformat parsing code of Oracle Outside In Technology Content Access SDK.\nAn unchecked pointer arithmetic leads to an out of bounds memory overwrite\nresulting in code execution. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html When parsing a Mac Word document a single-byte value from a file is used as a\nstarting value for a counter which is used in arithmetic operations for memory access.\nNo size checks are performed after the arithmetic operations resulting in an\nout of bounds 4 byte memory write. Although the file is identified by OIT CA SDK as FI word library, the vulnerability can be triggered by the example\n  application supplied with the SDK. Technical information below: Vulnerability is present in function at address 0xB74A83AC in libvs_word.so library\n(with image base at 0xB74A2000), specifically starting in the following basic block: Initial value of   register comes from a byte at offset 0x29d in the\nsupplied testcase and is used as a starting value for a counter. Value\nis zero extended into edx at [1] and is then used in arithmetic operations at\n[2], [3] and [4]. Final value is used as a pointer to a structure and values of\n  and   registers get written to appropriate structure fields at [5], [6], [7]\nand [8]. Upper limit for the counter value is 0x100. No bounds checking is\nbeing made after pointer arithmetic resulting in a possible out of bounds\nmemory overwrite. While parsing the first supplied testcase, out of bounds write results in a\npointer previously initialized to NULL to become non-NULL leading\nto an invalid free() during the cleanup after the file has been parsed.\nIn the case of the second supplied testcase, the same vulnerability results in\na function pointer overwrite leading to an even simpler exploitable condition. 2015–10-19 - Discovery  \n2016-04-20 - Initial Vendor Notification  \n2016-07-19 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0158');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (490, 'Oracle OIT IX SDK libvs_pdf Kids List Information Leak', 'None', '2016-7-19', 'When parsing a specially crafted PDF document, the parser is expecting a pointer where string is located leading to a read access violation with a controlled source operand. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a malformed PDF file, with an object that contains malformed\n/Kids reference, the value right after the /Kids element is interpreted as a string, where\nan array of references should be located. This leads to parser expecting a pointer where\nthe string copied from the file is located resulting in an arbitrary read access violation.\nIn a properly formatted PDF file, an array of at least one reference must follow after   element. In the supplied testcase, an ASCII value after the /Kids element is placed on the heap\nand is later referenced by the parser, and wrongfully interpreted as a pointer. The bug\nappears in libvs_pdf.so (with base address 0x0xB74BF000): At [1],   points to the string copied from the file into the heap. First\nfour bytes of the string are used in the memory access calculation at [2]\ncausing an arbitrary ReadAV. If the value calculated at [2] ends up pointing to valid memory, the read will succeed\nat the controlled address. The read value is later again used as a pointer during a\n  instruction. If the value after the /Kids element is a pure integer, a different code path is reached\nand the integer value is interpreted as a pointer resulting in a fully controlled\narbitrary read at: Value of   at [1] in the above basic block is the integer value following\nthe   element in the file making a fully controlled arbitrary read.\nFurther more, the read value ends up being used as a pointer at the start of\nthe basic block mentioned first leading to a double controlled dereference. With the integer value following the   element equal to 1094795585 (or 0x41414141)\nthe application crashes in the following way : It is possible that by carefully setting the value of the initially\ndereferenced pointer, more interesting code paths could be reached and, coupled with other\nbugs, lead to further abuse. 2016-04-12 - Vendor Notification  \n2016-07-19 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0096');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (491, 'Apple Core Graphics BMP Framework img_decode_read Remote Code Execution Vulnerability', 'None', '2016-7-18', 'An exploitable out of bounds write exists in the handling of BMP images on Apple OS X and iOS. A crafted BMP document can lead to an out of bounds write resulting in remote code execution. Vulnerability can be triggered via a saved BMP file delivered by other means when opened in any application using the Apple Core Graphics API. OS X El Capitan - 10.11.5 https://developer.apple.com/osx/download 6.3 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N This vulnerability is present in the Apple CoreGraphics framework which is used for path-based drawing, transformations, color management, offscreen rendering, patterns, gradients and shadings, image data management, image creation, masking, and PDF document creation, display, and parsing on OS X and iOS. There exists a vulnerability in the parsing and handling of BMP images. A specially crafted BMP image file can lead to an out of bounds write and ultimately to remote code execution. The BMP file format, also known as bitmap image file or device independent bitmap file format or simply a bitmap, is a raster graphics image file format used to store bitmap digital images, independently of the display device (such as a graphics adapter), especially on Microsoft Windows. BMP handles multiple different forms of compression as well making it a somewhat difficult graphics format to parse. A dump of the files relevant header components is shown below: And running the file through Qlmanage with guard malloc enabled shows us this crash: Disassembling down from the backtrace we can spot where the vulnerability arises in img_decode_read. This function is used in a loop to continually grab more data from the image with an increasing value passed in via RSI (at [0]) until it reaches the image height value. When the value grows large enough a sign extension error occurs. In this case it is 0xff00 that causes the problem. A pointer to a valid image data buffer (at [1]) is returned and then some indexing is done on it to get to the proper element. The problem arises because the image height is not properly checked so when the value in R14 is promoted to a larger type stored in RCX the remaining bits gets filled in with 0xF causing an invalid index into the array. As shown previously the invalid index is calculated via the image height allowing this vulnerability to potentially be leveraged into an information leak or full remote code execution. 2016-06-15 - Vendor Disclosure \n2016-07-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0186');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (492, 'Apple OS X Scene Kit DAE XML Code Execution Vulnerability', 'None', '2016-7-18', 'An exploitable type confusion vulnerability exists in the handling of DAE images on OS X. A crafted DAE document can trigger a type confusion vulnerability which potentially could be exploited to achieve attacker controlled code execution. Vulnerability can be triggered via a saved DAE file delivered by other means. OSX El Capitan - 10.11.4 https://developer.apple.com/scenekit/ 7.4 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N/E:U This vulnerability is present in the Apple Scene Kit API which is used for all 3D image handling on OS X including most 3rd party 3D applications. There exists a vulnerability inside of Scene Kit in the parsing and handling of DAE images. A specially crafted DAE image file can lead to a type confusion vulnerability and ultimately to control. COLLADA defines an open standard XML schema for exchanging digital assets among various graphics software applications that might otherwise store their assets in incompatible file formats. COLLADA documents that describe digital assets are XML files, usually identified with a .dae (digital asset exchange) filename extension. In the XML it i possible to specify and create custom objects to be used by the renderer. Invalid checking allows a user to pass in an object that doesn\'t have the proper properties and gets illegally accessed. The inital crash is shown below: SceneKit`(anonymous namespace)::getAttributeIndex:\n->  0x10078dc5f <+33>: mov    r13, qword ptr [r12 + 0x30] It is seen that R12 is an out of bounds user controlled value and that this crashing function was called from ReadGeometry assuming the object passed in was a geometry type object. Looking at our DAE file we can see what caused the crash. By looking at the DAE file itself the problem becomes readily apparent. If an attacker was able to shape an object in such a way as to bypass this illegal access and continue on to the virtual call they could gain full remote code execution. 2016-05-16 - Vendor Disclosure  \n2016-07-18 - Patch released', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0183');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (493, 'Apple Image I/O EXR Compression Remote Code Execution Vulnerability', 'None', '2016-7-18', 'An exploitable heap based buffer overflow exists in the handling of EXR images on OS X. A crafted EXR document can lead to a heap based buffer overflow resulting in remote code execution. Vulnerability can be triggered via a saved EXR file delivered by other means when opened in any application using the Apple Image I/O API. OSX El Capitan - 10.11.4 https://developer.apple.com/osx/download 7.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:N This vulnerability is present in the Apple Image I/O API which is used for all image handling on OS X including rendering images in Preview. There exists a vulnerability in the parsing and handling of EXR images. A specially crafted EXR image file can lead to an out of bounds write and ultimately to remote code execution. OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light & Magic for use in computer imaging applications and is used in all motion pictures currently in production. EXR uses 16-bit floating-point color component values. Since the IEEE-754 floating-point specification does not define a 16-bit format, EXR created the \"half\" format. Half values have 1 sign bit, 5 exponent bits, and 10 mantissa bits. This information is then read in as rows of x and y coordinates to draw the image. The vulnerability arises when the values read in are not properly sanitized. EXR includes support for multiple different compression formats. B44 compression is used in this case and ultimately leads to the vulnerability. Below is the crash that happens when running the trigger: And running the trigger again except with guard malloc enabled this time shows us some interesting output: The large malloc is caused by a user controlled value for the size of the compressed B44 data. This pointer ultimately gets stored in an int despite the fact that it is the size of long. This ultimately causes truncation of the malloced value leading to an out of bounds access. This is a direct memcpy of user controlled data into an out of bounds buffer and could be leveraged to gain full remote code execution. 2016-05-16 - Vendor Disclosure  \n2016-07-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0181');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (494, 'Apple Image I/O EXR Color Component Remote Code Execution Vulnerability', 'None', '2016-7-18', 'An exploitable heap based buffer overflow exists in the handling of EXR images on OS X. A crafted EXR document can lead to a heap based buffer overflow resulting in remote code execution. Vulnerability can be triggered via a saved EXR file delivered by other means when opened in any application using the Apple Image I/O API. OSX El Capitan - 10.11.4 https://developer.apple.com/osx/download 6.4 - CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:L/A:L This vulnerability is present in the Apple Image I/O API which is used for all image handling on OS X including rendering images in Preview. There exists a vulnerability in the parsing and handling of EXR images. A specially crafted EXR image file can lead to an out of bounds write and ultimately to remote code execution. OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light & Magic for use in computer imaging applications and is used in all motion pictures currently in production. EXR uses 16-bit floating-point color component values. Since the IEEE-754 floating-point specification does not define a 16-bit format, EXR created the \"half\" format. Half values have 1 sign bit, 5 exponent bits, and 10 mantissa bits. This information is then read in as rows of x and y coordinates to draw the image. The vulnerability arises when the values read in are not properly sanitized. The relevant code for the reading of the image is shown below. The problem here arises when toPtr is calculated, [1], and the values of xStride and yStride are user controlled. If these variables are signed it causes the resulting calculation to be sign extended and points the destination buffer out of bounds. Shown below is where the toPtr is calculated and the corresponding values. Notice RAX is sign extended and contains a very large negative value. When the base of the buffer is added to it, [1], it is pointing well out of bounds, causing an out of bounds write. With proper calculation and set up this vulnerability could potentially be leveraged into a remote code execution vulnerability and give an attacker full control. The resulting crash is shown below. 2016-05-16 - Vendor Disclosure  \n2016-07-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0180');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (495, 'Apple Image I/O API Tiled TIFF Remote Code Execution Vulnerability', 'None', '2016-7-18', 'An exploitable heap based buffer overflow exists in the handling of TIFF images on Apple OS X and iOS operating systems. A crafted TIFF document can lead to a heap based buffer overflow resulting in remote code execution. This vulnerability can be triggered via malicious web page, MMS message, iMessage or a file attachment delivered by other means when opened in applications using the Apple Image I/O API. OSX El Capitan - 10.11.4\niOS - 9.3.1 https://developer.apple.com/osx/download/ 8.1 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N This vulnerability is present in the Apple Image IO API which is used for all image handling on OS X including rendering images in Preview and Safari. There exists a vulnerability in the parsing and handling of Tiled TIFF images. A specially crafted TIFF image file can lead to an out of bounds write and ultimately to remote code execution. TIFF (Tagged Image File Format) images consist of data describing the image in the header then tags throughout the image file describing how and where the data should be displayed. Running the attached test case through a Tiff analyzer shows us the following output: Each piece of information shown here is derived from a tag with a specific identifier in the image file. Take note of the warning alerting the user that the tile width is invalid. Running this through Preview the following output is shown: It can be seen that this is corrupting a free heap block header so this is most likely a heap overflow. Now turning on guard malloc and reproducing the crash gives us the following output: Here we see a crash on an attempt to write to memory at the address held in RAX. Investigating further we see RAX is pointing to the very end of a heap block yet there is still a lot of data to be written as RDX (counter) is still 0xFE. It is also noted that the malloced buffer is the same size as the tile width which becomes of interest when looking further into what is causing this. Decompiling the code near where the malloc block is allocated in ImageIO`copyImageBlockSetTiledTIFF is shown below: The information is read in from the tiff image then some calculations are performed on it. At [1] it compares the tile width and the image width and defaults to the smaller value. It does the same check for image length at [2]. The tile width and length, 255 and 1024, are both longer than the image width and length, 2 and 1, thus the code defaults to the smaller values. It then calculates the needed size by multiplying the calculated width from above, times the number of samples[4]. If this is less than the size of a tile, one tile size is allocated, 255, which is what happens in this case[5]. Further into this function we see where our overwrite is happening: The code is reading in tile data from the tiff image, one tile per sample, and moving the buffer forward the size of one tile[1]. The problem comes in when we look at the previous code and see it defaulted to the smaller width and only allocated 255 bytes, enough for one sample. Every subsequent sample writes out of bounds and further corrupts memory.  The number of samples is easily controlled in the tiff image allowing for further heap corruption quite easily. 2016-05-17 - Vendor Disclosure  \n2016-07-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0171');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (496, 'Intel HD Graphics Windows Kernel Driver (igdkmd64) Code Execution Vulnerability', 'None', '2016-7-11', 'A vulnerability exists in the communication functionality of Intel Graphics Kernel Mode Driver. A specially crafted message can cause a vulnerability resulting in executing arbitrary code. An attacker can send specific message to trigger this vulnerability and escalate his privileges on the local system. http://intel.com 8.4 - CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N/E:P/RL:U/RC:C This vulnerability can be triggered by sending specially crafted D3DKMTEscape request to\nthe Intel HD graphics driver. The faulting code is located in the Intel Graphics Kernel Mode Driver driver (igdkmd64 module): Instruction at 0x1BE920 tries to execute a memory location pointed by qword value located at\n@rax+0x250. In this case @rax value points to NULL (memory location at address 0). Additional information from the crash dump: 2016-03-07 - Vendor Notification \n2016-07-11 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0087');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (497, 'Symantec Norton Security IDSvix86 PE Remote System Denial of Service Vulnerability', 'None', '2016-7-7', 'A denial of service vulnerability exists in the Portable Executable file scanning functionality of Symantec Norton Security. A specially crafted\nPE file can cause an access violation in IDSvix86 kernel driver resulting in denial of service. An attacker can trigger this vulnerability for example by emailing the victim the forged file. Symantec Corporation Norton Security 22.6.0.142, IDSvix86 driver version 15.1.0.1263 7.5 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:H This vulnerability occurs when Norton is trying to parse specifically crafted file Portable Executable file. The faulting code is located in the IDSvix86 driver: Loop at 0x00058E26 is executed till the counter ebx is less than section\'s raw size (comparison at 0x00058E3B) which is controlled\nfreely by the attacker. If the SectionRawData parameter is big enough it can cause the MD5Compress function to access memory which is\ncurrently unavailable causing the machine to crash. 2016-05-31 -  Vendor Notification  \n2016-07-07 -  Patch Released  \n2016-07-07 -  Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0182');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (498, 'The Document Foundation LibreOffice RTF Stylesheet Code Execution Vulnerability', 'None', '2016-6-27', 'An exploitable Use After Free vulnerability exists in the RTF parser LibreOffice. A specially crafted file can cause a use after free resulting in a possible arbitrary code execution. To exploit the vulnerability a malicious file needs to be opened by the user via vulnerable application. The Document Foundation LibreOffice 5.0.4 [6.3] - [CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L] LibreOffice is a popular open source office suite. An use after free vulnerability is present in the RTF parser of the lates release. The core of the vulnerability lies in the way documents containing both stylesheet and superscript tokens are parsed. A malformed document with   token in top group causes the invalid parser operation. A minimal example testcase triggering the vulnerability is: It can be observed that the token   (a keyword for supperscript text) is in outermost group while the stylesheet is in its own inner group. In an usual RTF document, superscript would be in an inner group too. Looking at the code, for each new token a new parser state is pushed to the state stack: It should be noted that variable   above is of type   which is a warper for STL deque container. In this specific case, the states are popped and subsequently freed in the   method, specifically at line 5844: By observing the process under debugger, it can be observed that   is called one time too many, leading to an access to an invalid pointer which eventually crashes the process at: The invalid memory being dereferenced ultimately comes from a previously used chunk on the heap of size 0x50 which is allocated during one of the   calls: A truncated callstack shows that the debugger is stopped inside a   method of the RTFStack deque. Disassembly of at the breakpoint shows a call to a new operator which allocates an array of 18 unsigned ints. The heap chunk returned is  in   and can be observed to be in use: The chunk is located at 0x873c200 and is 80 bytes in size. This chunk is later freed in a   call but it\'s content is ultimately accessed again just before the crash. The program crashes inside  : In the above debugger output, the process crashes due to a read access violation. Contents of register   above come from the previous call to  : In the above disassembly, the final value of eax ultimately comes from an address pointed at by   [1] which actually points inside the previously freed chunk. Observe that the buffer is inside the chunk (chunk was at 0x873c200 and was 80 bytes) which has been allocated by another part of the code in the mean time. Further memory layout control could potentially allow for more abuse and ultimately for code execution. By careful heap manipulation, a dereferenced pointer can be put under control which can be demonstrated by the following (shortened) testcase: Opening the above testcase in LibreOffice results in the same crash but with obvious control over the pointer: Further process and memory state manipulation is needed to possibly turn this arbitrary read into code execution. 2016-04-13 - Initial Vendor Contact  \n2016-06-27 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0126');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (499, 'Pidgin MXIT File Transfer Length Memory Disclosure Vulnerability', 'None', '2016-6-21', 'An information leak exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could potentially result in an out of bounds read. A malicious user, server, or man-in-the-middle can send an invalid size for a file transfer which will trigger an out-of-bounds read vulnerability. This could result in a denial of service or copy data from memory to the file, resulting in an information leak if the file is sent to another user. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ When a file transfer is received via the MXIT server, the server will send a CP GET command. This will be handled by the function mxit cmd_media at lines 2195-2206 of mxit/protocol.c. At line 2201 it will call the function mxit parse chunk structure. This function is defined in the file mxit/chunk.c and the length is read at line 509: After this function has parsed the information and returned, the function mxit rx_file will be called at line 2204. This function is defined in the file mxit/filexfer.c, where at line 445 it will read from the received buffer into the file: If the length of the chunk that was specified is longer than the buffer, it will result in an out-of-bounds read and the resulting data in memory will be written after the received file. Depending on the memory layout of the program at the time the vulnerability is triggered this could result in a scenario where either program crashes because pages are not accessible or where sensitive data is leaked from memory into the file. The user may decide to copy this file to other places or might send it to another user which would result in the leaking of this data. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0140');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (500, 'Pidgin MXIT Avatar Length Memory Disclosure Vulnerability', 'None', '2016-6-21', 'An information leak exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could potentially result in an out of bounds read. A malicious user, server, or man-in-the-middle can send an invalid size for an avatar which will trigger an out-of-bounds read vulnerability. This could result in a denial of service or copy data from memory to the file, resulting in an information leak if the avatar is sent to another user. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ When an avatar is received via the MXIT server, the server will send a CP GET parse media at lines 2208-2234 of mxit/protocol.c: At line 2215 it will call the function mxit parse avatar() which will read the size of the chunk from the data at line 683 of mxit/chunk.c: If the length of the chunk that was specified is longer than the buffer, it will result in an out-of-bounds read and the resulting data in memory will be written after the received avatar. Depending on the memory layout of the program at the time the vulnerability is triggered this could result in a scenario where either program crashes because pages are not accessible or where sensitive data is leaked from memory into the file. The user may decide to copy this avatar to other places or might send it to another user which would result in the leaking of this data. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0135');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (501, 'Pidgin MXIT Table Command Denial of Service Vulnerability', 'None', '2016-6-21', 'A denial of service vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could potentially result in an out-of-bounds read. A malicious server or an attacker who intercepts the network traffic can send invalid data to trigger this vulnerability and cause a crash. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ In the function command_table in mxit/formcmds.c at lines 531 and 535, the number of rows and columns for the table are received from the server. These two values are then used in loops at line 547 and 548 and to access an array at line 549. An attacker can cause access to unmapped memory addresses, resulting in a denial of service. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0134');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (502, 'Pidgin MXIT Markup Command Denial of Service Vulnerability', 'None', '2016-6-21', 'A denial of service vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could potentially result in a null pointer dereference. A malicious server or an attacker who intercepts the network traffic can send invalid data to trigger this vulnerability and cause a crash. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ When handling markup commands there are insufficient checks to validate that all required fields have been provided to successfully execute the command, potentially resulting in a null pointer dereference when trying to use those values. When a command is received in a message, the function mxit command() is called. This function is defined at line 562 in the file mxit/formcmds.c. This function excepts to find values in the key=value format and will insert these pairs into a hashtable: It will then check what type of command it is dealing with and will call the appropriate function. Two functions in particular will rely on key/value pairs that, if not defined, will cause a null pointer dereference. The first function is command_imagestrip(), defined at line 383 in mxit/formcmds.c: At lines 393-399 it will look up the values of the keys nm, v and dat: While there is a check at line 400 to ensure that tmp is not NULL, there are no similar checks for name and validator. This will cause a null pointer dereference when they are used at lines 419 and 420: The keys fw, fh and layer have similar errors at lines 432-439: Similar errors also occur in the function command_table() defined in  mxit/formcmds.c at lines 530-543: If any of these key/value pairs are missing, a crash will ensue. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0133');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (503, 'Pidgin MXIT Suggested Contacts Memory Disclosure Vulnerability', 'None', '2016-6-21', 'An exploitable out-of-bounds ready exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT contact information sent from the server can result in memory disclosure. 5.3 CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N Pidgin 2.10.11 https://www.pidgin.im/ In the function  mxit cmd_suggestcontacts in the file mxit/protocol.c at line 2020 the number of attributes will be read from the incoming packet into the variable count. This value is subsequently used as the bounds for a loop at line 2030 and the loop index is used as an array index at lines 2034-2036. The pointers set at these locations will subsequently be used to read data, potentially resulting in an out-of-bounds read, copying data into results fields, for example at lines 2056-2059: Most of the out-of-bounds reads would simply result in a crash if a memory page is inaccessible since most information is not sent back to the server. However, when the add button is pushed, the following callback is called (defined in mxit/profile.c at lines 288-291): The data in this row is set in mxit search_results() in mxit/profile.c at lines 340-346: This means that the nickname will be sent to the function purple request buddy() as last argument, which ends up calling: Which should call the callback mxit buddy() defined in roster.c at line 729: This function then sends the alias back as a message to the server at lines 754 and 759: 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0143');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (504, 'Pidgin MXIT Contact Mood Denial of Service Vulnerability', 'None', '2016-6-21', 'A denial of service vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could potentially result in an out-of-bounds read. A malicious server or  user can send an invalid mood to trigger this vulnerability. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ In the function  mxit cmd_contact in mxit/protocol.c at line 1743 contact->mood will be read from data coming from the server when parsing a contact update packet. At line 1759, this mood will be passed to the function mxit contact(): This function is defined in mxit/roster.c at line 363.\nIf mood is anything other than 0, then this value is subsequently used to as index into the mxit_moods array at line 432. This can result in an out-of-bounds read of this information, potentially resulting in a crash of the program if that memory location is not accessible. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0141');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (505, 'Pidgin MXIT MultiMX Message Code Execution Vulnerability', 'None', '2016-6-21', 'An exploitable memory corruption vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT MultiMX message sent via the server can result in an out-of-bounds write leading to memory disclosure and code execution. 8.1 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Pidgin 2.10.11 https://www.pidgin.im/ The function multimx received defined in mxit/multimx.c will be called when a message is received from a MultiMX room. This message will be parsed and it will check if the message is coming from a particular user (if it contains a nickname) or from the system. If the received message starts with a   then a nickname is embedded and the server will search for a corresponding  . The code to handle is at lines 358-374: If a message only contains a nickname followed by a NULL, then msg at line 367 will point out of bounds of the string. This string is subsequently processed for markup at line 374. The mxit markup function allows for a number of scenarios to exploit this out-of-bounds access vulnerability. If the out-of-bounds data contains some user-controlled values, then the attacker can direct the markup down a number of paths. This can include an information leak where the markup contains a directive to download an emoticon string or a command to download an image (MXIT IMAGE), both will send data from the string back via a URL request. Another avenue of attack is to perform an out-of-bounds write which could potentially lead to code execution. The string being parsed is written to at multiple locations, including at line 578 in mxit/formcmds.c: And line 864 of of markup.c: 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0142');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (506, 'Pidgin MXIT Extended Profiles Code Execution Vulnerability', 'None', '2016-6-21', 'An out-of-bounds write vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could cause memory corruption resulting in code execution. 8.1 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Pidgin 2.10.11 https://www.pidgin.im/ The function mxit cmd_extprofile() is called when extended profile packets are received from the server. At line 1837 it will read the number of attributes that were sent by the server into the variable count. This value is subsequently used as the bounds for a loop at line 1839 and used to calculate the index into an array at line 1843 and that value is subsequently used to access values in the array at lines 1845-1847. The index is also used to write to an array at lines 1859-1860 potentially causing an out-of-bounds write. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0139');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (507, 'Pidgin MXIT Custom Resource Denial of Service Vulnerability', 'None', '2016-6-21', 'A denial of service vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent from the server could potentially result in an out-of-bounds read. A malicious server or man-in-the-middle can send invalid data to trigger this vulnerability. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ The function mxit parse_cr() in the file mxit/chunk.c is used to parse custom resources like a new splash image. These type of resources are sent as part of a multimedia packet. At lines 573 the length of the chunk is read from the chunk being parsed without bounds checks. This chunk can contain one or more resource chuncks that are set at line 577. The size of the resource chunk is contained at the top of the chunk and again the size is read without bounds checks at lines 587 and 604: This length is then used to access data in the chunk at lines 582 and 587, resulting in an out-of-bounds read. This data is not sent back to the server, so it is unlikely to result in an information leak vulnerability, but could result in a denial of service when accessing the out-of-bounds memory if the accessed location is not an allocated memory region. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0138');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (508, 'Pidgin MXIT read stage 0x3 Code Execution Vulnerability', 'None', '2016-6-21', 'A buffer overflows vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent from the server could potentially result in arbitrary code execution. A malicious server or an attacker who intercepts the network traffic can send an invalid size for a packet which will trigger a buffer overflow. 8.1 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Pidgin 2.10.11 https://www.pidgin.im/ The function mxit rx in the file mxit/protocol.c is a callback function will be called by Pidgin whenever data is sent from the MXIT server. When data is received, the size of the incoming packet will also be received at line 2825. There is a check at line 2826 to ensure that this data is not larger than the maximum size of that an MXIT packet can be which is defined as CP PACKET. This is also the size of the buffer that the data is read into. However if the size is larger than CP PACKET, an error will be logged but execution will simply continue. Moreover, if the size is negative (this is possible since rx_res is an int) then no error will be logged and execution will also continue. This size will be subsequently used in a read operation at line 2846. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0118');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (509, 'Pidgin MXIT get_utf8_string Code Execution Vulnerability', 'None', '2016-6-21', 'A buffer overflow vulnerability exists in the handling of the MXIT protocol Pidgin. Specially crafted data sent via the server could potentially result in a buffer overflow, potentially resulting in memory corruption. A malicious server or an unfiltered malicious user can send negative length values to trigger this vulnerability. 8.1 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Pidgin 2.10.11 https://www.pidgin.im/ The function get string, defined at line 231 in libpurple/protocols/mxit/chunk.c will take a maximum string length as argument. Usually this is passed in as the size of the string str that is being written to. It will read the length of the string at line 238 and check to ensure that it is not larger than the maximum string length at line 240. If it is, it will set the length to be equal to maxstrlen. However, len is a signed short that will be read from nthos, which will read an unsigned integer, but because len is signed it will be cast to a signed integer. If the value of len is a large positive value it will be cast to a negative value, bypassing the size check at line 240. The call to get data( &chunkdata[pos], str, len ); The function get_data will end up calling memcpy which expects an unsigned size parameter and will interpret a negative value as a large positive value. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0120');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (510, 'Pidgin MXIT HTTP Content-Length Buffer Overflow Vulnerability', 'None', '2016-6-21', 'A buffer vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent by the server could potentially result in an out of bounds write of one byte. A malicious server can send a negative content-length in response to a HTTP request triggering the vulnerability. 8.1 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Pidgin 2.10.11 https://www.pidgin.im/ When receiving a reply to a HTTP request from the HTTP server the callback function mxit http_read(), defined in mxit/http.c, will be called. This function will parse the HTTP headers and then send the body off for processing as a regular MXIT packet. As part of HTTP header parsing that occurs, the CONTENT_LENGTH is read from the headers at lines 178-185: Bodylen is defined as a signed integer and thus the input read  from the HTTP header could be negative. There is a size check at lines 189-192: However this check will pass if bodylen is set to a negative value. At line 206 bodylen is copied to the variable session->rx_i which is an unsigned integer, thus casting a potential negative bodylen to a large positive value. This value is then later used to control a loop when the packet is processed in the function mxit packet in mxit/procotol.c at line 2669: The index i is subsequently used a multiple locations to write to the buffer rx dbuf. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0119');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (511, 'Pidgin MXIT mxit_convert_markup_tx Information Leak Vulnerability', 'None', '2016-6-21', 'An information leak exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent to the server could potentially result in an out of bounds read. A user could be convinced to enter a particular string which would then get converted incorrectly and could lead to a potential out-of-bounds read. 3.1 CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N Pidgin 2.10.11 https://www.pidgin.im/ When a message is sent by Pidgin to the server, it has to convert the markup from libpurple (HTML-based) markup to MXIT markup. To do this, the function mxit markup_tx defined in the file markup.c will be called. This function will copy the data from the old string message to the new string mx, converting it along the way. However, at lines 1146-1154 it will convert the markup to change the font color without checking the length of the string that is remaining: It will compare if the string starts with <font color= at the current position in the message at line 1146. If it does it will copy 7 bytes from 1 element past the end of  , presumably to skip over the   tag. However, if   is at the end of the string then this will result in an out-of-bounds read of message. Since one byte after the end of the   will be skipped over, the NULL termination string will be skipped over, allowing the 7 bytes of data behind the string to be copied to the mx, which is the string that will be sent to the server. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0123');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (512, 'Pidgin MXIT Splash Image Arbitrary File Overwrite Vulnerability', 'None', '2016-6-21', 'A directory traversal exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent from the server could potentially result in an overwrite of files. A malicious server or someone with access to the network traffic can provide an invalid filename for a splash image triggering the vulnerability. 4.8 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:L Pidgin 2.10.11 https://www.pidgin.im/ Pidgin allows the MXIT server to provide a splash image to show when connecting to the server. The server can also update this image by providing a new one via a command sent back from the server. When the server provides a new image via a multimedia command then the function splash_update will be called at line 2170 of mxit/protocol.c: The variable chunk.id is read from data coming from the server in the function mxit parse_cr at line 564: The function splash_update is defined in mxit/splashscreen.c at lines 115-136: At line 127 splashId will be correctly escaped to prevent a directory traversal from occurring. However the unescaped string is stored in the MXIT SPLASHID variable at line 130. The function splash CONFIG_SPLASHID to find the file to delete (lines 84-104): However unlike in splash_update, in this case there is no escaping of the filename, allowing an attacker to delete arbitrary png files on the system. 2016-04-12 - Initial Vendor Contact  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0128');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (513, 'Pidgin MXIT g_snprintf Multiple Buffer Overflow Vulnerabilities', 'None', '2016-6-21', 'Multiple memory corruption vulnerabilities exist in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could result in multiple buffer overflows, potentially resulting in code execution or memory disclosure. 7.5 CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H Pidgin 2.10.11 https://www.pidgin.im/ The MXIT plugin for Pidgin uses the function g snprintf returns, it will return the number of bytes that would have been written had the buffer been large enough, not the amount of bytes that have actually been written. This is described at https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-snprintf. The MXIT plugin uses the return value of g snprintf are checked, the following 12 calls spread over 7 functions appear to be the most problematic as they will copy data that might come from an untrusted location into a string. The following functions are all defined in the file mxit/protocol.c Function: mxit_send_invite()\nLines: 1015-1024 The data passed into g_snprintf comes from both the server and the user and the return value will be used to specify the bounds of the data to be sent in the function mxit_queue_packet, potentially resulting in an out-of-bounds read of data which will be sent to the server, which might cause an information leak. Function: mxit_queue_packet()\nLines: 467-479 A long user account returned at line 467 will potentially cause buffer overflows at lines 471, 473, 476 or 479. Function: mxit message()\nLines: 808-817 Data passed to mxit message comes from the server and the user in the variables to and msg respectively. The variable msg might also contain data coming from the server if itÕs the result of a clicked link. This will subsequently result in an out-of-bounds read of data sent back to the server in mxit_queue_packet, which might cause an information leak. Function: mxit_write_http_post()\nLines: 355-369 The size of the packet->header combined with the URL and the other data being printed could result in a value larger than 256, resulting in a buffer overflow at line 369. The packet->header will be set in mxit packet, which is discussed earlier in this advisory. Function: mxit splashclick()\nLines 1136-1142 Splash id is data that comes from the server, which is used in the g queue_packet. Since this data is sent back to the server, this could result in an information leak. Function: mxit suggest_search()\nLines: 937-946 The value text will come from the user, who could be tricked into entering a potential long string. This could then result in a buffer overflow at line 942 and an out-of-bounds read leading to an information leak at line 946. Function: mxit_send_msgevent\nLines 1162-1168 The issue is the same as before, to and id come from the server and are used in line 1162, which could result in an information leak at line 1168. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0136');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (514, 'Pidgin MXIT CP_SOCK_REC_TERM Denial of Service Vulnerability', 'None', '2016-6-21', 'An NULL pointer dereference vulnerability exists in the handling of the MXIT protocol in Pidgin. Specially crafted MXIT data sent via the server could potentially result in a denial of service vulnerability. A malicious server can send a packet starting with a NULL byte triggering the vulnerability. 5.9 CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H Pidgin 2.10.11 https://www.pidgin.im/ The function mxit packet() in mxit/protocol.c is called when data is received from an MXIT server to parse the relevant stream of bytes into an MXIT packet. When the packet is received, a new record is created in the packet to reflect the data (near line 2672): The function add_record does the following: This will create a record in the packet and increase the rcount variable by 1. At lines 2679-2744 the packet is further analyzed and broken up into records and fields depending on if the separator being used is 0x0, 0x1 or 0x2. The following code if of particular interest: The value CP REC_TERM indicates that the end of a record is reached and it will retrieve the command that the packet is sending. However, if the packet starts with a NULL byte then the fields value for the record will not have been initialized resulting in a crash when trying to dereference it at line 2686. 2016-04-13 - Vendor Notification  \n2016-06-21 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0137');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (515, 'Libarchive mtree parse_device Code Execution Vulnerability', 'None', '2016-6-19', 'An exploitable stack based buffer overflow vulnerability exists in the mtree parse_device functionality of libarchive.\nA specially crafted mtree file can cause a buffer overflow resulting in memory corruption/code execution.\nAn attacker can send a malformed file to trigger this vulnerability. libarchive 3.1.2 https://github.com/libarchive/libarchive 7.8 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H\nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0 Vulnerable code exists in mtree support format module: In line 1357 we see definition of static buffer prepared to contain 3 elements. Next in while loop in lines 1377-1389 exist condition (line 1384)\nwhich should protect against overflowing \"numbers\" buffer but this condition is wrong and allows to overflow buffer with one element.\nDepending on platform and architecture, size of overwrite can be 4 or 8 bytes with content fully controlled. 2016-04-19 - Vendor Disclosure  \n2016-06-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0153');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (516, 'Libarchive Rar RestartModel Code Execution Vulnerability', 'None', '2016-6-19', 'An exploitable heap overflow vulnerability exists in the Rar decompression functionality of libarchive.\nA specially crafted Rar file can cause a heap corruption eventually leading to code execution.\nAn attacker can send a malformed file to trigger this vulnerability. libarchive git version on date 02.12.2015\nPlatform : x86/x64 https://github.com/libarchive/libarchive 7.8 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H  \nCVSSv3 Calculator: https://www.first.org/cvss/calculator/3.0  Here we see the execution flow leading to heap corruption: Let\'s focus on extraction phase, so everyting below archive_read_extract. The key variable/field here is rar->dictionary_size. First we see that its value is set to: Next, because of small value of \"packed_size\": Another portion of data is read from file and parsed like during \"reading phase\" in archive_read_next_header by calling\narchive_read_format_rar_read_header and read_header functions. During one of these calls, we see that value of dictionary_size is\nset to zero. Next allocation for Ppmd context depends on the value of dictionary_size: As we can see for dictionary_size equal 0 we will have allocation made for 0 bytes: Finally we land in RestartModel function: The key values here are: As we can see above both equal 0 which has consequences in line 328 where UNIT_SIZE (12) is subtracted from p->HiUnit pointer and assigned to p->MinContext:\nWhen everything is correct p->HiUnit first is set at the end of allocated space for Ppmd context, but because AlignOffset and Size is equal 0\nit still points to the beginning. In result of this substraction p->MinContext is set to the inside of previous heap chunk space. Further writes to this structure overwrite heap chunks: 2016-04-19 - Vendor Disclosure  \n2016-06-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0154');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (517, 'Libarchive 7zip read_SubStreamsInfo Code Execution Vulnerability', 'None', '2016-6-19', 'An exploitable \\heap overflow vulnerability exists in the 7zip read_SubStreamsInfo functionality of libarchive. A specially crafted 7zip file can cause a integer overflow resulting in memory corruption that can lead to code execution. An attacker can send a malformed file to trigger this vulnerability. libarchive 3.1.2 https://github.com/libarchive/libarchive 7.8 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H Vulnerable code exists in 7zip support format module:\nlibarchive\\archive support 7zip.c: In lines 2149-2157 we can see that for all \"folders\" is calculated sum of \"numUnpackStreams\" which result is stored in \"unpack t what means that on x86 platform will be 32bit unsigned int. Maxium value of of \"numUnpackStreams\" is equal to UMAX streams\" variable we need to have 7zip file with number of folders \"numFolders\" bigger than 42 and \"numUnpackStreams\"\nwith sufficient values. The overflowed value is also used as size parameter in calloc in lines 2166-2171. Interesting buffer allocated there for us is \"ss->unpackSizes\".\nLater in lines 2187-2194 based on \"numFolders\" and \"numUnpackStreams\" of each folder, a 64bit unsigned integer (maximum) is read from the file and stored\ninto buffer \"usizes\" which is indeed \"ss->unpackSizes\" ( line 2177 ) causing a heap based buffer overflow after some iterations. At this point the attacker controls the length and contents of the memory corruption. valgrind output: 2016-04-19 - Vendor Disclosure  \n2016-06-18 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0152');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (518, 'Ruby TclTkIp ip_cancel_eval Type Confusion Vulnerabilities', 'None', '2016-6-14', 'Type Confusion exists in  eval Ruby\'s TclTkIp class method. Attacker passing different type of object than String\nas \"retval\" argument can cause arbitrary code execution. Ruby 2.3.0 dev\nRuby 2.2.2\nTcl/Tk8.6 or later https://www.ruby-lang.org Vulnerable code: In line 7769 \" eval\" method argument is parse out into \"retval\" variable. Next this variable is passed to\n\"ip eval_core\" function (line 7772). In line 7753 we can see that our \"retval\" variable which in this function is passed as \"msg\" argument is\ntreated as String object.Passing object different than String we will cause type confusion vulnerability in this line. 2015-06-18 - Initial Discovery  \n2015-06-30 - Vendor Notification  \n2016—06-14 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0031');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (519, 'Adobe Flash Player Infinite Recursion Arbitrary Read Access Violation', 'None', '2016-6-14', 'A potentially exploitable read access violation vulnerability exists in the a way Adobe Flash Player handles infinitely recursive calls. A specially crafted ActionScript code can cause a read access violation which can potentially be further abused. To trriger this vulnerability user interaction is required in that the user needs to visit a webpage with embedded malicious SWF file. Adobe Flash Player 21.0 (latest at the time of writing) Vulnerability exists in a way Flash Player handles recursion when calling implicit functions such as \"toString\" or \"valueOf\".  It is best illustrated by an example: The above code is broken down in a few steps: Above example is using objects of type UriError, ByteArray, and Math, but other combinations are possible. Most combinations end up crashing as straight forward null pointer dereferences but Math constants are somewhat special. We can observe the following crash when Math.PI is being dereferenced: Note that the crash happens in the JITed code which is generated based on the actionscript bytecode. Above crash is still a null pointer dereference but what makes it slightly more interesting is the fact that varying the constant in use gives us limited control over the offset in the JITed code. For example, using Math.SQRT2 instead of Math.PI gives: So, by varying the constant, we can vary the offset in the JITed code, but unfortunately as expected, in case of Math the highest offset is with SQRT2 (0x60) which is still far too low to be of any use. Slight variations of the crashing piece of actionscript code yield slightly different results. For example: Even though not strictly valid, the above code produces slightly more interesting assembly when JITed and crashes here: Still a null pointer dereference, but this time near a call instruction and with eax fully controlled: By digging into the preceding code, we can see the following: We can see that NULL being dereferenced at the time of the crash comes indirectly from the first   above and second argument (0x41414141) is put into ecx directly and pushed to the stack. The part with the xor is just an artifact of \"constant blinding\" JIT spray mitigation. So, in the above code, function 00a7cb10, at [1], will return a pointer in eax, which gets read at [2] (this sets eax to NULL). Then it gets incremented at [3] and pushed to the stack at [4]. Later, in the function 00a52a20 this NULL pointer is dereferenced and the process crashes due to ReadAV. That being said, the working hypothesis is that hitting a recursion limit sets the process in an irregular state, then, since the exception is inhibited by the try/catch block, code continues with execution in this exceptional state which leads to an invalid dereference when retrieving the Math object further leading to a crash. Above examples use Math constants to demonstrate limited control over the dereference offset. It could be possible that a special object could be crafted which would allow for bigger offsets turning this into an arbitrary read access violation which could be further abused. 2016-04-28 - Vendor Disclosure  \n2016-06-14 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0165');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (520, 'Ruby WIN32OLE ole_invoke and ole_query_interface Type Confusion Vulnerabilities', 'None', '2016-6-14', 'Type Confusion exists in two methods of Ruby\'s WIN32OLE class, ole query_interface. Attacker passing different type of object than this assumed by developers can cause arbitrary code execution. Ruby 2.3.0 dev\nRuby 2.2.2 https://www.ruby-lang.org 1#Details - WIN32OLE invoke \"ole query query_interface\" Vulnerable code: As you can see in line 2550 ole bracket\" param is set to false so \"paramS\" will only be reached in line 2578.\nAs we can observe, before line 2578 type of \"paramS\" is not check anywhere and in this line its treated as Ruby array object. Passing object different\nthan Array type confusion vulnerability will appear in this line. Vulnerable code: fole interface takes one argument which is iid of specified interface. Developers assumed that this parameter will be passed to the function\nin string form and before usaged of \"str_iid\" param in line 3543 non of check for type is made.\nAttacker passing different type of object than this assumed by developers can cause arbitrary code execution. 2015-06-18 - Initial Discovery  \n2015-06-30 - Vendor Notification  \n2016-06-14 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0029');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (521, 'Ruby Psych::Emitter start_document Heap Overflow Vulnerability', 'None', '2016-6-14', 'An exploitable heap overflow vulnerability exists in the Psych::Emitter start document function heap buffer \"head\" allocation is made based on tags array length. Specially constructed object passed as element of tags array can increase this array size after mentioned allocation and cause heap overflow. Ruby 2.3.0 dev\nRuby 2.2.2 https://www.ruby-lang.org In Line 166 based on length of passed by user tags array, xcalloc allocates buffer for yaml directive_t structures.\nLater in the loop, each element of tags array is checked whether is in form of tuple, which here means [name,value].\nname and value of this tuple is \"converted\" in two different ways: Solving a)\nAs we dive deep into rb export enc function we encounter rb get_index function defined in encoding.c file. There are at least 3 objects having encoding fields which we can use. I decided to use Regexp object in my PoC.\nb) To created with proper encoding Regex object we need to add to_str method Vulnerable code: 2015-06-08 - Initial Discovery  \n2015-06-30 - Vendor Notification  \n2016-06-14 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0032');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (522, 'Ruby Fiddle::Function.new Heap Overflow Vulnerability', 'None', '2016-6-14', 'An exploitable heap overflow vulnerability exists in the Fiddle::Function.new \"initialize\" function functionality of Ruby. In Fiddle::Function.new \"initialize\" heap buffer \"arg_types\" allocation is made based on args array length. Specially constructed object passed as element of args array can increase this array size after mentioned allocation and cause heap overflow. Ruby 2.3.0 dev\nRuby 2.2.2 https://www.ruby-lang.org In Line 110 based on length of passed by user args array, xcalloc allocates buffer for ffi type structure.\nResults of this conversions are stored in previous allocated array \"arg_types\". implement this method and it\'s responsible will be to increase size of args array. Increased size of args array inside for loop just after space\nallocation for arg type structures. 2015-06-11 - Initial Discovery  \n2015-06-30 - Vendor Notification  \n2016-06-14 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0034');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (523, 'Ruby pack_pack Use After Free Vulnerability', 'None', '2016-6-14', 'An exploitable User After Free vulnerability exists in the pack pack function each element of array which should be \"pack\", based on template string is converted to binary representation in proper way. If element is not compatible with corresponding to him format, element is converted to proper form. Exploiting this knowledge and fact that size of array used later in iteration is taken before loop, specially constructed object can be passed as element of \"ary\" and during conversion to pointed by template string format clear \"ary\" array triggering in next iteration use after free vulnerability. Ruby 2.3.0 dev\nRuby 2.2.2 https://www.ruby-lang.org In Line 366 length of array contains elements to pack is taken. It\'s important to notice it that this length is read one time not each time during loop iteration because later we will exploit that fact.\nNext in Line 373 starts loop where each element from \"ary\" array is \"pack\" to corresponding form pointed by directives passed in \"fmt\" argument.\nFor an example I chose to use \"A\" directives.\nLine 460 take another element from \"ary\" and treating it according with directive as a string. Before any operation is made on \"from\" object\nin Line 466 by calling StringValue function checks whether indeed \"form\" object is a String object. If \"from\" object is not a string\n\"to str\" method gives possibility to manipulate e.g \"ary\" content\nAttacker can create object and pass it in \"ary\" array as element, which implements \"to str\" method on released memory. With proper spraying it can lead to code execution.\nBelow PoC shows entire attack. 2015-06-08 - Initial Discovery  \n2015-06-30 - Vendor Notification  \n2016-06-14 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0033');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (524, 'ESnet iPerf3 JSON parse_string UTF Code Execution Vulnerability', 'None', '2016-6-8', 'An exploitable remote code execution vulnerability exists in the JSON handling functionality of ESnet iPerf3. A specially crafted JSON string can lead to buffer overflow on the heap resulting in remote code execution. An attacker can send an unauthenticated packet to any reachable iPerf3 server to trigger this vulnerability. Note a list of iPerf3 servers are listed here that are currently vulnerable to this attack https://iperf.fr/iperf-servers.php iperf 3.1.1 ESnet iPerf3 is a tool for active measurements of the maximum achievable bandwidth on IP networks. It supports tuning of various parameters related to timing, protocols, and buffers. For each test it reports the bandwidth, loss, and other parameters. The vulnerability centers around the mishandling of UTF8/16 strings within cjson.c. When attempting to allocate room for the resulting cstring, a logic error occurs when sscanf reaches a non-hex character (\'\"\'), however the pointer is incremented by 4 bytes regardless of the result. This skips the quote character causing the while loop to miss the first quote and continue writing until the second quote is found. This results in an overflow into the next heap structure, clobbering the heap block header. The \"key\" found in this JSON string does not match any known keys and is later freed. I have commented some of the lines below: This object is then compared against a list of keys, the JSON object is deleted and the string is freed. When attempting to delete the object cJSON->valuestring, the corrupted chunk is read in and then freed: 2016-04-20 - Initial Vendor Contact  \n2016-06-08 - Patch Released', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0164');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (525, 'IBM Domino KeyView PDF Filter BaseFont Code Execution Vulnerability', 'None', '2016-6-8', 'A heap buffer overflow vulnerability present in the PDF filter of KeyView as used by Domino can lead to arbitrary code execution. http://www-03.ibm.com/software/products/en/ibmdomino While parsing a specially crafted PDF file containing with a   element type that references a malformed   object, an unchecked string copy operation can be triggered that can lead to unlimited buffer overflow on the heap. The core of the test case triggering this vulnerability is as follows: In the above test case, object 4 references a   object number 5 which in turn references object number 6 for   data. Object 6 contains an overly long string (minimal length that triggers heap metadata overwrite is 229 as the rest of the object is also used in the overwrite). The overflow happens while parsing the font data, in   function, in the following basic block: Function   is called without doing proper bounds checking. Vulnerable path is reached specifically\nafter the parser starts gathering font information: The supplied test case triggers the vulnerability and leads to a crash as the buffer overflow overwrites the heap meta data. The attacker is in full control over the contents of the overflown data which can lead to successful exploitation and arbitrary code execution in the remote process. The vulnerability can be triggered with the supplied test case in the   standalone KeyView binary shipped with IBM Domino, or by sending it as an attachment with an email to a Domino mail server. 2016-02-09 - Vendor Notification  \n2016-06-08 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0091');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (526, 'IBM Domino KeyView PDF Filter Trailer ID Code Execution Vulnerability', 'None', '2016-6-8', 'A heap based buffer overflow vulnerability present in KeyView PDF filter as used by Domino can\nlead to remote arbitrary code execution. http://www-03.ibm.com/software/products/en/ibmdomino While parsing an ID description of a PDF trailer, no checks are being made regarding its length.\nThe ID, which is usually an ASCII representation of hexadecimal value, is converted into it\'s\nbyte array equivalent without size checks leading to a straight forward heap overflow which\ncan be abused to overwrite sensitive data structures or heap metadata and subvert the process\nexecution flow to arbitrary code execution. Shortened test case triggering the vulnerability can be summarized as follows: When initializing the parser, a large chunk of memory is allocated in   function\nof   library (132648 bytes in size to be precise). An offset into this large context memory\nchunk is used as a start of the buffer that ends up being overflown. The overflow happens in the\nfollowing code: At the beginning of the above code, at [1],   contains the first character of the ID hex string\nwhich is saved in  , at [2],[3] and [4] the second character is saved in   which, along\nwith  , makes up a string that is passed to   at [5]. Function   is called\nwith base set to 0x10, converting from hex string into bytes. At [6] the returned value is written\nto the buffer. This is where the out of bounds write occurs when the counters are past the boundary\nof the buffer. At [7] the current string counter is checked against the file end,   points\nto the end of file. If the check at [7] passes, another check is made at [8] which is looking\nfor a terminating   character. No buffer length checks are being made. This buffer overflow can be abused to overwrite other parts of the context structure or even,\nfurther up the heap, the heap metadata thus leading to process crash and possible arbitrary code\nexecution. The supplied test case is crafted in such way that the buffer overflow will overwrite a pointer\non the heap which is later dereferenced during heap cleanup. The process crashes while calling\nfree on an invalid pointer. Further control over data overwritten in the context structure can\nlead to arbitrary code execution. Detection of PDF files specifically crafted to trigger this vulnerability can be based on the\nabnormally large length of the ID value in the PDF trailer. The vulnerability can be triggered with the supplied test case in the   standalone KeyView\nbinary shipped with IBM Domino, or by sending it as an attachment with an email to a Domino\nmail server. 2016-02-09 - Vendor Notification  \n2016-06-08 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0092');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (527, 'IBM Domino KeyView PDF Filter Stream Length Code Execution Vulnerability', 'None', '2016-6-8', 'An integer overflow vulnerability present in the PDF filter of KeyView as used by\nDomino can lead to process crash and possible arbitrary code execution. http://www-03.ibm.com/software/products/en/ibmdomino An improper check on   parameter of a compressed PDF stream can  result in an integer\noverflow leading to an unbounded   call. Shortened test case triggering the vulnerability can be summarized as follows: In the above test case the length value is specified to be exactly 2147483647 or 0x7fffffff in hex,\nwhich is the biggest positive value of a 32bit integer. String value of length is converted into\nan integer by calling   function (base address of pdfsr.so being 0xB79BA000): If a string representing an integer supplied to   is equal to 2147483647 or bigger,  \nwill return 0x7fffffff. The integer overflow happens later in the code, when the parser specifically\nchecks if the destination buffer for faulting   call is bug enough to hold the source buffer: An integer overflow happens above when 1 is added to the length value, the result being 0x80000000.\nA signed comparison is made with 0x2000 and the jump will be successful. Parser concludes that the destination buffer is big enough and proceeds to call   with the original length value (0x7fffffff): The unbounded   call will result in a process crash when it hits invalid memory. Detection of PDF files specifically crafted to trigger this vulnerability can be based on the abnormally large stream   value in the PDF file. The vulnerability can be triggered with the supplied test case in the   standalone KeyView binary shipped with IBM Domino, or by sending it as an attachment with an email to a Domino mail server. 2016-02-09 - Vendor Notification \n2016-06-08 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0090');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (528, 'Google Chrome PDFium jpeg2000 SIZ Code Execution Vulnerability', 'None', '2016-6-8', 'An exploitable  heap buffer overflow vulnerability exists in the Pdfium PDF reader included in the Google Chrome web browser. A specially crafted PDF document with embedded jpeg2000 image can cause a heap buffer overflow potentially resulting in an arbitrary code execution. An attacker can serve the malicious PDF file on a website and wait for a victim to visit to trigger this vulnerability. Google Chrome 50.0.2661.94\nPdfium Git 2016-05-08 6.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L A heap buffer overflow vulnerability is present in the jpeg2000 image parser library as used by the Chrome\'s PDF renderer, PDFium. The vulnerability is located in the underlying jpeg2000 parsing library, openjpeg, but is made exploitable in case of Chrome due to special build process. Namely, an existing assert call in the openjpeg library usually prevents the heap overflow from being reached, but in the release versions of Chrome the assertations are omited. The source of the vulnerability is located in the following code in function   in   file: If in the above call to  , which is a   wrapper,   value happens to be zero,   will return a unique pointer which can be later passed to   (this is implementation dependent, but is so on modern Linux OSes). The unique pointer returned by   will usually be a small allocation (0x20 bytes in case of x64 code). This can lead to a heap buffer overflow later in the code when this buffer is being used. The overflow happens inside    function where previously allocated buffer is being dereferenced.  The first out of bounds memory write happens in the following code: In the above code,   pointer will be pointing to the previously erroneously allocated area. The same structure is dereferenced during further out of bounds writes in the following code. First requirement for this overflow to happen, number of components to be 0, is actually checked against in an assert at the beginning of the function: If the required condition for the erroneous allocation is satisfied, the above assert would fail which indeed does happen in the default build of openjpeg library. But, since the release builds of Chrome and PDFium omit these asserts the point of buffer overflow can be reached. The attached jpeg2000 testcase (embedded inside a PDF) has it\'s SIZ marker truncated (SIZ marker begins with 0xFF51). Number of components specified in the SIZ marker is 0 and isn\'t followed by individual component information. This short circuits the code that is parsing the file in    and leads to the required erroneous call to  . The only difference between a valid jpeg2000 file and the one that triggers this vulnerability is the fact that SIZ marker specifies 0 components. For debugging purposes, both a standard and ASAN build of latest PDFium code were tested, resulting in following crashes. Regular build crashes due to heap corruption. A heap buffer overflow has resulted in adjacent heap chunk metadata overwrite: PDFium build with address sanitizer : Debugging output of Chromium nightly build revision 392151 (latest at the time of writting): Latest Chrome release crashes upon opening the attached PDF file in a similar manner. 2016-05-19 - Vendor Disclosure  \n2016-05-31 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0174');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (529, 'IBM Domino KeyView PDF Filter Encrypted Stream Code Execution Vulnerability', 'None', '2016-6-8', 'A stack overflow vulnerability present in the PDF filter of KeyView as used by\nDomino can lead to process crash and possible arbitrary code execution. http://www-03.ibm.com/software/products/en/ibmdomino While parsing a specially crafted PDF file, a user controlled length field is used in a\nwrite loop with fixed destination size leading to a stack based buffer overflow. The vulnerability\nis triggered while parsing the PDF file that specifies an encrypted stream. As per the PDF specification, the   value specifies the key length and is at most 16 bytes long. In the vulnerable function a stack buffer 16 bytes in length is reserved, but unchecked   value is used during the copy operation which allows adjacent stack data to be overwritten, including the return address. The minimized test case that triggers the vulnerability is as follows: In the above test case, the PDF   specifies that object 8 is encrypted. Further, object 8 specifies that it is using a standard filter for encryption ( ) and is using a revision 3 ( ) of the algorithm. Owner password ( ) and user password (\'/U\'), as well as object type don\'t play a significant role in this test case. While parsing the supplied test case, the   function in   will be called.\nThis function implements the algorithm for deriving the decryption key. The overflow happens in the following\ncode (image base being 0xB79BA00): In the above code,   serves as a counter. At [1], a byte is zero extended from a stack based\nbuffer, is xored with   at [2] and written to a stack buffer at [3]. The value of   comes\nfrom an outer loop counter, starts at 19 and is decreased untill 0. At [4], the counter in   is\ncompared against a maximum value in   which comes straight from the   value divided by 8.\nTo reiterate, the PDF specification states that   will be at most 128 bits, so the maximum\nvalue in   should be 16. Appropriate ly, 16 bytes are allocated for   buffer. If the\nvalue of   is more, a buffer overflow will occur, overwriting the adjacent stack memory. The supplied test case triggers the vulnerability and leads to a crash as the buffer overflow\noverwrites the return address as well as the stack cookie present on the stack. There are two mitigating factors that lower the chance of successful exploitation of this\nvulnerability. First, the function is protected with a stack cookie making a straight forward\nreturn address overwrite difficult. And second, the bytes that end up overflowing the buffer\nare constant. To elaborate on the second point, a shortened pseudo code of the algorithm follows: As can be seen from the pseudocode above, algorithm revision must be set to 3. Also,\nin examined use cases of this function, the UserPassword will always be blank, length 0,\nmeaning that the   will be initialized to the fixed value of padding which is\nequal to magic value \"28bf4e5e4e758a4164004e56fffa01082e2e00b6d0683e802f0ca9fe6453697a\" that\ncomes from PDF specification. This means that the attacker has limited control over overflowing\nbytes as it always depends on this fixed string (51 iterations of md5 of it, to be precise) and\npast contents of the stack. By controlling the size of the overwrite, data past the stack cookie and return address can be overwritten potentially leading to further abuse in certain circumstances. Detection of PDF files specifically crafted to trigger this vulnerability can be based on the\npresence of objects encrypted with revision 3 of the encryption algorithm (the exact algorithm is\nspecified in PDF specification version 1.4) with abnormally, illegally, large   value. The vulnerability can be triggered with the supplied test case in the   standalone KeyView\nbinary shipped with IBM Domino, or by sending it as an attachment with an email to a Domino\nmail server. 2016-02-09 - Vendor Notification  \n2016-06-08 – Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0089');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (530, '7zip HFS+ NArchive::NHfs::CHandler::ExtractZlibFile Code Execution Vulnerability', 'None', '2016-5-10', 'An exploitable heap overflow vulnerability exists in the NArchive::NHfs::CHandler::ExtractZlibFile method functionality of 7zip that can lead to arbitrary code execution. 7-Zip [32] 15.05 beta\n7-Zip [64] 9.20 http://www.7-zip.org/ 7.3 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H In HFS+ file system, files can be stored in compressed form with zlib usage. There is 3 different ways of keeping data in that form\nwhich depends on their size. Data of files which compressed size is bigger than 3800 bytes is stored in resource fork, split into blocks.\nBlocks size and their offset are keep in table just after resource fork header. Before decompression, ExtractZlibFile method read block size and its offset from file\nand after that read block data into static size buffer \"buf\". Because there is no check whether size of block\nis bigger than size of \"buf\", malformed size of block exceeding mentioned \"buf\" size will cause buffer overflow and heap corruption. Vulnerable code During extraction from HFS+ image having compressed files with \"com.apple.decmpfs\" attribute and data stored in resource fork we land in above code.\nLet we start our analysis from line where buffer overflow appears. Like mentioned in description compressed file data is split into blocks and each block before decompression is read into \"buf\" as we can see in\nLine 1575. Based on \"size\" value ReadStream_FALSE reads portion of data into \"buf\" buffer.\nBuffer \"buf\" definition and its size we can observe in ExtractZlibFile caller CHandler::Extract method: As you can see its size is constant and equal to 0x10010 bytes. Going back to ExtractZlibFile method.\nLine 1573 presents setting block \"size\" value read from tableBuf. tableBuf in Line 1538 is read from file, what implicates that \"size\" is a\njust a part of data coming from file so we can have direct influence on its value. Setting value for \"size\" bigger than 0x10010 we should achieve\nbuffer overflow and in consequences heap corruption. Let us check eventual constraints.\n  Before Line 1573 value of \"size\" variable is read in loop included in lines 1543-1555. This block of code is responsible of check whether\ndata blocks are consistent, what means that :\n- data block should start just after tableBuf ,line 1540\n- following data block should start at previous block size + offset, line: 1549\n- offset should not be bigger than dataSize2 (size of compressed data) ,line 1551\n- \"size\" should not be bigger than remaining data, line 1552 As we can see there is no check whether \"size\" is bigger than \"buf\" size and described above constraints don\'t have influence on it either.\nNow, the best way to trigger overflow is to decrease value of \"numBlocks\" to 2, set first \"size\" value to enough to overflow \"buf\" (so > 0x10010 )\nand rest of values just to fit constraints. Example of modified values:   file offset:  variable:        Original:          Malformed:\n  0xD342A       item.UnpackSize      0x1411b0         0x0020000\n  0x786104      numBlocks       0x15            0x2\n  0x786108      tableBuf[0].offset    0xAC            0x14\n  0x78610C      tableBuf[0].size    0x95f6            0x11fff\n  0x786110      tableBuf[1].offset    0x96A2            0x12013\n  0x786114      tableBuf[1].size    0x9a6d            0x8E4FB 2016-03-03 - Vendor Notification  \n2016-05-10 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0093');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (531, '7zip UDF CInArchive::ReadFileItem Code Execution Vulnerability', 'None', '2016-5-10', 'An out of bound read vulnerability exists in the CInArchive::ReadFileItem method functionality of 7zip for handling UDF files that can lead to denial of service or code execution. 7-Zip [32] 15.05 beta\n7-Zip [64] 9.20 http://www.7-zip.org/ CInArchive::ReadFileItem method to achieve proper information about file/directory location on particular partition use inter alia the following information:\nPartition Map and Long Allocation Descriptor [2.3.10.1 Long Allocation Descriptor].\nBecause volumes can have more than one partition map their objects are keep in object vector. To start looking for item, method tries to achieve proper partition object\nusing to this mentioned partition maps object vector and \"PartitionRef\" field from Long Allocation Descriptor. Lack of checking whether \"PartitionRef\" field\nis bigger than available amount of partition map objects cause read out of bounds and can lead in some circumstances to arbitrary code execution. Vulnerable code: Vulnerability can be triggered for any entry contains malformed long allocation descriptor but\nin this example we will focus on File set RootDirICB [2.3.2 File Set Descriptor]. As you can see in above code in lines 898-905 search for elements on particular volume and file set starts based on RootDirICB Long Allocation Descriptor\nand that record we will try to malformed for our purpose.\nVulnerability appears in line 392 when PartitionRef field exceed number of elements in ParitionMaps vector.\nLet we check how many PartitionMaps contains our PoC:   As we can see there is 1 Partition map where our PartitionRef field is equal: Vulnerability is obvious, let’s see how it manifests:  First chance exceptions are reported before any exception handling.\n This exception may be expected and handled. At the end, let us see how FileSet RootDirICB entry has been modified. As you can see at offset 00080990 + 8, 0x00 changed to 0xff which we could observe during bug analysis as a value of PartitionRef. 2016-03-03 - Vendor Notification \n2016-05-10 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0094');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (532, 'Libarchive zip zip_read_mac_metadata Code Execution Vulnerability', 'None', '2016-5-1', 'An exploitable heap overflow vulnerability exists in the zip archive decompression functionality of libarchive.\nA specially crafted zip file can cause memory corruption leading to code execution. An attacker can send a malformed file to trigger this vulnerability. libarchive 3.1.2 https://github.com/libarchive/libarchive Vulnerable code exists in zip support format module: Zip file created on Mac OSX can contain also special directory/files called resource fork : https://en.wikipedia.org/wiki/Resource_fork.\nIn line 2750 we see that based on \"uncompressed_size\" field of resource entry is used for allocation of the \"metadata\" buffer. This value is not checked, so a zero sized buffer may be allocated. Later on line 2787, the user controlled \"compressed_size\" field is copied into \"mp\" (\"metadata\") buffer.\nDepending on malloc implementation and heap state, malloc for size 0 will succeed and memory can be written outside the bounds of the undersized buffer.\nAttacker in this scenario can fully control amount and content of bytes used to overwrite. 2016-04-19 - Vendor Disclosure  \n2016-05-01 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0155');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (533, 'Network Time Protocol libntp Message Digest Disclosure Vulnerability', 'None', '2016-4-26', 'An exploitable vulnerability exists in the message authentication functionality of Network Time Protocol libntp. An attacker can send a series of crafted messages to  attempt to recover the message digest key. ntp 4.2.8p4\nNTPSec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 http://www.ntp.org\nhttp://www.ntpsec.org/ CVSSv2: 4.0 - AV:N/AC:H/Au:N/C:P/I:P/A:N\nCVSSv3: 4.8 - AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N The MD5authdecrypt() function in libntp/a_md5encrypt.c is used to verify the authenticity of a received packet that uses keyed-hash symmetric authentication, where the hash algorithm used is specified by an argument passed to the function.This functionality is implemented by comparing a received message digest to one computed by using the input packet and the key pointed to by the input packet\'s key id field. The comparison is performed with memcmp() or the byte specific version bcmp() depending on the NTP version being examined.  Depending on how these functions are implemented, a timing attack might be possible.  Certain memory comparison function implementations return as soon as a mismatch is found between the compared memory to optimize execution time.  As a result, valid memory comparisons will take more time as execution proceeds. If the memory comparison function compares a small number of bytes at a time, then an attacker could brute-force the message digest by guessing values and determining when the comparison function runs for a longer amount of time. bcmp() is especially susceptible to this type of attack because it is a byte-comparison function. Instead, it is recommended that a constant time memory comparison function be used. Specifically, the CRYPTO_memcmp() function that is provided by openssl is the recommended replacement. For more information, please see:\n  https://wiki.openssl.org/index.php/EVP and 2\n  http://rdist.root.org/2010/08/05/optimized-memcmp-leaks-useful-timing-differences/ 2016-02-11 (approx) - CERT reports to NTP  \n2016-04-26 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0084');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (534, 'Network Time Protocol Crypto-NAK Preemptible Association Denial of Service Vulnerability', 'None', '2016-4-26', 'An off-path attacker can cause a preemptible client association to be demobilized by sending a crypto NAK packet to a victim client with a\nspoofed source address of an existing associated peer.  This is true even if authentication is enabled. Furthermore, if the attacker keeps sending crypto NAK packets, for example every one second, the victim never has a chance to reestablish\nthe association and synchronize time with the legitimate server. ntp 4.2.8p3\nntp 4.2.8p4\nNTPSec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 http://www.ntp.org\nhttp://www.ntpsec.org/ The root cause of this defect is an error in ntp_proto.c that causes an association to be demobilized with a call to the unpeer() function\nwhen a crypto-NAK packet is received and FLAG_PREEMPT is set for the peer. The defect occurs when an unauthenticated crypto-NAK packet with the source address of an existing peer with whom the client has a\npreemptible association reaches the following code: Since the packet is a crypto-NAK, and the client has a preemptible association with the peer, is CRYPTO will be true,\nthe FLAG_PREEMPT bit will be set in peer->flags, and the call to unpeer() will occur. The documentation states that preemptible associations are created when the preempt flag is specified with the server command in the NTP\nconfiguration or upon arrival of an automatic server discovery packet. Examination of the code reveals that preemptible associations are created in the following ways: There are two places where broadcast and multicast associations can be created. The first packet from either a broadcast server or multicast server is received, the client is configured as a broadcast or multicast client,\nand sys_bdelay != 0. One example of when this will occur is when a broadcast delay is specified in the configuration. The second case occurs when the first packet from a broadcast or multicast server is received, the client is a broadcast or multicast\nclient, and sys_bdelay == 0. In our virtualized testbed, we were able to cause demobilization of preemptible associations and denial of service in each of these cases. The underlying causes of this defect are similar to those of other recent defects reported by Cisco and Boston University. \nSpecifically, they are similar to those of the the NAK-to-the-Future defect discovered by Matthew Van Gundy and the off-path authenticated\nbroadcast mode denial of service discovered by Aanchal Malhotra. The recommendations are likewise similar: 2016-01-19 - CERT reports to NTP  \n2016-04-26 - Public disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0081');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (535, 'Network Time Protocol Ephemeral Association Time Spoofing Vulnerability', 'None', '2016-4-26', 'ntpd is vulnerable to Sybil attacks.  A malicious authenticated peer\ncan create arbitrarily-many ephemeral associations in order to win\nntpd\'s clock selection algorithm and modify a victim\'s clock. NTP 4.2.8p3\nNTP 4.2.8p4\nNTPsec 3e160db8dc248a0bcb053b56a80167dc742d2b74\nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 http://www.ntp.org\nhttp://www.ntpsec.org CVSSv2: 3.5 - (AV:N/AC:M/Au:S/C:N/I:P/A:N)\nCVSSv3: 5.3 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N ntpd has the ability to create ephemeral peer associations on the fly in response to certain kinds of incoming requests.  In most\ncommon configurations, if an incoming request will cause a new ephemeral association to be mobilized, ntpd requires the request to\nbe authenticated under a trusted symmetric key.  However, ntpd does not enforce any limit on the number of active ephemeral associations\nthat may be created under a single key making ntpd vulnerable to Sybil attacks. A malicious authenticated peer can use its knowledge of the trusted key that it shares with a victim ntpd process in order to create\nmultiple ephemeral associations with the victim from different source IP addresses.  Each of these malicious associations can\nadvertise false time to the victim.  If the malicious associations providing consistent false time advertisements outweigh the number of\nlegitimate peer associations, the victim will sync to the time advertised by the attacker. RFC 5905 does not appear to mandate any specific behavior with regard to authenticating ephemeral associations.  Therefore, we\nrecommend that an incoming request only mobilize an ephemeral association if both of the following conditions hold: To our knowledge, any ntpd instance configured using the \'trustedkey\' directive is vulnerable, as in: There does not appear to be any other configuration directives that would affect or mitigate this vulnerability.  ntpd instances that\nare not configured with the \'trustedkey\' directive are not vulnerable. Though this vulnerability has only been confirmed against specific releases of NTP and NTPsec, any release of ntp-3 or ntp-4 may be\naffected. To illustrate this attack, a malicious authenticated ephemeral peer (attacker1) with knowledge of keyid 2 trusted by ntp-client-4.2.8p4\nwill create multiple malicious ephemeral peer associations with ntp-client-4.2.8p4, overwhelm the victim\'s legitimate time sources,\nand cause ntp-client-4.2.8p4 to modify its clock.  We will illustrate this by querying ntp-client-4.2.8p4 for its active peer associations with: Initially, ntp-client-4.2.8p4 is peered with one legitimate server (ntp-server). As a proof-of-concept, the attacker will attempt to move the victim\'s clock back by an amount just under the panic threshold, 15\nminutes in this case.  (Significantly larger steps have been achieved with some ntpd releases.)  The attacker spins up three attacking nodes at different IP addresses (attacker1..3). After the attacking nodes are well synchronized, the attacker commences the attack by adding the following configuration line to\neach attacking node instructing it to peer with the victim using keyid 2: As a result, we see that ntp-client-4.2.8p4 now has 3 new malicious peers. The attackers consistently provide time advertisements that are about 15 minutes behind the time advertised by the legitimate\nntp-server.  Because the attackers outnumber legitimate peers, eventually the victim selects an attacker as its system peer\nindicating that it will synchronize its time to the attackers. Eventually, the victim steps its clock. After stepping the clock, we see that the victim is 931 seconds behind ntp-server confirming the attack. While ntp-server is initially selected as the system peer after the clock step, the attacking nodes quickly regain their status as\npreferred time sources. At this point, the attacker has control of the victim\'s clock and can continue to make modifications. The most complete mitigation is to upgrade to ntp-TBD or NTPsec TBD. If your system\'s ntpd is packaged by the system vendor, apply your\nvendor\'s security update as soon as it becomes available. Administrators that are not using authenticated NTP can prevent exploitation by removing any unused \'trustedkey\' configuration\ndirectives from their ntpd configuration file. If your system supports a host-based firewall which blocks incoming traffic, such as the Windows Firewall, Mac OS X Application\nFirewall, or firewalls such as Uncomplicated Firewall or iptables on Linux, you should enable it. For other systems, appropriate firewall rules will depend on your environment.  Use the following recommendations as a guideline: In most common configurations, you can use ntpq to query the ntpd process running on your system for its list of peers.  Any\nunexpected peers that are not configured in your ntp.conf file could indicate an attack.  For example, if your system is configured\nto be a client of ntp-server and you expect one peer (known-peer), the appearance of additional peers (sybil) could indicate an attack: You can delete any rogue associations by restarting ntpd after applying the mitigations above. If you have a compatible IDS product, the following Snort rules detect exploits of this vulnerability: TBD. At the network level, multiple symmetric, broadcast, or manycast associations using the same keyid could indicate an attack. 2016-01-19 - CERT reports to NTP', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0083');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (536, 'Network Time Protocol ntpd Reference Clock Impersonation Vulnerability', 'None', '2016-4-26', 'ntpd relies on the underlying operating system to protect it from requests that impersonate reference clocks. Because reference clocks are treated like other peers and stored in the same structure, any packet with a source ip address of a reference clock (127.127.1.1 for example) that reaches the receive() function will match that reference clock\'s peer record and will be treated as a trusted peer. Any system that lacks the typical martian packet filtering [1] which would block these packets is in danger of having its time controlled by an attacker. The read_network_packet() function  in ntp_io.c addresses this issue for IPv6 with Bug 2672, because some OS\'s were known to\nnot block spoofed ::1 addresses. Some, if not all, reference clock drivers set their origin values to zero. It would be trivial to control time on a system with one of these drivers configured if these spoofed packets were not filtered. ntpd should filter IPv4 packets with the address of 127.127.x.x for proactive protection for systems that fail to implement martian packet filtering. [1] https://en.wikipedia.org/wiki/Martian_packet NTP 4.2.8p3  \nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92  http://www.ntp.org/\nhttps://www.ntpsec.org/ CVSSv2: 2.6 - (AV:N/AC:H/Au:N/C:N/I:P/A:N)\nCVSSv3: 3.7 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N Modern Operating Systems already mitigate this vulnerability. For instances where the user can\'t rely on their OS to filter martian packets, they could introduce additional filtering though a firewall. 2016-01-07 - Vulnerability disclosed to CERT \n2016-04-26 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0132');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (537, 'Network Time Protocol Forced Interleaved Time Spoofing Vulnerability', 'None', '2016-4-26', 'It is possible to change the time of an ntpd client or deny service to an ntpd\nclient by forcing it to change from basic client/server mode to interleaved\nsymmetric mode. An attacker can spoof a packet from a legitimate ntpd server\nwith an origin timestamp that matches the peer->dst timestamp recorded for that\nserver. After making this switch, the client will reject all future legitimate\nserver responses. It is possible to force the victim client to move time after\nthe mode has been changed. ntpq gives no indication that the mode has been\nswitched. ntp 4.2.8p4\nNTPSec aa48d001683e5b791a743ec9c575aaf7d867a2b0c http://www.ntp.org\nhttp://www.ntpsec.org/ In basic modes, ntpd attempts to protect against spoofed packets from off-path\nattackers by using the transmit timestamp in each request as a nonce. ntpd notes\nthe time it transmitted its last request in the peer->aorg variable. When a\nlegitimate peer composes a response, the peer will initialize the origin\ntimestamp in the response packet to the value of the transmit timestamp from the\nrequest packet. Any response packet that does not carry the expected origin\ntimestamp should be discarded as bogus. receive() contains the following check for a bogus packet in basic mode: If the incoming packet has an origin timestamp that does not match the origin\nexpected for a basic mode packet (the last client transmit time), there is an\nadditional check that determines if this packet is a valid interleaved mode\npacket This check compares the incoming origin timestamp to peer->dst, the last\ntime the client received a packet from the peer. If they match, the client moves\nto interleaved mode (peer->flip = 1; Only the value of peer->flip changes and\nneither symmetric nor broadcast mode are explicitly enabled, however the change\neffectively places the client in interleaved symmetric mode and will be\ndiscussed as such). This happens even when the client is not configured for\ninterleaved symmetric mode in the ntp.conf file. Once a client has been changed to interleaved mode, all future legitimate server\nresponses are ignored because the server is still in basic mode. The server sets\nthe origin timestamp in outgoing packets to the transmit time of the client\npackets it receives. However, the client, instead of doing the above basic mode\ncheck, verifies the incoming server packet with this code from receive(): The client is expecting the origin timestamp to match peer->dst rather than its\nlast transmit timestamp. This results in all future legitimate server responses\nfailing with TEST2 and TEST3 (marked elsewhere in the receive() function). It should be noted that the client never changes the peer modes stored in the\npeer struct (pmode and hmode). Both continue to be Server (4) and Client (3),\nrespectively. The mode change occurs only through the value of peer->flip.\nAnytime the peer is reset it comes back in basic mode. The peer is reset every\ntime the clock is stepped (via clear_all()), but the legitimate server will\nnever cause the clock to step since the client is rejecting all its packets.\nThe client can only be switched back to basic mode with a restart of ntpd. Obtaining peer->dst: ntpq can be used to retrieve the precise peer->dst time with the following\ncommand: Even if ntpq did not reveal this variable, ntpd\'s current design for switching\nto interleaved mode should be considered vulnerable. If there is ever a weakness\nthat allows an attacker to brute-force peer->dst (e.g. the random fuzz in the\ntimestamp is found to be insufficient to protect against a brute-force attack\nwithin a poll period), the attacker only needs to send one packet to switch the\nmode and DoS the client. UPDATE: Miroslav Lichvar of RedHat has discovered that NTP leaks peer->dst via the NTP packet reftime field. It is possible to set the time on the client after it has changed to interleaved\nsymmetric mode. The attacker must have ongoing access to the current value of\npeer->dst since it is updated each time the victim receives a spoofed packet.\nAgain, ntpq makes this easier but it is not required. The attacker can send spoofed time updates with peer->dst in the origin\ntimestamp field to be considered for clock selection. The spoofed packets must\nset the transmit timestamp (xmt) to this same value in order to minimize delay.\nThe receive timestamp (rec) must be set to the time of peer->dst when the last\nlegitimate server packet was received to approximate what value aorg or borg\nwill be when process xmit() right after the client sends out a\npacket to the server. They are used alternately depending on the value of flip,\nwhich alternates between 1 and -1 every time a poll update is sent. The delay\nand offset are calculated as: The attacker can control rec and xmt. The attacker can gain access to peer->dst\nthrough ntpq or by guessing at the delay. But the attacker has no insight into\naorg or borg. Both values are sent out alternately in the transmit timestamp\nfield in client packets. But the value sent out is always the last one used,\nnever the one that is about to be used. To keep delay between 0 and 1 seconds\nand win the clock selection, the attacker must estimate a time for aorg or borg\nthat is within a second of the real values. On modern networks with low delay,\nif the attacker uses peer->dst time (the time the client received a response to\nthat request) as an estimate, it will generally fall within a second of aorg or\nborg, the time the packet was sent. If normal delay in a certain network is\nusually larger, and if it is within a predictable range, the attacker could\nfudge for that time by adjusting the receive timestamp. Since the peer will be reset to basic mode after stepping the clock, the\nattacker must send one more packet with peer->dst as the origin timestamp to\npivot the client back to interleaved mode. Once this is done, the attacker does\nnot need to send any more packets to maintain the incorrect time since no\nlegitimate server packets will be processed. The client will continue to move\nforward in time from the incorrect time the attacker provided. If the attacker\nwants to change the time further, the client will continue to process spoofed\npackets as long as the attacker continues to correctly set the origin timestamp. Ideally, a basic mode client would not move to interleaved mode unless it was\nexplicitly configured to do so. If a dynamic mode transition is required, the\nclient needs a way to detect that the legitimate server it is talking to is in\nbasic mode allowing the client to change back to basic mode without requiring a\nclock step to occur first. Additionally, the peer->dst value should be treated\nas sensitive and ntpq should not have access it. On Nov 12, 2015, Cisco ASIG received notification that Miroslav\nLichvar of RedHat had independently discovered and reported this\nvulnerability to the NTP project. ASIG\'s initial analysis indicated that, with access to ntpq, this\nvulnerability allows time spoofing.  To our knowledge, Miroslav\'s\ninitial analysis indicated that this vulnerability was an off-path\ndenial of service.  It appears that the attacks can be combined to\nallow time spoofing by an off-path attacker without access to ntpq. The only mitigation is to upgrade to ntp-4.2.8p. ntp-4.2.8p fixes\na number of other critical issues in addition to this vulnerability. If your\nsystem’s ntpd is packaged by the system vendor, apply your vendor’s security\nupdate as soon as it becomes available. There are no other mitigations to prevent an ntpd client from changing to\ninterleaved mode when the origin timestamp matches the peer->dst timestamp.\nDisabling ntpq access will make it more difficult, though not impossible, for an\nattacker to determine the peer->dst timestamp. ntpq can be disabled via\nrestrict configuration directives as in: 2015-10-30 - Initial Discovery by Cisco ASIG, analysis begins  \n2015-11-12 - Reported to NTP project by Miroslav Lichvar of RedHat after independent discovery  \n2015-11-12 - Miroslav Lichvar of RedHat notifies Cisco ASIG of independent discovery  \n2015-11-16 - Disclosure to CERT  \n2016-01-19 - CERT reports to NTP', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0082');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (538, 'Oracle IOT IX SDK libvs_pdf XRef Index Code Execution Vulnerability', 'None', '2016-4-19', 'A vulnerability in PDF parser of the IX SDK exists that allows an\nout of bounds heap memory overwrite potentially leading to remote\ncode execution. Outside In IX sdk 8.5.1. http://www.oracle.com/technetwork/middleware/content-management/oit-all-085236.html While parsing a PDF file which contains an object of type XRef, values from /Index entry are used when handling the decoded stream.\nA malformed PDF file with many objects specified by /Index entry can lead to memory overwrite past the ends of the allocated buffer\noverwriting adjacent heap chunks. Technical information below:\nThe vulnerability is located in sub pdf.so (image base is at 0xB74BF000). A heap structure is being iterated over\nin 16 byte increments starting at the following code: In this code excerpt, initial pointer to the structure being iterated over is derived from   into   at [1]. At [2], [3] and [4] depending on\nthe branch taken, different values are written at memory address pointed to by   with an offset. At [5],   is incremented and  at [6] execution jumps back to the begining of the loop. The number of times the loop is executed is bounded by number of objects specified in the /Index entry. An abbrevIated version of the crashing testcase: In this sample PDF file, /Size of 6 is specified but /Index states that object stream contains references to 20 objects starting from object\nnumber 40. The supplied minimized testcase triggers the vulnerability and results in heap corruption and a function pointer overwrite. This function pointer is later dereferenced resulting in a direct program counter control. The vulnerability can be triggered by the   program supplied with the SDK. 2016-02-09 - Vendor Notification  \n2016-04-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0086');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (539, 'Lhasa lha decode_level3_header Heap Corruption Vulnerability', 'None', '2016-3-31', 'An exploitable integer underflow exists during calculation size for all headers in decode header function of Lhasa (lha) application.\nSmaller value of header 3 LEN  ( 32 ) cause during subtraction integer underflow and lead later to memory corruption via heap based buffer overflow. Lhasa v0.3.0 command line LHA tool  - Copyright (C) 2011,2012 Simon Howard \nLhasa v0.0.7 command line LHA tool  - Copyright (C) 2011,2012 Simon Howard https://github.com/fragglet/lhasa Code analysis: header 3 HEADER len values smaller than LEVEL HEADER len values in range <0;32) result of this subtraction from line 789 will be close to UINT_MAX. Next we land inside : Here the result of mentioned above subtraction is of course nbytes argument. First problem starts in Line 357, when header raw_len will equal 0 and realloc instead of increase “header” memory area going to decrees its size. In consequences “result” pointer will point on released memory. Heap based buffer overflow appears in Line 371 where to “result” buffer is readed “nbytes” (~UINT_MAX) directly from file. Attacker controlling length and content of file can fully controllable overwrite heap with specified content. File format based on attached PoC: Lets see this in gdb: 2016-02-16 - Vendor Notification\n2016-03-31 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0095');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (540, 'Apple OS X Gen6Accelerator IOGen575Shared::new_texture Local Privilege Escalation Vulnerability', 'None', '2016-3-22', 'A vulnerability exists in the communication functionality of the Apple Intel HD 3000 Graphics kernel driver. A specially crafted message can cause a vulnerability resulting in local privilege escalation. Apple OSX Intel HD 3000 Graphics driver 10.0.0 - com.apple.driver.AppleIntelHD3000Graphics (10.0.0) D3CFD566-1AE5-3315-B91B-B8264A621EB5 <78 12 7 5 4 3 1> This vulnerability can be triggered by sending specially crafted IOConnectCallMethod request to the AppleIntelHD3000Graphics driver. Faulting code is located in the AppleIntelHD3000Graphics driver in the IOGen575Shared::new_texture function. The vulnerability is caused by instruction at address 0x1AA2F which references memory that is\ncurrently not available since RDX register points to zero. This vulnerability can lead to local privilege\nescalation since NULL page can be allocated on OSX systems. Attacker can forge the input data and force the\nsystem to execute instruction at 0x1AA68 which is a call pointer instruction. Where pointer data is completely\ncontrolled by attacker. We have successfully exploited this vulnerability on OS X 10.11. 2016-02-02 - Vendor Disclosure  \n2016-03-22 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0088');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (541, 'Trane ComfortLink II SCC Service Hardcoded Credentials Vulnerability', 'None', '2016-2-8', 'A design flaw in the Trane ComfortLink II SCC service allows remote attackers to take complete control of the system. During system boot the SCC service installs two sets of user credentials with hardcoded passwords. These credentials can be used to remotely access the system over SSH and to locally gain root privileges. Trane ComfortLink II - firmware version 2.0.2 http://www.trane.com/residential/products/thermostats-and-controls/comfortlink%E2%84%A2%20ii-thermostats-and-controls The following user credentials are set during system initialization: 2014-04-09 - Initial contact with Trane is established. Advisories delivered. \n2014-06-03 - Second attempt to contact Trane for follow up. No response received.  \n2014-08-15 - Third attempt to made to contact Trane for follow up. No response received.  \n2014-09-30 - Fourth attempt to contact Trane is made. Advisories re-sent. No further correspondence.  \n2015-05-26 - CERT/CC notified. CERT attempts to establish contact with Trane, but receives no response.  \n2015-07-13 - Fifth and final attempt to contact Trane is made. Communication is reestablished. Advisories re-sent.  \n2015-08-19 - Talos follows up with Trane. No patch available.  \n2015-09-30 - Talos follows up with Trane again. No patch available.  \n2015-10-19 - Talos follows up with Trane again. No patch available.  \n2016-01-26 - Talos follows up with Trane again. Trane informs Talos that firmware version 4.0.3 is being released that week which addresses TALOS-2015-028.  \n2016-01-27 - Trane makes firmware version 4.0.3 available to the public.  \n2016-02-08 - Talos and CERT/CC disclose these vulnerabilities.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0028');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (542, 'Trane Comfortlink II DSS Service REG Handling Remote Code Execution Vulnerability', 'None', '2016-2-8', 'An exploitable remote code execution vulnerability exists in the Trane ComfortLink II DSS service. An attacker who can connect to the DSS service on the Trane ComfortLink II device can send an overly long REG request that can overflow a fixed size stack buffer, resulting in arbitrary code execution. Trane ComfortLink II - firmware version 2.0.2 http://www.trane.com/residential/products/thermostats-and-controls/comfortlink%E2%84%A2%20ii-thermostats-and-controls The crash below is in the reg command parsing functionality of the DSS service: Below is a decompiled representation of the iHer_discRegPutEntry function: We can see there is useage of an unsafe call to strcpy that does not verify the sizes of the source and destination buffer. An overly long user input results in a buffer overflow on the stack. The following Metasploit module will demonstrate remote code execution due to the vulnerability: 2014-04-09 - Initial contact with Trane is established. Advisories delivered.  \n2014-06-03 - Second attempt to contact Trane for follow up. No response received.  \n2014-08-15 - Third attempt to made to contact Trane for follow up. No response received.  \n2014-09-30 - Fourth attempt to contact Trane is made. Advisories re-sent. No further correspondence.  \n2015-05-26 - CERT/CC notified. CERT attempts to establish contact with Trane, but receives no response.  \n2015-07-13 - Fifth and final attempt to contact Trane is made. Communication is reestablished. Advisories re-sent.  \n2015-08-19 - Talos follows up with Trane. No patch available.  \n2015-09-30 - Talos follows up with Trane again. No patch available.  \n2015-10-19 - Talos follows up with Trane again. No patch available.  \n2016-01-26 - Talos follows up with Trane again. Trane informs Talos that firmware version 4.0.3 is being released that week which addresses TALOS-2015-028.  \n2016-01-27 - Trane makes firmware version 4.0.3 available to the public.  \n2016-02-08 - Talos and CERT/CC disclose these vulnerabilities.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0027');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (543, 'Trane Comfortlink II DSS Service Request Handling Remote Code Execution Vulnerability', 'None', '2016-2-8', 'An exploitable remote code execution vulnerability exists in the Trane ComfortLink II DSS service. An attacker who can connect to the DSS service on the Trane ComfortLink II device can send an overly long request that can overflow a fixed size stack buffer, resulting in arbitrary code execution. Trane ComfortLink II - firmware version 2.0.2 http://www.trane.com/residential/products/thermostats-and-controls/comfortlink%E2%84%A2%20ii-thermostats-and-controls The crash below is in the request parsing functionality of the DSS service: The below code is a partially decompiled representation of the iHer_discProParseRequest function: We can see here there is usage of sscanf which is an unsafe function that performs an unbounded copy of user input into a fixed size stack buffer, resulting in a buffer overflow. 2014-04-09 - Initial contact with Trane is established. Advisories delivered.  \n2014-06-03 - Second attempt to contact Trane for follow up. No response received.  \n2014-08-15 - Third attempt to made to contact Trane for follow up. No response received.  \n2014-09-30 - Fourth attempt to contact Trane is made. Advisories re-sent. No further correspondence.  \n2015-05-26 - CERT/CC notified. CERT attempts to establish contact with Trans, but received no response.\n2015-07-13 - Fifth and final attempt to contact Trane is made. Communication is reestablished and advisories re-sent.  \n2015-08-19 - Talos follows up with Trane. No patch available.  \n2015-09-30 - Talos follows up with Trane again. No patch available.  \n2015-10-19 - Talos follows up with Trane again. No patch available.  \n2016-01-26 - Talos follows up with Trane again. Trane informs Talos that firmware version 4.0.3 is being released that week which addressesTALOS-2015-028.  \n2016-01-27 - Trane makes firmware version 4.0.3 available to the public.  \n2016-02-08 - Talos and CERT/CC disclose these vulnerabilities.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0026');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (544, 'Libgraphite Bidirectional Font BracketPairStack Code Execution Vulnerability', 'None', '2016-2-5', 'An exploitable out-of-bounds access vulnerability exists in the bidirectional font handling\nfunctionality of Libgraphite. A specially crafted font can cause an out-of-bounds access\nresulting in arbitrary code execution. An attacker can provide a malicious font to trigger\nthis vulnerability. Libgraphite 2-1.2.4 In Segment.cpp at line 469 in the function Segment::bidiPass, the variable ssize is\ninitialized to 0 at line 455 and will increase in size depending on attributes that\nare read from the font at lines 456-466. However if those attributes aren’t set, then\nssize will remain 0 when a new BracketPairStack is allocated at line 469. This will cause the constructor of BracketPairStack to call grzeroallocsize with the\nsize provided to allocate the stack. This in turns calls calloc with the size of the\nBracketPair object and the provided size. On a 64-bit machine, this will result in\ncalloc(0,48). This will result in the smallest size chunk being allocated and\nzeroed-out. On a 64-bit machine that is 32-bytes. Since the resulting stack is expected\nto be at least 48 bytes, an out-of-bounds access on the heap memory will occur when\ntrying to use BrackPairStack’s stack. When the stack is used, BracketPairs will be read from the stack and will be walked\nusing their next pointer until a NULL pointer is reached. An example of this can be\nseen at line at line 574 in the function ProcessParens in the file Bidi.cpp: In the case of the sample provided here, the next pointer is corrupted because it\nhasn’t been initialized to 0, because it is read from outside the bounds of the\nBracketPairStack object. If an attacker controls the memory behind the BracketPairStack,\nthis can result in arbitrary code execution. The malicious font provided here can be used to generate the problem by using the ‘simple’\ntest program provided with libgraphite and the parameter ‘test’: ./simple maliciousfont test', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0057');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (545, 'Libgraphite Context Item Code Execution Vulnerability', 'None', '2016-2-5', 'An exploitable heap-based buffer overflow exists in the context item handling functionality\nof Libgraphite. A specially crafted font can cause a buffer overflow resulting in potential\ncode execution. An attacker can provide a malicious font to trigger this vulnerability. Libgraphite 2-1.2.4 If a malicious font is provided then an arbitrary length buffer overflow can occur when handling context items. In Code.cpp at lines 158-161, memory is allocated for  data to be the expected maximum size of the\ncode and data loaded from the bytecode. However, the actual size read from the file can be larger than the\nexpected size. At line 181 the function dec.load() is called with pointers to the beginning and end of the bytecode. This\nfunction, at lines 230-240, will then load opcodes from the bytecode until the end of the bytecode is reached.\nIt will call emitopcode() at line 238 with the current value of the bytecode that is being handled. If the opcode being handled by emitopcode refers to a context item (CNTXTITEM). Then the load function will\nbe called recursively at line 500, with a new bytecodeend that is specified by the bytecode in instrskip. The size checks to ensure that data isn’t read from outside of the buffer, occur in the validateopcode\nfunction at line 548 where it is checked that the new opcode being read will be less than _max.bytecode\n(which contains the value of bytecodeend). However, when recursively handling multiple CNTXTITEMs, this means that while data is being copied to _data,\nit can be read past the new bytecodeend that is specified by the recursive call to load, this will terminate\nthe loop once it reaches there, but in the mean time more data can be read than specified by instrskip,\nbecause when validateopcode is called, the current value of bytecode will still be lower than the end of\nthe bytecode. Doing this multiple times, results in the same memory being handled multiple times and\nallowing data to become larger than bytecode allowing an out-of-bounds write. The same can occur with the\ncode buffer. A proposed fix is to ensure that when returning from a CNTXTITEM, the current value of bytecode\nminus the begin value of bytecode is larger or equal to datasize and instrcount. A similar check to what is\nperformed via an assert at lines 210 and 211. The attached sample causes the overflow, in this case it will be cause an invalid size on the heap due to\nthe buffer overflow overwriting the size field in the adjacent chunk. When realloc is called at line 213\nto (normally) lower the size of the code and data buffers, the invalid size is detected.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0059');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (546, 'Libgraphite directrun Opcode Handling Code Execution Vulnerability', 'None', '2016-2-5', 'An exploitable out-of-bounds read vulnerability exists in the opcode handling functionality of\nLibgraphite. A specially crafted font can cause an out-of-bounds read resulting in arbitrary\ncode execution. An attacker can provide a malicious font to trigger this vulnerability. Libgraphite 2-1.2.4 If a malicious font is provided, an out of bounds read can occur while interpreting the opcodes\nin a font. The problem occurs when executing the various opcodes in the function directrun in the file\ndirectmachine.cpp. At line 85, the interpreter for the opcodes will be executed by performing\na goto instruction. If the opcode in particular is a cntxt_item, then ip variable will be advanced by iskip bytes\nto find the next opcode and continue interpreting the opcodes. This is done at line 369 of\nopcodes.h. However there are no checks to ensure that ip remains within the bounds of the memory allocated\nfor the memory to be interpreted (the program variable). In the case of the malicious font\nprovided here, the value of iskip will be 55, resulting in an out-of-bound read when the program\nperforms a jump to **ip. This memory is memory that was previously allocated for data. This\nallows an attacker to potentially execute arbitrary code. The malicious font provided here can be used to generate the problem by using the ‘simple’\ntest program provided with libgraphite and the parameter ‘test’: ./simple maliciousfont test', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0058');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (547, 'Libgraphite Bidirectional Font mFeatureMap Denial of Service Vulnerability', 'None', '2016-2-5', 'An exploitable NULL pointer dereference exists in the bidirectional font handling functionality\nof Libgraphite. A specially crafted font can cause a NULL pointer dereference resulting in a crash.\nAn attacker can provide a malicious font to trigger this vulnerability. Libgraphite 2-1.2.4 The attached font will generate a NULL pointer dereference when used. When the font is loaded via grmakefile_face, the function readFeats will be called at line 190\nin the file FeatureMap.cpp in the function SillMap::readFace. At line 110, in the function readFeats, mnumFeats will be assigned the value 0. This results in a\nreturn from the readFeats function at line 115. However the return will return the value true. This\nresults in none of the variables in mFeatureMap being initialized even though the font will load\nwithout any errors being returned. If the function grmakeseg is later called on this font, the call\nto SillMap::cloneFeatures will fail at line 241 because it tries to dereference mFeatureMap.mdefaultFeatures,\nwhich is set to 0. A similar error can occur at line 103 in the same function if the constructor for Table fails.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0060');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (548, 'Libgraphite LocaLookup Denial of Service Vulnerability', 'None', '2016-2-5', 'An exploitable denial of service vulnerability exists in the font handling of Libgraphite.\nA specially crafted font can cause an out-of-bounds read potentially resulting in an\ninformation leak or denial of service. An attacker can provide a malicious font to\ntrigger this vulnerability. Libgraphite 2-1.2.4 When reading an invalid font where the loca table size is set to 0 an out of bounds read will occur. At line 187 in GlyphCache.cpp, the function Loader is defined which loads a number of tables from the\nfont, including the loca table. At line 206 it will then call the function TtfUtil:LocaLookup with\narguments that provide the number of glyphs, the local table and its size: At line 1164 in this function (in file TtfUtil.cpp), the loca table will be accessed using the number of glyphs: A size check is performed at line 1161, but since the size is set to 0, this will always pass. This will read out of the bounds of the table by an arbitrary 16-byte number, which will cause a denial\nof service and could potentially lead to an information leak. The malicious font provided here can be used to generate the problem by using the ‘simple’ test program\nprovided with libgraphite and the parameter ‘test’: ./simple maliciousfont test', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0061');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (549, 'Matroska libebml EbmlUnicodeString Heap Information Leak', 'None', '2016-1-28', 'A specially crafted unicode string can cause an off-by-few read on the heap\nin unicode string parsing code in libebml. This issue can potentialy\nbe used for information leaks. http://matroska.org An off-by-few read on heap occurs when parsing unicode strings in\n . String is parsed\nin a for loop but in case of a four byte character, no check is made\nif the last bytes accessed fall outside the allocated buffer: Technical information below: Vulnerable code is located in  :   for (j=0, i=0; i<UTF8string.length(); j++) {   } If the last byte in the string being parsed satisfies the\n  condition, for example 0xf2, 3 bytes\n past the end of the buffer will be read thereby causing a out of\n bounds read on the heap.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0036');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (550, 'Matroska Media Container libmatroska Multiple ElementList Double Free Vulnerabilities', 'None', '2016-1-28', 'A use after free/double free vulnerability can occur in libmatroska while parsing\n  elements of the MKV container. http://matroska.org In a specially crafted file,   element is being added to ElementList of both  \nelement and   element which causes a double free when when   and\n  objects are beeing freed. Technical information below: Parsing of   elements creates object dependencies in a following way:\n  +---------------+                        \n  |  Tracks       |                        \n  |               |                        \n  ++---+----------+                        \n   |   |                                   \n   |   |        +----------------+         \n   |   |        |                |         \n   |   +-------->   Track Entry  |         \n   |            |                |         \n   |            +--+-------------+         \n   |               |                       \n   |               |     +----------------+\n   |               |     |                |\n   |               +----->   Track Video  |\n   +--------------------->                | Later in the code, each element of \"Tracks\" is being\nfreed by calling their respective destructor.\n\"Track Entry\" destructor in turn frees all it\'s elements\nthus freeing \"Track Video\" element which the loop in\n\"Tracks\" element tries to free again causing the crash. The initial freeing is triggered in EbmlMaster::Read: This delete in turn triggers the EbmlMaster destructor: EbmlMaster::~EbmlMaster()\n{\n  assert(!IsLocked()); // you\'re trying to delete a locked element !!!   size_t Index;   for (Index = 0; Index < ElementList.size(); Index++) {   }\n} Similar issue is present in relation to parsing  \nelement which gets added to subelemet lists of both   and  \nelements. Similar issue is present in relation to parsing  \nelement which gets added to subelemet lists of both   and  \nelements.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0037');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (551, 'Network Time Protocol Private Mode \'reslist\' NULL Pointer Dereference Vulnerability', 'None', '2016-1-19', 'An unauthenticated ntpdc reslist command can cause a segmentation\nfault in ntpd by causing a NULL pointer dereference. The following conditions must be met:\n  1. Mode 7 must be enabled.  By default, mode 7 is disabled.\n  2. A large enough number of entries must exist in the restrict list The ntpdc reslist command is used to query the restrictions currently\nenforced by ntpd.  If the number of restrictions is too large to fit\ninto a single packet, the results will be split across a sequence of\npackets.  The reslist command does not require authentication. The functions that return the results (list restrict6()) do not correctly handle the case where the number of\npackets required is greater than the maximum value of the response\npacket sequence number resulting in a NULL pointer dereference. In the event that seqno is equal to MAXSEQ and more_pkt() returns NULL\nthe return value should be checked and ntpd should fail gracefully. The root cause of the crash is a segmentation violation caused by a\nNULL pointer dereference in list restrict6(). The IPv4 and IPv6 restriction lists are kept sorted in reverse order.\nTo correctly display the output, the functions list restrict6() traverse the list recursively and dump the lists in\nreverse. After recursing to the end of the list, the value pointed to by ppir\nis assigned the result of more pkt(), if databytes\n+ itemsize > RESP SIZE and seqno == MAXSEQ then NULL is returned\nand assigned to  ppir and\ndereferenced, resulting in a segmentation violation. An attacker that can increase the size of the restrict list on a\nserver with request mode enabled can crash ntpd.  The attacker might\nbe able to increase the number of restrictions dynamically via\nthe \"restrict source\" mechanism. Additionally, an authenticated user\ncan add restrict lines to the configuration with mode 6 if it is\nenabled. Check the return value of more pkt() function is used in several places, and\nthe value should be checked at each invocation. ntp 4.2.8p3 \nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 \n CVSSv2: 5.4 - AV:N/AC:H/Au:N/C:N/I:N/A:C \nCVSSv3: 5.9 - AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H 2015-10-07 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0074');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (552, 'Network Time Protocol Private Mode \'reslist\' Stack Memory Exhaustion Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 An unauthenticated ntpdc reslist command can cause a segmentation\nfault in ntpd by exhausting the call stack. The following conditions must be met: The ntpdc reslist command is used to query the restrictions currently\nenforced by ntpd. If the number of restrictions is too large, enough\nfunction calls to list restric6() will occur to\nexhaust the space on the call stack. The reslist command does not\nrequire authentication. The ntpd process should be able to traverse any number of entries in\nthe restrict list without exhausting the call stack. The IPv4 and IPv6 restriction lists are kept sorted in reverse order.\nTo correctly display the output, the functions list restrict6() traverse the list recursively and dump the lists in\nreverse. If enough entries exist in the restrict list, the recursion\nwill eventually exhaust the available space on the call stack.   An attacker that can increase the size of the restrict list on a\n  server with request mode enabled can crash ntpd. The attacker might be\n  able to increase the number of restrictions dynamically via the\n  \"restrict source\" mechanism.  Additionally, an authenticated user can\n  add restrict lines to the configuration with mode 6 if it is enabled.   Use iteration to traverse the restrict list or terminate the recursion\n  after some number of entries have been processed. ntp 4.2.8p3 \nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 \n CVSSv2: 5.4 - AV:N/AC:H/Au:N/C:N/I:N/A:C \nCVSSv3: 5.9 - AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H 2015-10-07 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0075');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (553, 'Network Time Protocol Skeleton Key: Symmetric Authentication Impersonation Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 Symmetric key encryption requires a single trusted key to be specified for\neach server configuration. A key specified only for one server should only work\nto authenticate that server, other trusted keys should be refused. Instead we observe that when symmetric key authentication is verified, there is\nno check that the key used is the key specified for the address, any trusted key\ncan be used as long as the keyid references another key the systems share and\nthat key is used to compute the MAC. This has three implications for the client server model. A client that has multiple\nservers configured each with different keys could be attacked by one of its servers\nspoofing every other server using its own key. Even worse a server can be attacked\nby any of its authenticated clients in a similar manner. Finally, being able to use any key to authenticate a packet for a client or server\nmeans that if any key in the trustedkeys list uses a  weak digest algorithim (MD5),\nthen an attacker can abuse that method instead of being restricted by the stronger\nkeys configured. NOTE: Code locations referenced below refer to the NTP reference\nimplementation from http://www.ntp.org. There is no clear location in the code where this defect occurs, since it exists\ndue to an omission. Verifying the key used matches the proper server\'s key could be\ndone in ntp_proto.c around line 803 (in 4.8.2p3) where authdecrypt is called, or\nit might make sense to build it into the libntp code such as the authdecrypt\nfunction itself. Be aware that this issue could affect other ntpd modes of operation such as\nbroadcast or active/passive peering. NTP 4.2.8p3 \nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 \nchrony 2.2 (http://www.ntp.org/)[http://www.ntp.org/]\n(https://www.ntpsec.org/)[https://www.ntpsec.org/]\n(http://chrony.tuxfamily.org/)[http://chrony.tuxfamily.org/] CVSSv2: 3.6 - AV:N/AC:H/Au:S/C:N/I:P/A:P \nCVSSv3: 4.2 - CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:L ntpd does not ensure that the key used to verify the authenticity of a\npacket actually belongs to the alleged sender of the packet. The intended binding between keys (via keyids) and peers is indicated\nto ntpd through the configuration file.  For example: indicates that keyid 1 is a symmetric key shared with ntp-server.\nPackets bound for ntp-server should be authenticated under keyid 1\nand, to prevent impersonation, packets from ntp-server should be\nauthenticated using keyid 1. Unfortunately, when receiving a packet, allegedly from ntp-sever, ntpd\ndoes not require the packet to authenticate under keyid 1.  ntpd only\nensures that the packet authenticates under   trustedkey known to\nntpd.  This allows any authenticated peer to impersonate any other\nauthenticated peer. We confirmed this vulnerability with the following setup.  (The tests\nbelow were performed with NTP 4.2.8p3.  4.2.8p4 appears to introduce\nregressions which break LOCAL refclocks and symmetric associations.) According to the ntpd documentation  : Though it doesn\'t indicate precisely what \"agreement\" means or why,\nthis conflicts with RFC 5905 which states: This statement is problematic and only partially true.  It is\nproblematic because it does not address the binding of symmetric keys\n(specified by keyid) to the peers that they authenticate, allowing for\nimpersonation between peers.  It is only partially true because, in\nclient-server modes, the server will use the keyid from the client\nmode packet to authenticate the incoming client mode packet as well as\nthe outgoing server mode packet.  Thus, in a benign scenario, clients\nand server must agree both on keyid and the key value.  In symmetric\nmodes, the statement is partially true because each peer uses the\nkeyid specified in its peer association when generating an outgoing\npacket.  However, in all cases, the keyid specified in an incoming\npacket will be used to authenticate that packet.  Therefore, even in\nsymmetric modes, if the two peers use different keyids A and B for a\ngiven symmetric association, each peer must map   keyids to the\nsame key --- the sender will use A (respectively B) to generate the\nauthenticator for the outgoing packet and, therefore, the recipient\nwill use A (respectively B) to authenticate the incoming packet.  This\nis illustrated by the non-normative example code from RFC 5905: This is also borne out by the ntpd source code.  When ntpd receives an\nincoming packet with an authenticator, it verifies the authentication\nunder the key specified by the keyid from the incoming packet: To verify that the sender and recipient can\'t merely use different\nkeyids to refer to the same key material unless   have been\nconfigured to map   keyids to the same key, we configured\nntp-client2 with the same keys as ntp-server and ntp-client, but we\nswapped the keyids on ntp-client2.  This confirmed that, though\nntp-client2 was using the same key material as the other two nodes, all\npackets from ntp-client2 would fail authentication because the other\nnodes did not also have the same key material mapped to the keyids\nsent by ntp-client2. This tests confirms that, as long as the sender and the recipient have\nthe same key material configured for a given keyid, the recipient\nwon\'t enforce the binding between the keyid configured for an\nassociation and the keyid used to authenticate an incoming packet\nunder that association. We configure the same keys on both hosts But ntp-client uses keyid 2 to communicate with ntp-client2. And ntp-client2 uses keyid 1 when sending packets to ntp-client. As can be seen here, both ntp-client and ntp-client2 accept the\npackets from their peer despite being configured to use different\nkeyids. The following (untested) patch ensures that the keyid used to\nauthenticate the packet is the same as the keyid configured for the\ncorresponding peer association.  If not, it sets   to\n  and skips the call to  . 2015-10-07 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0071');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (554, 'Network Time Protocol Deja Vu: Broadcast Mode Replay Vulnerability', 'None', '2016-1-19', 'Expected Behavior: RFC 5905 page 29 Section 8 states that the\non-wire protocol resists replay of server response packet in broadcast\nmode. Also on page 55 section 15, the RFC claims security in\nauthenticated mode against on-path attackers where an attacker can: a) Intercept and archive packets forever b) In a wiretap attack, intercept, modify and replay a packet. c) In a middleman attack or masquerade attack, intercept, modify\n  and replay a packet and prevent onward transmission of the\n  original packet. The expected behavior in authenticated broadcast mode MUST then at the\nleast prevent against an on-path replay attack. Actual Behavior: a) In a middleman attack, where the intruder is positioned between\n  the server and the client and can intercept, and replay a\n  packet and prevent onward transmission of the original packet,\n  the protocol does not resist the replay attack. b) Also if the attacker is one of the machines on the network or\n  adjacent network who also gets broadcast packets from the same\n  NTP server and has the same trusted keys as the victim, then he\n  can simply replay the packets that he receives from the broadcast server. Implications of the attack: Man-in-the-middle or a malicious client\non the same/adjacent subnet can replay broadcast server packets and\nmake the victim client’s machine be stuck at a particular time value\nforever. Having time  back in the past has severe implications on\nvarious applications. Note: Be aware that this issue could affect other ntpd modes of operation such as\nmulticast. ntp 4.2.8p3 \nNTPSec aa48d001683e5b791a743ec9c575aaf7d867a2b0c (http://www.ntp.org)[http://www.ntp.org] \n(http://www.ntpsec.org/)[http://www.ntpsec.org/] CVSSv2: 4.3 - AV:A/AC:M/Au:N/C:N/I:P/A:P \nCVSSv3: 4.2 - CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:L Testbed Configuration for NTP: a) We have a broadcast server and broadcast client. b) The broadcast server is a stratum 1 server. Its refid is\n.LOCL. The following lines are added to the ntp.conf file for\nbroadcast server. We also create a key file ntp_key where all the keys are listed\nin /etc/ntp directory: c) The broadcast client is configured only as a broadcast client\nand does not have any other associations. Following lines are\nadded to the ntp.conf on the client: We also create a key file ntp_key where all the keys are listed\nin /etc/ntp directory: Testbed Configuration for NTPSec: a) We have a broadcast server and broadcast client. b) The broadcast server is a stratum 4 server. Its refid is\n192.168.33.9. The following lines are added to the ntp.conf file for\nbroadcast server. We also create a key file ntp_key where all the keys are listed\nin /etc/ntp directory: c) The broadcast client is configured only as a broadcast client\nand does not have any other associations. Following lines are\nadded to the ntp.conf on the client: We also create a key file ntp_key where all the keys are listed\nin /etc/ntp directory: The major problem here is that there is no origin timestamp check on\nthe broadcast packets as origin timestamp is set to null in the\nbroadcast server packets. There are a couple of recommendations that\nmight be effective: a) The broadcast server packet may include an incrementing counter\nvalue in the extensions field. The client should maintain state\nfor this value in the previous packet and check if this counter\nvalue in the current packet is greater than that of the previous\npacket. This simple check can prevent the replay of the old packets. b) There could be some way for NTP to see if it is stuck at the\nsame timestamp for a considerable amount of time and should log\nan error or do something to warn the admin. 2015-10-07 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0070');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (555, 'Network Time Protocol ntpq Special Character Filtering Vulnerability', 'None', '2016-1-19', 'The ntpq saveconfig command does not do adequate filtering of special\ncharacters from the supplied filename.  Only back slash and forward\nslash are currently filtered out.  There are other special characters\nthat are allowed in the filename which can cause issues during\nglobbing. In addition to special characters that are passed straight through to\nthe filename, strftime() is called on format specifiers defined by the\nntpq user.  The %n and %t format specifiers insert a newline and a\ntab, respectively, into the filename.  These could have unintended\nconsequences during globbing as well. Note that the ntpq user is required to authenticate to run this\ncommand. ntp 4.2.8p3 \nNTPsec aa48d001683e5b791a743ec9c575aaf7d867a2b0c \n CVSSv2: 3.6 - AV:N/AC:H/Au:S/C:N/I:P/A:P \nCVSSv3: 4.4 - CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:C/C:N/I:L/A:L For instance, dash can be the first character in a filename.  So if\nthe ntpq user saves the config to a file named \"-rf\", an admin on the\nntp server could run \"rm  \" after globbing.  This is an extreme\nand unlikely example, but there are any number of similar issues that\ncould occur with commands an admin would likely run with wildcards\nfrom the config directory. The save control.c should filter out special\ncharacters with the exception of a small number that normally get used\nin filenames:  ._-  (dot, underscore, and dash).  Filenames should\nnot be allowed to start with these special characters.  Also, the %n\nand %t format specifiers should be disallowed to avoid whitespace in a\nfilename.  A more conservative approach would be to completely remove\nthe call to strftime() in case there are other vulnerabilities with\nstrftime() that could be exploited by an ntpq user. 2015-10-07 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0073');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (556, 'Network Time Protocol Authenticated Preemptable Modes Denial-of-Service Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 The protocol should prevent against off-path Denial of\nService attacks in authenticated broadcast and other modes\nwhich create preemptable associations, such as: multicast\nclient, manycast client, pool client modes, and associations\nconfigured with the \"preempt\" option. An off-path attacker can send broadcast packets with bad\nauthentication (wrong key, mismatched key, incorrect MAC, etc)\nto broadcast clients. It is observed that the broadcast client tears\ndown the association with the broadcast server upon receiving just\none bad packet. If an attacker keeps sending “bad” authenticated packets\nfrequently, then the broadcast client can never sync with the real\nbroadcast server (because of lack of sufficient number of good samples.) This vulnerability has also been confirmed against multicast,\nmanycast, pool and client associations configured with the\n\"preempt\" option. An off-path attacker can deny NTP service to the broadcast\nclient even in authenticated mode. ntp 4.2.8p3 \nNTPsec a48d001683e5b791a743ec9c575aaf7d867a2b0c \n CVSSv2: 4.3 - AV:N/AC:M/Au:N/C:N/I:N/A:P \nCVSSv3: 3.7 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L Testbed Configuration for NTP: a) We have a broadcast server, broadcast client and on off-path\nattacker. b) The broadcast server is a stratum 4 server. The following\nlines are added to the ntp.conf file for broadcast server. We also create a key file ntp_key where all the keys are\nlisted in /etc/ntp directory: c) The broadcast client is configured only as a broadcast\nclient and does not have any other associations. The following\nlines are added to the ntp.conf on the client: We also create a key file ntp_key where all the keys are\nlisted in /etc/ntp directory: d) Attacker sends broadcast packets to the subnet with\nincorrect key. There are two main problems here: a) There is no origin timestamp check on the broadcast\npackets as origin timestamp is set to zero in the broadcast\nserver packets. b) The client tears down the association and clears the\nstate variables on receiving a bad packet. Improperly-authenticated packets should be discarded without\nfurther action.  If ntpd makes state changes to authenticated\nassociations in response to unauthenticated or\nimproperly-authenticated packets, it is likely to result in a\nDenial of Service vulnerability. 2015-10-07 - Vendor Disclosure \n2015-10-23 - Vendors notified that all preemptable associations are 2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0076');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (557, 'Network Time Protocol ntpq and ntpdc Origin Timestamp Disclosure Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 To prevent off-path attackers from impersonating legitimate peers,\nclients require that the origin timestamp in a received response\npacket match the transmit timestamp from its last request to a\ngiven peer.  Under assumption that only the recipient of the\nrequest packet will know the value of the transmit timestamp, this\nprevents an attacker from forging replies. Unfortunately, ntpq and ntpdc will disclose the value of the origin\ntimestamp expected in the next peer response to any clients that are\nauthorized to make ntpq (respectively ntpdc) queries. This vulnerability appears to have been present in ntpd since, at\nleast, 4.0.94 of May 1999.  It appears in the earliest commit in\nthe NTP project git repository. ntp 4.2.8p3 \nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 \n CVSSv2: 5.0 - AV:N/AC:L/Au:N/C:P/I:N/A:N \nCVSSv3: 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N Here is an example from ntpq:  Here is an example from ntpdc: For associations that do not employ authentication, response packets\nare only authenticated using the packet source address and the\nexpected origin timestamp.  The necessary ntpq and ntpdc commands do\nnot require authentication.  As a result, an unauthenticated off-path\nattacker that can spoof the source address of a remote peer can forge\nresponses from that peer using this vulnerability. There is an interplay between this vulnerability and the 0rigin\n(zero origin) vulnerability (CVE-2015-8138).  Because the 0rigin\nvulnerability resets the expected origin timestamp from live servers\nto zero when a response with the correct origin timestamp is\nreceived, forging responses from live servers is trivial.  This\nvulnerability gives attackers the additional power to forge\nresponses from unreachable peers and symmetric peers. The peer origin variable is read via ntpq (mode 6) packets with a\nnon-zero association id, opcode equal to READVAR (2), and the\nvariable name \"org\". It can also be read with ntpdc (mode 7) packets with a request code of\nPEER_INFO (2). This vulnerability can be mitigated by adding the   option to\nall restrict entries as in: WARNING: Common configurations allow local users to send ntpq and\nntpdc requests to the local ntpd using permissive restrict\nentries.  This will allow malicious, unprivileged, local users to\ndiscover the value of the origin timestamp necessary to spoof\nresponses from ntpd peers.  Therefore, we DO NOT recommend the\ncommon practice of allowing queries from localhost. Unfortunately, despite the impression given by NTP\'s documentation,\nthe   restrict option CANNOT be used to mitigate this\nvulnerability because it DOES NOT have any effect on ntpq and ntpdc\nrequests. 2015-10-16 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0078');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (558, 'Network Time Protocol ntpq Control Protocol Replay Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 The ntpq protocol is vulnerable to replay attacks. The sequence\nnumber being included under the signature fails to prevent replay\nattacks for two reasons. Commands that don\'t require\nauthentication can be used to move the sequence number forward,\nand NTP doesn\'t actually care what sequence number is used so a\npacket can be replayed at any time. A simple example of this being used against an NTP server is if\nan attacker at some point observed an ntpq command to configure\na server address. This setting might be changed later due to problems\nwith that server, such as being inaccurate or even a malicious server.\nA replay attack could reset the server address back to this malicious\nserver. It is recommended that users restrict ntpq to localhost and change\nthe key it\'s using, the key change would prevent messages already\nrecorded from being replayed with local access. A possible fix would be for the client to request a sequence number\nto be generated whenever it wants to start a session with the server,\nthe server would create a large random nonce, store it for the session,\nand reply with it. The client would then include this sequence number in\nthe signed portion of its authenticated messages, incrementing the sequence\neach message. The nonce must be large enough to make a repeated value\nsufficiently unlikely. The server must validate that the correct sequence\nvalue was included (the current sequence must be greater than the last\nsequence within some sort of window, such as 10, to allow for some missed\npackets). If too many packets are dropped the session must be restarted. A more involved fix would be implementing a secure channel, such as TLS.\nThis would also provide the benifit of confidentiality. NTP ntpd 4.2.8p3 \nNTPsec ntpd aa48d001683e5b791a743ec9c575aaf7d867a2b0c \n CVSSv2: 5.4 - AV:A/AC:M/Au:N/C:P/I:P/A:P \nCVSSv3: 5.0 - CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L This defect can be mitigated by disabling ntpq in ntp.conf. 2015-10-16 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0079');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (559, 'Network Time Protocol ntpq Buffer Overflow Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 ntpq contains a buffer overflow.  nextvar() executes a memcpy() into\nthe name buffer without a proper length check against its maximum\nlength of 256 bytes. ntp 4.2.8p3 \nNTPsec a5fb34b9cc89b92a8fef2f459004865c93bb7f92 (http://www.ntp.org)[http://www.ntp.org]\n(http://www.ntpsec.org/)[http://www.ntpsec.org/] CVSSv2: 3.7 - AV:L/AC:H/Au:N/C:P/I:P/A:P \nCVSSv3: 5.6 - CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:L This can be exploited by the following call to the addvar command in\nntpq: The argument will be truncated to 503 bytes, but name is only 256\nbytes.  As long as no spaces, commas, equal signs or carriage returns\nare in the argument, the entire 503 bytes will be memcpy()\'d in to\nname.  There are several other functions that call nextvar() which\ncould be used for the same type of exploit. For the purpose of reproducing this, the system\'s buffer overflow\nprotection scheme (e.g. fortify source) could affect whether an actual\nerror is seen. This could be exploited by a malicious user in a context wherein ntpq\nis run by another script that reads variable names from an untrusted\nsource such as a user or environment variable.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0072');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (560, 'Network Time Protocol ntpq and ntpdc Infinite Loop Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 ntpq processes incoming packets in a loop in getresponse().  The\nloop\'s only stopping conditions are receiving a complete and correct\nresponse or hitting a small number of error conditions.  If the packet\ncontains incorrect values that don\'t trigger one of the error\nconditions, the loop continues to receive new packets.  ntpdc suffers\nfrom the same issue. This can be leveraged by an attacker to DoS an ntpq or ntpdc client by\ncreating an infinite loop.  As long as the incoming packets are not\ncorrect and don\'t trigger an error condition, the loop will never end. ntp 4.2.8p3 \nNTPsec aa48d001683e5b791a743ec9c575aaf7d867a2b0c \n CVSSv2: 6.1 - AV:A/AC:L/Au:N/C:N/I:N/A:C \nCVSSv3: 5.9 - CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H For example, if an attacker causes response packets to contain an NTP\nversion of 5, the processing loop will continue back to the top when\nit checks the version number.  As long as the attacker continues to\nsend packets with NTP version 5 in them, the ntpq client will never\nstop receiving packets and therefore never return from getresponse(). This type of attack requires the attacker to do one of the following: If an attacker can manage to prevent an NTP server from sending ntpq\nresponses, they can spoof responses from any machine with network\naccess to the client and ntpq will process them. It appears ntpdc has a similar problem.  Rather than running in a loop\nwith no exit condition, it uses goto to jump back to a label. Ideally, the loop which receives packets would have some type of\nfallback terminating condition that does not depend on the incoming\npackets. 2015-10-16 - Vendor Disclosure  \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0080');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (561, 'Network Time Protocol Origin Timestamp Check Impersonation Vulnerability', 'None', '2016-1-19', 'CERT VU#357792 To distinguish legitimate peer responses from forgeries, a client\nattempts to verify a response packet by ensuring that the origin\ntimestamp in an incoming packet matches the transmit timestamp it\ntransmitted in its last request.  A logic error exists that allows\npackets with an origin timestamp of zero to bypass this check\nwhenever there is not an outstanding request to the server. It appears this defect applies to all modes except interleaved and\nbroadcast modes and was introduced in version 4.2.5p179. ntp 4.2.8p3 \nNTPsec aa48d001683e5b791a743ec9c575aaf7d867a2b0c \n CVSSv2: 5.0 - AV:N/AC:L/Au:N/C:N/I:P/A:N \nCVSSv3: 5.3 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N receive() in ntp_proto.c contains the following sanity check for the\norigin timestamp when running in basic mode: If the incoming origin timestamp is not equal to the stored origin\ntimestamp in the peer structure, the packet is marked as bogus and\nwill be ignored.  If the origin timestamp matches the saved origin\ntimestamp in the peer structure, the origin timestamp in the peer\nstructure is zeroed out. This means an attacker can spoof the peer server and send a time\nupdate with a zero origin timestamp.  The client will check that\nincoming timestamp against the one stored in the peer, which is zero.\nThe timestamps will match and the client will process the incoming\npacket for time.  The client is not in a state in which it is\nexpecting a reply from the server, but it processes it anyway. We have successfully used this vulnerability to force a client to move\nits time.  Our proof-of-concept requires no authentication or\nspecial access and works for any client configured in basic mode. We can maintain the client at our spoofed time by sending regular\nupdates, every 5 seconds for example, enough to overcome the real\nserver time updates in the clock selection process.  The client will\noscillate between the peered and rejected state with the peer since it\nis receiving drastically different times between the spoofed and real\npackets. In order to be considered for clock selection, we have to ensure that\nthe measured dispersion and delay for our packets are low.  We achieve\nthis by setting the receive timestamp to the offset value by which we\nwant to move the clock for the initial time change.  For example, to\nmove the clock 20 years forward we set the transmit timestamp to\n(current time + 630720000) and the receive timestamp to 630720000.  We\nalso must set the precision to -128 to minimize the dispersion.  Once the\ntime has changed, we can maintain that spoofed time by changing\nreceive to zero and keeping transmit the same.  This keeps the delay\nlow enough to be considered in clock selection. Additionally, even when the update has too large of an offset or too\nbig of a delay to win the clock selection, we can at least use the\nzero origin timestamp to make a client ignore real time updates in\nsome instances by forcing the client to think a real server update is\na popcorn spike. Ideally, the client would not process any packet from a peer if it did\nnot have an active request out. 2015-10-16 - Vendor Disclosure \n2016-01-19 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0077');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (562, 'Apple Quicktime mdat Corruption Denial of Service Vulnerability', 'None', '2016-1-8', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the content of the mdat section\nof a .mov file can cause an out-of-bounds read. Since the function would fail a bounds check immediately after the read occurs,\nthe impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit \nApple Quicktime 7.7.6 - Windows 7 32-bit The function Quicktime!0x8a6b00 parses data from the mdat section of the file in a loop. At the end of each iteration, the value in v54 is used as an index into an array and a value is read. This index is\nadvanced by at least 1 byte on each iteration, but sometimes more. There is a test block towards the end of the\nloop to validate this value: The function should return with an error code if v54 > 0x3f, however, this condition is only tested after the value\nin v54 is used as an index into the array. If 0x3f is the last legitimate index value, then the highest offset\nthe crash instruction should be attempting to access would be 0x6d0 + 0x3f*4 = 0x7cc There are several places within each iteration of the loop before the access that add an additional\nvalue to the index counter influenced by bytes read from the mov file. If an attacker crafts a sequence of bytes in the mdat data section such that the calculated array index is larger\nthan 0x3f before hitting the above block of code, then an out-of-bounds read will occur. However, once the\nout-of-bounds read occurs, the index fails the max size check and the function returns, limiting this\nvulnerability to a denial of service. 2012-12-04 - Discovery  \n2015-05-08 - Reported', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0021');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (563, 'Apple Quicktime mdat Corruption Denial of Service Vulnerability', 'None', '2016-1-8', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the content of the mdat section\nof a .mov file can cause an out-of-bounds read. The impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit \nApple Quicktime 7.7.6 - Windows 7 32-bit The function QuickTime!0x8b0050 parses data generated from the mdat section of the file, making reads on an array of\nbyte values of size 0x5c4 (0x7dc - 0x218 initial offset) in a loop. The index used to calculate where in this byte array to make a read comes from a second byte array. This second array is\noperated on 0x10 bytes at a time in a loop. There is a counter value that is hardcoded at 8 by the function, meaning a\ntotal of 0x80 bytes from this data structure are used in these calculations. The function responsible for populating the index table from which the out-of-bounds offset is pulled starts\nat Quicktime!0x8bc010. There is a loop at the very end of the function (QuickTime!0x8bc271) that does several\ncomplex calculations and copies the resulting word values (indices) to the 0x80-byte buffer of indices used above. If an index calculated by the function Quicktime!0x8bc010 exceeds 0x5c4, then, in QuickTime!0x8b3400, when this\nindex is used to calculate the address at which to read a byte from a matrix object, an out-of-bounds read will occur. 2012-12-04 - Discovery  \n2015-05-08 - Reported', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0020');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (564, 'Apple Quicktime dref Atom Null Data Reference Entry Denial of Service Vulnerability', 'None', '2016-1-8', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the size and type of a data\nreference entry in a dref atom in a .mov file can cause an undersized allocation which can lead to an out-of-bounds read.\nSince the allocation only contains data already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable The function QuickTime!0x73b390 is responsible for parsing dref atoms. There is some looping code within the function that looks for a dref atom and then processes the data there. The data portion of the dref atom is copied into a new allocation. The allocation is the atom size - 0x8 header bytes\n(size and 4CC) + 0x4 bytes the module\'s custom alloc wrapper tacks on. The following snippet of code runs the dref atom data through a big-to-little-endian function\nthen checks the type and size fields for the data reference entry that follows. If dref type_size are both zero, the code fails the check and execution passes to line 74. If the if-block\nis taken, it does not reach this line because of the goto at line 72. The crash may occur on line 87 or 88 depending\non the size of dref atom data, but the code expects at least 26 bytes without first checking the size of the allocation. If there is at least 1 data reference entry in a dref atom with a type and size both set to 0, an out-of-bounds read\nwill occur. 2012-12-05 - Discovery \n2015-05-08 - Reported', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0023');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (565, 'Apple Quicktime Invalid samr Atom Size Denial of Service Vulnerability', 'None', '2016-1-8', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the size of a samr atom in a\n.mov file can cause an undersized allocation which can lead to an out-of-bounds read. Since the allocation only contains\ndata already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable  \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable The function QuickTime3GPP!0x37D0 is responsible for parsing samr atoms inside the file. After the 4CC of the atom is checked, there is a check to ensure the atom is at least 0x24 bytes in size. No additional size check is performed to evaluate whether the atom size is large enough for there\nto be data past the initial 0x25 bytes. As long as the size is > 0x24, the code will attempt\nto read the bytes at offset 0x28, expecting an additional 4CC. The following pseudocode checks for a \"damr\" subatom, and then attempts to copy 9 bytes into a destination buffer\nstarting at 0x2c bytes into the atom. A \"samr\" atom with \"damr\" component must be 0x35 bytes long, however, the atom size controls\nthe size of the source buffer passed to the samr parsing function. Since it contains\nless than 0x35 bytes of data, and the function contains only a minimum length check of 0x24,\nthe function results in an out-of-bounds read. Reasonably, the crash could occur here if less than 0x2C bytes were provided. However, since the\n4CC check passes, the code proceeds to the memcpy, attemping to copy out an additional 9 bytes\nof data (0x11-0x8 = 0x9) to a stack address without checking it doesn\'t exceed the source buffer. Conditions for triggering this crash are: if samr atom size is between 0x25 and 0x2b: if samr atom size is between 0x2c and 0x34: 2012-12-03 - Discovery  \n2015-05-08 - Reported', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0019');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (566, 'Apple Quicktime Invalid alis Atom Size Denial of Service Vulnerability', 'None', '2016-1-8', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the size of an alis atom in\na .mov file can cause an undersized allocation which can lead to an out-of-bounds read. Since the allocation only contains\ndata already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable  \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable The function QuickTime!0x73aad0 is responsible for calculating the size of the alis data and passing it up\nto an allocation function. If the alis atom is at least 12 bytes, the alis data is size-12 bytes and a new buffer of that size is allocated. The function QuickTime!0xb429d later uses this new allocation and attempts to make a read of 2 bytes at offset 4\nwithout first checking the allocation is large enough. If an alis atom size is not at least 18 bytes, an out-of-bounds read occurs. There are no\nchecks to ensure there are at least 6 bytes of data to read in the newly allocated object. If the atom does contain at least 18 bytes, the 2-byte value read from offset 6 is another size value. If this value is\nat least 0x9c in size, the function will continue to read values from various offsets in the allocation. If the alis atom is at least 18 bytes and the value at offset 6 is at least 0x9c, then if the alis size is less than\n0x9c, the allocation will not be large enough to accomodate further reads, resulting in an out-of-bounds read. 2012-12-04 - Discovery  \n2015-05-08 - Reported', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0022');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (567, 'RTMPDump rtmpsrv PlayPath Null Pointer Dereference', 'None', '2016-1-7', 'A vulnerability exists in rtmpsrv in which an attacker can\nentice a user to utilize rtmpsrv to save an RTMP media stream\nthat is missing a playpath. This leads to a NULL pointer\ndereference, crashing the program. RTMPDump 2.4 \nlibrtmp 1.0 rtmpsrv is a stub for a server; it logs the connect and play parameters\nfrom a regular client that connects to it. It then invokes rtmpdump\nwith those parameters to retrieve the stream. This is often used in\nconjunction with IPTables to intercept RTMP streams viewed online and\ndumping the stream to a local file for viewing at another time.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0068');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (568, 'RTMPDump librtmp AMF3 Class Member Count Remote Code Execution Vulnerability', 'None', '2016-1-7', 'The vulnerability occurs within the AMF3CD_AddProp function within amf.c.\nIf an attacker sets up a malicious RTMP Media server that defines the number\nof AMF3 Class Members in a certain way, the attacker can write data to a pointer\ncopied to an arbitrary address ending in 0. This leads to a \"write-what-where\"\ncondition that could lead to arbitrary remote code execution. RTMPDump 2.4 \nlibrtmp 1.0 The RTMP protocol was developed by Macromedia (Adobe) for streaming audio,\nvideo and data over the internet between a Flash player and a server. One\nsuch client used for saving these streams locally to a file is called\nRTMPDump. RTMPDump is available on Windows and Linux for free either\nthrough https://rtmpdump.mplayerhq.hu/ or many Linux Official/Extra Repositories.\nRTMPDump is also used by many media players including FFmpeg, MPlayer,\nHTS Home Theater System and cURL. The developers of RTMPDump also created a library for communicating over RTMP\ncalled librtmp. This API provides a simplified interface to communicating over\nthis protocol. librtmp is used by several programs/platforms such as\nRTMPDump (itself), livestreamer, youtube-dl, XBMC (Kodi), streamCapture and\nseveral others. When an RTMPClient initiates a connected with a server, a simple Handshake\nexchange occurs. The client sends a packet starting with 0x03 to represent the\nprotocol followed by a 4-byte time stamp (not required) and \'random\' data totaling\n1536 bytes (known as C0 & C1, respectively). The server then responds with the byte 0x03\nand another packet 1536 bytes long with the first 4 bytes containing a time stamp,\nthe second 4 containing 0\'s and the rest being \'random\' as well. (S0 and S1). The\nclient then sends C2, which is a copy of S1 and the server responds with S2 which is\na copy of C1. After this handshake is completed, RTMP data can be exchanged. If a server sends\nthe following bytes to the client after the handshake, the crash occurs: :-: AMF3 Objects Objects can be sent as a reference to a previously occurring Object by using an index to\nthe implicit object reference table. Further more, trait information can also be sent as a\nreference to a previously occurring set of traits by using an index to the implicit traits\nreference table. Note that for U29O-traits-ext, after the class-name follows an indeterminable\nnumber of bytes as *(U8). This represents the completely custom serialization of\n\"externalizable\" types. The client and server have an agreement as to how to read in this\ninformation. :-: AMF3 Variable-Length Encoding\n1.3.2 Strings and UTF-8\nAMF 0 and AMF 3 use (non-modified) UTF-8 to encode strings. UTF-8 is the\nabbreviation for 8-bit Unicode Transformation Format. UTF-8 strings are typically\npreceded with a byte-length header followed by a sequence of variable length (1 to 4\noctets) encoded Unicode code-points. AMF 3 uses a slightly modified byte-length header;\na detailed description is provided below and referred to throughout the document. This is handled by the function AMF3ReadInteger().', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0067');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (569, 'RTMPDump librtmp AMF3 MemberName Denial of Service Vulnerability', 'None', '2016-1-7', 'The vulnerability occurs within the AMF3ReadString function within amf.c.\nIf an attacker sets up a malicious RTMP Media server that defines an AMF3 Class\n\'memberName\' string by reference, the \'memberName\' property of that object is\nnot assigned, leading to an invalid pointer dereference when attempting to\ndisplay the invalid \'memberName\' in a debug message. This also occurs if a\nliteral string value is defined but not in the datastream. Debug output can be specified in rtmpdump with the \'-z\' switch\nor in librtmp itself with _DEBUG defined. The problem is that rtmpdump will call\nthese debug logging functions regardless of whether or not the user requested it.\nThe \'-z\' switch only determines whether the debug messages are displayed to the user. RTMPDump 2.4 \nlibrtmp 1.0 The RTMP protocol was developed by Macromedia (Adobe) for streaming audio,\nvideo and data over the internet between a Flash player and a server. One\nsuch client used for saving these streams locally to a file is called\nRTMPDump. RTMPDump is available on Windows and Linux for free either\nthrough https://rtmpdump.mplayerhq.hu/ or many Linux Official/Extra Repositories.\nRTMPDump is also used by many media players including FFmpeg, MPlayer,\nHTS Home Theater System and cURL. The developers of RTMPDump also created a library for communicating over RTMP\ncalled librtmp. This API provides a simplified interface to communicating over\nthis protocol. librtmp is used by several programs/platforms such as\nRTMPDump (itself), livestreamer, youtube-dl, XBMC (Kodi), streamCapture and\nseveral others. When an RTMPClient initiates a connected with a server, a simple Handshake\nexchange occurs. The client sends a packet starting with 0x03 to represent the\nprotocol followed by a 4-byte time stamp (not required) and \'random\' data totaling\n1536 bytes (known as C0 & C1, respectively). The server then responds with the byte 0x03\nand another packet 1536 bytes long with the first 4 bytes containing a time stamp,\nthe second 4 containing 0\'s and the rest being \'random\' as well. (S0 and S1). The\nclient then sends C2, which is a copy of S1 and the server responds with S2 which is\na copy of C1. After this handshake is completed, RTMP data can be exchanged. If a server sends\nthe following bytes to the client after the handshake, the crash occurs: You could also crash librtmp by sending the following:', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2016-0066');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (570, 'Microsoft .NET Manifest Resource Information Disclosure Vulnerability', 'None', '2015-12-8', 'An exploitable information leak or denial of service vulnerability exists in the manifest resource parsing functionality of the .NET Framework.\nA specially crafted resource can cause an integer overflow resulting in an out of bounds read which may return arbitrary memory contents or\ncause the application to unexpectedly terminate. An attacker can supply a corrupted manifest through a .NET or Silverlight assembly,\nwhich can be automatically loaded in Internet Explorer or other browsers with the appropriate plugin installed. This vulnerability can\nbe used to crash the program or to return memory contents to assist with bypassing memory hardening mitigations such as ASLR. Microsoft Silverlight 5.1.30514.0 \nMicrosoft .NET Framework 4.5.50938 6.1 - CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:H The .NET Manifest Resources format is undocumented but to learn about it we use one of source mentioned in references  .\nThe resource structure is documented in the following way: We will focus our attention on Number of resources field. An attacker can modify this field to corrupt a pointer in the following way. Vulnerable code appears in ResourceReader class: .net\\coreclr\\src\\mscorlib\\src\\System\\Resources\\ResourceReader.cs\nThis class has multipple constructors, in our scenario we are interested in constructors that assign a value to the _ums field.\nSo it can be : or Let’s we analyze the way .NET Manifest Resources structure is parsed.\nBoth constructors call internal _ReadResources method: Number of resources is represented by 32bit signed integer variable which value can’t be larger than MAX numResources is used two times in code to calculate stream offset: You can see the vulnerable code at line 992 where integer overflow appears, but we won’t focus on it right now, just remember that _nameHashesPtr pointer was initialized here and it points to area where Resources Name hashes(DWORDs) should appears. We observe here also that the programmer planned to check whether pointer is assigned within stream boundaries but ultimately nothing is checked. Second usage of _numResources: This code containts another integer overflow and lack of checking whether  numResources and _nameHashesPtr is set and that there is lack of sanitization for these variables, we can run test application with malformed .NET resource manifest and see where it crashes. If application has one .NET resource and it’s major resource e.g MainPage.xaml it will be automatically loaded during application start in components initialization method which will trigger the vulnerability: Access violation appears in ReadUnalignedI4 method in the following way: To understand where this *p pointer came from and how its value was calculated let’s we take a look at the call stack: We will start our investigation in FindPosForResource method. This function is searching for a particular resource name using its hash representation on Line 319. Calculated hash is searched for in the array pointed by  ReadResources method. Index for this array is calculated based on malformed by us  numResources from 1 to 0x40000001 in the manifest. Setting a breakpoint at the beginning of FindPosForResource method we can easy check it out: First index value calculated will be 0x20000000. Further index is passed to GetNameHash function. According to call stack and  nameHashesPtr table. As we can see index argument is used as index into the name hashes array. In this case the corrupted value will point outside array (Resource section/directory) space. 00be11bc  nameHashesPtr should be constrained within the  length memory boundary. Notice that here the index is multiplied by 4 (sizeof of element in array) which is another place for possible overflow. Finally read access violation appears during read of first byte from calculated pointer:   \n   2015-05-08 - Vendor Disclosure \n2015-12-08 - Public Disclosure', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0130');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (571, 'Network Time Protocol Reference Clock Memory Corruption Vulnerability', 'None', '2015-10-21', 'A potential buffer overflow vulnerability exists in the refclock of ntpd. An invalid length provided by a hardware reference clock could cause a buffer overflow potentially resulting in memory being modified. A malicious reflock could provide a negative length to trigger this vulnerability. ntp 4.2.8p2 At line 3233 in ntp_io.c, a size check is performed to ensure that the length provided isn’t greater than the space available in the buffer that is being written to. However, the size is performed by casting the size of the buffer to an integer type and doing an integer comparison. This means that if datalen is negative, then i will be assigned a negative value, resulting in a buffer overflow when it is used as an argument to read at line 3238.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0064');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (572, 'Network Time Protocol ntpd multiple integer overflow read access violations', 'None', '2015-10-21', 'When processing a specially crafted private mode packet, an integer overflow can\noccur leading to out of bounds memory copy operation. The crafted packet needs to\nhave the correct message authentication code and a valid timestamp. When processed\nby the NTP daemon, it leads to an immediate crash. ntp-dev.4.3.70 While parsing a private mode packet with a request code of RESET_PEER (0x16) two\nvalues 16 bit big endian values from the packet are interpreted as number of items\nand size of item respectively. A faulty check on the number of items ends up\ndecrementing the value which is later used in a second check. If the initial value\nwas zero, the decremented value will be 65535 leading to a crash in a while loop. With a request code of RESET peer() is reached We check first to see that every peer exists.  If not, we return an error. Now do it in earnest. At [1] the number of items is derived and the size of each item at [2]. Size can be either 4 of 24.\nAt [3], a check is being made to ensure \'items\' is greated than zero. If it\'s not, the check\nfails and the code never enters the while loop. At [4], the same check is performed again, but\nbecause of the postdecrement operator at [3], the value in \'items\' is now already decremented by one. In case the initial value of \'items\' was 0, the first check will fail, but the post decrement\noperator will decremet this value thus overflowing the integer. New value of \'items\' will be\n65535 when it reaches [4], passing the check and entering the while loop.\nA crash occures on memcpy when \'datap\' pointer is incremented past the allocated memory. Size of the \'memcpy\' is limited to either 4 of 24, and the destination buffer is always\nlarge enough, thus limiting this issue to an out of bounds read leading to sudden termination\nof the process. The similar condition occurs inside do_restrict() function, which can be triggered with a packet\nwith different opcode (0x12 for example) and different size value (0x0c for example) Do a check of the flags to make sure that only the NTPPORT flag is set, if any.  If not, complain about it.  Note we are very picky here. Looks okay, try it out  Same as in reset_peer(), at [1] the \'items\' value is derived, at [2] it is checked against zero\n and decremented, and at [3], the decremented value is used in a check again.  Both of these issues can be triggered by the supplied proof of concept code which contains\n two payloads, for each of the vulnerabilities.  The vulnerabilities can be triggered in the latest version of ntpd with the supplied configuration files\n that set up proper keys and options as the vulnerabilities are only reachable with proper authentication.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0052');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (573, 'Network Time Protocol Remote Configuration Denial of Service Vulnerability', 'None', '2015-10-21', 'An exploitable denial of service vulnerability exists in the remote configuration functionality of the Network Time Protocol. A specially crafted configuration file could cause an endless loop resulting in a denial of service. An attacker could provide a the malicious configuration file to trigger this vulnerability. ntp 4.2.8p2 When sending a remote configuration file, an attacker can enable extended logging via the logconfig=allall setting. An attacker can also set the keys file when specifying this remote configuration. If the attacker sets the keys file to be the log file, the key parsing will go into an endless loop. NTP will log an invalid key in parsing, and will then subsequently parse that line as a key and again log the error, continuing in an infinite loop.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0055');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (574, 'Network Time Protocol ntpq atoascii Memory Corruption Vulnerability', 'None', '2015-10-21', 'A potential off by one vulnerability exists in the cookedprint functionality of ntpq. A specially crafted buffer could cause a buffer overflow potentially resulting in null byte being written out of bounds. ntp 4.2.8p2 At line 3330 in ntpq.c, the atoascii function will be called to transform data into printable ascii (i.e. characters below 127): The function atoascii won’t write more than sizeof(bv) bytes into bv and will ensure NULL termination if it runs out of space in bv. Depending on the specific character in the value parameter, it will write between 1 and 2 characters to bv. If bv is filled in atoascii, it will be NULL terminated at its final byte. This means that len = strlen(bv) will return the size of the buffer-1. Accessing the buffer via len will overwrite the NULL byte with output_raw. However if the buffer is full because it ran out of space during the atoascii function, then len+1 will equal 4096, resulting in an off by on the buffer.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0063');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (575, 'Network Time Protocol Trusted Keys Memory Corruption Vulnerability', 'None', '2015-10-21', 'An exploitable use-after-free vulnerability exists in the password management functionality of the Network Time Protocol. A specially crafted key file could cause a buffer overflow resulting in memory corruption. An attacker could provide a malicious password file to trigger this vulnerability. ntp 4.2.8p2 The function authdelkeys() will free all the keys that are used for user authentication. In the case of normal keys, they will also be removed from the list of keys. However in the case of trusted keys, the memory holding the keys will be freed but the pointer to that memory location will not be set to NULL. This is the code at line 598 in authkeys.c: Since the key is still in the linked list it will simply be copied to at line 541 in authkeys.c: Reuse of a previous buffer can lead to inconsistencies in authentication tokens or memory corruption.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0054');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (576, 'NAK to the Future: NTP Symmetric Association Authentication Bypass Vulnerability', 'None', '2015-10-21', 'Unauthenticated off-path attackers can force ntpd processes to peer\nwith malicious time sources of the attacker\'s choosing allowing the\nattacker to make arbitrary changes to system time.  This attack\nleverages a logic error in ntpd\'s handling of certain crypto-NAK\npackets.  When a vulnerable ntpd receives an NTP symmetric active\ncrypto-NAK packet, it will peer with the sender bypassing the\nauthentication typically required to establish a peer association. ntp 4.2.8p3 CVSSv2: 6.4 - (AV:N/AC:L/Au:N/C:N/I:P/A:P) \nCVSSv3: 7.2 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L In most common configurations, ntpd determines which other NTP daemons\nto peer with via explicit configuration directives specified by an\nadministrator in the ntp.conf configuration file.  However, ntpd also\nhas the ability to create ephemeral peer associations on the fly in\nresponse to certain kinds of incoming requests.  In most common\nconfigurations, if ntpd receives such a packet, it will set up an\nephemeral association with the sender only if the packet is correctly\nauthenticated under a key that ntpd trusts. For example, when ntpd receives a symmetric active (NTP mode 1) packet\nand there is no existing peer association with the sender, ntpd\nexecutes the following check to determine if the packet has been\ncorrectly authenticated before mobilizing a new ephemeral symmetric\nassociation. In contrast to the simpler checks present in other locations where\nephemeral associations are mobilized, the logic for symmetric active\npackets has been complicated by a workaround to accommodate some non\nstandards compliant clients.  The intent of this code appears to be: In most cases, when ntpd receives a packet with a cryptographic digest\nthat does not validate correctly, it bails out early and responds with\na crypto-NAK --- an unauthenticated packet containing a keyid but no\ncryptographic digest which informs the sender that the received packet\nwas not correctly authenticated. Internally, ntpd represents the authentication state of a received\npacket using the \"is_authentic\" variable which can take on four\nvalues under the following conditions: Thus, when ntpd receives a crypto-NAK packet, it sets the\n\"is CRYPTO.  This has\ninteresting implications for the authentication check described above.\nThe AUTH() macro always returns false if the second input is\nAUTH authentic == AUTH_ERROR) only matches packets that contain a bad\ndigest.  As a result, crypto-NAK packets avoid both early termination\nconditions and proceed through to code which creates a new ephemeral\nassociation authenticated under the keyid specified by the packet, in\nthis case keyid == 0.  This has interesting implications when we\nconsider how authentication is enforced. ntpd can communicate simultaneously with both authenticated and\nunauthenticated peers.  ntpd indicates the authentication requirements\nfor an association by storing the id of the required authentication\nkey in the \"keyid\" variable of the peer association structure.  The\nspecial keyid value 0 indicates that no authentication is required.\nBy default, when a packet is received from a peer with an active\nassociation, ntpd requires the packet to be authenticated only if the\nassociation requires authentication.  This check is governed by the\nfollowing code. Let us consider what happens to subsequent unauthenticated packets\nsent after an attacker sends a crypto-NAK.  Because the association is\nconfigured with keyid 0, peer->keyid == 0.  For unauthenticated\npackets has authentic == AUTH_NONE for unauthenticated packets, AUTH() will\nreturn true, the guard will be false, and the packet will proceed to\nfurther processing.  As long as the packet passes all the other\nconsistency checks that can be met by any consistent NTP peer, it will\nbe processed for time.  If there are a majority of mutually-consistent\nattacking peers advertising the incorrect time, they can win the clock\nselection algorithm and cause the victim to accept their time. Lets look at an attack in action.  We can monitor the attack progress\nby querying the victim for the status of its peer associations using\nthe \"ntpq -c lpeer\" command.  As the attack progresses, we\'ll see how\nthe victim\'s peer status changes.  Initially, the victim is configured\nwith 5 upstream servers, server1-5: Six attacking nodes (attacker1-6) send symmetric active crypto-NAK packets to the\nvictim causing the victim to establish ephemeral peer associations\nwith the attacking nodes: In this attack, the attackers consistently advertise time that is 5\nminutes behind true time.  Because the time provided by the attackers\nis consistent and they outnumber the legitimate servers, ntpd\neventually declares the legitimate servers to be falsetickers and\nchooses an attacker node as the chosen peer. Eventually the victim steps its clock to match the attacker-provided\ntime and resets its associations. Once the victim has stepped its clock, the attackers win the election\nto become the chosen peers.  They can maintain the system\'s clock at\nthe offset time or make further changes. In this example attack, we have only stepped the clock by 5 minutes.\nHowever, we have achieved larger offsets in lab testing.  We are not\naware of any limitations that would prevent attackers from stepping\nthe clock by significantly greater values nor are we aware of\nlimitations to prevent attackers from executing multiple successive\nsteps to move the victim\'s system time arbitrarily from the initial\ntime. Attempts to exploit this vulnerability are detected by the following\nIDS rules: The most complete mitigation is to upgrade to ntp-4.2.8p4.\nntp-4.2.8p4 fixes a number of other critical issues in addition to\nthis vulnerability.  If your system\'s ntpd is packaged by the system\nvendor, apply your vendor\'s security update as soon as it becomes\navailable.  Until then, the best defense is to use firewall rules to\nblock malicious traffic. If your system supports a host-based firewall which blocks incoming\ntraffic, such as the Windows Firewall, Mac OS X Application Firewall,\nor the Uncomplicated Firewall on Linux, you should enable it. For other systems, appropriate firewall rules will depend on your\nenvironment.  Use the following recommendations as a guideline for\ntypical client-server and peer modes: In environments where authentication has been configured between all\nNTP clients, servers, and peers, ntpd can be prevented from\ncommunicating with unauthenticated peers by enabling the ntpd\n\"notrust\" restriction.  This does not prevent an attacker from causing\nthe ephemeral peer association to be created.  However, even with\nmalicious peer associations active, ntpd should reject packets sent by\nthose the malicious peers.  The \"notrust\" restriction can be enabled\nby adding it to ntpd\'s default restriction lists: If there are known-good peer connections that cannot be authenticated, the\n\"notrust\" restriction can be selectively relaxed for those peers only\nas follows: Malicious changes system time can have grave implications in a number\nof systems.  With the ability to change system time, an attacker may\nbe able to: This vulnerability has been confirmed in ntp version 4.2.8p3.  The\nvulnerable code path was introduced in ntp version 4.2.5p186 (late\n2009).  Therefore, all ntp-4 stable releases from 4.2.5p186\nthrough 4.2.8p3 appear to be vulnerable.  All ntp-4 development\nversions from 4.3.0 through, at least, 4.3.76 also appear to be\nvulnerable. Any product which integrates an ntpd version from the vulnerable range\nmay also be affected.  Because many vendors patch ntpd before\npackaging it for distribution in their products, the susceptibility of\nany specific product must be considered on a per-product basis. The Cisco Product Security Incident Response Team (PSIRT) is currently\ninvestigating the susceptibility of Cisco products to the\nvulnerabilities disclosed with ntp-4.2.8p4.  A Cisco Security\nAdvisory should be posted shortly: Please refer to the Cisco Security Vulnerability Policy for further\ninformation about vulnerability response: If an attacker can send symmetric active crypto-NAK packets to your\nntpd process and can receive responses back, then you are vulnerable\nunless your ntpd is configured to reject unauthenticated packets from\nunknown peers (e.g. \"restrict default notrust ...\").  In a lab\nenvironment, we have successfully attacked: In most common configurations, you can use ntpq to query the ntpd\nprocess running on your system for its list of peers.  Any unexpected\npeers that are not configured in your /etc/ntp.conf file could\nindicate an attack: You can delete any rogue associations by restarting ntpd after\napplying the mitigations above. If you have a compatible IDS product, the following Snort rules detect\nexploits of this vulnerability: 36536. More generally, reception of unsolicited crypto-NAKs that are not in\nresponse to a packet originated by the recipient may indicate an\nattack. 2015-10-07 - Vendor Disclosure \n2015-10-21 - Public Release', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0069');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (577, 'Network Time Protocol ntpd saveconfig Directory Traversal Vulnerability', 'None', '2015-10-21', 'A potential path traversal vulnerability exists in the config file saving of ntpd on VMS. A specially crafted path could cause a path traversal potentially resulting in files being overwritten. An attacker could provide a malicious path to trigger this vulnerability. ntp 4.2.8p2 The function save control.c will perform path sanitization by stripping out ‘\\’ and ‘/’ from the filename provided to ensure that a user does not save files outside of the saveconfigdir that was previously configured. However on operating systems such as OpenVMS, directory separation is not done by using ‘\\’ or ‘/’ but instead by characters such as ‘.’, ’-‘ and ‘:’.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0062');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (578, 'Network Time Protocol Password Length Memory Corruption Vulnerability', 'None', '2015-10-21', 'A potential buffer overflow vulnerability exists in the password management functionality of ntp. A specially crafted key file could cause a buffer overflow potentially resulting in memory being modified. An attacker could provide a malicious password to trigger this vulnerability. ntp 4.2.8p2 The function MD5auth_setkey() is called in three places: void MD5auth t keyno, int  keytype, const u t len) The function takes 4 arguments, the keyno, keytype, key and len. If a keyno doesn’t exist, then a new key will be allocated based on len. If keyno does exist, the new key will be copied over the old key, using the new length as a size for the strlcpy or memcpy function. The 2 calls in authreadkeys.c have size checks (20 and 32 bytes respectively): In the code above, keystr is a 32 byte unsigned character array. The one in authusekey does not have size checks: However it is called twice from the functions sendrequest and passwd in ntpd.c (lines 895 and 1785) and ntpq.c (lines 1217 and 2453). The code to call authusekey is identical in both files. Both functions retrieve the key via a call to getpass which requires console access and only use it for the info keyid. Below is the code from ntpd.c for the functions sendrequest and passwd respectively: Below is the vulnerable code in the MD5auth_setkey function: If a key is set to 20 bytes and later replaced by a key that is 32 bytes or larger, no extra size checks will be performed, the key will simply be copied over the old key, potentially resulting in a heap-based buffer overflow. This allows an attacker to first provide a shorter key and then a longer one. This can be exploited either through the console using the getpass functionality or via the remote configuration facility: specifying a password file where a specific key is set to a short password and then replacing it with one up to 32 bytes in length, causing a buffer overflow.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0065');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (579, 'MiniUPnP Internet Gateway Device Protocol XML Parser Buffer Overflow', 'None', '2015-9-15', 'An exploitable buffer overflow vulnerability exists in the XML parser functionality of the MiniUPnP library. A specially crafted XML response can lead to a buffer overflow on the stack resulting in remote code execution. An attacker can set up a server on the local network to trigger this vulnerability. MiniUPnP repository master branch Buffer overflow is present in client-side, miniupnpc, part of the library. Vulnerable part of the code is triggered when applications using miniupnpc library are doing initial network discovery upon startup, while parsing the replies from UPNP servers on the local network. Buffer overflow is triggered by an oversized XML element name. When parsing the UPNP replies, the XML parser is initialized and parsexml() function is called: Start element function callback is initialized to   function and parser   variable is of   type: Structure member   is initialized to a static maximum value.> Buffer overflow occurs in   function when parsing new XML element: An unsafe call to   is made with both source and length arguments under external control.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0035');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (580, 'Microsoft Windows CDD Font Parsing Kernel Memory Corruption', 'None', '2015-9-15', 'An exploitable kernel memory corruption vulnerability exists in Microsoft Windows. A specially crafted font file can cause the Microsoft Windows kernel to corrupt internal memory structures, leading to denial of service on the system or possible code execution and elevation of privilege. Windows 7 x64 SP1 \nWindows 8.1 X64 The faulting code is located inside the CDD driver. The DrvTextOut routine acquires and locks the associated device and acts differently based on the surface type. If the type is a bitmap and the Windows DWM is on, the routine reads/writes directly to the video frame buffer and call EngTextOut then exits.\nOtherwise, a new background rect is generated mixing the \"OpaqueRect\" rectangle located in the sixth parameter and the rectangle located in the \"pStringTextObj\" object. If the ClipObject describes a non-trivial clip, the \"rclBounds\" of the clip object is merged to the background rectangle. The font object is parsed and finally the routine decides if it should clip the background rect or not. The final decision is based on the following check: The ClipDstRect routine performs the actual clipping based on the complexity of the Clip object. If the complexity is DC_TRIVIAL, the CPU cache is flushed and the callback routine is called. As we see below, the FillColorKeyCallback routine implementation fails to properly check the rectangle width and height: The background rectangle dimensions are checked in the DrvTextOut routine code: As you can see, the check appears to log the bug but fails to prevent the condition that leads to kernel memory corruption.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0007');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (581, 'Apple Quicktime esds Atom Descriptor Type Length Mismatch Denial of Service Vulnerability', 'None', '2015-8-13', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the elementary video header start codes section or type descriptor length in an \"esds\" atom in a .mov file can cause additional structures to be expected which can lead to an out-of-bounds read. Since the allocation only contains data already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable https://www.apple.com/quicktime/ The function QuickTimeMPEG4!0x9990 is responsible for parsing out the ES header start codes section of the esds atom in a loop. On each iteration, the algorithm pulls the next start code from the buffer and, based on the code, it calls the designated parsing function for the data that follows. A data structure is used to track the algorithm\'s location within the buffer, as well as the boundaries, total size, and last 4 bytes pulled from that data block: Before, and after each start code and structure, a function is called at QuickTimeMPEG4!0x91F0 to check to see if the value of \"current location (obj+8)\" is less than \"end of buffer (obj+0x0c)\": The designated parsing functions for the data that follows each start code contain many optional elements that are parsed as needed based on whether bit flags within the data itself are set. This makes these data sections variable sized, however no check is made within these functions to ensure the read location does not exceed the end of the read buffer. This bug is therefore triggered by a mismatch between the descriptor length (0x22) and the total size of all start codes, required elements, and optional elements within the Elementary Video Header. By flipping bit flags in the data, an attacker can cause additional structures to be parsed resulting in an out-of-bounds read off the end of the data buffer.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0015');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (582, 'Apple Quicktime Invalid 3GPP stsd Sample Description Entry Size Denial of Service Vulnerability', 'None', '2015-8-13', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the number of entries and entry size of a sample description table in a .mov file of type 3GPP can cause an undersized allocation which can lead to an out-of-bounds read. Since the allocation only contains data already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable https://www.apple.com/quicktime/ Details The function QuickTime3GPP!0xa720 is responsible for parsing a sample descriptor entry in an stsd atom. On lines 16, 18, and 21, the object passed to the function is dereferenced without ensuring the object is large enough. The\ndereference on line 21 expects the object to contain at least 40 bytes. The first size integrity check (verifying the subatom fits in the sample description entry) occurs only after this read is complete. The object is allocated using the sample description entry size value from the file: If there is at least one sample description entry and that entry has a non-zero size, then a buffer is allocated and size bytes of data are copied. This buffer is then passed up to QuickTime3GPP!0xa720 which looks for a second size value at 0x24, assuming there at least 0x28 bytes of data without checking the size of the allocation. This results in an out-of-bounds read.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0013');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (583, 'Apple Quicktime Invalid mvhd Atom Size Denial of Service Vulnerability', 'None', '2015-8-13', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the size of an mvhd atom can cause an undersized allocation which can lead to an out-of-bounds read. Since the allocation only contains data already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable The function QuickTime!0x111709 is responsible for copying the data from an mvhd atom to a buffer on the stack. The copy expects at least 0x64 bytes of data, however there is no check to ensure the source buffer is at least 0x64 bytes before the copy takes place. The source buffer is allocated using the mvhd size value from the file: Minus the size and 4CC, mvhd atoms are expected to have at least 0x64 bytes of data. When a mvhd size value of less than 0x6C is specified in the file (0x64 bytes of data, plus 0x8 bytes for the size and 4CC), the code above attempts to copy 0x64 of data from an undersized source buffer and the copy results in an out-of-bounds read.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0014');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (584, 'Apple Quicktime Invalid URL Atom Size Denial of Service Vulnerability', 'None', '2015-8-13', 'An exploitable denial of service vulnerability exists in Apple Quicktime. An attacker who can control the size of a \"url\" atom in a mov media file can cause an undersized allocation leading to an out-of-bounds read. Since the allocation only contains data already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable The function Quicktime!0x73aad0 is responsible for calculating the size of the data portion of a \"url \" atom. The atom size must be at least 8 bytes and the size of the new allocation is computed by subtracting 12 from this size.\nBecause of the way this is calculated, the new allocation may contain 0 bytes of data. The function QuicktimeStreaming!0x8b2e0 is responsible for processing the url atom data. A null-terminated string is\nexpected, however a pointed to the data is passed directly to strlen() to determine the string length. The problem occurs when there are either 0 bytes of data in a \"url \" atom or the data is not null-terminated. In both cases,\nthe call to strlen() will read off the end of the buffer without stopping, resulting in an out-of-bounds read.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0012');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (585, 'Apple Quicktime mdat Corruption Denial of Service Vulnerability', 'None', '2015-8-13', 'There is a denial of service vulnerability in Apple Quicktime. An attacker who can control the content of the mdat section of a .mov file can cause an out-of-bounds read. Since the allocation only contains data already from the file, the impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable https://www.apple.com/quicktime/ The function QuickTimeAuthoring!0x63f00 operates on data from the mdat atom in a loop. At various points, there is a buffer sanity check to ensure the current position within the data buffer has not exceeded the end of the buffer, after which 4 bytes are read from the current position. and here: The function iterates through a large section of memory reading in four bytes at a time. If the 4 bytes read in matches a specific control code, it alters the behavior of the function, causing it to advance through the data by either 1, 3, or 4 bytes. If the function reads in a control code that throws the function out of sync with the alignment of the object, an out-of-bounds read may occur. For example, if the data buffer is 0x100 bytes, and the function parses the data along 4-byte increments, hits a control code (0x80000000) that skips the data by 1, then continues to parse 4 byte increments till the end of the memory buffer, at some point the function gets into a situation where 0xfd bytes have been read. The function checks to ensure cursor < end of buffer, but because we\'re out of alignment, the check passes (0xfd < 0x100). Another 4 bytes are then read, resulting in a read 1 byte off the end of the buffer. No check is there to ensure current location + number of bytes to read < end of buffer before reading.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0017');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (586, 'Apple Quicktime tkhd Atom Matrix Corruption Denial of Service Vulnerability', 'None', '2015-7-20', 'An exploitable denial of service vulnerability exists in Apple Quicktime. An attacker who can control the values in the matrix structure of a tkhd atom in a .mov media file can cause an integer overflow in an idiv operation. The impact is limited to denial of service. Apple Quicktime 7.7.5 - Windows 7 32-bit   Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit   Vulnerable The function Quicktime!0x83e4c0 returns the result of a signed idiv. An integer overflow can occur during this division. If the result of the operation is larger than the max signed value capable of being stored in a 32-bit register, an integer overflow condition is raised and goes unhandled. The calling function, QuickTime!0x849b10, passes the hardcoded value 0x1000000, which is part of the dividend, and a 4-byte divisor. If the divisor is <= 0x20000, an integer overflow will occur in the signed division leading to a denial of service. The value in question is calculated at Quicktime!0x83e460 from the matrix structure in a tkhd atom. The data from this structure is passed to the function QuickTime!0x83efc0, which operates on these values in a loop. Corrupt matrix values cause calculations to result in unaccounted for values used by the idiv operation, leading to the overflow condition above. However, due to the complexity the calculations involved, the exact relationship between the corrupt matrix values and the resultant divisor has not been determined.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0016');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (587, 'Total Commander FileInfo Plugin Multiple Denial of Service Vulnerabilities', 'None', '2015-7-16', 'Multiple exploitable denial of service vulnerabilities exist in the FileInfo Plugin for Total Commander. An attacker who can control the contents of a COFF Archive Library (.lib) file can can cause an out of bounds read by specifying overly large values for the \'Size\' field of the Archive Member Header or the \"Number Of Symbols\" field in the 1st Linker Member. An attacker who can control the contents of a Linear Executable file can cause an out of bounds read by specifying overly large values for the \"Resource Table Count\" field of the LE Header or the \"Object\" field at offset 0x8 from a \"Resource Table Entry\". An attacker who successfully exploits this vulnerability can cause the Total Commander application to unexpectedly terminate. FileInfo 2.21 \nFileInfo 2.22 The Microsoft documentation defines the COFF Archive File Structure as shown below: Each Archive Member is preceeded by a Header structure which contains a \'Size\' field as shown below: The 1st Linker Member contains a structure which includes a \'Number of Symbols\' field as shown below: The first vulnerability is due to lack of validation on the \'Size\' field from the Member Header. The below pseudocode is decompiled from the function that reads the Archive Member Headers, we have included annotations inline: This is where we begin to read the series of Archive Members which are described by their headers: The next line reads the Size field offset (48) from the current Archive Header pointer which is held in the \'currentLocation\' variable and then adds the Size value to the current Archive Header pointer:   currentLocation += (atoi(currentLocation + 48) + 61) & 0xFFFFFFFE; Finally, the attacker controlled pointer is passed to the strncmp function, resulting in an invalid memory access: The second vulnerability is due to lack of validation on the \'Number of Symbols\' field from the 1st Linker Member. The below pseudocode is decompiled from the function that reads the 1st Linker Member, we have included annotations inline: The next two lines read the numberOfSymbols value from the file and set a pointer based upon that value: Finally, the attacker controlled value is passed to the strncmp function, resulting in an invalid memory access: Linear Executable File Format: http://faydoc.tripod.com/formats/exe-LE.htm The important structures for these vulnerabilities are: The below pseudocode is decompiled from the function that reads the Resource Table Entry, we have included annotations inline: The vulnerability is due to lack of validation whether the size of the resource data is greater than entire file size before passing it as the size parameter for a memcpy operation. Value of this fieLd is defined in LE Header at specified location: Setting this value greater than file size causes a read access violation at line: WinDbg output when read access violation occurs: *Note - This report replaces TALOS-2015-24 and TALOS-2015-25.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0024');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (588, 'Apple Quicktime Corrupt stbl Atom Remote Code Execution Vulnerability', 'None', '2015-6-30', 'There is a remote code execution vulnerability in Apple Quicktime. An attacker who can control the data inside an stbl atom in a .mov file can cause an undersized allocation which can lead to an out-of-bounds read. An attacker can use this to create a use-after-free scenario that could lead to remote code execution. Apple Quicktime 7.7.5 - Windows 7 32-bit Vulnerable \nApple Quicktime 7.7.6 - Windows 7 32-bit Vulnerable The function QuickTimeMPEG4!0x147f0 is responsible for processing the data in an hdlr atom.\nA 16-byte memory region is allocated near the beginning of the function. If the hdlr subtype field in an mdia atom is set to \'vide\', this reference is passed to a set of two functions. The first function swaps out the reference in object_ref for a bigger object, one of size 0xb0 bytes and the second function operates on this new object. At some point up the call stack for the first of these two functions, the reference in question is passed to the function QuickTime!0x73e0f0. However, when the stbl atom is missing from the file (or the 4CC is corrupted) the object at eax does not get populated. When this happens, the check at line 15 will pass and an error code (0xfffff809) will be passed back down the call stack. This series of calls would normally lead to the replacement of the object reference lie in the function QuickTime!0x748a40. However, because the error code returned down the stack isn\'t zero, the branch below is taken and the code path skipped. Eventually, the calls return and the function at line 57 of QuickTimeMPEG4!0x147f0 is called. Code execution makes its way up to the function QuickTime!0x21ab00. A read of 2 bytes is attempted at an offset of 84 bytes into the 16-byte object, resulting in an out-of-bounds read. Crash Information', 'None', 'https://www.talosintelligence.com/vulnerability_reports/TALOS-2015-0018');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (589, 'Pidgin libpurple STUN Response Length NULL Write Vulnerability', 'None', '2015-5-11', 'A exploitable NULL write vulnerability exists in Pidgin\'s implementation of the STUN protocol in the libpurple library. An attacker who can control the response to a STUN protocol packet can cause a network receive operation to retun an undersized value, resulting in an out-of-bounds write of a NULL value. Pidgin 2.10.7 An off by one exists in libpurple/stun.c at line 182 in the function reply_cb(): If the attacker causes a network error during the STUN message reply, the recv function call will return -1. The check at line 178 will be bypassed and the negative index will be used on line 182, resulting in an out of bounds write of NULL.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2014-0202');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (590, 'Pidgin libpurple MSN Message Parsing NULL Dereference Denial of Service Vulnerability', 'None', '2015-5-11', 'A exploitable denial of service vulnerability exists in Pidgin\'s implem ntation of the MSN Messenger protocol in the libpurple library. An attacker who can control the contents of a MSN message cause a string search function to return a NULL pointer which is later dereferenced without validation. Pidgin 2.10.7 In file libpurple/protocols/msn/msg.c at line 199 in function msnmessageparsepayload(), the following code exists: If a message contains \'boundary = \"value\' (i.e. without a closing quote) then the strchr function call at line 199 will return NULL. This NULL pointer is dereferenced on the following line, resulting in program termination.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2014-0201');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (591, 'Pidgin libpurple Novell Protocol Multiple Denial of Service Vulnerabilities', 'None', '2014-11-6', 'Several exploitable denial of service vulnerabilities exist in Pidgin\'s implementation of the Novell protocol in the libpurple library. An attacker who can control the contents of an Novell protocol message can cause an out of memory condition by specifying an overly large size value for a memory allocation operation. Pidgin 2.10.7 A denial of service condition exists in Pidgin when handling events in the Novell protocol. The vulnerability occurs in file pidgin-2.10.7\\libpurple\\protocols\\novell\\nmevent.c at lines 155, 170, 276, 285, 355, 407, 446, 496, 536, 595, 638, 676 and 837. Below is a representative example from line 155: While there is a check at line 154 to ensure that there is no integer overflow at line 155, an attacker can still specify a value of MAXUINT32-1, this will result in a g new0 function will attempt to allocate this memory, resulting in an out of memory exception and termination of the program.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2014-0204');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (592, 'Pidgin Theme/Smiley Untar Arbitrary File Write Vulnerability', 'None', '2014-11-6', 'An exploitable remote code execution vulnerability exists in Pidgin\'s implementation of the TAR archive parsing functionality. An attacker who can control the contents of a Theme or Smiley package can write arbitrary files to absolute paths on Windows. Pidgin 2.10.7 When installing a new theme or smiley, Pidgin untars the archive file into the theme or smiley directory. On Linux, Pidgin executes the tar command with the -C argument to untar it into the specified directory. The Linux tar utility will refuse to untar a file with an absolute path unless passed the -P argument, which is not used by Pidgin, so files are contained within the specified directory. However, in Windows, Pidgin can not rely on the presense of the untar utility, so instead code is included to perform the untar operation. This code, unlike tar, does allow the specification of an absolute path in the tar file, resulting in the ability to write or overwrite any file allowed by the file system permissions for that user. In themeinstalltheme() at line 698 in pidgin-2.10.7\\pidgin\\gtkprefs.c, the function winpidgingzuntar() is called witg options UNTAR_FORCE, meaning it will overwrite existing files. At line 413 in pidgin-2.10.7\\pidgin\\win32\\untar.c in the function untar_block() a check is performed to check if the path doesn\'t start with a / A strip of leading slashes is performed on the next few lines: However, an absolute path in the form of \"c:/path/file.ext\" will bypass the absolute path checks and will still be considered a valid absolute path by g_fopen() which is called by the createpath() function during the untar operation.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2014-0205');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (593, 'Pidgin libpurple Mxit Emoticon ASN Length Denial of Service Vulnerability', 'None', '2014-11-6', 'An exploitable denial of service vulnerability exists in Pidgin\'s implementation of the Mxit protocol in the libpurple library. An attacker who can control the contents of an Emoticon downloaded through the Mxit protocol can cause an out of bounds read by specifying an overly large ASN length value. Since this data is not returned to the attacker, the impact is limited to a denial of service. An attack requires the ability to spoof messages from the mxit.com domain to exploit this vulnerability. Pidgin 2.10.7 When downloading an emoticon via the mxit protocol, it is possible to cause an out of bounds read by providing an invalid length. This occurs in the function emoticonreturned() at line 520 in file pidgin-2.10.7\\libpurple\\protocols\\mxit\\markup.c The function asngetlength() will do the following: This function parses and returns a 4 byte size value from the ASN format. However, the only validation that occurs on the value is to ensure that the result is not negative. There is no check to ensure that the returned result is within the bounds of the memory pointed to by data. It will simply add the returned value to pos at line 526 and use that as an index into data at line 532, allowing an attacker to specify up to 2GB read length.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2014-0203');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (594, 'Microsoft Windows FastFAT NumberOfFATs Buffer Overflow Vulnerability', 'None', '2014-3-7', 'An exploitable local privileged code execution vulnerability exists in the Microsoft Windows FastFAT system driver. The FastFAT system driver is responsible for handling FAT32 disk partitions. An attacker who can control the NumberOfFATs value of a FAT32 boot sector can cause an undersized allocation which can later be used to write controlled data into the kernel pool. Windows XP SP3  Vulnerable \nWindows 7       Not Vulnerable \nWindows 8       Not Vulnerable http://windows.microsoft.com/ The FatCommonWrite function in FastFAT.sys is responsible for parsing the FAT32 boot sector. The boot sector contains a BIOS Parameter Block which is represented in the partial BPB_FAT32 structure below: The below pseudo code is responsible for parsing part of the BIOS Parameter Block. The first clause shows that the NumberOfFATs value, if greater than ‘2’, is used as the size of a kernel pool allocation: As we continue, the function also performs a loop using the NumberOfFATs value as the iteration count: Within the loop, the code expects there to be an array of 24-byte structures in the allocated buffer for each FAT indicated by the NumberOfFATs field. Since the allocation size was not multiplied by the size of the structure, memory will be written outside the bounds of the buffer.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2014-0301');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (595, 'Pidgin for Windows URL Handling Remote Code Execution Vulnerability', 'None', '2014-1-26', 'An exploitable remote code execution vulnerability exists in Pidgin\'s implementation of HTTP URL handling. An attacker can supply a remote path which will be evaluated by ShellExecute and can be leveraged to execute arbitrary code. The program attempts to block execution of several file formats and provide a prompt to the user, however this simple filter can be bypassed by specifying alternate file types and we have achieved code execution using .jar files. Pidgin 2.10.7 (Windows only) An attacker can pass arbitrary paths to ShellExecute when a user clicks on a URL delivered in any of the communication protocols supported by Pidgin on the Windows platform. If this URL specifies a file:// protocol handler, the URL will be examined for file type to determine if the user should be prompted. When we tested Pidgin on Windows 7, for example, WebDAV paths ending in file extensions such a .exe and .bat were filtered. However, the user can simply supply a path to an unfiltered file type such as a Java .jar to have the user download and execute arbitrary code if they have the Java Runtime Environment installed. Note, this is just one example and other file formats can be used. It\'s worth noting the attacker can also control the displayed string for the URL, so the true destination of a clicked URL may be obfuscated.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2013-1003');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (596, 'Pidgin libpurple Gadu Gadu HTTP Content-Length Integer Overflow Vulnerability', 'None', '2014-1-26', 'An exploitable remote code execution vulnerability exists in Pidgin\'\'s implementation of the Gadu Gadu protocol in the libpurple library. An attacker who can control the content-length of a HTTP request can cause an undersized allocation which can later be used to overflow into the heap. An attack requires the ability to spoof messages from the gadu-gadu.pl domain to exploit this vulnerability. Pidgin 2.10.7 In gghttpwatch_fd() in file pidgin-2.10.7\\libpurple\\protocols\\gg\\lib\\http.c at line 353 content-length will be read from the HTTP server: It then checks if h->bodysize is less than or equal to 0, however h->body_size is an unsigned int so a negative value will return a large positive size, meaning the check for less than zero will never be true: This check will also pass because left will not be larger than a negative body_size: If h->body_size is 4294967295 (or -1) then the below will result in a malloc(0): Finally we reach our out of bounds write into the heap here: The client will keep copying data as long as there\'\'s data in the http response body and will then free the original heap chunk. The following python code will trigger the vulnerability by supplying an overly large content-length value. We used DNS redirection on register.gadu-gadu.pl and had this listening for a password change request.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2013-1001');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (597, 'Pidgin libpurple Mxit Emoticon Name Length Integer Overflow Vulnerability', 'None', '2014-1-26', 'An exploitable remote code execution vulnerability exists in Pidgin\'s implementation of the Mxit protocol in the libpurple library. An attacker who can control the contents of an Emoticon downloaded through the Mxit protocol can cause an allocation to return NULL which can later be used to write into the lowest page of memory. An attack requires the ability to spoof messages from the mxit.com domain to exploit this vulnerability. Pidgin 2.10.7 When downloading an emoticon via the mxit protocol, it is possible to cause a buffer overflow, by providing an invalid utf8 length. This occurs in the function asn_getUtf8() at line 216 of pidgin-2.10.7\\libpurple\\protocols\\mxit\\markup.c: Here len will be read in as a 1 byte value from data[]. However, because len is a signed int, a length of 0xFF will be interpreted as a len of -1. The malloc at the next line will then result in an integer overflow at line 217. Unlike libc malloc, gmalloc returns NULL when it is called with a size of zero. As a result of that behavior, this ends up being a a write to the NULL page rather than the typical heap overflow. Writes to the zero page are exploitable if an attacker can cause enough allocations and exhaust enough of the memory address range to make the system map the low page.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2013-1002');
INSERT INTO `talosintelligence` (`id`, `title`, `author`, `publish_date`, `content`, `tags`, `url`) VALUES (598, 'Pidgin libpurple SIP/SIMPLE Content-Length Integer Overflow Vulnerability', 'None', '2014-1-26', 'An exploitable remote code execution vulnerability exists in Pidgin\'s implementation of SIP/SIMPLE message handling. An attacker who can control the Content-Length of a SIP/SIMPLE message can cause an allocation to return NULL which can later be used to write into the lowest page of memory. Pidgin 2.10.7 (Windows only) In sipmsg header() in file pidgin-2.10.7\\libpurple\\protocols\\simple\\sipmsg.c at line 114, the length of the message is read from an incoming message into an int: The above sipmsg header is called from process_input() in file pidgin-2.10.7\\libpurple\\protocols\\simple\\simple.c at line 1631. If the message specifies a negative bodylen (-1), then restlen will be larger than bodylen, which means the if statement at line 1642 will be entered. The following allocation of bodylen + 1 evaluates to a size of zero: Unlike libc malloc, g_malloc returns NULL when it is called with a size of zero. As a result of that behavior, this ends up being a a write to the NULL page rather than the typical heap overflow. Writes to the zero page are exploitable if an attacker can cause enough allocations and exhaust enough of the memory address range to make the system map the low page.', 'None', 'https://www.talosintelligence.com/vulnerability_reports/VRT-2013-1004');
